/******/ (() => {
  // webpackBootstrap
  /******/ var __webpack_modules__ = {
    /***/ "./node_modules/prettier/standalone.js":
      /*!*********************************************!*\
  !*** ./node_modules/prettier/standalone.js ***!
  \*********************************************/
      /***/ (module, exports, __webpack_require__) => {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__;
        (function (e) {
          if (true) module.exports = e();
          else {
            var f;
          }
        })(function () {
          "use strict";
          var be = (e, n) => () => (
            n || e((n = { exports: {} }).exports, n), n.exports
          );
          var Ye = be((yg, ru) => {
            var er = function (e) {
              return e && e.Math == Math && e;
            };
            ru.exports =
              er(typeof globalThis == "object" && globalThis) ||
              er(typeof window == "object" && window) ||
              er(typeof self == "object" && self) ||
              er(
                typeof __webpack_require__.g == "object" &&
                  __webpack_require__.g
              ) ||
              (function () {
                return this;
              })() ||
              Function("return this")();
          });
          var ft = be((hg, nu) => {
            nu.exports = function (e) {
              try {
                return !!e();
              } catch {
                return !0;
              }
            };
          });
          var ht = be((Cg, uu) => {
            var vo = ft();
            uu.exports = !vo(function () {
              return (
                Object.defineProperty({}, 1, {
                  get: function () {
                    return 7;
                  },
                })[1] != 7
              );
            });
          });
          var tr = be((Eg, su) => {
            var Fo = ft();
            su.exports = !Fo(function () {
              var e = function () {}.bind();
              return typeof e != "function" || e.hasOwnProperty("prototype");
            });
          });
          var Ct = be((vg, au) => {
            var Ao = tr(),
              rr = Function.prototype.call;
            au.exports = Ao
              ? rr.bind(rr)
              : function () {
                  return rr.apply(rr, arguments);
                };
          });
          var lu = be((cu) => {
            "use strict";
            var iu = {}.propertyIsEnumerable,
              ou = Object.getOwnPropertyDescriptor,
              So = ou && !iu.call({ 1: 2 }, 1);
            cu.f = So
              ? function (n) {
                  var t = ou(this, n);
                  return !!t && t.enumerable;
                }
              : iu;
          });
          var nr = be((Ag, pu) => {
            pu.exports = function (e, n) {
              return {
                enumerable: !(e & 1),
                configurable: !(e & 2),
                writable: !(e & 4),
                value: n,
              };
            };
          });
          var at = be((Sg, mu) => {
            var fu = tr(),
              Du = Function.prototype,
              xo = Du.bind,
              Lr = Du.call,
              bo = fu && xo.bind(Lr, Lr);
            mu.exports = fu
              ? function (e) {
                  return e && bo(e);
                }
              : function (e) {
                  return (
                    e &&
                    function () {
                      return Lr.apply(e, arguments);
                    }
                  );
                };
          });
          var ur = be((xg, gu) => {
            var du = at(),
              To = du({}.toString),
              Bo = du("".slice);
            gu.exports = function (e) {
              return Bo(To(e), 8, -1);
            };
          });
          var hu = be((bg, yu) => {
            var No = Ye(),
              wo = at(),
              _o = ft(),
              Po = ur(),
              Or = No.Object,
              Io = wo("".split);
            yu.exports = _o(function () {
              return !Or("z").propertyIsEnumerable(0);
            })
              ? function (e) {
                  return Po(e) == "String" ? Io(e, "") : Or(e);
                }
              : Or;
          });
          var jr = be((Tg, Cu) => {
            var ko = Ye(),
              Lo = ko.TypeError;
            Cu.exports = function (e) {
              if (e == null) throw Lo("Can't call method on " + e);
              return e;
            };
          });
          var sr = be((Bg, Eu) => {
            var Oo = hu(),
              jo = jr();
            Eu.exports = function (e) {
              return Oo(jo(e));
            };
          });
          var it = be((Ng, vu) => {
            vu.exports = function (e) {
              return typeof e == "function";
            };
          });
          var Et = be((wg, Fu) => {
            var qo = it();
            Fu.exports = function (e) {
              return typeof e == "object" ? e !== null : qo(e);
            };
          });
          var Mt = be((_g, Au) => {
            var qr = Ye(),
              Mo = it(),
              Ro = function (e) {
                return Mo(e) ? e : void 0;
              };
            Au.exports = function (e, n) {
              return arguments.length < 2 ? Ro(qr[e]) : qr[e] && qr[e][n];
            };
          });
          var Mr = be((Pg, Su) => {
            var Vo = at();
            Su.exports = Vo({}.isPrototypeOf);
          });
          var bu = be((Ig, xu) => {
            var Wo = Mt();
            xu.exports = Wo("navigator", "userAgent") || "";
          });
          var Iu = be((kg, Pu) => {
            var _u = Ye(),
              Rr = bu(),
              Tu = _u.process,
              Bu = _u.Deno,
              Nu = (Tu && Tu.versions) || (Bu && Bu.version),
              wu = Nu && Nu.v8,
              lt,
              ar;
            wu &&
              ((lt = wu.split(".")),
              (ar = lt[0] > 0 && lt[0] < 4 ? 1 : +(lt[0] + lt[1])));
            !ar &&
              Rr &&
              ((lt = Rr.match(/Edge\/(\d+)/)),
              (!lt || lt[1] >= 74) &&
                ((lt = Rr.match(/Chrome\/(\d+)/)), lt && (ar = +lt[1])));
            Pu.exports = ar;
          });
          var Vr = be((Lg, Lu) => {
            var ku = Iu(),
              $o = ft();
            Lu.exports =
              !!Object.getOwnPropertySymbols &&
              !$o(function () {
                var e = Symbol();
                return (
                  !String(e) ||
                  !(Object(e) instanceof Symbol) ||
                  (!Symbol.sham && ku && ku < 41)
                );
              });
          });
          var Wr = be((Og, Ou) => {
            var Ho = Vr();
            Ou.exports =
              Ho && !Symbol.sham && typeof Symbol.iterator == "symbol";
          });
          var $r = be((jg, ju) => {
            var Go = Ye(),
              Jo = Mt(),
              Uo = it(),
              zo = Mr(),
              Xo = Wr(),
              Ko = Go.Object;
            ju.exports = Xo
              ? function (e) {
                  return typeof e == "symbol";
                }
              : function (e) {
                  var n = Jo("Symbol");
                  return Uo(n) && zo(n.prototype, Ko(e));
                };
          });
          var ir = be((qg, qu) => {
            var Yo = Ye(),
              Qo = Yo.String;
            qu.exports = function (e) {
              try {
                return Qo(e);
              } catch {
                return "Object";
              }
            };
          });
          var Rt = be((Mg, Mu) => {
            var Zo = Ye(),
              ec = it(),
              tc = ir(),
              rc = Zo.TypeError;
            Mu.exports = function (e) {
              if (ec(e)) return e;
              throw rc(tc(e) + " is not a function");
            };
          });
          var or = be((Rg, Ru) => {
            var nc = Rt();
            Ru.exports = function (e, n) {
              var t = e[n];
              return t == null ? void 0 : nc(t);
            };
          });
          var Wu = be((Vg, Vu) => {
            var uc = Ye(),
              Hr = Ct(),
              Gr = it(),
              Jr = Et(),
              sc = uc.TypeError;
            Vu.exports = function (e, n) {
              var t, s;
              if (
                (n === "string" &&
                  Gr((t = e.toString)) &&
                  !Jr((s = Hr(t, e)))) ||
                (Gr((t = e.valueOf)) && !Jr((s = Hr(t, e)))) ||
                (n !== "string" && Gr((t = e.toString)) && !Jr((s = Hr(t, e))))
              )
                return s;
              throw sc("Can't convert object to primitive value");
            };
          });
          var Hu = be((Wg, $u) => {
            $u.exports = !1;
          });
          var cr = be(($g, Ju) => {
            var Gu = Ye(),
              ac = Object.defineProperty;
            Ju.exports = function (e, n) {
              try {
                ac(Gu, e, { value: n, configurable: !0, writable: !0 });
              } catch {
                Gu[e] = n;
              }
              return n;
            };
          });
          var lr = be((Hg, zu) => {
            var ic = Ye(),
              oc = cr(),
              Uu = "__core-js_shared__",
              cc = ic[Uu] || oc(Uu, {});
            zu.exports = cc;
          });
          var Ur = be((Gg, Ku) => {
            var lc = Hu(),
              Xu = lr();
            (Ku.exports = function (e, n) {
              return Xu[e] || (Xu[e] = n !== void 0 ? n : {});
            })("versions", []).push({
              version: "3.21.1",
              mode: lc ? "pure" : "global",
              copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
              license:
                "https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE",
              source: "https://github.com/zloirock/core-js",
            });
          });
          var pr = be((Jg, Yu) => {
            var pc = Ye(),
              fc = jr(),
              Dc = pc.Object;
            Yu.exports = function (e) {
              return Dc(fc(e));
            };
          });
          var mt = be((Ug, Qu) => {
            var mc = at(),
              dc = pr(),
              gc = mc({}.hasOwnProperty);
            Qu.exports =
              Object.hasOwn ||
              function (n, t) {
                return gc(dc(n), t);
              };
          });
          var zr = be((zg, Zu) => {
            var yc = at(),
              hc = 0,
              Cc = Math.random(),
              Ec = yc((1).toString);
            Zu.exports = function (e) {
              return (
                "Symbol(" + (e === void 0 ? "" : e) + ")_" + Ec(++hc + Cc, 36)
              );
            };
          });
          var Ft = be((Xg, us) => {
            var vc = Ye(),
              Fc = Ur(),
              es = mt(),
              Ac = zr(),
              ts = Vr(),
              ns = Wr(),
              Tt = Fc("wks"),
              vt = vc.Symbol,
              rs = vt && vt.for,
              Sc = ns ? vt : (vt && vt.withoutSetter) || Ac;
            us.exports = function (e) {
              if (!es(Tt, e) || !(ts || typeof Tt[e] == "string")) {
                var n = "Symbol." + e;
                ts && es(vt, e)
                  ? (Tt[e] = vt[e])
                  : ns && rs
                  ? (Tt[e] = rs(n))
                  : (Tt[e] = Sc(n));
              }
              return Tt[e];
            };
          });
          var os = be((Kg, is) => {
            var xc = Ye(),
              bc = Ct(),
              ss = Et(),
              as = $r(),
              Tc = or(),
              Bc = Wu(),
              Nc = Ft(),
              wc = xc.TypeError,
              _c = Nc("toPrimitive");
            is.exports = function (e, n) {
              if (!ss(e) || as(e)) return e;
              var t = Tc(e, _c),
                s;
              if (t) {
                if (
                  (n === void 0 && (n = "default"),
                  (s = bc(t, e, n)),
                  !ss(s) || as(s))
                )
                  return s;
                throw wc("Can't convert object to primitive value");
              }
              return n === void 0 && (n = "number"), Bc(e, n);
            };
          });
          var fr = be((Yg, cs) => {
            var Pc = os(),
              Ic = $r();
            cs.exports = function (e) {
              var n = Pc(e, "string");
              return Ic(n) ? n : n + "";
            };
          });
          var fs = be((Qg, ps) => {
            var kc = Ye(),
              ls = Et(),
              Xr = kc.document,
              Lc = ls(Xr) && ls(Xr.createElement);
            ps.exports = function (e) {
              return Lc ? Xr.createElement(e) : {};
            };
          });
          var Kr = be((Zg, Ds) => {
            var Oc = ht(),
              jc = ft(),
              qc = fs();
            Ds.exports =
              !Oc &&
              !jc(function () {
                return (
                  Object.defineProperty(qc("div"), "a", {
                    get: function () {
                      return 7;
                    },
                  }).a != 7
                );
              });
          });
          var Yr = be((ds) => {
            var Mc = ht(),
              Rc = Ct(),
              Vc = lu(),
              Wc = nr(),
              $c = sr(),
              Hc = fr(),
              Gc = mt(),
              Jc = Kr(),
              ms = Object.getOwnPropertyDescriptor;
            ds.f = Mc
              ? ms
              : function (n, t) {
                  if (((n = $c(n)), (t = Hc(t)), Jc))
                    try {
                      return ms(n, t);
                    } catch {}
                  if (Gc(n, t)) return Wc(!Rc(Vc.f, n, t), n[t]);
                };
          });
          var ys = be((t0, gs) => {
            var Uc = ht(),
              zc = ft();
            gs.exports =
              Uc &&
              zc(function () {
                return (
                  Object.defineProperty(function () {}, "prototype", {
                    value: 42,
                    writable: !1,
                  }).prototype != 42
                );
              });
          });
          var Bt = be((r0, Cs) => {
            var hs = Ye(),
              Xc = Et(),
              Kc = hs.String,
              Yc = hs.TypeError;
            Cs.exports = function (e) {
              if (Xc(e)) return e;
              throw Yc(Kc(e) + " is not an object");
            };
          });
          var mr = be((vs) => {
            var Qc = Ye(),
              Zc = ht(),
              el = Kr(),
              tl = ys(),
              Dr = Bt(),
              Es = fr(),
              rl = Qc.TypeError,
              Qr = Object.defineProperty,
              nl = Object.getOwnPropertyDescriptor,
              Zr = "enumerable",
              en = "configurable",
              tn = "writable";
            vs.f = Zc
              ? tl
                ? function (n, t, s) {
                    if (
                      (Dr(n),
                      (t = Es(t)),
                      Dr(s),
                      typeof n == "function" &&
                        t === "prototype" &&
                        "value" in s &&
                        tn in s &&
                        !s[tn])
                    ) {
                      var i = nl(n, t);
                      i &&
                        i[tn] &&
                        ((n[t] = s.value),
                        (s = {
                          configurable: en in s ? s[en] : i[en],
                          enumerable: Zr in s ? s[Zr] : i[Zr],
                          writable: !1,
                        }));
                    }
                    return Qr(n, t, s);
                  }
                : Qr
              : function (n, t, s) {
                  if ((Dr(n), (t = Es(t)), Dr(s), el))
                    try {
                      return Qr(n, t, s);
                    } catch {}
                  if ("get" in s || "set" in s)
                    throw rl("Accessors not supported");
                  return "value" in s && (n[t] = s.value), n;
                };
          });
          var dr = be((u0, Fs) => {
            var ul = ht(),
              sl = mr(),
              al = nr();
            Fs.exports = ul
              ? function (e, n, t) {
                  return sl.f(e, n, al(1, t));
                }
              : function (e, n, t) {
                  return (e[n] = t), e;
                };
          });
          var gr = be((s0, As) => {
            var il = at(),
              ol = it(),
              rn = lr(),
              cl = il(Function.toString);
            ol(rn.inspectSource) ||
              (rn.inspectSource = function (e) {
                return cl(e);
              });
            As.exports = rn.inspectSource;
          });
          var bs = be((a0, xs) => {
            var ll = Ye(),
              pl = it(),
              fl = gr(),
              Ss = ll.WeakMap;
            xs.exports = pl(Ss) && /native code/.test(fl(Ss));
          });
          var Ns = be((i0, Bs) => {
            var Dl = Ur(),
              ml = zr(),
              Ts = Dl("keys");
            Bs.exports = function (e) {
              return Ts[e] || (Ts[e] = ml(e));
            };
          });
          var nn = be((o0, ws) => {
            ws.exports = {};
          });
          var Os = be((c0, Ls) => {
            var dl = bs(),
              ks = Ye(),
              un = at(),
              gl = Et(),
              yl = dr(),
              sn = mt(),
              an = lr(),
              hl = Ns(),
              Cl = nn(),
              _s = "Object already initialized",
              cn = ks.TypeError,
              El = ks.WeakMap,
              yr,
              Vt,
              hr,
              vl = function (e) {
                return hr(e) ? Vt(e) : yr(e, {});
              },
              Fl = function (e) {
                return function (n) {
                  var t;
                  if (!gl(n) || (t = Vt(n)).type !== e)
                    throw cn("Incompatible receiver, " + e + " required");
                  return t;
                };
              };
            dl || an.state
              ? ((dt = an.state || (an.state = new El())),
                (Ps = un(dt.get)),
                (on = un(dt.has)),
                (Is = un(dt.set)),
                (yr = function (e, n) {
                  if (on(dt, e)) throw new cn(_s);
                  return (n.facade = e), Is(dt, e, n), n;
                }),
                (Vt = function (e) {
                  return Ps(dt, e) || {};
                }),
                (hr = function (e) {
                  return on(dt, e);
                }))
              : ((At = hl("state")),
                (Cl[At] = !0),
                (yr = function (e, n) {
                  if (sn(e, At)) throw new cn(_s);
                  return (n.facade = e), yl(e, At, n), n;
                }),
                (Vt = function (e) {
                  return sn(e, At) ? e[At] : {};
                }),
                (hr = function (e) {
                  return sn(e, At);
                }));
            var dt, Ps, on, Is, At;
            Ls.exports = {
              set: yr,
              get: Vt,
              has: hr,
              enforce: vl,
              getterFor: Fl,
            };
          });
          var Ms = be((l0, qs) => {
            var ln = ht(),
              Al = mt(),
              js = Function.prototype,
              Sl = ln && Object.getOwnPropertyDescriptor,
              pn = Al(js, "name"),
              xl = pn && function () {}.name === "something",
              bl = pn && (!ln || (ln && Sl(js, "name").configurable));
            qs.exports = { EXISTS: pn, PROPER: xl, CONFIGURABLE: bl };
          });
          var Hs = be((p0, $s) => {
            var Tl = Ye(),
              Rs = it(),
              Bl = mt(),
              Vs = dr(),
              Nl = cr(),
              wl = gr(),
              Ws = Os(),
              _l = Ms().CONFIGURABLE,
              Pl = Ws.get,
              Il = Ws.enforce,
              kl = String(String).split("String");
            ($s.exports = function (e, n, t, s) {
              var i = s ? !!s.unsafe : !1,
                r = s ? !!s.enumerable : !1,
                u = s ? !!s.noTargetGet : !1,
                a = s && s.name !== void 0 ? s.name : n,
                c;
              if (
                (Rs(t) &&
                  (String(a).slice(0, 7) === "Symbol(" &&
                    (a =
                      "[" +
                      String(a).replace(/^Symbol\(([^)]*)\)/, "$1") +
                      "]"),
                  (!Bl(t, "name") || (_l && t.name !== a)) && Vs(t, "name", a),
                  (c = Il(t)),
                  c.source ||
                    (c.source = kl.join(typeof a == "string" ? a : ""))),
                e === Tl)
              ) {
                r ? (e[n] = t) : Nl(n, t);
                return;
              } else i ? !u && e[n] && (r = !0) : delete e[n];
              r ? (e[n] = t) : Vs(e, n, t);
            })(Function.prototype, "toString", function () {
              return (Rs(this) && Pl(this).source) || wl(this);
            });
          });
          var Cr = be((f0, Gs) => {
            var Ll = Math.ceil,
              Ol = Math.floor;
            Gs.exports = function (e) {
              var n = +e;
              return n !== n || n === 0 ? 0 : (n > 0 ? Ol : Ll)(n);
            };
          });
          var Us = be((D0, Js) => {
            var jl = Cr(),
              ql = Math.max,
              Ml = Math.min;
            Js.exports = function (e, n) {
              var t = jl(e);
              return t < 0 ? ql(t + n, 0) : Ml(t, n);
            };
          });
          var Xs = be((m0, zs) => {
            var Rl = Cr(),
              Vl = Math.min;
            zs.exports = function (e) {
              return e > 0 ? Vl(Rl(e), 9007199254740991) : 0;
            };
          });
          var Nt = be((d0, Ks) => {
            var Wl = Xs();
            Ks.exports = function (e) {
              return Wl(e.length);
            };
          });
          var Zs = be((g0, Qs) => {
            var $l = sr(),
              Hl = Us(),
              Gl = Nt(),
              Ys = function (e) {
                return function (n, t, s) {
                  var i = $l(n),
                    r = Gl(i),
                    u = Hl(s, r),
                    a;
                  if (e && t != t) {
                    for (; r > u; ) if (((a = i[u++]), a != a)) return !0;
                  } else
                    for (; r > u; u++)
                      if ((e || u in i) && i[u] === t) return e || u || 0;
                  return !e && -1;
                };
              };
            Qs.exports = { includes: Ys(!0), indexOf: Ys(!1) };
          });
          var ra = be((y0, ta) => {
            var Jl = at(),
              fn = mt(),
              Ul = sr(),
              zl = Zs().indexOf,
              Xl = nn(),
              ea = Jl([].push);
            ta.exports = function (e, n) {
              var t = Ul(e),
                s = 0,
                i = [],
                r;
              for (r in t) !fn(Xl, r) && fn(t, r) && ea(i, r);
              for (; n.length > s; )
                fn(t, (r = n[s++])) && (~zl(i, r) || ea(i, r));
              return i;
            };
          });
          var ua = be((h0, na) => {
            na.exports = [
              "constructor",
              "hasOwnProperty",
              "isPrototypeOf",
              "propertyIsEnumerable",
              "toLocaleString",
              "toString",
              "valueOf",
            ];
          });
          var aa = be((sa) => {
            var Kl = ra(),
              Yl = ua(),
              Ql = Yl.concat("length", "prototype");
            sa.f =
              Object.getOwnPropertyNames ||
              function (n) {
                return Kl(n, Ql);
              };
          });
          var oa = be((ia) => {
            ia.f = Object.getOwnPropertySymbols;
          });
          var la = be((v0, ca) => {
            var Zl = Mt(),
              ep = at(),
              tp = aa(),
              rp = oa(),
              np = Bt(),
              up = ep([].concat);
            ca.exports =
              Zl("Reflect", "ownKeys") ||
              function (n) {
                var t = tp.f(np(n)),
                  s = rp.f;
                return s ? up(t, s(n)) : t;
              };
          });
          var Da = be((F0, fa) => {
            var pa = mt(),
              sp = la(),
              ap = Yr(),
              ip = mr();
            fa.exports = function (e, n, t) {
              for (
                var s = sp(n), i = ip.f, r = ap.f, u = 0;
                u < s.length;
                u++
              ) {
                var a = s[u];
                !pa(e, a) && !(t && pa(t, a)) && i(e, a, r(n, a));
              }
            };
          });
          var da = be((A0, ma) => {
            var op = ft(),
              cp = it(),
              lp = /#|\.prototype\./,
              Wt = function (e, n) {
                var t = fp[pp(e)];
                return t == mp ? !0 : t == Dp ? !1 : cp(n) ? op(n) : !!n;
              },
              pp = (Wt.normalize = function (e) {
                return String(e).replace(lp, ".").toLowerCase();
              }),
              fp = (Wt.data = {}),
              Dp = (Wt.NATIVE = "N"),
              mp = (Wt.POLYFILL = "P");
            ma.exports = Wt;
          });
          var $t = be((S0, ga) => {
            var Dn = Ye(),
              dp = Yr().f,
              gp = dr(),
              yp = Hs(),
              hp = cr(),
              Cp = Da(),
              Ep = da();
            ga.exports = function (e, n) {
              var t = e.target,
                s = e.global,
                i = e.stat,
                r,
                u,
                a,
                c,
                l,
                C;
              if (
                (s
                  ? (u = Dn)
                  : i
                  ? (u = Dn[t] || hp(t, {}))
                  : (u = (Dn[t] || {}).prototype),
                u)
              )
                for (a in n) {
                  if (
                    ((l = n[a]),
                    e.noTargetGet
                      ? ((C = dp(u, a)), (c = C && C.value))
                      : (c = u[a]),
                    (r = Ep(s ? a : t + (i ? "." : "#") + a, e.forced)),
                    !r && c !== void 0)
                  ) {
                    if (typeof l == typeof c) continue;
                    Cp(l, c);
                  }
                  (e.sham || (c && c.sham)) && gp(l, "sham", !0),
                    yp(u, a, l, e);
                }
            };
          });
          var mn = be((x0, ya) => {
            var vp = ur();
            ya.exports =
              Array.isArray ||
              function (n) {
                return vp(n) == "Array";
              };
          });
          var dn = be((b0, Ca) => {
            var ha = at(),
              Fp = Rt(),
              Ap = tr(),
              Sp = ha(ha.bind);
            Ca.exports = function (e, n) {
              return (
                Fp(e),
                n === void 0
                  ? e
                  : Ap
                  ? Sp(e, n)
                  : function () {
                      return e.apply(n, arguments);
                    }
              );
            };
          });
          var gn = be((T0, va) => {
            "use strict";
            var xp = Ye(),
              bp = mn(),
              Tp = Nt(),
              Bp = dn(),
              Np = xp.TypeError,
              Ea = function (e, n, t, s, i, r, u, a) {
                for (var c = i, l = 0, C = u ? Bp(u, a) : !1, m, g; l < s; ) {
                  if (l in t) {
                    if (((m = C ? C(t[l], l, n) : t[l]), r > 0 && bp(m)))
                      (g = Tp(m)), (c = Ea(e, n, m, g, c, r - 1) - 1);
                    else {
                      if (c >= 9007199254740991)
                        throw Np("Exceed the acceptable array length");
                      e[c] = m;
                    }
                    c++;
                  }
                  l++;
                }
                return c;
              };
            va.exports = Ea;
          });
          var Sa = be((B0, Aa) => {
            var wp = Ft(),
              _p = wp("toStringTag"),
              Fa = {};
            Fa[_p] = "z";
            Aa.exports = String(Fa) === "[object z]";
          });
          var yn = be((N0, xa) => {
            var Pp = Ye(),
              Ip = Sa(),
              kp = it(),
              Er = ur(),
              Lp = Ft(),
              Op = Lp("toStringTag"),
              jp = Pp.Object,
              qp =
                Er(
                  (function () {
                    return arguments;
                  })()
                ) == "Arguments",
              Mp = function (e, n) {
                try {
                  return e[n];
                } catch {}
              };
            xa.exports = Ip
              ? Er
              : function (e) {
                  var n, t, s;
                  return e === void 0
                    ? "Undefined"
                    : e === null
                    ? "Null"
                    : typeof (t = Mp((n = jp(e)), Op)) == "string"
                    ? t
                    : qp
                    ? Er(n)
                    : (s = Er(n)) == "Object" && kp(n.callee)
                    ? "Arguments"
                    : s;
                };
          });
          var _a = be((w0, wa) => {
            var Rp = at(),
              Vp = ft(),
              ba = it(),
              Wp = yn(),
              $p = Mt(),
              Hp = gr(),
              Ta = function () {},
              Gp = [],
              Ba = $p("Reflect", "construct"),
              hn = /^\s*(?:class|function)\b/,
              Jp = Rp(hn.exec),
              Up = !hn.exec(Ta),
              Ht = function (n) {
                if (!ba(n)) return !1;
                try {
                  return Ba(Ta, Gp, n), !0;
                } catch {
                  return !1;
                }
              },
              Na = function (n) {
                if (!ba(n)) return !1;
                switch (Wp(n)) {
                  case "AsyncFunction":
                  case "GeneratorFunction":
                  case "AsyncGeneratorFunction":
                    return !1;
                }
                try {
                  return Up || !!Jp(hn, Hp(n));
                } catch {
                  return !0;
                }
              };
            Na.sham = !0;
            wa.exports =
              !Ba ||
              Vp(function () {
                var e;
                return (
                  Ht(Ht.call) ||
                  !Ht(Object) ||
                  !Ht(function () {
                    e = !0;
                  }) ||
                  e
                );
              })
                ? Na
                : Ht;
          });
          var La = be((_0, ka) => {
            var zp = Ye(),
              Pa = mn(),
              Xp = _a(),
              Kp = Et(),
              Yp = Ft(),
              Qp = Yp("species"),
              Ia = zp.Array;
            ka.exports = function (e) {
              var n;
              return (
                Pa(e) &&
                  ((n = e.constructor),
                  Xp(n) && (n === Ia || Pa(n.prototype))
                    ? (n = void 0)
                    : Kp(n) && ((n = n[Qp]), n === null && (n = void 0))),
                n === void 0 ? Ia : n
              );
            };
          });
          var Cn = be((P0, Oa) => {
            var Zp = La();
            Oa.exports = function (e, n) {
              return new (Zp(e))(n === 0 ? 0 : n);
            };
          });
          var ja = be(() => {
            "use strict";
            var ef = $t(),
              tf = gn(),
              rf = Rt(),
              nf = pr(),
              uf = Nt(),
              sf = Cn();
            ef(
              { target: "Array", proto: !0 },
              {
                flatMap: function (n) {
                  var t = nf(this),
                    s = uf(t),
                    i;
                  return (
                    rf(n),
                    (i = sf(t, 0)),
                    (i.length = tf(
                      i,
                      t,
                      t,
                      s,
                      0,
                      1,
                      n,
                      arguments.length > 1 ? arguments[1] : void 0
                    )),
                    i
                  );
                },
              }
            );
          });
          var En = be((L0, qa) => {
            qa.exports = {};
          });
          var Ra = be((O0, Ma) => {
            var af = Ft(),
              of = En(),
              cf = af("iterator"),
              lf = Array.prototype;
            Ma.exports = function (e) {
              return e !== void 0 && (of.Array === e || lf[cf] === e);
            };
          });
          var vn = be((j0, Wa) => {
            var pf = yn(),
              Va = or(),
              ff = En(),
              Df = Ft(),
              mf = Df("iterator");
            Wa.exports = function (e) {
              if (e != null)
                return Va(e, mf) || Va(e, "@@iterator") || ff[pf(e)];
            };
          });
          var Ha = be((q0, $a) => {
            var df = Ye(),
              gf = Ct(),
              yf = Rt(),
              hf = Bt(),
              Cf = ir(),
              Ef = vn(),
              vf = df.TypeError;
            $a.exports = function (e, n) {
              var t = arguments.length < 2 ? Ef(e) : n;
              if (yf(t)) return hf(gf(t, e));
              throw vf(Cf(e) + " is not iterable");
            };
          });
          var Ua = be((M0, Ja) => {
            var Ff = Ct(),
              Ga = Bt(),
              Af = or();
            Ja.exports = function (e, n, t) {
              var s, i;
              Ga(e);
              try {
                if (((s = Af(e, "return")), !s)) {
                  if (n === "throw") throw t;
                  return t;
                }
                s = Ff(s, e);
              } catch (r) {
                (i = !0), (s = r);
              }
              if (n === "throw") throw t;
              if (i) throw s;
              return Ga(s), t;
            };
          });
          var Qa = be((R0, Ya) => {
            var Sf = Ye(),
              xf = dn(),
              bf = Ct(),
              Tf = Bt(),
              Bf = ir(),
              Nf = Ra(),
              wf = Nt(),
              za = Mr(),
              _f = Ha(),
              Pf = vn(),
              Xa = Ua(),
              If = Sf.TypeError,
              vr = function (e, n) {
                (this.stopped = e), (this.result = n);
              },
              Ka = vr.prototype;
            Ya.exports = function (e, n, t) {
              var s = t && t.that,
                i = !!(t && t.AS_ENTRIES),
                r = !!(t && t.IS_ITERATOR),
                u = !!(t && t.INTERRUPTED),
                a = xf(n, s),
                c,
                l,
                C,
                m,
                g,
                p,
                f,
                h = function (T) {
                  return c && Xa(c, "normal", T), new vr(!0, T);
                },
                N = function (T) {
                  return i
                    ? (Tf(T), u ? a(T[0], T[1], h) : a(T[0], T[1]))
                    : u
                    ? a(T, h)
                    : a(T);
                };
              if (r) c = e;
              else {
                if (((l = Pf(e)), !l)) throw If(Bf(e) + " is not iterable");
                if (Nf(l)) {
                  for (C = 0, m = wf(e); m > C; C++)
                    if (((g = N(e[C])), g && za(Ka, g))) return g;
                  return new vr(!1);
                }
                c = _f(e, l);
              }
              for (p = c.next; !(f = bf(p, c)).done; ) {
                try {
                  g = N(f.value);
                } catch (T) {
                  Xa(c, "throw", T);
                }
                if (typeof g == "object" && g && za(Ka, g)) return g;
              }
              return new vr(!1);
            };
          });
          var ei = be((V0, Za) => {
            "use strict";
            var kf = fr(),
              Lf = mr(),
              Of = nr();
            Za.exports = function (e, n, t) {
              var s = kf(n);
              s in e ? Lf.f(e, s, Of(0, t)) : (e[s] = t);
            };
          });
          var ti = be(() => {
            var jf = $t(),
              qf = Qa(),
              Mf = ei();
            jf(
              { target: "Object", stat: !0 },
              {
                fromEntries: function (n) {
                  var t = {};
                  return (
                    qf(
                      n,
                      function (s, i) {
                        Mf(t, s, i);
                      },
                      { AS_ENTRIES: !0 }
                    ),
                    t
                  );
                },
              }
            );
          });
          var ri = be(() => {
            var Rf = $t(),
              Vf = Ye();
            Rf({ global: !0 }, { globalThis: Vf });
          });
          var ni = be(() => {
            ri();
          });
          var ui = be(() => {
            "use strict";
            var Wf = $t(),
              $f = gn(),
              Hf = pr(),
              Gf = Nt(),
              Jf = Cr(),
              Uf = Cn();
            Wf(
              { target: "Array", proto: !0 },
              {
                flat: function () {
                  var n = arguments.length ? arguments[0] : void 0,
                    t = Hf(this),
                    s = Gf(t),
                    i = Uf(t, 0);
                  return (
                    (i.length = $f(i, t, t, s, 0, n === void 0 ? 1 : Jf(n))), i
                  );
                },
              }
            );
          });
          var dg = be((Y0, yo) => {
            var zf = ["cliName", "cliCategory", "cliDescription"],
              Xf = ["_"],
              Kf = ["languageId"],
              si,
              ai,
              ii,
              oi,
              ci,
              li;
            function _n(e, n) {
              if (e == null) return {};
              var t = Yf(e, n),
                s,
                i;
              if (Object.getOwnPropertySymbols) {
                var r = Object.getOwnPropertySymbols(e);
                for (i = 0; i < r.length; i++)
                  (s = r[i]),
                    !(n.indexOf(s) >= 0) &&
                      (!Object.prototype.propertyIsEnumerable.call(e, s) ||
                        (t[s] = e[s]));
              }
              return t;
            }
            function Yf(e, n) {
              if (e == null) return {};
              var t = {},
                s = Object.keys(e),
                i,
                r;
              for (r = 0; r < s.length; r++)
                (i = s[r]), !(n.indexOf(i) >= 0) && (t[i] = e[i]);
              return t;
            }
            ja();
            ti();
            ni();
            ui();
            function wt(e, n) {
              return (
                n || (n = e.slice(0)),
                Object.freeze(
                  Object.defineProperties(e, {
                    raw: { value: Object.freeze(n) },
                  })
                )
              );
            }
            var Pn = Object.defineProperty,
              Qf = Object.getOwnPropertyDescriptor,
              In = Object.getOwnPropertyNames,
              Zf = Object.prototype.hasOwnProperty,
              br = (e, n) =>
                function () {
                  return e && (n = (0, e[In(e)[0]])((e = 0))), n;
                },
              Z = (e, n) =>
                function () {
                  return (
                    n || (0, e[In(e)[0]])((n = { exports: {} }).exports, n),
                    n.exports
                  );
                },
              kn = (e, n) => {
                for (var t in n) Pn(e, t, { get: n[t], enumerable: !0 });
              },
              eD = (e, n, t, s) => {
                if ((n && typeof n == "object") || typeof n == "function")
                  for (let i of In(n))
                    !Zf.call(e, i) &&
                      i !== t &&
                      Pn(e, i, {
                        get: () => n[i],
                        enumerable: !(s = Qf(n, i)) || s.enumerable,
                      });
                return e;
              },
              pt = (e) => eD(Pn({}, "__esModule", { value: !0 }), e),
              pi,
              fi,
              xt,
              ae = br({
                "<define:process>"() {
                  (pi = {}), (fi = []), (xt = { env: pi, argv: fi });
                },
              }),
              gi = Z({
                "package.json"(e, n) {
                  n.exports = { version: "2.6.2" };
                },
              }),
              tD = Z({
                "node_modules/diff/lib/diff/base.js"(e) {
                  "use strict";
                  ae(),
                    Object.defineProperty(e, "__esModule", { value: !0 }),
                    (e.default = n);
                  function n() {}
                  n.prototype = {
                    diff: function (r, u) {
                      var a =
                          arguments.length > 2 && arguments[2] !== void 0
                            ? arguments[2]
                            : {},
                        c = a.callback;
                      typeof a == "function" && ((c = a), (a = {})),
                        (this.options = a);
                      var l = this;
                      function C(b) {
                        return c
                          ? (setTimeout(function () {
                              c(void 0, b);
                            }, 0),
                            !0)
                          : b;
                      }
                      (r = this.castInput(r)),
                        (u = this.castInput(u)),
                        (r = this.removeEmpty(this.tokenize(r))),
                        (u = this.removeEmpty(this.tokenize(u)));
                      var m = u.length,
                        g = r.length,
                        p = 1,
                        f = m + g,
                        h = [{ newPos: -1, components: [] }],
                        N = this.extractCommon(h[0], u, r, 0);
                      if (h[0].newPos + 1 >= m && N + 1 >= g)
                        return C([{ value: this.join(u), count: u.length }]);
                      function T() {
                        for (var b = -1 * p; b <= p; b += 2) {
                          var v = void 0,
                            B = h[b - 1],
                            w = h[b + 1],
                            I = (w ? w.newPos : 0) - b;
                          B && (h[b - 1] = void 0);
                          var E = B && B.newPos + 1 < m,
                            D = w && 0 <= I && I < g;
                          if (!E && !D) {
                            h[b] = void 0;
                            continue;
                          }
                          if (
                            (!E || (D && B.newPos < w.newPos)
                              ? ((v = s(w)),
                                l.pushComponent(v.components, void 0, !0))
                              : ((v = B),
                                v.newPos++,
                                l.pushComponent(v.components, !0, void 0)),
                            (I = l.extractCommon(v, u, r, b)),
                            v.newPos + 1 >= m && I + 1 >= g)
                          )
                            return C(
                              t(l, v.components, u, r, l.useLongestToken)
                            );
                          h[b] = v;
                        }
                        p++;
                      }
                      if (c)
                        (function b() {
                          setTimeout(function () {
                            if (p > f) return c();
                            T() || b();
                          }, 0);
                        })();
                      else
                        for (; p <= f; ) {
                          var A = T();
                          if (A) return A;
                        }
                    },
                    pushComponent: function (r, u, a) {
                      var c = r[r.length - 1];
                      c && c.added === u && c.removed === a
                        ? (r[r.length - 1] = {
                            count: c.count + 1,
                            added: u,
                            removed: a,
                          })
                        : r.push({ count: 1, added: u, removed: a });
                    },
                    extractCommon: function (r, u, a, c) {
                      for (
                        var l = u.length,
                          C = a.length,
                          m = r.newPos,
                          g = m - c,
                          p = 0;
                        m + 1 < l &&
                        g + 1 < C &&
                        this.equals(u[m + 1], a[g + 1]);

                      )
                        m++, g++, p++;
                      return (
                        p && r.components.push({ count: p }), (r.newPos = m), g
                      );
                    },
                    equals: function (r, u) {
                      return this.options.comparator
                        ? this.options.comparator(r, u)
                        : r === u ||
                            (this.options.ignoreCase &&
                              r.toLowerCase() === u.toLowerCase());
                    },
                    removeEmpty: function (r) {
                      for (var u = [], a = 0; a < r.length; a++)
                        r[a] && u.push(r[a]);
                      return u;
                    },
                    castInput: function (r) {
                      return r;
                    },
                    tokenize: function (r) {
                      return r.split("");
                    },
                    join: function (r) {
                      return r.join("");
                    },
                  };
                  function t(i, r, u, a, c) {
                    for (var l = 0, C = r.length, m = 0, g = 0; l < C; l++) {
                      var p = r[l];
                      if (p.removed) {
                        if (
                          ((p.value = i.join(a.slice(g, g + p.count))),
                          (g += p.count),
                          l && r[l - 1].added)
                        ) {
                          var h = r[l - 1];
                          (r[l - 1] = r[l]), (r[l] = h);
                        }
                      } else {
                        if (!p.added && c) {
                          var f = u.slice(m, m + p.count);
                          (f = f.map(function (T, A) {
                            var b = a[g + A];
                            return b.length > T.length ? b : T;
                          })),
                            (p.value = i.join(f));
                        } else p.value = i.join(u.slice(m, m + p.count));
                        (m += p.count), p.added || (g += p.count);
                      }
                    }
                    var N = r[C - 1];
                    return (
                      C > 1 &&
                        typeof N.value == "string" &&
                        (N.added || N.removed) &&
                        i.equals("", N.value) &&
                        ((r[C - 2].value += N.value), r.pop()),
                      r
                    );
                  }
                  function s(i) {
                    return {
                      newPos: i.newPos,
                      components: i.components.slice(0),
                    };
                  }
                },
              }),
              rD = Z({
                "node_modules/diff/lib/diff/array.js"(e) {
                  "use strict";
                  ae(),
                    Object.defineProperty(e, "__esModule", { value: !0 }),
                    (e.diffArrays = i),
                    (e.arrayDiff = void 0);
                  var n = t(tD());
                  function t(r) {
                    return r && r.__esModule ? r : { default: r };
                  }
                  var s = new n.default();
                  (e.arrayDiff = s),
                    (s.tokenize = function (r) {
                      return r.slice();
                    }),
                    (s.join = s.removeEmpty =
                      function (r) {
                        return r;
                      });
                  function i(r, u, a) {
                    return s.diff(r, u, a);
                  }
                },
              }),
              Ln = Z({
                "src/document/doc-builders.js"(e, n) {
                  "use strict";
                  ae();
                  function t(y) {
                    return { type: "concat", parts: y };
                  }
                  function s(y) {
                    return { type: "indent", contents: y };
                  }
                  function i(y, o) {
                    return { type: "align", contents: o, n: y };
                  }
                  function r(y) {
                    let o =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : {};
                    return {
                      type: "group",
                      id: o.id,
                      contents: y,
                      break: Boolean(o.shouldBreak),
                      expandedStates: o.expandedStates,
                    };
                  }
                  function u(y) {
                    return i(Number.NEGATIVE_INFINITY, y);
                  }
                  function a(y) {
                    return i({ type: "root" }, y);
                  }
                  function c(y) {
                    return i(-1, y);
                  }
                  function l(y, o) {
                    return r(
                      y[0],
                      Object.assign(
                        Object.assign({}, o),
                        {},
                        { expandedStates: y }
                      )
                    );
                  }
                  function C(y) {
                    return { type: "fill", parts: y };
                  }
                  function m(y, o) {
                    let x =
                      arguments.length > 2 && arguments[2] !== void 0
                        ? arguments[2]
                        : {};
                    return {
                      type: "if-break",
                      breakContents: y,
                      flatContents: o,
                      groupId: x.groupId,
                    };
                  }
                  function g(y, o) {
                    return {
                      type: "indent-if-break",
                      contents: y,
                      groupId: o.groupId,
                      negate: o.negate,
                    };
                  }
                  function p(y) {
                    return { type: "line-suffix", contents: y };
                  }
                  var f = { type: "line-suffix-boundary" },
                    h = { type: "break-parent" },
                    N = { type: "trim" },
                    T = { type: "line", hard: !0 },
                    A = { type: "line", hard: !0, literal: !0 },
                    b = { type: "line" },
                    v = { type: "line", soft: !0 },
                    B = t([T, h]),
                    w = t([A, h]),
                    I = { type: "cursor", placeholder: Symbol("cursor") };
                  function E(y, o) {
                    let x = [];
                    for (let F = 0; F < o.length; F++)
                      F !== 0 && x.push(y), x.push(o[F]);
                    return t(x);
                  }
                  function D(y, o, x) {
                    let F = y;
                    if (o > 0) {
                      for (let S = 0; S < Math.floor(o / x); ++S) F = s(F);
                      (F = i(o % x, F)), (F = i(Number.NEGATIVE_INFINITY, F));
                    }
                    return F;
                  }
                  function d(y, o) {
                    return { type: "label", label: y, contents: o };
                  }
                  n.exports = {
                    concat: t,
                    join: E,
                    line: b,
                    softline: v,
                    hardline: B,
                    literalline: w,
                    group: r,
                    conditionalGroup: l,
                    fill: C,
                    lineSuffix: p,
                    lineSuffixBoundary: f,
                    cursor: I,
                    breakParent: h,
                    ifBreak: m,
                    trim: N,
                    indent: s,
                    indentIfBreak: g,
                    align: i,
                    addAlignmentToDoc: D,
                    markAsRoot: a,
                    dedentToRoot: u,
                    dedent: c,
                    hardlineWithoutBreakParent: T,
                    literallineWithoutBreakParent: A,
                    label: d,
                  };
                },
              }),
              On = Z({
                "src/common/end-of-line.js"(e, n) {
                  "use strict";
                  ae();
                  function t(u) {
                    let a = u.indexOf("\r");
                    return a >= 0
                      ? u.charAt(a + 1) ===
                        `
`
                        ? "crlf"
                        : "cr"
                      : "lf";
                  }
                  function s(u) {
                    switch (u) {
                      case "cr":
                        return "\r";
                      case "crlf":
                        return `\r
`;
                      default:
                        return `
`;
                    }
                  }
                  function i(u, a) {
                    let c;
                    switch (a) {
                      case `
`:
                        c = /\n/g;
                        break;
                      case "\r":
                        c = /\r/g;
                        break;
                      case `\r
`:
                        c = /\r\n/g;
                        break;
                      default:
                        throw new Error(
                          'Unexpected "eol" '.concat(JSON.stringify(a), ".")
                        );
                    }
                    let l = u.match(c);
                    return l ? l.length : 0;
                  }
                  function r(u) {
                    return u.replace(
                      /\r\n?/g,
                      `
`
                    );
                  }
                  n.exports = {
                    guessEndOfLine: t,
                    convertEndOfLineToChars: s,
                    countEndOfLineChars: i,
                    normalizeEndOfLine: r,
                  };
                },
              }),
              st = Z({
                "src/utils/get-last.js"(e, n) {
                  "use strict";
                  ae();
                  var t = (s) => s[s.length - 1];
                  n.exports = t;
                },
              }),
              nD = Z({
                "vendors/string-width.js"(e, n) {
                  ae();
                  var t = Object.create,
                    s = Object.defineProperty,
                    i = Object.getOwnPropertyDescriptor,
                    r = Object.getOwnPropertyNames,
                    u = Object.getPrototypeOf,
                    a = Object.prototype.hasOwnProperty,
                    c = (v, B) =>
                      function () {
                        return (
                          B ||
                            (0, v[r(v)[0]])((B = { exports: {} }).exports, B),
                          B.exports
                        );
                      },
                    l = (v, B) => {
                      for (var w in B) s(v, w, { get: B[w], enumerable: !0 });
                    },
                    C = (v, B, w, I) => {
                      if ((B && typeof B == "object") || typeof B == "function")
                        for (let E of r(B))
                          !a.call(v, E) &&
                            E !== w &&
                            s(v, E, {
                              get: () => B[E],
                              enumerable: !(I = i(B, E)) || I.enumerable,
                            });
                      return v;
                    },
                    m = (v, B, w) => (
                      (w = v != null ? t(u(v)) : {}),
                      C(
                        B || !v || !v.__esModule
                          ? s(w, "default", { value: v, enumerable: !0 })
                          : w,
                        v
                      )
                    ),
                    g = (v) => C(s({}, "__esModule", { value: !0 }), v),
                    p = c({
                      "node_modules/emoji-regex/index.js"(v, B) {
                        "use strict";
                        B.exports = function () {
                          return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
                        };
                      },
                    }),
                    f = {};
                  l(f, { default: () => b }), (n.exports = g(f));
                  function h() {
                    let { onlyFirst: v = !1 } =
                        arguments.length > 0 && arguments[0] !== void 0
                          ? arguments[0]
                          : {},
                      B = [
                        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
                      ].join("|");
                    return new RegExp(B, v ? void 0 : "g");
                  }
                  function N(v) {
                    if (typeof v != "string")
                      throw new TypeError(
                        "Expected a `string`, got `".concat(typeof v, "`")
                      );
                    return v.replace(h(), "");
                  }
                  function T(v) {
                    return Number.isInteger(v)
                      ? v >= 4352 &&
                          (v <= 4447 ||
                            v === 9001 ||
                            v === 9002 ||
                            (11904 <= v && v <= 12871 && v !== 12351) ||
                            (12880 <= v && v <= 19903) ||
                            (19968 <= v && v <= 42182) ||
                            (43360 <= v && v <= 43388) ||
                            (44032 <= v && v <= 55203) ||
                            (63744 <= v && v <= 64255) ||
                            (65040 <= v && v <= 65049) ||
                            (65072 <= v && v <= 65131) ||
                            (65281 <= v && v <= 65376) ||
                            (65504 <= v && v <= 65510) ||
                            (110592 <= v && v <= 110593) ||
                            (127488 <= v && v <= 127569) ||
                            (131072 <= v && v <= 262141))
                      : !1;
                  }
                  var A = m(p(), 1);
                  function b(v) {
                    if (
                      typeof v != "string" ||
                      v.length === 0 ||
                      ((v = N(v)), v.length === 0)
                    )
                      return 0;
                    v = v.replace((0, A.default)(), "  ");
                    let B = 0;
                    for (let w = 0; w < v.length; w++) {
                      let I = v.codePointAt(w);
                      I <= 31 ||
                        (I >= 127 && I <= 159) ||
                        (I >= 768 && I <= 879) ||
                        (I > 65535 && w++, (B += T(I) ? 2 : 1));
                    }
                    return B;
                  }
                },
              }),
              yi = Z({
                "src/utils/get-string-width.js"(e, n) {
                  "use strict";
                  ae();
                  var t = nD().default,
                    s = /[^\x20-\x7F]/;
                  function i(r) {
                    return r ? (s.test(r) ? t(r) : r.length) : 0;
                  }
                  n.exports = i;
                },
              }),
              jn = Z({
                "src/document/doc-utils.js"(e, n) {
                  "use strict";
                  ae();
                  var t = st(),
                    { literalline: s, join: i } = Ln(),
                    r = (o) => Array.isArray(o) || (o && o.type === "concat"),
                    u = (o) => {
                      if (Array.isArray(o)) return o;
                      if (o.type !== "concat" && o.type !== "fill")
                        throw new Error(
                          "Expect doc type to be `concat` or `fill`."
                        );
                      return o.parts;
                    },
                    a = {};
                  function c(o, x, F, S) {
                    let k = [o];
                    for (; k.length > 0; ) {
                      let _ = k.pop();
                      if (_ === a) {
                        F(k.pop());
                        continue;
                      }
                      if ((F && k.push(_, a), !x || x(_) !== !1))
                        if (r(_) || _.type === "fill") {
                          let O = u(_);
                          for (let R = O.length, M = R - 1; M >= 0; --M)
                            k.push(O[M]);
                        } else if (_.type === "if-break")
                          _.flatContents && k.push(_.flatContents),
                            _.breakContents && k.push(_.breakContents);
                        else if (_.type === "group" && _.expandedStates)
                          if (S)
                            for (
                              let O = _.expandedStates.length, R = O - 1;
                              R >= 0;
                              --R
                            )
                              k.push(_.expandedStates[R]);
                          else k.push(_.contents);
                        else _.contents && k.push(_.contents);
                    }
                  }
                  function l(o, x) {
                    let F = new Map();
                    return S(o);
                    function S(_) {
                      if (F.has(_)) return F.get(_);
                      let O = k(_);
                      return F.set(_, O), O;
                    }
                    function k(_) {
                      if (Array.isArray(_)) return x(_.map(S));
                      if (_.type === "concat" || _.type === "fill") {
                        let O = _.parts.map(S);
                        return x(
                          Object.assign(Object.assign({}, _), {}, { parts: O })
                        );
                      }
                      if (_.type === "if-break") {
                        let O = _.breakContents && S(_.breakContents),
                          R = _.flatContents && S(_.flatContents);
                        return x(
                          Object.assign(
                            Object.assign({}, _),
                            {},
                            { breakContents: O, flatContents: R }
                          )
                        );
                      }
                      if (_.type === "group" && _.expandedStates) {
                        let O = _.expandedStates.map(S),
                          R = O[0];
                        return x(
                          Object.assign(
                            Object.assign({}, _),
                            {},
                            { contents: R, expandedStates: O }
                          )
                        );
                      }
                      if (_.contents) {
                        let O = S(_.contents);
                        return x(
                          Object.assign(
                            Object.assign({}, _),
                            {},
                            { contents: O }
                          )
                        );
                      }
                      return x(_);
                    }
                  }
                  function C(o, x, F) {
                    let S = F,
                      k = !1;
                    function _(O) {
                      let R = x(O);
                      if ((R !== void 0 && ((k = !0), (S = R)), k)) return !1;
                    }
                    return c(o, _), S;
                  }
                  function m(o) {
                    if (
                      (o.type === "group" && o.break) ||
                      (o.type === "line" && o.hard) ||
                      o.type === "break-parent"
                    )
                      return !0;
                  }
                  function g(o) {
                    return C(o, m, !1);
                  }
                  function p(o) {
                    if (o.length > 0) {
                      let x = t(o);
                      !x.expandedStates && !x.break && (x.break = "propagated");
                    }
                    return null;
                  }
                  function f(o) {
                    let x = new Set(),
                      F = [];
                    function S(_) {
                      if (
                        (_.type === "break-parent" && p(F), _.type === "group")
                      ) {
                        if ((F.push(_), x.has(_))) return !1;
                        x.add(_);
                      }
                    }
                    function k(_) {
                      _.type === "group" && F.pop().break && p(F);
                    }
                    c(o, S, k, !0);
                  }
                  function h(o) {
                    return o.type === "line" && !o.hard
                      ? o.soft
                        ? ""
                        : " "
                      : o.type === "if-break"
                      ? o.flatContents || ""
                      : o;
                  }
                  function N(o) {
                    return l(o, h);
                  }
                  var T = (o, x) =>
                    o &&
                    o.type === "line" &&
                    o.hard &&
                    x &&
                    x.type === "break-parent";
                  function A(o) {
                    if (!o) return o;
                    if (r(o) || o.type === "fill") {
                      let x = u(o);
                      for (; x.length > 1 && T(...x.slice(-2)); ) x.length -= 2;
                      if (x.length > 0) {
                        let F = A(t(x));
                        x[x.length - 1] = F;
                      }
                      return Array.isArray(o)
                        ? x
                        : Object.assign(Object.assign({}, o), {}, { parts: x });
                    }
                    switch (o.type) {
                      case "align":
                      case "indent":
                      case "indent-if-break":
                      case "group":
                      case "line-suffix":
                      case "label": {
                        let x = A(o.contents);
                        return Object.assign(
                          Object.assign({}, o),
                          {},
                          { contents: x }
                        );
                      }
                      case "if-break": {
                        let x = A(o.breakContents),
                          F = A(o.flatContents);
                        return Object.assign(
                          Object.assign({}, o),
                          {},
                          { breakContents: x, flatContents: F }
                        );
                      }
                    }
                    return o;
                  }
                  function b(o) {
                    return A(B(o));
                  }
                  function v(o) {
                    switch (o.type) {
                      case "fill":
                        if (o.parts.every((F) => F === "")) return "";
                        break;
                      case "group":
                        if (
                          !o.contents &&
                          !o.id &&
                          !o.break &&
                          !o.expandedStates
                        )
                          return "";
                        if (
                          o.contents.type === "group" &&
                          o.contents.id === o.id &&
                          o.contents.break === o.break &&
                          o.contents.expandedStates === o.expandedStates
                        )
                          return o.contents;
                        break;
                      case "align":
                      case "indent":
                      case "indent-if-break":
                      case "line-suffix":
                        if (!o.contents) return "";
                        break;
                      case "if-break":
                        if (!o.flatContents && !o.breakContents) return "";
                        break;
                    }
                    if (!r(o)) return o;
                    let x = [];
                    for (let F of u(o)) {
                      if (!F) continue;
                      let [S, ...k] = r(F) ? u(F) : [F];
                      typeof S == "string" && typeof t(x) == "string"
                        ? (x[x.length - 1] += S)
                        : x.push(S),
                        x.push(...k);
                    }
                    return x.length === 0
                      ? ""
                      : x.length === 1
                      ? x[0]
                      : Array.isArray(o)
                      ? x
                      : Object.assign(Object.assign({}, o), {}, { parts: x });
                  }
                  function B(o) {
                    return l(o, (x) => v(x));
                  }
                  function w(o) {
                    let x = [],
                      F = o.filter(Boolean);
                    for (; F.length > 0; ) {
                      let S = F.shift();
                      if (!!S) {
                        if (r(S)) {
                          F.unshift(...u(S));
                          continue;
                        }
                        if (
                          x.length > 0 &&
                          typeof t(x) == "string" &&
                          typeof S == "string"
                        ) {
                          x[x.length - 1] += S;
                          continue;
                        }
                        x.push(S);
                      }
                    }
                    return x;
                  }
                  function I(o) {
                    return l(o, (x) =>
                      Array.isArray(x)
                        ? w(x)
                        : x.parts
                        ? Object.assign(
                            Object.assign({}, x),
                            {},
                            { parts: w(x.parts) }
                          )
                        : x
                    );
                  }
                  function E(o) {
                    return l(o, (x) =>
                      typeof x == "string" &&
                      x.includes(`
`)
                        ? D(x)
                        : x
                    );
                  }
                  function D(o) {
                    let x =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : s;
                    return i(
                      x,
                      o.split(`
`)
                    ).parts;
                  }
                  function d(o) {
                    if (o.type === "line") return !0;
                  }
                  function y(o) {
                    return C(o, d, !1);
                  }
                  n.exports = {
                    isConcat: r,
                    getDocParts: u,
                    willBreak: g,
                    traverseDoc: c,
                    findInDoc: C,
                    mapDoc: l,
                    propagateBreaks: f,
                    removeLines: N,
                    stripTrailingHardline: b,
                    normalizeParts: w,
                    normalizeDoc: I,
                    cleanDoc: B,
                    replaceTextEndOfLine: D,
                    replaceEndOfLine: E,
                    canBreak: y,
                  };
                },
              }),
              uD = Z({
                "src/document/doc-printer.js"(e, n) {
                  "use strict";
                  ae();
                  var { convertEndOfLineToChars: t } = On(),
                    s = st(),
                    i = yi(),
                    { fill: r, cursor: u, indent: a } = Ln(),
                    { isConcat: c, getDocParts: l } = jn(),
                    C,
                    m = 1,
                    g = 2;
                  function p() {
                    return { value: "", length: 0, queue: [] };
                  }
                  function f(v, B) {
                    return N(v, { type: "indent" }, B);
                  }
                  function h(v, B, w) {
                    return B === Number.NEGATIVE_INFINITY
                      ? v.root || p()
                      : B < 0
                      ? N(v, { type: "dedent" }, w)
                      : B
                      ? B.type === "root"
                        ? Object.assign(Object.assign({}, v), {}, { root: v })
                        : N(
                            v,
                            {
                              type:
                                typeof B == "string"
                                  ? "stringAlign"
                                  : "numberAlign",
                              n: B,
                            },
                            w
                          )
                      : v;
                  }
                  function N(v, B, w) {
                    let I =
                        B.type === "dedent"
                          ? v.queue.slice(0, -1)
                          : [...v.queue, B],
                      E = "",
                      D = 0,
                      d = 0,
                      y = 0;
                    for (let O of I)
                      switch (O.type) {
                        case "indent":
                          F(), w.useTabs ? o(1) : x(w.tabWidth);
                          break;
                        case "stringAlign":
                          F(), (E += O.n), (D += O.n.length);
                          break;
                        case "numberAlign":
                          (d += 1), (y += O.n);
                          break;
                        default:
                          throw new Error(
                            "Unexpected type '".concat(O.type, "'")
                          );
                      }
                    return (
                      k(),
                      Object.assign(
                        Object.assign({}, v),
                        {},
                        { value: E, length: D, queue: I }
                      )
                    );
                    function o(O) {
                      (E += "	".repeat(O)), (D += w.tabWidth * O);
                    }
                    function x(O) {
                      (E += " ".repeat(O)), (D += O);
                    }
                    function F() {
                      w.useTabs ? S() : k();
                    }
                    function S() {
                      d > 0 && o(d), _();
                    }
                    function k() {
                      y > 0 && x(y), _();
                    }
                    function _() {
                      (d = 0), (y = 0);
                    }
                  }
                  function T(v) {
                    if (v.length === 0) return 0;
                    let B = 0;
                    for (
                      ;
                      v.length > 0 &&
                      typeof s(v) == "string" &&
                      /^[\t ]*$/.test(s(v));

                    )
                      B += v.pop().length;
                    if (v.length > 0 && typeof s(v) == "string") {
                      let w = s(v).replace(/[\t ]*$/, "");
                      (B += s(v).length - w.length), (v[v.length - 1] = w);
                    }
                    return B;
                  }
                  function A(v, B, w, I, E, D) {
                    let d = B.length,
                      y = [v],
                      o = [];
                    for (; w >= 0; ) {
                      if (y.length === 0) {
                        if (d === 0) return !0;
                        y.push(B[d - 1]), d--;
                        continue;
                      }
                      let [x, F, S] = y.pop();
                      if (typeof S == "string") o.push(S), (w -= i(S));
                      else if (c(S)) {
                        let k = l(S);
                        for (let _ = k.length - 1; _ >= 0; _--)
                          y.push([x, F, k[_]]);
                      } else
                        switch (S.type) {
                          case "indent":
                            y.push([f(x, I), F, S.contents]);
                            break;
                          case "align":
                            y.push([h(x, S.n, I), F, S.contents]);
                            break;
                          case "trim":
                            w += T(o);
                            break;
                          case "group": {
                            if (D && S.break) return !1;
                            let k = S.break ? m : F;
                            y.push([
                              x,
                              k,
                              S.expandedStates && k === m
                                ? s(S.expandedStates)
                                : S.contents,
                            ]),
                              S.id && (C[S.id] = k);
                            break;
                          }
                          case "fill":
                            for (let k = S.parts.length - 1; k >= 0; k--)
                              y.push([x, F, S.parts[k]]);
                            break;
                          case "if-break":
                          case "indent-if-break": {
                            let k = S.groupId ? C[S.groupId] : F;
                            if (k === m) {
                              let _ =
                                S.type === "if-break"
                                  ? S.breakContents
                                  : S.negate
                                  ? S.contents
                                  : a(S.contents);
                              _ && y.push([x, F, _]);
                            }
                            if (k === g) {
                              let _ =
                                S.type === "if-break"
                                  ? S.flatContents
                                  : S.negate
                                  ? a(S.contents)
                                  : S.contents;
                              _ && y.push([x, F, _]);
                            }
                            break;
                          }
                          case "line":
                            switch (F) {
                              case g:
                                if (!S.hard) {
                                  S.soft || (o.push(" "), (w -= 1));
                                  break;
                                }
                                return !0;
                              case m:
                                return !0;
                            }
                            break;
                          case "line-suffix":
                            E = !0;
                            break;
                          case "line-suffix-boundary":
                            if (E) return !1;
                            break;
                          case "label":
                            y.push([x, F, S.contents]);
                            break;
                        }
                    }
                    return !1;
                  }
                  function b(v, B) {
                    C = {};
                    let w = B.printWidth,
                      I = t(B.endOfLine),
                      E = 0,
                      D = [[p(), m, v]],
                      d = [],
                      y = !1,
                      o = [];
                    for (; D.length > 0; ) {
                      let [F, S, k] = D.pop();
                      if (typeof k == "string") {
                        let _ =
                          I !==
                          `
`
                            ? k.replace(/\n/g, I)
                            : k;
                        d.push(_), (E += i(_));
                      } else if (c(k)) {
                        let _ = l(k);
                        for (let O = _.length - 1; O >= 0; O--)
                          D.push([F, S, _[O]]);
                      } else
                        switch (k.type) {
                          case "cursor":
                            d.push(u.placeholder);
                            break;
                          case "indent":
                            D.push([f(F, B), S, k.contents]);
                            break;
                          case "align":
                            D.push([h(F, k.n, B), S, k.contents]);
                            break;
                          case "trim":
                            E -= T(d);
                            break;
                          case "group":
                            switch (S) {
                              case g:
                                if (!y) {
                                  D.push([F, k.break ? m : g, k.contents]);
                                  break;
                                }
                              case m: {
                                y = !1;
                                let _ = [F, g, k.contents],
                                  O = w - E,
                                  R = o.length > 0;
                                if (!k.break && A(_, D, O, B, R)) D.push(_);
                                else if (k.expandedStates) {
                                  let M = s(k.expandedStates);
                                  if (k.break) {
                                    D.push([F, m, M]);
                                    break;
                                  } else
                                    for (
                                      let H = 1;
                                      H < k.expandedStates.length + 1;
                                      H++
                                    )
                                      if (H >= k.expandedStates.length) {
                                        D.push([F, m, M]);
                                        break;
                                      } else {
                                        let P = k.expandedStates[H],
                                          G = [F, g, P];
                                        if (A(G, D, O, B, R)) {
                                          D.push(G);
                                          break;
                                        }
                                      }
                                } else D.push([F, m, k.contents]);
                                break;
                              }
                            }
                            k.id && (C[k.id] = s(D)[1]);
                            break;
                          case "fill": {
                            let _ = w - E,
                              { parts: O } = k;
                            if (O.length === 0) break;
                            let [R, M] = O,
                              H = [F, g, R],
                              P = [F, m, R],
                              G = A(H, [], _, B, o.length > 0, !0);
                            if (O.length === 1) {
                              G ? D.push(H) : D.push(P);
                              break;
                            }
                            let re = [F, g, M],
                              $ = [F, m, M];
                            if (O.length === 2) {
                              G ? D.push(re, H) : D.push($, P);
                              break;
                            }
                            O.splice(0, 2);
                            let W = [F, S, r(O)],
                              ee = O[0];
                            A([F, g, [R, M, ee]], [], _, B, o.length > 0, !0)
                              ? D.push(W, re, H)
                              : G
                              ? D.push(W, $, H)
                              : D.push(W, $, P);
                            break;
                          }
                          case "if-break":
                          case "indent-if-break": {
                            let _ = k.groupId ? C[k.groupId] : S;
                            if (_ === m) {
                              let O =
                                k.type === "if-break"
                                  ? k.breakContents
                                  : k.negate
                                  ? k.contents
                                  : a(k.contents);
                              O && D.push([F, S, O]);
                            }
                            if (_ === g) {
                              let O =
                                k.type === "if-break"
                                  ? k.flatContents
                                  : k.negate
                                  ? a(k.contents)
                                  : k.contents;
                              O && D.push([F, S, O]);
                            }
                            break;
                          }
                          case "line-suffix":
                            o.push([F, S, k.contents]);
                            break;
                          case "line-suffix-boundary":
                            o.length > 0 &&
                              D.push([F, S, { type: "line", hard: !0 }]);
                            break;
                          case "line":
                            switch (S) {
                              case g:
                                if (k.hard) y = !0;
                                else {
                                  k.soft || (d.push(" "), (E += 1));
                                  break;
                                }
                              case m:
                                if (o.length > 0) {
                                  D.push([F, S, k], ...o.reverse()), (o = []);
                                  break;
                                }
                                k.literal
                                  ? F.root
                                    ? (d.push(I, F.root.value),
                                      (E = F.root.length))
                                    : (d.push(I), (E = 0))
                                  : ((E -= T(d)),
                                    d.push(I + F.value),
                                    (E = F.length));
                                break;
                            }
                            break;
                          case "label":
                            D.push([F, S, k.contents]);
                            break;
                          default:
                        }
                      D.length === 0 &&
                        o.length > 0 &&
                        (D.push(...o.reverse()), (o = []));
                    }
                    let x = d.indexOf(u.placeholder);
                    if (x !== -1) {
                      let F = d.indexOf(u.placeholder, x + 1),
                        S = d.slice(0, x).join(""),
                        k = d.slice(x + 1, F).join(""),
                        _ = d.slice(F + 1).join("");
                      return {
                        formatted: S + k + _,
                        cursorNodeStart: S.length,
                        cursorNodeText: k,
                      };
                    }
                    return { formatted: d.join("") };
                  }
                  n.exports = { printDocToString: b };
                },
              }),
              sD = Z({
                "src/document/doc-debug.js"(e, n) {
                  "use strict";
                  ae();
                  var { isConcat: t, getDocParts: s } = jn();
                  function i(u) {
                    if (!u) return "";
                    if (t(u)) {
                      let a = [];
                      for (let c of s(u))
                        if (t(c)) a.push(...i(c).parts);
                        else {
                          let l = i(c);
                          l !== "" && a.push(l);
                        }
                      return { type: "concat", parts: a };
                    }
                    return u.type === "if-break"
                      ? Object.assign(
                          Object.assign({}, u),
                          {},
                          {
                            breakContents: i(u.breakContents),
                            flatContents: i(u.flatContents),
                          }
                        )
                      : u.type === "group"
                      ? Object.assign(
                          Object.assign({}, u),
                          {},
                          {
                            contents: i(u.contents),
                            expandedStates:
                              u.expandedStates && u.expandedStates.map(i),
                          }
                        )
                      : u.type === "fill"
                      ? { type: "fill", parts: u.parts.map(i) }
                      : u.contents
                      ? Object.assign(
                          Object.assign({}, u),
                          {},
                          { contents: i(u.contents) }
                        )
                      : u;
                  }
                  function r(u) {
                    let a = Object.create(null),
                      c = new Set();
                    return l(i(u));
                    function l(m, g, p) {
                      if (typeof m == "string") return JSON.stringify(m);
                      if (t(m)) {
                        let f = s(m).map(l).filter(Boolean);
                        return f.length === 1
                          ? f[0]
                          : "[".concat(f.join(", "), "]");
                      }
                      if (m.type === "line") {
                        let f =
                          Array.isArray(p) &&
                          p[g + 1] &&
                          p[g + 1].type === "break-parent";
                        return m.literal
                          ? f
                            ? "literalline"
                            : "literallineWithoutBreakParent"
                          : m.hard
                          ? f
                            ? "hardline"
                            : "hardlineWithoutBreakParent"
                          : m.soft
                          ? "softline"
                          : "line";
                      }
                      if (m.type === "break-parent")
                        return Array.isArray(p) &&
                          p[g - 1] &&
                          p[g - 1].type === "line" &&
                          p[g - 1].hard
                          ? void 0
                          : "breakParent";
                      if (m.type === "trim") return "trim";
                      if (m.type === "indent")
                        return "indent(" + l(m.contents) + ")";
                      if (m.type === "align")
                        return m.n === Number.NEGATIVE_INFINITY
                          ? "dedentToRoot(" + l(m.contents) + ")"
                          : m.n < 0
                          ? "dedent(" + l(m.contents) + ")"
                          : m.n.type === "root"
                          ? "markAsRoot(" + l(m.contents) + ")"
                          : "align(" +
                            JSON.stringify(m.n) +
                            ", " +
                            l(m.contents) +
                            ")";
                      if (m.type === "if-break")
                        return (
                          "ifBreak(" +
                          l(m.breakContents) +
                          (m.flatContents ? ", " + l(m.flatContents) : "") +
                          (m.groupId
                            ? (m.flatContents ? "" : ', ""') +
                              ", { groupId: ".concat(C(m.groupId), " }")
                            : "") +
                          ")"
                        );
                      if (m.type === "indent-if-break") {
                        let f = [];
                        m.negate && f.push("negate: true"),
                          m.groupId && f.push("groupId: ".concat(C(m.groupId)));
                        let h =
                          f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                        return "indentIfBreak("
                          .concat(l(m.contents))
                          .concat(h, ")");
                      }
                      if (m.type === "group") {
                        let f = [];
                        m.break &&
                          m.break !== "propagated" &&
                          f.push("shouldBreak: true"),
                          m.id && f.push("id: ".concat(C(m.id)));
                        let h =
                          f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                        return m.expandedStates
                          ? "conditionalGroup(["
                              .concat(
                                m.expandedStates.map((N) => l(N)).join(","),
                                "]"
                              )
                              .concat(h, ")")
                          : "group(".concat(l(m.contents)).concat(h, ")");
                      }
                      if (m.type === "fill")
                        return "fill([".concat(
                          m.parts.map((f) => l(f)).join(", "),
                          "])"
                        );
                      if (m.type === "line-suffix")
                        return "lineSuffix(" + l(m.contents) + ")";
                      if (m.type === "line-suffix-boundary")
                        return "lineSuffixBoundary";
                      if (m.type === "label")
                        return "label("
                          .concat(JSON.stringify(m.label), ", ")
                          .concat(l(m.contents), ")");
                      throw new Error("Unknown doc type " + m.type);
                    }
                    function C(m) {
                      if (typeof m != "symbol")
                        return JSON.stringify(String(m));
                      if (m in a) return a[m];
                      let g = String(m).slice(7, -1) || "symbol";
                      for (let p = 0; ; p++) {
                        let f = g + (p > 0 ? " #".concat(p) : "");
                        if (!c.has(f))
                          return (
                            c.add(f),
                            (a[m] = "Symbol.for(".concat(
                              JSON.stringify(f),
                              ")"
                            ))
                          );
                      }
                    }
                  }
                  n.exports = { printDocToDebug: r };
                },
              }),
              Le = Z({
                "src/document/index.js"(e, n) {
                  "use strict";
                  ae(),
                    (n.exports = {
                      builders: Ln(),
                      printer: uD(),
                      utils: jn(),
                      debug: sD(),
                    });
                },
              }),
              aD = Z({
                "vendors/escape-string-regexp.js"(e, n) {
                  ae();
                  var t = Object.defineProperty,
                    s = Object.getOwnPropertyDescriptor,
                    i = Object.getOwnPropertyNames,
                    r = Object.prototype.hasOwnProperty,
                    u = (m, g) => {
                      for (var p in g) t(m, p, { get: g[p], enumerable: !0 });
                    },
                    a = (m, g, p, f) => {
                      if ((g && typeof g == "object") || typeof g == "function")
                        for (let h of i(g))
                          !r.call(m, h) &&
                            h !== p &&
                            t(m, h, {
                              get: () => g[h],
                              enumerable: !(f = s(g, h)) || f.enumerable,
                            });
                      return m;
                    },
                    c = (m) => a(t({}, "__esModule", { value: !0 }), m),
                    l = {};
                  u(l, { default: () => C }), (n.exports = c(l));
                  function C(m) {
                    if (typeof m != "string")
                      throw new TypeError("Expected a string");
                    return m
                      .replace(/[|\\{}()[\]^$+*?.]/g, "\\$&")
                      .replace(/-/g, "\\x2d");
                  }
                },
              }),
              hi = Z({
                "node_modules/semver/internal/debug.js"(e, n) {
                  ae();
                  var t =
                    typeof xt == "object" &&
                    xt.env &&
                    xt.env.NODE_DEBUG &&
                    /\bsemver\b/i.test(xt.env.NODE_DEBUG)
                      ? function () {
                          for (
                            var s = arguments.length, i = new Array(s), r = 0;
                            r < s;
                            r++
                          )
                            i[r] = arguments[r];
                          return console.error("SEMVER", ...i);
                        }
                      : () => {};
                  n.exports = t;
                },
              }),
              Ci = Z({
                "node_modules/semver/internal/constants.js"(e, n) {
                  ae();
                  var t = "2.0.0",
                    s = 256,
                    i = Number.MAX_SAFE_INTEGER || 9007199254740991,
                    r = 16;
                  n.exports = {
                    SEMVER_SPEC_VERSION: t,
                    MAX_LENGTH: s,
                    MAX_SAFE_INTEGER: i,
                    MAX_SAFE_COMPONENT_LENGTH: r,
                  };
                },
              }),
              iD = Z({
                "node_modules/semver/internal/re.js"(e, n) {
                  ae();
                  var { MAX_SAFE_COMPONENT_LENGTH: t } = Ci(),
                    s = hi();
                  e = n.exports = {};
                  var i = (e.re = []),
                    r = (e.src = []),
                    u = (e.t = {}),
                    a = 0,
                    c = (l, C, m) => {
                      let g = a++;
                      s(g, C),
                        (u[l] = g),
                        (r[g] = C),
                        (i[g] = new RegExp(C, m ? "g" : void 0));
                    };
                  c("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
                    c("NUMERICIDENTIFIERLOOSE", "[0-9]+"),
                    c("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"),
                    c(
                      "MAINVERSION",
                      "("
                        .concat(r[u.NUMERICIDENTIFIER], ")\\.(")
                        .concat(r[u.NUMERICIDENTIFIER], ")\\.(")
                        .concat(r[u.NUMERICIDENTIFIER], ")")
                    ),
                    c(
                      "MAINVERSIONLOOSE",
                      "("
                        .concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(")
                        .concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(")
                        .concat(r[u.NUMERICIDENTIFIERLOOSE], ")")
                    ),
                    c(
                      "PRERELEASEIDENTIFIER",
                      "(?:"
                        .concat(r[u.NUMERICIDENTIFIER], "|")
                        .concat(r[u.NONNUMERICIDENTIFIER], ")")
                    ),
                    c(
                      "PRERELEASEIDENTIFIERLOOSE",
                      "(?:"
                        .concat(r[u.NUMERICIDENTIFIERLOOSE], "|")
                        .concat(r[u.NONNUMERICIDENTIFIER], ")")
                    ),
                    c(
                      "PRERELEASE",
                      "(?:-("
                        .concat(r[u.PRERELEASEIDENTIFIER], "(?:\\.")
                        .concat(r[u.PRERELEASEIDENTIFIER], ")*))")
                    ),
                    c(
                      "PRERELEASELOOSE",
                      "(?:-?("
                        .concat(r[u.PRERELEASEIDENTIFIERLOOSE], "(?:\\.")
                        .concat(r[u.PRERELEASEIDENTIFIERLOOSE], ")*))")
                    ),
                    c("BUILDIDENTIFIER", "[0-9A-Za-z-]+"),
                    c(
                      "BUILD",
                      "(?:\\+("
                        .concat(r[u.BUILDIDENTIFIER], "(?:\\.")
                        .concat(r[u.BUILDIDENTIFIER], ")*))")
                    ),
                    c(
                      "FULLPLAIN",
                      "v?"
                        .concat(r[u.MAINVERSION])
                        .concat(r[u.PRERELEASE], "?")
                        .concat(r[u.BUILD], "?")
                    ),
                    c("FULL", "^".concat(r[u.FULLPLAIN], "$")),
                    c(
                      "LOOSEPLAIN",
                      "[v=\\s]*"
                        .concat(r[u.MAINVERSIONLOOSE])
                        .concat(r[u.PRERELEASELOOSE], "?")
                        .concat(r[u.BUILD], "?")
                    ),
                    c("LOOSE", "^".concat(r[u.LOOSEPLAIN], "$")),
                    c("GTLT", "((?:<|>)?=?)"),
                    c(
                      "XRANGEIDENTIFIERLOOSE",
                      "".concat(r[u.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")
                    ),
                    c(
                      "XRANGEIDENTIFIER",
                      "".concat(r[u.NUMERICIDENTIFIER], "|x|X|\\*")
                    ),
                    c(
                      "XRANGEPLAIN",
                      "[v=\\s]*("
                        .concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(")
                        .concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(")
                        .concat(r[u.XRANGEIDENTIFIER], ")(?:")
                        .concat(r[u.PRERELEASE], ")?")
                        .concat(r[u.BUILD], "?)?)?")
                    ),
                    c(
                      "XRANGEPLAINLOOSE",
                      "[v=\\s]*("
                        .concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(")
                        .concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(")
                        .concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:")
                        .concat(r[u.PRERELEASELOOSE], ")?")
                        .concat(r[u.BUILD], "?)?)?")
                    ),
                    c(
                      "XRANGE",
                      "^"
                        .concat(r[u.GTLT], "\\s*")
                        .concat(r[u.XRANGEPLAIN], "$")
                    ),
                    c(
                      "XRANGELOOSE",
                      "^"
                        .concat(r[u.GTLT], "\\s*")
                        .concat(r[u.XRANGEPLAINLOOSE], "$")
                    ),
                    c(
                      "COERCE",
                      "(^|[^\\d])(\\d{1,"
                        .concat(t, "})(?:\\.(\\d{1,")
                        .concat(t, "}))?(?:\\.(\\d{1,")
                        .concat(t, "}))?(?:$|[^\\d])")
                    ),
                    c("COERCERTL", r[u.COERCE], !0),
                    c("LONETILDE", "(?:~>?)"),
                    c("TILDETRIM", "(\\s*)".concat(r[u.LONETILDE], "\\s+"), !0),
                    (e.tildeTrimReplace = "$1~"),
                    c(
                      "TILDE",
                      "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAIN], "$")
                    ),
                    c(
                      "TILDELOOSE",
                      "^"
                        .concat(r[u.LONETILDE])
                        .concat(r[u.XRANGEPLAINLOOSE], "$")
                    ),
                    c("LONECARET", "(?:\\^)"),
                    c("CARETTRIM", "(\\s*)".concat(r[u.LONECARET], "\\s+"), !0),
                    (e.caretTrimReplace = "$1^"),
                    c(
                      "CARET",
                      "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAIN], "$")
                    ),
                    c(
                      "CARETLOOSE",
                      "^"
                        .concat(r[u.LONECARET])
                        .concat(r[u.XRANGEPLAINLOOSE], "$")
                    ),
                    c(
                      "COMPARATORLOOSE",
                      "^"
                        .concat(r[u.GTLT], "\\s*(")
                        .concat(r[u.LOOSEPLAIN], ")$|^$")
                    ),
                    c(
                      "COMPARATOR",
                      "^"
                        .concat(r[u.GTLT], "\\s*(")
                        .concat(r[u.FULLPLAIN], ")$|^$")
                    ),
                    c(
                      "COMPARATORTRIM",
                      "(\\s*)"
                        .concat(r[u.GTLT], "\\s*(")
                        .concat(r[u.LOOSEPLAIN], "|")
                        .concat(r[u.XRANGEPLAIN], ")"),
                      !0
                    ),
                    (e.comparatorTrimReplace = "$1$2$3"),
                    c(
                      "HYPHENRANGE",
                      "^\\s*("
                        .concat(r[u.XRANGEPLAIN], ")\\s+-\\s+(")
                        .concat(r[u.XRANGEPLAIN], ")\\s*$")
                    ),
                    c(
                      "HYPHENRANGELOOSE",
                      "^\\s*("
                        .concat(r[u.XRANGEPLAINLOOSE], ")\\s+-\\s+(")
                        .concat(r[u.XRANGEPLAINLOOSE], ")\\s*$")
                    ),
                    c("STAR", "(<|>)?=?\\s*\\*"),
                    c("GTE0", "^\\s*>=\\s*0.0.0\\s*$"),
                    c("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
                },
              }),
              oD = Z({
                "node_modules/semver/internal/parse-options.js"(e, n) {
                  ae();
                  var t = ["includePrerelease", "loose", "rtl"],
                    s = (i) =>
                      i
                        ? typeof i != "object"
                          ? { loose: !0 }
                          : t
                              .filter((r) => i[r])
                              .reduce((r, u) => ((r[u] = !0), r), {})
                        : {};
                  n.exports = s;
                },
              }),
              cD = Z({
                "node_modules/semver/internal/identifiers.js"(e, n) {
                  ae();
                  var t = /^[0-9]+$/,
                    s = (r, u) => {
                      let a = t.test(r),
                        c = t.test(u);
                      return (
                        a && c && ((r = +r), (u = +u)),
                        r === u
                          ? 0
                          : a && !c
                          ? -1
                          : c && !a
                          ? 1
                          : r < u
                          ? -1
                          : 1
                      );
                    },
                    i = (r, u) => s(u, r);
                  n.exports = { compareIdentifiers: s, rcompareIdentifiers: i };
                },
              }),
              lD = Z({
                "node_modules/semver/classes/semver.js"(e, n) {
                  ae();
                  var t = hi(),
                    { MAX_LENGTH: s, MAX_SAFE_INTEGER: i } = Ci(),
                    { re: r, t: u } = iD(),
                    a = oD(),
                    { compareIdentifiers: c } = cD(),
                    l = class {
                      constructor(C, m) {
                        if (((m = a(m)), C instanceof l)) {
                          if (
                            C.loose === !!m.loose &&
                            C.includePrerelease === !!m.includePrerelease
                          )
                            return C;
                          C = C.version;
                        } else if (typeof C != "string")
                          throw new TypeError("Invalid Version: ".concat(C));
                        if (C.length > s)
                          throw new TypeError(
                            "version is longer than ".concat(s, " characters")
                          );
                        t("SemVer", C, m),
                          (this.options = m),
                          (this.loose = !!m.loose),
                          (this.includePrerelease = !!m.includePrerelease);
                        let g = C.trim().match(
                          m.loose ? r[u.LOOSE] : r[u.FULL]
                        );
                        if (!g)
                          throw new TypeError("Invalid Version: ".concat(C));
                        if (
                          ((this.raw = C),
                          (this.major = +g[1]),
                          (this.minor = +g[2]),
                          (this.patch = +g[3]),
                          this.major > i || this.major < 0)
                        )
                          throw new TypeError("Invalid major version");
                        if (this.minor > i || this.minor < 0)
                          throw new TypeError("Invalid minor version");
                        if (this.patch > i || this.patch < 0)
                          throw new TypeError("Invalid patch version");
                        g[4]
                          ? (this.prerelease = g[4].split(".").map((p) => {
                              if (/^[0-9]+$/.test(p)) {
                                let f = +p;
                                if (f >= 0 && f < i) return f;
                              }
                              return p;
                            }))
                          : (this.prerelease = []),
                          (this.build = g[5] ? g[5].split(".") : []),
                          this.format();
                      }
                      format() {
                        return (
                          (this.version = ""
                            .concat(this.major, ".")
                            .concat(this.minor, ".")
                            .concat(this.patch)),
                          this.prerelease.length &&
                            (this.version += "-".concat(
                              this.prerelease.join(".")
                            )),
                          this.version
                        );
                      }
                      toString() {
                        return this.version;
                      }
                      compare(C) {
                        if (
                          (t("SemVer.compare", this.version, this.options, C),
                          !(C instanceof l))
                        ) {
                          if (typeof C == "string" && C === this.version)
                            return 0;
                          C = new l(C, this.options);
                        }
                        return C.version === this.version
                          ? 0
                          : this.compareMain(C) || this.comparePre(C);
                      }
                      compareMain(C) {
                        return (
                          C instanceof l || (C = new l(C, this.options)),
                          c(this.major, C.major) ||
                            c(this.minor, C.minor) ||
                            c(this.patch, C.patch)
                        );
                      }
                      comparePre(C) {
                        if (
                          (C instanceof l || (C = new l(C, this.options)),
                          this.prerelease.length && !C.prerelease.length)
                        )
                          return -1;
                        if (!this.prerelease.length && C.prerelease.length)
                          return 1;
                        if (!this.prerelease.length && !C.prerelease.length)
                          return 0;
                        let m = 0;
                        do {
                          let g = this.prerelease[m],
                            p = C.prerelease[m];
                          if (
                            (t("prerelease compare", m, g, p),
                            g === void 0 && p === void 0)
                          )
                            return 0;
                          if (p === void 0) return 1;
                          if (g === void 0) return -1;
                          if (g === p) continue;
                          return c(g, p);
                        } while (++m);
                      }
                      compareBuild(C) {
                        C instanceof l || (C = new l(C, this.options));
                        let m = 0;
                        do {
                          let g = this.build[m],
                            p = C.build[m];
                          if (
                            (t("prerelease compare", m, g, p),
                            g === void 0 && p === void 0)
                          )
                            return 0;
                          if (p === void 0) return 1;
                          if (g === void 0) return -1;
                          if (g === p) continue;
                          return c(g, p);
                        } while (++m);
                      }
                      inc(C, m) {
                        switch (C) {
                          case "premajor":
                            (this.prerelease.length = 0),
                              (this.patch = 0),
                              (this.minor = 0),
                              this.major++,
                              this.inc("pre", m);
                            break;
                          case "preminor":
                            (this.prerelease.length = 0),
                              (this.patch = 0),
                              this.minor++,
                              this.inc("pre", m);
                            break;
                          case "prepatch":
                            (this.prerelease.length = 0),
                              this.inc("patch", m),
                              this.inc("pre", m);
                            break;
                          case "prerelease":
                            this.prerelease.length === 0 &&
                              this.inc("patch", m),
                              this.inc("pre", m);
                            break;
                          case "major":
                            (this.minor !== 0 ||
                              this.patch !== 0 ||
                              this.prerelease.length === 0) &&
                              this.major++,
                              (this.minor = 0),
                              (this.patch = 0),
                              (this.prerelease = []);
                            break;
                          case "minor":
                            (this.patch !== 0 ||
                              this.prerelease.length === 0) &&
                              this.minor++,
                              (this.patch = 0),
                              (this.prerelease = []);
                            break;
                          case "patch":
                            this.prerelease.length === 0 && this.patch++,
                              (this.prerelease = []);
                            break;
                          case "pre":
                            if (this.prerelease.length === 0)
                              this.prerelease = [0];
                            else {
                              let g = this.prerelease.length;
                              for (; --g >= 0; )
                                typeof this.prerelease[g] == "number" &&
                                  (this.prerelease[g]++, (g = -2));
                              g === -1 && this.prerelease.push(0);
                            }
                            m &&
                              (this.prerelease[0] === m
                                ? isNaN(this.prerelease[1]) &&
                                  (this.prerelease = [m, 0])
                                : (this.prerelease = [m, 0]));
                            break;
                          default:
                            throw new Error(
                              "invalid increment argument: ".concat(C)
                            );
                        }
                        return this.format(), (this.raw = this.version), this;
                      }
                    };
                  n.exports = l;
                },
              }),
              qn = Z({
                "node_modules/semver/functions/compare.js"(e, n) {
                  ae();
                  var t = lD(),
                    s = (i, r, u) => new t(i, u).compare(new t(r, u));
                  n.exports = s;
                },
              }),
              pD = Z({
                "node_modules/semver/functions/lt.js"(e, n) {
                  ae();
                  var t = qn(),
                    s = (i, r, u) => t(i, r, u) < 0;
                  n.exports = s;
                },
              }),
              fD = Z({
                "node_modules/semver/functions/gte.js"(e, n) {
                  ae();
                  var t = qn(),
                    s = (i, r, u) => t(i, r, u) >= 0;
                  n.exports = s;
                },
              }),
              DD = Z({
                "src/utils/arrayify.js"(e, n) {
                  "use strict";
                  ae(),
                    (n.exports = (t, s) =>
                      Object.entries(t).map((i) => {
                        let [r, u] = i;
                        return Object.assign({ [s]: r }, u);
                      }));
                },
              }),
              mD = Z({
                "node_modules/outdent/lib/index.js"(e, n) {
                  "use strict";
                  ae(),
                    Object.defineProperty(e, "__esModule", { value: !0 }),
                    (e.outdent = void 0);
                  function t() {
                    for (var A = [], b = 0; b < arguments.length; b++)
                      A[b] = arguments[b];
                  }
                  function s() {
                    return typeof WeakMap < "u" ? new WeakMap() : i();
                  }
                  function i() {
                    return {
                      add: t,
                      delete: t,
                      get: t,
                      set: t,
                      has: function (A) {
                        return !1;
                      },
                    };
                  }
                  var r = Object.prototype.hasOwnProperty,
                    u = function (A, b) {
                      return r.call(A, b);
                    };
                  function a(A, b) {
                    for (var v in b) u(b, v) && (A[v] = b[v]);
                    return A;
                  }
                  var c = /^[ \t]*(?:\r\n|\r|\n)/,
                    l = /(?:\r\n|\r|\n)[ \t]*$/,
                    C = /^(?:[\r\n]|$)/,
                    m = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/,
                    g = /^[ \t]*[\r\n][ \t\r\n]*$/;
                  function p(A, b, v) {
                    var B = 0,
                      w = A[0].match(m);
                    w && (B = w[1].length);
                    var I = "(\\r\\n|\\r|\\n).{0," + B + "}",
                      E = new RegExp(I, "g");
                    b && (A = A.slice(1));
                    var D = v.newline,
                      d = v.trimLeadingNewline,
                      y = v.trimTrailingNewline,
                      o = typeof D == "string",
                      x = A.length,
                      F = A.map(function (S, k) {
                        return (
                          (S = S.replace(E, "$1")),
                          k === 0 && d && (S = S.replace(c, "")),
                          k === x - 1 && y && (S = S.replace(l, "")),
                          o &&
                            (S = S.replace(/\r\n|\n|\r/g, function (_) {
                              return D;
                            })),
                          S
                        );
                      });
                    return F;
                  }
                  function f(A, b) {
                    for (var v = "", B = 0, w = A.length; B < w; B++)
                      (v += A[B]), B < w - 1 && (v += b[B]);
                    return v;
                  }
                  function h(A) {
                    return u(A, "raw") && u(A, "length");
                  }
                  function N(A) {
                    var b = s(),
                      v = s();
                    function B(I) {
                      for (var E = [], D = 1; D < arguments.length; D++)
                        E[D - 1] = arguments[D];
                      if (h(I)) {
                        var d = I,
                          y =
                            (E[0] === B || E[0] === T) &&
                            g.test(d[0]) &&
                            C.test(d[1]),
                          o = y ? v : b,
                          x = o.get(d);
                        if (
                          (x || ((x = p(d, y, A)), o.set(d, x)), E.length === 0)
                        )
                          return x[0];
                        var F = f(x, y ? E.slice(1) : E);
                        return F;
                      } else return N(a(a({}, A), I || {}));
                    }
                    var w = a(B, {
                      string: function (I) {
                        return p([I], !1, A)[0];
                      },
                    });
                    return w;
                  }
                  var T = N({
                    trimLeadingNewline: !0,
                    trimTrailingNewline: !0,
                  });
                  if (((e.outdent = T), (e.default = T), typeof n < "u"))
                    try {
                      (n.exports = T),
                        Object.defineProperty(T, "__esModule", { value: !0 }),
                        (T.default = T),
                        (T.outdent = T);
                    } catch {}
                },
              }),
              dD = Z({
                "src/main/core-options.js"(e, n) {
                  "use strict";
                  ae();
                  var { outdent: t } = mD(),
                    s = "Config",
                    i = "Editor",
                    r = "Format",
                    u = "Other",
                    a = "Output",
                    c = "Global",
                    l = "Special",
                    C = {
                      cursorOffset: {
                        since: "1.4.0",
                        category: l,
                        type: "int",
                        default: -1,
                        range: {
                          start: -1,
                          end: Number.POSITIVE_INFINITY,
                          step: 1,
                        },
                        description: t(
                          si ||
                            (si = wt([
                              `
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `,
                            ]))
                        ),
                        cliCategory: i,
                      },
                      endOfLine: {
                        since: "1.15.0",
                        category: c,
                        type: "choice",
                        default: [
                          { since: "1.15.0", value: "auto" },
                          { since: "2.0.0", value: "lf" },
                        ],
                        description: "Which end of line characters to apply.",
                        choices: [
                          {
                            value: "lf",
                            description:
                              "Line Feed only (\\n), common on Linux and macOS as well as inside git repos",
                          },
                          {
                            value: "crlf",
                            description:
                              "Carriage Return + Line Feed characters (\\r\\n), common on Windows",
                          },
                          {
                            value: "cr",
                            description:
                              "Carriage Return character only (\\r), used very rarely",
                          },
                          {
                            value: "auto",
                            description: t(
                              ai ||
                                (ai = wt([
                                  `
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `,
                                ]))
                            ),
                          },
                        ],
                      },
                      filepath: {
                        since: "1.4.0",
                        category: l,
                        type: "path",
                        description:
                          "Specify the input filepath. This will be used to do parser inference.",
                        cliName: "stdin-filepath",
                        cliCategory: u,
                        cliDescription:
                          "Path to the file to pretend that stdin comes from.",
                      },
                      insertPragma: {
                        since: "1.8.0",
                        category: l,
                        type: "boolean",
                        default: !1,
                        description:
                          "Insert @format pragma into file's first docblock comment.",
                        cliCategory: u,
                      },
                      parser: {
                        since: "0.0.10",
                        category: c,
                        type: "choice",
                        default: [
                          { since: "0.0.10", value: "babylon" },
                          { since: "1.13.0", value: void 0 },
                        ],
                        description: "Which parser to use.",
                        exception: (m) =>
                          typeof m == "string" || typeof m == "function",
                        choices: [
                          { value: "flow", description: "Flow" },
                          {
                            value: "babel",
                            since: "1.16.0",
                            description: "JavaScript",
                          },
                          {
                            value: "babel-flow",
                            since: "1.16.0",
                            description: "Flow",
                          },
                          {
                            value: "babel-ts",
                            since: "2.0.0",
                            description: "TypeScript",
                          },
                          {
                            value: "typescript",
                            since: "1.4.0",
                            description: "TypeScript",
                          },
                          {
                            value: "acorn",
                            since: "2.6.0",
                            description: "JavaScript",
                          },
                          {
                            value: "espree",
                            since: "2.2.0",
                            description: "JavaScript",
                          },
                          {
                            value: "meriyah",
                            since: "2.2.0",
                            description: "JavaScript",
                          },
                          { value: "css", since: "1.7.1", description: "CSS" },
                          {
                            value: "less",
                            since: "1.7.1",
                            description: "Less",
                          },
                          {
                            value: "scss",
                            since: "1.7.1",
                            description: "SCSS",
                          },
                          {
                            value: "json",
                            since: "1.5.0",
                            description: "JSON",
                          },
                          {
                            value: "json5",
                            since: "1.13.0",
                            description: "JSON5",
                          },
                          {
                            value: "json-stringify",
                            since: "1.13.0",
                            description: "JSON.stringify",
                          },
                          {
                            value: "graphql",
                            since: "1.5.0",
                            description: "GraphQL",
                          },
                          {
                            value: "markdown",
                            since: "1.8.0",
                            description: "Markdown",
                          },
                          { value: "mdx", since: "1.15.0", description: "MDX" },
                          { value: "vue", since: "1.10.0", description: "Vue" },
                          {
                            value: "yaml",
                            since: "1.14.0",
                            description: "YAML",
                          },
                          {
                            value: "glimmer",
                            since: "2.3.0",
                            description: "Ember / Handlebars",
                          },
                          {
                            value: "html",
                            since: "1.15.0",
                            description: "HTML",
                          },
                          {
                            value: "angular",
                            since: "1.15.0",
                            description: "Angular",
                          },
                          {
                            value: "lwc",
                            since: "1.17.0",
                            description: "Lightning Web Components",
                          },
                        ],
                      },
                      plugins: {
                        since: "1.10.0",
                        type: "path",
                        array: !0,
                        default: [{ value: [] }],
                        category: c,
                        description:
                          "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
                        exception: (m) =>
                          typeof m == "string" || typeof m == "object",
                        cliName: "plugin",
                        cliCategory: s,
                      },
                      pluginSearchDirs: {
                        since: "1.13.0",
                        type: "path",
                        array: !0,
                        default: [{ value: [] }],
                        category: c,
                        description: t(
                          ii ||
                            (ii = wt([
                              `
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `,
                            ]))
                        ),
                        exception: (m) =>
                          typeof m == "string" || typeof m == "object",
                        cliName: "plugin-search-dir",
                        cliCategory: s,
                      },
                      printWidth: {
                        since: "0.0.0",
                        category: c,
                        type: "int",
                        default: 80,
                        description:
                          "The line length where Prettier will try wrap.",
                        range: {
                          start: 0,
                          end: Number.POSITIVE_INFINITY,
                          step: 1,
                        },
                      },
                      rangeEnd: {
                        since: "1.4.0",
                        category: l,
                        type: "int",
                        default: Number.POSITIVE_INFINITY,
                        range: {
                          start: 0,
                          end: Number.POSITIVE_INFINITY,
                          step: 1,
                        },
                        description: t(
                          oi ||
                            (oi = wt([
                              `
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `,
                            ]))
                        ),
                        cliCategory: i,
                      },
                      rangeStart: {
                        since: "1.4.0",
                        category: l,
                        type: "int",
                        default: 0,
                        range: {
                          start: 0,
                          end: Number.POSITIVE_INFINITY,
                          step: 1,
                        },
                        description: t(
                          ci ||
                            (ci = wt([
                              `
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `,
                            ]))
                        ),
                        cliCategory: i,
                      },
                      requirePragma: {
                        since: "1.7.0",
                        category: l,
                        type: "boolean",
                        default: !1,
                        description: t(
                          li ||
                            (li = wt([
                              `
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `,
                            ]))
                        ),
                        cliCategory: u,
                      },
                      tabWidth: {
                        type: "int",
                        category: c,
                        default: 2,
                        description: "Number of spaces per indentation level.",
                        range: {
                          start: 0,
                          end: Number.POSITIVE_INFINITY,
                          step: 1,
                        },
                      },
                      useTabs: {
                        since: "1.0.0",
                        category: c,
                        type: "boolean",
                        default: !1,
                        description: "Indent with tabs instead of spaces.",
                      },
                      embeddedLanguageFormatting: {
                        since: "2.1.0",
                        category: c,
                        type: "choice",
                        default: [{ since: "2.1.0", value: "auto" }],
                        description:
                          "Control how Prettier formats quoted code embedded in the file.",
                        choices: [
                          {
                            value: "auto",
                            description:
                              "Format embedded code if Prettier can automatically identify it.",
                          },
                          {
                            value: "off",
                            description:
                              "Never automatically format embedded code.",
                          },
                        ],
                      },
                    };
                  n.exports = {
                    CATEGORY_CONFIG: s,
                    CATEGORY_EDITOR: i,
                    CATEGORY_FORMAT: r,
                    CATEGORY_OTHER: u,
                    CATEGORY_OUTPUT: a,
                    CATEGORY_GLOBAL: c,
                    CATEGORY_SPECIAL: l,
                    options: C,
                  };
                },
              }),
              Mn = Z({
                "src/main/support.js"(e, n) {
                  "use strict";
                  ae();
                  var t = { compare: qn(), lt: pD(), gte: fD() },
                    s = DD(),
                    i = gi().version,
                    r = dD().options;
                  function u() {
                    let {
                        plugins: c = [],
                        showUnreleased: l = !1,
                        showDeprecated: C = !1,
                        showInternal: m = !1,
                      } = arguments.length > 0 && arguments[0] !== void 0
                        ? arguments[0]
                        : {},
                      g = i.split("-", 1)[0],
                      p = c.flatMap((A) => A.languages || []).filter(h),
                      f = s(
                        Object.assign(
                          {},
                          ...c.map((A) => {
                            let { options: b } = A;
                            return b;
                          }),
                          r
                        ),
                        "name"
                      )
                        .filter((A) => h(A) && N(A))
                        .sort((A, b) =>
                          A.name === b.name ? 0 : A.name < b.name ? -1 : 1
                        )
                        .map(T)
                        .map((A) => {
                          (A = Object.assign({}, A)),
                            Array.isArray(A.default) &&
                              (A.default =
                                A.default.length === 1
                                  ? A.default[0].value
                                  : A.default
                                      .filter(h)
                                      .sort((v, B) =>
                                        t.compare(B.since, v.since)
                                      )[0].value),
                            Array.isArray(A.choices) &&
                              ((A.choices = A.choices.filter(
                                (v) => h(v) && N(v)
                              )),
                              A.name === "parser" && a(A, p, c));
                          let b = Object.fromEntries(
                            c
                              .filter(
                                (v) =>
                                  v.defaultOptions &&
                                  v.defaultOptions[A.name] !== void 0
                              )
                              .map((v) => [v.name, v.defaultOptions[A.name]])
                          );
                          return Object.assign(
                            Object.assign({}, A),
                            {},
                            { pluginDefaults: b }
                          );
                        });
                    return { languages: p, options: f };
                    function h(A) {
                      return (
                        l || !("since" in A) || (A.since && t.gte(g, A.since))
                      );
                    }
                    function N(A) {
                      return (
                        C ||
                        !("deprecated" in A) ||
                        (A.deprecated && t.lt(g, A.deprecated))
                      );
                    }
                    function T(A) {
                      if (m) return A;
                      let { cliName: b, cliCategory: v, cliDescription: B } = A;
                      return _n(A, zf);
                    }
                  }
                  function a(c, l, C) {
                    let m = new Set(c.choices.map((g) => g.value));
                    for (let g of l)
                      if (g.parsers) {
                        for (let p of g.parsers)
                          if (!m.has(p)) {
                            m.add(p);
                            let f = C.find((N) => N.parsers && N.parsers[p]),
                              h = g.name;
                            f &&
                              f.name &&
                              (h += " (plugin: ".concat(f.name, ")")),
                              c.choices.push({ value: p, description: h });
                          }
                      }
                  }
                  n.exports = { getSupportInfo: u };
                },
              }),
              Rn = Z({
                "src/utils/is-non-empty-array.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s) {
                    return Array.isArray(s) && s.length > 0;
                  }
                  n.exports = t;
                },
              }),
              Tr = Z({
                "src/utils/text/skip.js"(e, n) {
                  "use strict";
                  ae();
                  function t(a) {
                    return (c, l, C) => {
                      let m = C && C.backwards;
                      if (l === !1) return !1;
                      let { length: g } = c,
                        p = l;
                      for (; p >= 0 && p < g; ) {
                        let f = c.charAt(p);
                        if (a instanceof RegExp) {
                          if (!a.test(f)) return p;
                        } else if (!a.includes(f)) return p;
                        m ? p-- : p++;
                      }
                      return p === -1 || p === g ? p : !1;
                    };
                  }
                  var s = t(/\s/),
                    i = t(" 	"),
                    r = t(",; 	"),
                    u = t(/[^\n\r]/);
                  n.exports = {
                    skipWhitespace: s,
                    skipSpaces: i,
                    skipToLineEnd: r,
                    skipEverythingButNewLine: u,
                  };
                },
              }),
              Ei = Z({
                "src/utils/text/skip-inline-comment.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s, i) {
                    if (i === !1) return !1;
                    if (s.charAt(i) === "/" && s.charAt(i + 1) === "*") {
                      for (let r = i + 2; r < s.length; ++r)
                        if (s.charAt(r) === "*" && s.charAt(r + 1) === "/")
                          return r + 2;
                    }
                    return i;
                  }
                  n.exports = t;
                },
              }),
              vi = Z({
                "src/utils/text/skip-trailing-comment.js"(e, n) {
                  "use strict";
                  ae();
                  var { skipEverythingButNewLine: t } = Tr();
                  function s(i, r) {
                    return r === !1
                      ? !1
                      : i.charAt(r) === "/" && i.charAt(r + 1) === "/"
                      ? t(i, r)
                      : r;
                  }
                  n.exports = s;
                },
              }),
              Fi = Z({
                "src/utils/text/skip-newline.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s, i, r) {
                    let u = r && r.backwards;
                    if (i === !1) return !1;
                    let a = s.charAt(i);
                    if (u) {
                      if (
                        s.charAt(i - 1) === "\r" &&
                        a ===
                          `
`
                      )
                        return i - 2;
                      if (
                        a ===
                          `
` ||
                        a === "\r" ||
                        a === "\u2028" ||
                        a === "\u2029"
                      )
                        return i - 1;
                    } else {
                      if (
                        a === "\r" &&
                        s.charAt(i + 1) ===
                          `
`
                      )
                        return i + 2;
                      if (
                        a ===
                          `
` ||
                        a === "\r" ||
                        a === "\u2028" ||
                        a === "\u2029"
                      )
                        return i + 1;
                    }
                    return i;
                  }
                  n.exports = t;
                },
              }),
              gD = Z({
                "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(
                  e,
                  n
                ) {
                  "use strict";
                  ae();
                  var t = Ei(),
                    s = Fi(),
                    i = vi(),
                    { skipSpaces: r } = Tr();
                  function u(a, c) {
                    let l = null,
                      C = c;
                    for (; C !== l; )
                      (l = C),
                        (C = r(a, C)),
                        (C = t(a, C)),
                        (C = i(a, C)),
                        (C = s(a, C));
                    return C;
                  }
                  n.exports = u;
                },
              }),
              Ge = Z({
                "src/common/util.js"(e, n) {
                  "use strict";
                  ae();
                  var { default: t } = aD(),
                    s = st(),
                    { getSupportInfo: i } = Mn(),
                    r = Rn(),
                    u = yi(),
                    {
                      skipWhitespace: a,
                      skipSpaces: c,
                      skipToLineEnd: l,
                      skipEverythingButNewLine: C,
                    } = Tr(),
                    m = Ei(),
                    g = vi(),
                    p = Fi(),
                    f = gD(),
                    h = ($) => $[$.length - 2];
                  function N($) {
                    return (W, ee, U) => {
                      let ne = U && U.backwards;
                      if (ee === !1) return !1;
                      let { length: se } = W,
                        V = ee;
                      for (; V >= 0 && V < se; ) {
                        let oe = W.charAt(V);
                        if ($ instanceof RegExp) {
                          if (!$.test(oe)) return V;
                        } else if (!$.includes(oe)) return V;
                        ne ? V-- : V++;
                      }
                      return V === -1 || V === se ? V : !1;
                    };
                  }
                  function T($, W) {
                    let ee =
                        arguments.length > 2 && arguments[2] !== void 0
                          ? arguments[2]
                          : {},
                      U = c($, ee.backwards ? W - 1 : W, ee),
                      ne = p($, U, ee);
                    return U !== ne;
                  }
                  function A($, W, ee) {
                    for (let U = W; U < ee; ++U)
                      if (
                        $.charAt(U) ===
                        `
`
                      )
                        return !0;
                    return !1;
                  }
                  function b($, W, ee) {
                    let U = ee(W) - 1;
                    (U = c($, U, { backwards: !0 })),
                      (U = p($, U, { backwards: !0 })),
                      (U = c($, U, { backwards: !0 }));
                    let ne = p($, U, { backwards: !0 });
                    return U !== ne;
                  }
                  function v($, W) {
                    let ee = null,
                      U = W;
                    for (; U !== ee; )
                      (ee = U), (U = l($, U)), (U = m($, U)), (U = c($, U));
                    return (U = g($, U)), (U = p($, U)), U !== !1 && T($, U);
                  }
                  function B($, W, ee) {
                    return v($, ee(W));
                  }
                  function w($, W, ee) {
                    return f($, ee(W));
                  }
                  function I($, W, ee) {
                    return $.charAt(w($, W, ee));
                  }
                  function E($, W) {
                    let ee =
                      arguments.length > 2 && arguments[2] !== void 0
                        ? arguments[2]
                        : {};
                    return c($, ee.backwards ? W - 1 : W, ee) !== W;
                  }
                  function D($, W) {
                    let ee =
                        arguments.length > 2 && arguments[2] !== void 0
                          ? arguments[2]
                          : 0,
                      U = 0;
                    for (let ne = ee; ne < $.length; ++ne)
                      $[ne] === "	" ? (U = U + W - (U % W)) : U++;
                    return U;
                  }
                  function d($, W) {
                    let ee = $.lastIndexOf(`
`);
                    return ee === -1
                      ? 0
                      : D($.slice(ee + 1).match(/^[\t ]*/)[0], W);
                  }
                  function y($, W) {
                    let ee = { quote: '"', regex: /"/g, escaped: "&quot;" },
                      U = { quote: "'", regex: /'/g, escaped: "&apos;" },
                      ne = W === "'" ? U : ee,
                      se = ne === U ? ee : U,
                      V = ne;
                    if ($.includes(ne.quote) || $.includes(se.quote)) {
                      let oe = ($.match(ne.regex) || []).length,
                        K = ($.match(se.regex) || []).length;
                      V = oe > K ? se : ne;
                    }
                    return V;
                  }
                  function o($, W) {
                    let ee = $.slice(1, -1),
                      U =
                        W.parser === "json" ||
                        (W.parser === "json5" &&
                          W.quoteProps === "preserve" &&
                          !W.singleQuote)
                          ? '"'
                          : W.__isInHtmlAttribute
                          ? "'"
                          : y(ee, W.singleQuote ? "'" : '"').quote;
                    return x(
                      ee,
                      U,
                      !(
                        W.parser === "css" ||
                        W.parser === "less" ||
                        W.parser === "scss" ||
                        W.__embeddedInHtml
                      )
                    );
                  }
                  function x($, W, ee) {
                    let U = W === '"' ? "'" : '"',
                      ne = /\\(.)|(["'])/gs,
                      se = $.replace(ne, (V, oe, K) =>
                        oe === U
                          ? oe
                          : K === W
                          ? "\\" + K
                          : K ||
                            (ee &&
                            /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(oe)
                              ? oe
                              : "\\" + oe)
                      );
                    return W + se + W;
                  }
                  function F($) {
                    return $.toLowerCase()
                      .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3")
                      .replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1")
                      .replace(/^([+-])?\./, "$10.")
                      .replace(/(\.\d+?)0+(?=e|$)/, "$1")
                      .replace(/\.(?=e|$)/, "");
                  }
                  function S($, W) {
                    let ee = $.match(new RegExp("(".concat(t(W), ")+"), "g"));
                    return ee === null
                      ? 0
                      : ee.reduce(
                          (U, ne) => Math.max(U, ne.length / W.length),
                          0
                        );
                  }
                  function k($, W) {
                    let ee = $.match(new RegExp("(".concat(t(W), ")+"), "g"));
                    if (ee === null) return 0;
                    let U = new Map(),
                      ne = 0;
                    for (let se of ee) {
                      let V = se.length / W.length;
                      U.set(V, !0), V > ne && (ne = V);
                    }
                    for (let se = 1; se < ne; se++) if (!U.get(se)) return se;
                    return ne + 1;
                  }
                  function _($, W) {
                    ($.comments || ($.comments = [])).push(W),
                      (W.printed = !1),
                      (W.nodeDescription = re($));
                  }
                  function O($, W) {
                    (W.leading = !0), (W.trailing = !1), _($, W);
                  }
                  function R($, W, ee) {
                    (W.leading = !1),
                      (W.trailing = !1),
                      ee && (W.marker = ee),
                      _($, W);
                  }
                  function M($, W) {
                    (W.leading = !1), (W.trailing = !0), _($, W);
                  }
                  function H($, W) {
                    let { languages: ee } = i({ plugins: W.plugins }),
                      U =
                        ee.find((ne) => {
                          let { name: se } = ne;
                          return se.toLowerCase() === $;
                        }) ||
                        ee.find((ne) => {
                          let { aliases: se } = ne;
                          return Array.isArray(se) && se.includes($);
                        }) ||
                        ee.find((ne) => {
                          let { extensions: se } = ne;
                          return (
                            Array.isArray(se) && se.includes(".".concat($))
                          );
                        });
                    return U && U.parsers[0];
                  }
                  function P($) {
                    return $ && $.type === "front-matter";
                  }
                  function G($) {
                    let W = new WeakMap();
                    return function (ee) {
                      return W.has(ee) || W.set(ee, Symbol($)), W.get(ee);
                    };
                  }
                  function re($) {
                    let W = $.type || $.kind || "(unknown type)",
                      ee = String(
                        $.name ||
                          ($.id &&
                            (typeof $.id == "object" ? $.id.name : $.id)) ||
                          ($.key &&
                            (typeof $.key == "object" ? $.key.name : $.key)) ||
                          ($.value &&
                            (typeof $.value == "object"
                              ? ""
                              : String($.value))) ||
                          $.operator ||
                          ""
                      );
                    return (
                      ee.length > 20 && (ee = ee.slice(0, 19) + "\u2026"),
                      W + (ee ? " " + ee : "")
                    );
                  }
                  n.exports = {
                    inferParserByLanguage: H,
                    getStringWidth: u,
                    getMaxContinuousCount: S,
                    getMinNotPresentContinuousCount: k,
                    getPenultimate: h,
                    getLast: s,
                    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f,
                    getNextNonSpaceNonCommentCharacterIndex: w,
                    getNextNonSpaceNonCommentCharacter: I,
                    skip: N,
                    skipWhitespace: a,
                    skipSpaces: c,
                    skipToLineEnd: l,
                    skipEverythingButNewLine: C,
                    skipInlineComment: m,
                    skipTrailingComment: g,
                    skipNewline: p,
                    isNextLineEmptyAfterIndex: v,
                    isNextLineEmpty: B,
                    isPreviousLineEmpty: b,
                    hasNewline: T,
                    hasNewlineInRange: A,
                    hasSpaces: E,
                    getAlignmentSize: D,
                    getIndentSize: d,
                    getPreferredQuote: y,
                    printString: o,
                    printNumber: F,
                    makeString: x,
                    addLeadingComment: O,
                    addDanglingComment: R,
                    addTrailingComment: M,
                    isFrontMatterNode: P,
                    isNonEmptyArray: r,
                    createGroupIdMapper: G,
                  };
                },
              }),
              Ai = {};
            kn(Ai, {
              basename: () => Bi,
              default: () => wi,
              delimiter: () => bn,
              dirname: () => Ti,
              extname: () => Ni,
              isAbsolute: () => Wn,
              join: () => xi,
              normalize: () => Vn,
              relative: () => bi,
              resolve: () => xr,
              sep: () => xn,
            });
            function Si(e, n) {
              for (var t = 0, s = e.length - 1; s >= 0; s--) {
                var i = e[s];
                i === "."
                  ? e.splice(s, 1)
                  : i === ".."
                  ? (e.splice(s, 1), t++)
                  : t && (e.splice(s, 1), t--);
              }
              if (n) for (; t--; t) e.unshift("..");
              return e;
            }
            function xr() {
              for (
                var e = "", n = !1, t = arguments.length - 1;
                t >= -1 && !n;
                t--
              ) {
                var s = t >= 0 ? arguments[t] : "/";
                if (typeof s != "string")
                  throw new TypeError(
                    "Arguments to path.resolve must be strings"
                  );
                if (!s) continue;
                (e = s + "/" + e), (n = s.charAt(0) === "/");
              }
              return (
                (e = Si(
                  $n(e.split("/"), function (i) {
                    return !!i;
                  }),
                  !n
                ).join("/")),
                (n ? "/" : "") + e || "."
              );
            }
            function Vn(e) {
              var n = Wn(e),
                t = _i(e, -1) === "/";
              return (
                (e = Si(
                  $n(e.split("/"), function (s) {
                    return !!s;
                  }),
                  !n
                ).join("/")),
                !e && !n && (e = "."),
                e && t && (e += "/"),
                (n ? "/" : "") + e
              );
            }
            function Wn(e) {
              return e.charAt(0) === "/";
            }
            function xi() {
              var e = Array.prototype.slice.call(arguments, 0);
              return Vn(
                $n(e, function (n, t) {
                  if (typeof n != "string")
                    throw new TypeError(
                      "Arguments to path.join must be strings"
                    );
                  return n;
                }).join("/")
              );
            }
            function bi(e, n) {
              (e = xr(e).substr(1)), (n = xr(n).substr(1));
              function t(l) {
                for (var C = 0; C < l.length && l[C] === ""; C++);
                for (var m = l.length - 1; m >= 0 && l[m] === ""; m--);
                return C > m ? [] : l.slice(C, m - C + 1);
              }
              for (
                var s = t(e.split("/")),
                  i = t(n.split("/")),
                  r = Math.min(s.length, i.length),
                  u = r,
                  a = 0;
                a < r;
                a++
              )
                if (s[a] !== i[a]) {
                  u = a;
                  break;
                }
              for (var c = [], a = u; a < s.length; a++) c.push("..");
              return (c = c.concat(i.slice(u))), c.join("/");
            }
            function Ti(e) {
              var n = Br(e),
                t = n[0],
                s = n[1];
              return !t && !s
                ? "."
                : (s && (s = s.substr(0, s.length - 1)), t + s);
            }
            function Bi(e, n) {
              var t = Br(e)[2];
              return (
                n &&
                  t.substr(-1 * n.length) === n &&
                  (t = t.substr(0, t.length - n.length)),
                t
              );
            }
            function Ni(e) {
              return Br(e)[3];
            }
            function $n(e, n) {
              if (e.filter) return e.filter(n);
              for (var t = [], s = 0; s < e.length; s++)
                n(e[s], s, e) && t.push(e[s]);
              return t;
            }
            var Di,
              Br,
              xn,
              bn,
              wi,
              _i,
              yD = br({
                "node-modules-polyfills:path"() {
                  ae(),
                    (Di =
                      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/),
                    (Br = function (e) {
                      return Di.exec(e).slice(1);
                    }),
                    (xn = "/"),
                    (bn = ":"),
                    (wi = {
                      extname: Ni,
                      basename: Bi,
                      dirname: Ti,
                      sep: xn,
                      delimiter: bn,
                      relative: bi,
                      join: xi,
                      isAbsolute: Wn,
                      normalize: Vn,
                      resolve: xr,
                    }),
                    (_i = true
                      ? function (e, n, t) {
                          return e.substr(n, t);
                        }
                      : 0);
                },
              }),
              Pi = Z({
                "node-modules-polyfills-commonjs:path"(e, n) {
                  ae();
                  var t = (yD(), pt(Ai));
                  if (t && t.default) {
                    n.exports = t.default;
                    for (let s in t) n.exports[s] = t[s];
                  } else t && (n.exports = t);
                },
              }),
              Jt = Z({
                "src/common/errors.js"(e, n) {
                  "use strict";
                  ae();
                  var t = class extends Error {},
                    s = class extends Error {},
                    i = class extends Error {},
                    r = class extends Error {};
                  n.exports = {
                    ConfigError: t,
                    DebugError: s,
                    UndefinedParserError: i,
                    ArgExpansionBailout: r,
                  };
                },
              }),
              Dt = {};
            kn(Dt, {
              __assign: () => Sr,
              __asyncDelegator: () => wD,
              __asyncGenerator: () => ND,
              __asyncValues: () => _D,
              __await: () => Gt,
              __awaiter: () => AD,
              __classPrivateFieldGet: () => LD,
              __classPrivateFieldSet: () => OD,
              __createBinding: () => xD,
              __decorate: () => ED,
              __exportStar: () => bD,
              __extends: () => hD,
              __generator: () => SD,
              __importDefault: () => kD,
              __importStar: () => ID,
              __makeTemplateObject: () => PD,
              __metadata: () => FD,
              __param: () => vD,
              __read: () => Ii,
              __rest: () => CD,
              __spread: () => TD,
              __spreadArrays: () => BD,
              __values: () => Tn,
            });
            function hD(e, n) {
              Ar(e, n);
              function t() {
                this.constructor = e;
              }
              e.prototype =
                n === null
                  ? Object.create(n)
                  : ((t.prototype = n.prototype), new t());
            }
            function CD(e, n) {
              var t = {};
              for (var s in e)
                Object.prototype.hasOwnProperty.call(e, s) &&
                  n.indexOf(s) < 0 &&
                  (t[s] = e[s]);
              if (
                e != null &&
                typeof Object.getOwnPropertySymbols == "function"
              )
                for (
                  var i = 0, s = Object.getOwnPropertySymbols(e);
                  i < s.length;
                  i++
                )
                  n.indexOf(s[i]) < 0 &&
                    Object.prototype.propertyIsEnumerable.call(e, s[i]) &&
                    (t[s[i]] = e[s[i]]);
              return t;
            }
            function ED(e, n, t, s) {
              var i = arguments.length,
                r =
                  i < 3
                    ? n
                    : s === null
                    ? (s = Object.getOwnPropertyDescriptor(n, t))
                    : s,
                u;
              if (
                typeof Reflect == "object" &&
                typeof Reflect.decorate == "function"
              )
                r = Reflect.decorate(e, n, t, s);
              else
                for (var a = e.length - 1; a >= 0; a--)
                  (u = e[a]) &&
                    (r = (i < 3 ? u(r) : i > 3 ? u(n, t, r) : u(n, t)) || r);
              return i > 3 && r && Object.defineProperty(n, t, r), r;
            }
            function vD(e, n) {
              return function (t, s) {
                n(t, s, e);
              };
            }
            function FD(e, n) {
              if (
                typeof Reflect == "object" &&
                typeof Reflect.metadata == "function"
              )
                return Reflect.metadata(e, n);
            }
            function AD(e, n, t, s) {
              function i(r) {
                return r instanceof t
                  ? r
                  : new t(function (u) {
                      u(r);
                    });
              }
              return new (t || (t = Promise))(function (r, u) {
                function a(C) {
                  try {
                    l(s.next(C));
                  } catch (m) {
                    u(m);
                  }
                }
                function c(C) {
                  try {
                    l(s.throw(C));
                  } catch (m) {
                    u(m);
                  }
                }
                function l(C) {
                  C.done ? r(C.value) : i(C.value).then(a, c);
                }
                l((s = s.apply(e, n || [])).next());
              });
            }
            function SD(e, n) {
              var t = {
                  label: 0,
                  sent: function () {
                    if (r[0] & 1) throw r[1];
                    return r[1];
                  },
                  trys: [],
                  ops: [],
                },
                s,
                i,
                r,
                u;
              return (
                (u = { next: a(0), throw: a(1), return: a(2) }),
                typeof Symbol == "function" &&
                  (u[Symbol.iterator] = function () {
                    return this;
                  }),
                u
              );
              function a(l) {
                return function (C) {
                  return c([l, C]);
                };
              }
              function c(l) {
                if (s) throw new TypeError("Generator is already executing.");
                for (; t; )
                  try {
                    if (
                      ((s = 1),
                      i &&
                        (r =
                          l[0] & 2
                            ? i.return
                            : l[0]
                            ? i.throw || ((r = i.return) && r.call(i), 0)
                            : i.next) &&
                        !(r = r.call(i, l[1])).done)
                    )
                      return r;
                    switch (((i = 0), r && (l = [l[0] & 2, r.value]), l[0])) {
                      case 0:
                      case 1:
                        r = l;
                        break;
                      case 4:
                        return t.label++, { value: l[1], done: !1 };
                      case 5:
                        t.label++, (i = l[1]), (l = [0]);
                        continue;
                      case 7:
                        (l = t.ops.pop()), t.trys.pop();
                        continue;
                      default:
                        if (
                          ((r = t.trys),
                          !(r = r.length > 0 && r[r.length - 1]) &&
                            (l[0] === 6 || l[0] === 2))
                        ) {
                          t = 0;
                          continue;
                        }
                        if (
                          l[0] === 3 &&
                          (!r || (l[1] > r[0] && l[1] < r[3]))
                        ) {
                          t.label = l[1];
                          break;
                        }
                        if (l[0] === 6 && t.label < r[1]) {
                          (t.label = r[1]), (r = l);
                          break;
                        }
                        if (r && t.label < r[2]) {
                          (t.label = r[2]), t.ops.push(l);
                          break;
                        }
                        r[2] && t.ops.pop(), t.trys.pop();
                        continue;
                    }
                    l = n.call(e, t);
                  } catch (C) {
                    (l = [6, C]), (i = 0);
                  } finally {
                    s = r = 0;
                  }
                if (l[0] & 5) throw l[1];
                return { value: l[0] ? l[1] : void 0, done: !0 };
              }
            }
            function xD(e, n, t, s) {
              s === void 0 && (s = t), (e[s] = n[t]);
            }
            function bD(e, n) {
              for (var t in e)
                t !== "default" && !n.hasOwnProperty(t) && (n[t] = e[t]);
            }
            function Tn(e) {
              var n = typeof Symbol == "function" && Symbol.iterator,
                t = n && e[n],
                s = 0;
              if (t) return t.call(e);
              if (e && typeof e.length == "number")
                return {
                  next: function () {
                    return (
                      e && s >= e.length && (e = void 0),
                      { value: e && e[s++], done: !e }
                    );
                  },
                };
              throw new TypeError(
                n
                  ? "Object is not iterable."
                  : "Symbol.iterator is not defined."
              );
            }
            function Ii(e, n) {
              var t = typeof Symbol == "function" && e[Symbol.iterator];
              if (!t) return e;
              var s = t.call(e),
                i,
                r = [],
                u;
              try {
                for (; (n === void 0 || n-- > 0) && !(i = s.next()).done; )
                  r.push(i.value);
              } catch (a) {
                u = { error: a };
              } finally {
                try {
                  i && !i.done && (t = s.return) && t.call(s);
                } finally {
                  if (u) throw u.error;
                }
              }
              return r;
            }
            function TD() {
              for (var e = [], n = 0; n < arguments.length; n++)
                e = e.concat(Ii(arguments[n]));
              return e;
            }
            function BD() {
              for (var e = 0, n = 0, t = arguments.length; n < t; n++)
                e += arguments[n].length;
              for (var s = Array(e), i = 0, n = 0; n < t; n++)
                for (var r = arguments[n], u = 0, a = r.length; u < a; u++, i++)
                  s[i] = r[u];
              return s;
            }
            function Gt(e) {
              return this instanceof Gt ? ((this.v = e), this) : new Gt(e);
            }
            function ND(e, n, t) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var s = t.apply(e, n || []),
                i,
                r = [];
              return (
                (i = {}),
                u("next"),
                u("throw"),
                u("return"),
                (i[Symbol.asyncIterator] = function () {
                  return this;
                }),
                i
              );
              function u(g) {
                s[g] &&
                  (i[g] = function (p) {
                    return new Promise(function (f, h) {
                      r.push([g, p, f, h]) > 1 || a(g, p);
                    });
                  });
              }
              function a(g, p) {
                try {
                  c(s[g](p));
                } catch (f) {
                  m(r[0][3], f);
                }
              }
              function c(g) {
                g.value instanceof Gt
                  ? Promise.resolve(g.value.v).then(l, C)
                  : m(r[0][2], g);
              }
              function l(g) {
                a("next", g);
              }
              function C(g) {
                a("throw", g);
              }
              function m(g, p) {
                g(p), r.shift(), r.length && a(r[0][0], r[0][1]);
              }
            }
            function wD(e) {
              var n, t;
              return (
                (n = {}),
                s("next"),
                s("throw", function (i) {
                  throw i;
                }),
                s("return"),
                (n[Symbol.iterator] = function () {
                  return this;
                }),
                n
              );
              function s(i, r) {
                n[i] = e[i]
                  ? function (u) {
                      return (t = !t)
                        ? { value: Gt(e[i](u)), done: i === "return" }
                        : r
                        ? r(u)
                        : u;
                    }
                  : r;
              }
            }
            function _D(e) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var n = e[Symbol.asyncIterator],
                t;
              return n
                ? n.call(e)
                : ((e = typeof Tn == "function" ? Tn(e) : e[Symbol.iterator]()),
                  (t = {}),
                  s("next"),
                  s("throw"),
                  s("return"),
                  (t[Symbol.asyncIterator] = function () {
                    return this;
                  }),
                  t);
              function s(r) {
                t[r] =
                  e[r] &&
                  function (u) {
                    return new Promise(function (a, c) {
                      (u = e[r](u)), i(a, c, u.done, u.value);
                    });
                  };
              }
              function i(r, u, a, c) {
                Promise.resolve(c).then(function (l) {
                  r({ value: l, done: a });
                }, u);
              }
            }
            function PD(e, n) {
              return (
                Object.defineProperty
                  ? Object.defineProperty(e, "raw", { value: n })
                  : (e.raw = n),
                e
              );
            }
            function ID(e) {
              if (e && e.__esModule) return e;
              var n = {};
              if (e != null)
                for (var t in e)
                  Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);
              return (n.default = e), n;
            }
            function kD(e) {
              return e && e.__esModule ? e : { default: e };
            }
            function LD(e, n) {
              if (!n.has(e))
                throw new TypeError(
                  "attempted to get private field on non-instance"
                );
              return n.get(e);
            }
            function OD(e, n, t) {
              if (!n.has(e))
                throw new TypeError(
                  "attempted to set private field on non-instance"
                );
              return n.set(e, t), t;
            }
            var Ar,
              Sr,
              gt = br({
                "node_modules/tslib/tslib.es6.js"() {
                  ae(),
                    (Ar = function (e, n) {
                      return (
                        (Ar =
                          Object.setPrototypeOf ||
                          ({ __proto__: [] } instanceof Array &&
                            function (t, s) {
                              t.__proto__ = s;
                            }) ||
                          function (t, s) {
                            for (var i in s)
                              s.hasOwnProperty(i) && (t[i] = s[i]);
                          }),
                        Ar(e, n)
                      );
                    }),
                    (Sr = function () {
                      return (
                        (Sr =
                          Object.assign ||
                          function (n) {
                            for (
                              var t, s = 1, i = arguments.length;
                              s < i;
                              s++
                            ) {
                              t = arguments[s];
                              for (var r in t)
                                Object.prototype.hasOwnProperty.call(t, r) &&
                                  (n[r] = t[r]);
                            }
                            return n;
                          }),
                        Sr.apply(this, arguments)
                      );
                    });
                },
              }),
              ki = Z({
                "node_modules/vnopts/lib/descriptors/api.js"(e) {
                  "use strict";
                  ae(),
                    Object.defineProperty(e, "__esModule", { value: !0 }),
                    (e.apiDescriptor = {
                      key: (n) =>
                        /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n)
                          ? n
                          : JSON.stringify(n),
                      value(n) {
                        if (n === null || typeof n != "object")
                          return JSON.stringify(n);
                        if (Array.isArray(n))
                          return "[".concat(
                            n.map((s) => e.apiDescriptor.value(s)).join(", "),
                            "]"
                          );
                        let t = Object.keys(n);
                        return t.length === 0
                          ? "{}"
                          : "{ ".concat(
                              t
                                .map((s) =>
                                  ""
                                    .concat(e.apiDescriptor.key(s), ": ")
                                    .concat(e.apiDescriptor.value(n[s]))
                                )
                                .join(", "),
                              " }"
                            );
                      },
                      pair: (n) => {
                        let { key: t, value: s } = n;
                        return e.apiDescriptor.value({ [t]: s });
                      },
                    });
                },
              }),
              jD = Z({
                "node_modules/vnopts/lib/descriptors/index.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = (gt(), pt(Dt));
                  n.__exportStar(ki(), e);
                },
              }),
              Nr = Z({
                "scripts/build/shims/chalk.cjs"(e, n) {
                  "use strict";
                  ae();
                  var t = (s) => s;
                  (t.grey = t),
                    (t.red = t),
                    (t.bold = t),
                    (t.yellow = t),
                    (t.blue = t),
                    (t.default = t),
                    (n.exports = t);
                },
              }),
              Li = Z({
                "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = Nr();
                  e.commonDeprecatedHandler = (t, s, i) => {
                    let { descriptor: r } = i,
                      u = [
                        "".concat(
                          n.default.yellow(
                            typeof t == "string" ? r.key(t) : r.pair(t)
                          ),
                          " is deprecated"
                        ),
                      ];
                    return (
                      s &&
                        u.push(
                          "we now treat it as ".concat(
                            n.default.blue(
                              typeof s == "string" ? r.key(s) : r.pair(s)
                            )
                          )
                        ),
                      u.join("; ") + "."
                    );
                  };
                },
              }),
              qD = Z({
                "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = (gt(), pt(Dt));
                  n.__exportStar(Li(), e);
                },
              }),
              MD = Z({
                "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = Nr();
                  e.commonInvalidHandler = (t, s, i) =>
                    [
                      "Invalid ".concat(
                        n.default.red(i.descriptor.key(t)),
                        " value."
                      ),
                      "Expected ".concat(
                        n.default.blue(i.schemas[t].expected(i)),
                        ","
                      ),
                      "but received ".concat(
                        n.default.red(i.descriptor.value(s)),
                        "."
                      ),
                    ].join(" ");
                },
              }),
              Oi = Z({
                "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = (gt(), pt(Dt));
                  n.__exportStar(MD(), e);
                },
              }),
              RD = Z({
                "node_modules/vnopts/node_modules/leven/index.js"(e, n) {
                  "use strict";
                  ae();
                  var t = [],
                    s = [];
                  n.exports = function (i, r) {
                    if (i === r) return 0;
                    var u = i;
                    i.length > r.length && ((i = r), (r = u));
                    var a = i.length,
                      c = r.length;
                    if (a === 0) return c;
                    if (c === 0) return a;
                    for (; a > 0 && i.charCodeAt(~-a) === r.charCodeAt(~-c); )
                      a--, c--;
                    if (a === 0) return c;
                    for (
                      var l = 0;
                      l < a && i.charCodeAt(l) === r.charCodeAt(l);

                    )
                      l++;
                    if (((a -= l), (c -= l), a === 0)) return c;
                    for (var C, m, g, p, f = 0, h = 0; f < a; )
                      (s[l + f] = i.charCodeAt(l + f)), (t[f] = ++f);
                    for (; h < c; )
                      for (
                        C = r.charCodeAt(l + h), g = h++, m = h, f = 0;
                        f < a;
                        f++
                      )
                        (p = C === s[l + f] ? g : g + 1),
                          (g = t[f]),
                          (m = t[f] =
                            g > m ? (p > m ? m + 1 : p) : p > g ? g + 1 : p);
                    return m;
                  };
                },
              }),
              ji = Z({
                "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = Nr(),
                    t = RD();
                  e.levenUnknownHandler = (s, i, r) => {
                    let { descriptor: u, logger: a, schemas: c } = r,
                      l = [
                        "Ignored unknown option ".concat(
                          n.default.yellow(u.pair({ key: s, value: i })),
                          "."
                        ),
                      ],
                      C = Object.keys(c)
                        .sort()
                        .find((m) => t(s, m) < 3);
                    C &&
                      l.push(
                        "Did you mean ".concat(n.default.blue(u.key(C)), "?")
                      ),
                      a.warn(l.join(" "));
                  };
                },
              }),
              VD = Z({
                "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = (gt(), pt(Dt));
                  n.__exportStar(ji(), e);
                },
              }),
              WD = Z({
                "node_modules/vnopts/lib/handlers/index.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = (gt(), pt(Dt));
                  n.__exportStar(qD(), e),
                    n.__exportStar(Oi(), e),
                    n.__exportStar(VD(), e);
                },
              }),
              yt = Z({
                "node_modules/vnopts/lib/schema.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = [
                    "default",
                    "expected",
                    "validate",
                    "deprecated",
                    "forward",
                    "redirect",
                    "overlap",
                    "preprocess",
                    "postprocess",
                  ];
                  function t(r, u) {
                    let a = new r(u),
                      c = Object.create(a);
                    for (let l of n)
                      l in u && (c[l] = i(u[l], a, s.prototype[l].length));
                    return c;
                  }
                  e.createSchema = t;
                  var s = class {
                    constructor(r) {
                      this.name = r.name;
                    }
                    static create(r) {
                      return t(this, r);
                    }
                    default(r) {}
                    expected(r) {
                      return "nothing";
                    }
                    validate(r, u) {
                      return !1;
                    }
                    deprecated(r, u) {
                      return !1;
                    }
                    forward(r, u) {}
                    redirect(r, u) {}
                    overlap(r, u, a) {
                      return r;
                    }
                    preprocess(r, u) {
                      return r;
                    }
                    postprocess(r, u) {
                      return r;
                    }
                  };
                  e.Schema = s;
                  function i(r, u, a) {
                    return typeof r == "function"
                      ? function () {
                          for (
                            var c = arguments.length, l = new Array(c), C = 0;
                            C < c;
                            C++
                          )
                            l[C] = arguments[C];
                          return r(...l.slice(0, a - 1), u, ...l.slice(a - 1));
                        }
                      : () => r;
                  }
                },
              }),
              $D = Z({
                "node_modules/vnopts/lib/schemas/alias.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = yt(),
                    t = class extends n.Schema {
                      constructor(s) {
                        super(s);
                        this._sourceName = s.sourceName;
                      }
                      expected(s) {
                        return s.schemas[this._sourceName].expected(s);
                      }
                      validate(s, i) {
                        return i.schemas[this._sourceName].validate(s, i);
                      }
                      redirect(s, i) {
                        return this._sourceName;
                      }
                    };
                  e.AliasSchema = t;
                },
              }),
              HD = Z({
                "node_modules/vnopts/lib/schemas/any.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = yt(),
                    t = class extends n.Schema {
                      expected() {
                        return "anything";
                      }
                      validate() {
                        return !0;
                      }
                    };
                  e.AnySchema = t;
                },
              }),
              GD = Z({
                "node_modules/vnopts/lib/schemas/array.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = (gt(), pt(Dt)),
                    t = yt(),
                    s = class extends t.Schema {
                      constructor(r) {
                        var { valueSchema: u, name: a = u.name } = r,
                          c = n.__rest(r, ["valueSchema", "name"]);
                        super(Object.assign({}, c, { name: a }));
                        this._valueSchema = u;
                      }
                      expected(r) {
                        return "an array of ".concat(
                          this._valueSchema.expected(r)
                        );
                      }
                      validate(r, u) {
                        if (!Array.isArray(r)) return !1;
                        let a = [];
                        for (let c of r) {
                          let l = u.normalizeValidateResult(
                            this._valueSchema.validate(c, u),
                            c
                          );
                          l !== !0 && a.push(l.value);
                        }
                        return a.length === 0 ? !0 : { value: a };
                      }
                      deprecated(r, u) {
                        let a = [];
                        for (let c of r) {
                          let l = u.normalizeDeprecatedResult(
                            this._valueSchema.deprecated(c, u),
                            c
                          );
                          l !== !1 &&
                            a.push(
                              ...l.map((C) => {
                                let { value: m } = C;
                                return { value: [m] };
                              })
                            );
                        }
                        return a;
                      }
                      forward(r, u) {
                        let a = [];
                        for (let c of r) {
                          let l = u.normalizeForwardResult(
                            this._valueSchema.forward(c, u),
                            c
                          );
                          a.push(...l.map(i));
                        }
                        return a;
                      }
                      redirect(r, u) {
                        let a = [],
                          c = [];
                        for (let l of r) {
                          let C = u.normalizeRedirectResult(
                            this._valueSchema.redirect(l, u),
                            l
                          );
                          "remain" in C && a.push(C.remain),
                            c.push(...C.redirect.map(i));
                        }
                        return a.length === 0
                          ? { redirect: c }
                          : { redirect: c, remain: a };
                      }
                      overlap(r, u) {
                        return r.concat(u);
                      }
                    };
                  e.ArraySchema = s;
                  function i(r) {
                    let { from: u, to: a } = r;
                    return { from: [u], to: a };
                  }
                },
              }),
              JD = Z({
                "node_modules/vnopts/lib/schemas/boolean.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = yt(),
                    t = class extends n.Schema {
                      expected() {
                        return "true or false";
                      }
                      validate(s) {
                        return typeof s == "boolean";
                      }
                    };
                  e.BooleanSchema = t;
                },
              }),
              Hn = Z({
                "node_modules/vnopts/lib/utils.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  function n(p, f) {
                    let h = Object.create(null);
                    for (let N of p) {
                      let T = N[f];
                      if (h[T])
                        throw new Error(
                          "Duplicate ".concat(f, " ").concat(JSON.stringify(T))
                        );
                      h[T] = N;
                    }
                    return h;
                  }
                  e.recordFromArray = n;
                  function t(p, f) {
                    let h = new Map();
                    for (let N of p) {
                      let T = N[f];
                      if (h.has(T))
                        throw new Error(
                          "Duplicate ".concat(f, " ").concat(JSON.stringify(T))
                        );
                      h.set(T, N);
                    }
                    return h;
                  }
                  e.mapFromArray = t;
                  function s() {
                    let p = Object.create(null);
                    return (f) => {
                      let h = JSON.stringify(f);
                      return p[h] ? !0 : ((p[h] = !0), !1);
                    };
                  }
                  e.createAutoChecklist = s;
                  function i(p, f) {
                    let h = [],
                      N = [];
                    for (let T of p) f(T) ? h.push(T) : N.push(T);
                    return [h, N];
                  }
                  e.partition = i;
                  function r(p) {
                    return p === Math.floor(p);
                  }
                  e.isInt = r;
                  function u(p, f) {
                    if (p === f) return 0;
                    let h = typeof p,
                      N = typeof f,
                      T = [
                        "undefined",
                        "object",
                        "boolean",
                        "number",
                        "string",
                      ];
                    return h !== N
                      ? T.indexOf(h) - T.indexOf(N)
                      : h !== "string"
                      ? Number(p) - Number(f)
                      : p.localeCompare(f);
                  }
                  e.comparePrimitive = u;
                  function a(p) {
                    return p === void 0 ? {} : p;
                  }
                  e.normalizeDefaultResult = a;
                  function c(p, f) {
                    return p === !0 ? !0 : p === !1 ? { value: f } : p;
                  }
                  e.normalizeValidateResult = c;
                  function l(p, f) {
                    let h =
                      arguments.length > 2 && arguments[2] !== void 0
                        ? arguments[2]
                        : !1;
                    return p === !1
                      ? !1
                      : p === !0
                      ? h
                        ? !0
                        : [{ value: f }]
                      : "value" in p
                      ? [p]
                      : p.length === 0
                      ? !1
                      : p;
                  }
                  e.normalizeDeprecatedResult = l;
                  function C(p, f) {
                    return typeof p == "string" || "key" in p
                      ? { from: f, to: p }
                      : "from" in p
                      ? { from: p.from, to: p.to }
                      : { from: f, to: p.to };
                  }
                  e.normalizeTransferResult = C;
                  function m(p, f) {
                    return p === void 0
                      ? []
                      : Array.isArray(p)
                      ? p.map((h) => C(h, f))
                      : [C(p, f)];
                  }
                  e.normalizeForwardResult = m;
                  function g(p, f) {
                    let h = m(
                      typeof p == "object" && "redirect" in p ? p.redirect : p,
                      f
                    );
                    return h.length === 0
                      ? { remain: f, redirect: h }
                      : typeof p == "object" && "remain" in p
                      ? { remain: p.remain, redirect: h }
                      : { redirect: h };
                  }
                  e.normalizeRedirectResult = g;
                },
              }),
              UD = Z({
                "node_modules/vnopts/lib/schemas/choice.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = yt(),
                    t = Hn(),
                    s = class extends n.Schema {
                      constructor(i) {
                        super(i);
                        this._choices = t.mapFromArray(
                          i.choices.map((r) =>
                            r && typeof r == "object" ? r : { value: r }
                          ),
                          "value"
                        );
                      }
                      expected(i) {
                        let { descriptor: r } = i,
                          u = Array.from(this._choices.keys())
                            .map((l) => this._choices.get(l))
                            .filter((l) => !l.deprecated)
                            .map((l) => l.value)
                            .sort(t.comparePrimitive)
                            .map(r.value),
                          a = u.slice(0, -2),
                          c = u.slice(-2);
                        return a.concat(c.join(" or ")).join(", ");
                      }
                      validate(i) {
                        return this._choices.has(i);
                      }
                      deprecated(i) {
                        let r = this._choices.get(i);
                        return r && r.deprecated ? { value: i } : !1;
                      }
                      forward(i) {
                        let r = this._choices.get(i);
                        return r ? r.forward : void 0;
                      }
                      redirect(i) {
                        let r = this._choices.get(i);
                        return r ? r.redirect : void 0;
                      }
                    };
                  e.ChoiceSchema = s;
                },
              }),
              qi = Z({
                "node_modules/vnopts/lib/schemas/number.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = yt(),
                    t = class extends n.Schema {
                      expected() {
                        return "a number";
                      }
                      validate(s, i) {
                        return typeof s == "number";
                      }
                    };
                  e.NumberSchema = t;
                },
              }),
              zD = Z({
                "node_modules/vnopts/lib/schemas/integer.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = Hn(),
                    t = qi(),
                    s = class extends t.NumberSchema {
                      expected() {
                        return "an integer";
                      }
                      validate(i, r) {
                        return (
                          r.normalizeValidateResult(super.validate(i, r), i) ===
                            !0 && n.isInt(i)
                        );
                      }
                    };
                  e.IntegerSchema = s;
                },
              }),
              XD = Z({
                "node_modules/vnopts/lib/schemas/string.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = yt(),
                    t = class extends n.Schema {
                      expected() {
                        return "a string";
                      }
                      validate(s) {
                        return typeof s == "string";
                      }
                    };
                  e.StringSchema = t;
                },
              }),
              KD = Z({
                "node_modules/vnopts/lib/schemas/index.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = (gt(), pt(Dt));
                  n.__exportStar($D(), e),
                    n.__exportStar(HD(), e),
                    n.__exportStar(GD(), e),
                    n.__exportStar(JD(), e),
                    n.__exportStar(UD(), e),
                    n.__exportStar(zD(), e),
                    n.__exportStar(qi(), e),
                    n.__exportStar(XD(), e);
                },
              }),
              YD = Z({
                "node_modules/vnopts/lib/defaults.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = ki(),
                    t = Li(),
                    s = Oi(),
                    i = ji();
                  (e.defaultDescriptor = n.apiDescriptor),
                    (e.defaultUnknownHandler = i.levenUnknownHandler),
                    (e.defaultInvalidHandler = s.commonInvalidHandler),
                    (e.defaultDeprecatedHandler = t.commonDeprecatedHandler);
                },
              }),
              QD = Z({
                "node_modules/vnopts/lib/normalize.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = YD(),
                    t = Hn();
                  e.normalize = (i, r, u) => new s(r, u).normalize(i);
                  var s = class {
                    constructor(i, r) {
                      let {
                        logger: u = console,
                        descriptor: a = n.defaultDescriptor,
                        unknown: c = n.defaultUnknownHandler,
                        invalid: l = n.defaultInvalidHandler,
                        deprecated: C = n.defaultDeprecatedHandler,
                      } = r || {};
                      (this._utils = {
                        descriptor: a,
                        logger: u || { warn: () => {} },
                        schemas: t.recordFromArray(i, "name"),
                        normalizeDefaultResult: t.normalizeDefaultResult,
                        normalizeDeprecatedResult: t.normalizeDeprecatedResult,
                        normalizeForwardResult: t.normalizeForwardResult,
                        normalizeRedirectResult: t.normalizeRedirectResult,
                        normalizeValidateResult: t.normalizeValidateResult,
                      }),
                        (this._unknownHandler = c),
                        (this._invalidHandler = l),
                        (this._deprecatedHandler = C),
                        this.cleanHistory();
                    }
                    cleanHistory() {
                      this._hasDeprecationWarned = t.createAutoChecklist();
                    }
                    normalize(i) {
                      let r = {},
                        u = [i],
                        a = () => {
                          for (; u.length !== 0; ) {
                            let c = u.shift(),
                              l = this._applyNormalization(c, r);
                            u.push(...l);
                          }
                        };
                      a();
                      for (let c of Object.keys(this._utils.schemas)) {
                        let l = this._utils.schemas[c];
                        if (!(c in r)) {
                          let C = t.normalizeDefaultResult(
                            l.default(this._utils)
                          );
                          "value" in C && u.push({ [c]: C.value });
                        }
                      }
                      a();
                      for (let c of Object.keys(this._utils.schemas)) {
                        let l = this._utils.schemas[c];
                        c in r && (r[c] = l.postprocess(r[c], this._utils));
                      }
                      return r;
                    }
                    _applyNormalization(i, r) {
                      let u = [],
                        [a, c] = t.partition(
                          Object.keys(i),
                          (l) => l in this._utils.schemas
                        );
                      for (let l of a) {
                        let C = this._utils.schemas[l],
                          m = C.preprocess(i[l], this._utils),
                          g = t.normalizeValidateResult(
                            C.validate(m, this._utils),
                            m
                          );
                        if (g !== !0) {
                          let { value: T } = g,
                            A = this._invalidHandler(l, T, this._utils);
                          throw typeof A == "string" ? new Error(A) : A;
                        }
                        let p = (T) => {
                            let { from: A, to: b } = T;
                            u.push(
                              typeof b == "string"
                                ? { [b]: A }
                                : { [b.key]: b.value }
                            );
                          },
                          f = (T) => {
                            let { value: A, redirectTo: b } = T,
                              v = t.normalizeDeprecatedResult(
                                C.deprecated(A, this._utils),
                                m,
                                !0
                              );
                            if (v !== !1)
                              if (v === !0)
                                this._hasDeprecationWarned(l) ||
                                  this._utils.logger.warn(
                                    this._deprecatedHandler(l, b, this._utils)
                                  );
                              else
                                for (let { value: B } of v) {
                                  let w = { key: l, value: B };
                                  if (!this._hasDeprecationWarned(w)) {
                                    let I =
                                      typeof b == "string"
                                        ? { key: b, value: B }
                                        : b;
                                    this._utils.logger.warn(
                                      this._deprecatedHandler(w, I, this._utils)
                                    );
                                  }
                                }
                          };
                        t.normalizeForwardResult(
                          C.forward(m, this._utils),
                          m
                        ).forEach(p);
                        let N = t.normalizeRedirectResult(
                          C.redirect(m, this._utils),
                          m
                        );
                        if ((N.redirect.forEach(p), "remain" in N)) {
                          let T = N.remain;
                          (r[l] = l in r ? C.overlap(r[l], T, this._utils) : T),
                            f({ value: T });
                        }
                        for (let { from: T, to: A } of N.redirect)
                          f({ value: T, redirectTo: A });
                      }
                      for (let l of c) {
                        let C = i[l],
                          m = this._unknownHandler(l, C, this._utils);
                        if (m)
                          for (let g of Object.keys(m)) {
                            let p = { [g]: m[g] };
                            g in this._utils.schemas
                              ? u.push(p)
                              : Object.assign(r, p);
                          }
                      }
                      return u;
                    }
                  };
                  e.Normalizer = s;
                },
              }),
              ZD = Z({
                "node_modules/vnopts/lib/index.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = (gt(), pt(Dt));
                  n.__exportStar(jD(), e),
                    n.__exportStar(WD(), e),
                    n.__exportStar(KD(), e),
                    n.__exportStar(QD(), e),
                    n.__exportStar(yt(), e);
                },
              }),
              em = Z({
                "src/main/options-normalizer.js"(e, n) {
                  "use strict";
                  ae();
                  var t = ZD(),
                    s = st(),
                    i = {
                      key: (g) =>
                        g.length === 1 ? "-".concat(g) : "--".concat(g),
                      value: (g) => t.apiDescriptor.value(g),
                      pair: (g) => {
                        let { key: p, value: f } = g;
                        return f === !1
                          ? "--no-".concat(p)
                          : f === !0
                          ? i.key(p)
                          : f === ""
                          ? "".concat(i.key(p), " without an argument")
                          : "".concat(i.key(p), "=").concat(f);
                      },
                    },
                    r = (g) => {
                      let { colorsModule: p, levenshteinDistance: f } = g;
                      return class extends t.ChoiceSchema {
                        constructor(N) {
                          let { name: T, flags: A } = N;
                          super({ name: T, choices: A });
                          this._flags = [...A].sort();
                        }
                        preprocess(N, T) {
                          if (
                            typeof N == "string" &&
                            N.length > 0 &&
                            !this._flags.includes(N)
                          ) {
                            let A = this._flags.find((b) => f(b, N) < 3);
                            if (A)
                              return (
                                T.logger.warn(
                                  [
                                    "Unknown flag ".concat(
                                      p.yellow(T.descriptor.value(N)),
                                      ","
                                    ),
                                    "did you mean ".concat(
                                      p.blue(T.descriptor.value(A)),
                                      "?"
                                    ),
                                  ].join(" ")
                                ),
                                A
                              );
                          }
                          return N;
                        }
                        expected() {
                          return "a flag";
                        }
                      };
                    },
                    u;
                  function a(g, p) {
                    let {
                        logger: f,
                        isCLI: h = !1,
                        passThrough: N = !1,
                        colorsModule: T,
                        levenshteinDistance: A,
                      } = arguments.length > 2 && arguments[2] !== void 0
                        ? arguments[2]
                        : {},
                      b = N
                        ? Array.isArray(N)
                          ? (D, d) => (N.includes(D) ? { [D]: d } : void 0)
                          : (D, d) => ({ [D]: d })
                        : (D, d, y) => {
                            let o = y.schemas,
                              { _: x } = o,
                              F = _n(o, Xf);
                            return t.levenUnknownHandler(
                              D,
                              d,
                              Object.assign(
                                Object.assign({}, y),
                                {},
                                { schemas: F }
                              )
                            );
                          },
                      v = h ? i : t.apiDescriptor,
                      B = c(p, {
                        isCLI: h,
                        colorsModule: T,
                        levenshteinDistance: A,
                      }),
                      w = new t.Normalizer(B, {
                        logger: f,
                        unknown: b,
                        descriptor: v,
                      }),
                      I = f !== !1;
                    I && u && (w._hasDeprecationWarned = u);
                    let E = w.normalize(g);
                    return (
                      I && (u = w._hasDeprecationWarned),
                      h &&
                        E["plugin-search"] === !1 &&
                        (E["plugin-search-dir"] = !1),
                      E
                    );
                  }
                  function c(g, p) {
                    let {
                        isCLI: f,
                        colorsModule: h,
                        levenshteinDistance: N,
                      } = p,
                      T = [];
                    f && T.push(t.AnySchema.create({ name: "_" }));
                    for (let A of g)
                      T.push(
                        l(A, {
                          isCLI: f,
                          optionInfos: g,
                          colorsModule: h,
                          levenshteinDistance: N,
                        })
                      ),
                        A.alias &&
                          f &&
                          T.push(
                            t.AliasSchema.create({
                              name: A.alias,
                              sourceName: A.name,
                            })
                          );
                    return T;
                  }
                  function l(g, p) {
                    let {
                        isCLI: f,
                        optionInfos: h,
                        colorsModule: N,
                        levenshteinDistance: T,
                      } = p,
                      { name: A } = g;
                    if (A === "plugin-search-dir" || A === "pluginSearchDirs")
                      return t.AnySchema.create({
                        name: A,
                        preprocess(w) {
                          return (
                            w === !1 || (w = Array.isArray(w) ? w : [w]), w
                          );
                        },
                        validate(w) {
                          return w === !1
                            ? !0
                            : w.every((I) => typeof I == "string");
                        },
                        expected() {
                          return "false or paths to plugin search dir";
                        },
                      });
                    let b = { name: A },
                      v,
                      B = {};
                    switch (g.type) {
                      case "int":
                        (v = t.IntegerSchema),
                          f && (b.preprocess = (w) => Number(w));
                        break;
                      case "string":
                        v = t.StringSchema;
                        break;
                      case "choice":
                        (v = t.ChoiceSchema),
                          (b.choices = g.choices.map((w) =>
                            typeof w == "object" && w.redirect
                              ? Object.assign(
                                  Object.assign({}, w),
                                  {},
                                  {
                                    redirect: {
                                      to: { key: g.name, value: w.redirect },
                                    },
                                  }
                                )
                              : w
                          ));
                        break;
                      case "boolean":
                        v = t.BooleanSchema;
                        break;
                      case "flag":
                        (v = r({ colorsModule: N, levenshteinDistance: T })),
                          (b.flags = h.flatMap((w) =>
                            [
                              w.alias,
                              w.description && w.name,
                              w.oppositeDescription && "no-".concat(w.name),
                            ].filter(Boolean)
                          ));
                        break;
                      case "path":
                        v = t.StringSchema;
                        break;
                      default:
                        throw new Error("Unexpected type ".concat(g.type));
                    }
                    if (
                      (g.exception
                        ? (b.validate = (w, I, E) =>
                            g.exception(w) || I.validate(w, E))
                        : (b.validate = (w, I, E) =>
                            w === void 0 || I.validate(w, E)),
                      g.redirect &&
                        (B.redirect = (w) =>
                          w
                            ? {
                                to: {
                                  key: g.redirect.option,
                                  value: g.redirect.value,
                                },
                              }
                            : void 0),
                      g.deprecated && (B.deprecated = !0),
                      f && !g.array)
                    ) {
                      let w = b.preprocess || ((I) => I);
                      b.preprocess = (I, E, D) =>
                        E.preprocess(w(Array.isArray(I) ? s(I) : I), D);
                    }
                    return g.array
                      ? t.ArraySchema.create(
                          Object.assign(
                            Object.assign(
                              Object.assign(
                                {},
                                f
                                  ? {
                                      preprocess: (w) =>
                                        Array.isArray(w) ? w : [w],
                                    }
                                  : {}
                              ),
                              B
                            ),
                            {},
                            { valueSchema: v.create(b) }
                          )
                        )
                      : v.create(Object.assign(Object.assign({}, b), B));
                  }
                  function C(g, p, f) {
                    return a(g, p, f);
                  }
                  function m(g, p, f) {
                    return a(g, p, Object.assign({ isCLI: !0 }, f));
                  }
                  n.exports = {
                    normalizeApiOptions: C,
                    normalizeCliOptions: m,
                  };
                },
              }),
              nt = Z({
                "src/language-js/loc.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Rn();
                  function s(c, l) {
                    let { ignoreDecorators: C } = l || {};
                    if (!C) {
                      let m =
                        (c.declaration && c.declaration.decorators) ||
                        c.decorators;
                      if (t(m)) return s(m[0]);
                    }
                    return c.range ? c.range[0] : c.start;
                  }
                  function i(c) {
                    return c.range ? c.range[1] : c.end;
                  }
                  function r(c, l) {
                    let C = s(c);
                    return Number.isInteger(C) && C === s(l);
                  }
                  function u(c, l) {
                    let C = i(c);
                    return Number.isInteger(C) && C === i(l);
                  }
                  function a(c, l) {
                    return r(c, l) && u(c, l);
                  }
                  n.exports = {
                    locStart: s,
                    locEnd: i,
                    hasSameLocStart: r,
                    hasSameLoc: a,
                  };
                },
              }),
              tm = Z({
                "scripts/build/shims/babel-highlight.cjs"(e, n) {
                  "use strict";
                  ae();
                  var t = Nr(),
                    s = { shouldHighlight: () => !1, getChalk: () => t };
                  n.exports = s;
                },
              }),
              rm = Z({
                "node_modules/@babel/code-frame/lib/index.js"(e) {
                  "use strict";
                  ae(),
                    Object.defineProperty(e, "__esModule", { value: !0 }),
                    (e.codeFrameColumns = u),
                    (e.default = a);
                  var n = tm(),
                    t = !1;
                  function s(c) {
                    return {
                      gutter: c.grey,
                      marker: c.red.bold,
                      message: c.red.bold,
                    };
                  }
                  var i = /\r\n|[\n\r\u2028\u2029]/;
                  function r(c, l, C) {
                    let m = Object.assign({ column: 0, line: -1 }, c.start),
                      g = Object.assign({}, m, c.end),
                      { linesAbove: p = 2, linesBelow: f = 3 } = C || {},
                      h = m.line,
                      N = m.column,
                      T = g.line,
                      A = g.column,
                      b = Math.max(h - (p + 1), 0),
                      v = Math.min(l.length, T + f);
                    h === -1 && (b = 0), T === -1 && (v = l.length);
                    let B = T - h,
                      w = {};
                    if (B)
                      for (let I = 0; I <= B; I++) {
                        let E = I + h;
                        if (!N) w[E] = !0;
                        else if (I === 0) {
                          let D = l[E - 1].length;
                          w[E] = [N, D - N + 1];
                        } else if (I === B) w[E] = [0, A];
                        else {
                          let D = l[E - I].length;
                          w[E] = [0, D];
                        }
                      }
                    else
                      N === A
                        ? N
                          ? (w[h] = [N, 0])
                          : (w[h] = !0)
                        : (w[h] = [N, A - N]);
                    return { start: b, end: v, markerLines: w };
                  }
                  function u(c, l) {
                    let C =
                        arguments.length > 2 && arguments[2] !== void 0
                          ? arguments[2]
                          : {},
                      m =
                        (C.highlightCode || C.forceColor) &&
                        (0, n.shouldHighlight)(C),
                      g = (0, n.getChalk)(C),
                      p = s(g),
                      f = (I, E) => (m ? I(E) : E),
                      h = c.split(i),
                      { start: N, end: T, markerLines: A } = r(l, h, C),
                      b = l.start && typeof l.start.column == "number",
                      v = String(T).length,
                      w = (m ? (0, n.default)(c, C) : c)
                        .split(i, T)
                        .slice(N, T)
                        .map((I, E) => {
                          let D = N + 1 + E,
                            d = " ".concat(D).slice(-v),
                            y = " ".concat(d, " |"),
                            o = A[D],
                            x = !A[D + 1];
                          if (o) {
                            let F = "";
                            if (Array.isArray(o)) {
                              let S = I.slice(0, Math.max(o[0] - 1, 0)).replace(
                                  /[^\t]/g,
                                  " "
                                ),
                                k = o[1] || 1;
                              (F = [
                                `
 `,
                                f(p.gutter, y.replace(/\d/g, " ")),
                                " ",
                                S,
                                f(p.marker, "^").repeat(k),
                              ].join("")),
                                x &&
                                  C.message &&
                                  (F += " " + f(p.message, C.message));
                            }
                            return [
                              f(p.marker, ">"),
                              f(p.gutter, y),
                              I.length > 0 ? " ".concat(I) : "",
                              F,
                            ].join("");
                          } else
                            return " "
                              .concat(f(p.gutter, y))
                              .concat(I.length > 0 ? " ".concat(I) : "");
                        }).join(`
`);
                    return (
                      C.message &&
                        !b &&
                        (w = ""
                          .concat(" ".repeat(v + 1))
                          .concat(
                            C.message,
                            `
`
                          )
                          .concat(w)),
                      m ? g.reset(w) : w
                    );
                  }
                  function a(c, l, C) {
                    let m =
                      arguments.length > 3 && arguments[3] !== void 0
                        ? arguments[3]
                        : {};
                    if (!t) {
                      t = !0;
                      let p =
                        "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                      if (xt.emitWarning)
                        xt.emitWarning(p, "DeprecationWarning");
                      else {
                        let f = new Error(p);
                        (f.name = "DeprecationWarning"),
                          console.warn(new Error(p));
                      }
                    }
                    return (
                      (C = Math.max(C, 0)),
                      u(c, { start: { column: C, line: l } }, m)
                    );
                  }
                },
              }),
              Gn = Z({
                "src/main/parser.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Pi(),
                    { ConfigError: s } = Jt(),
                    i = nt(),
                    { locStart: r, locEnd: u } = i,
                    a = Object.getOwnPropertyNames,
                    c = Object.getOwnPropertyDescriptor;
                  function l(g) {
                    let p = {};
                    for (let f of g.plugins)
                      if (!!f.parsers)
                        for (let h of a(f.parsers))
                          Object.defineProperty(p, h, c(f.parsers, h));
                    return p;
                  }
                  function C(g) {
                    let p =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : l(g);
                    if (typeof g.parser == "function")
                      return {
                        parse: g.parser,
                        astFormat: "estree",
                        locStart: r,
                        locEnd: u,
                      };
                    if (typeof g.parser == "string") {
                      if (Object.prototype.hasOwnProperty.call(p, g.parser))
                        return p[g.parser];
                      throw new s(
                        `Couldn't resolve parser "`.concat(
                          g.parser,
                          '". Parsers must be explicitly added to the standalone bundle.'
                        )
                      );
                    }
                  }
                  function m(g, p) {
                    let f = l(p),
                      h = Object.defineProperties(
                        {},
                        Object.fromEntries(
                          Object.keys(f).map((T) => [
                            T,
                            {
                              enumerable: !0,
                              get() {
                                return f[T].parse;
                              },
                            },
                          ])
                        )
                      ),
                      N = C(p, f);
                    try {
                      return (
                        N.preprocess && (g = N.preprocess(g, p)),
                        { text: g, ast: N.parse(g, h, p) }
                      );
                    } catch (T) {
                      let { loc: A } = T;
                      if (A) {
                        let { codeFrameColumns: b } = rm();
                        throw (
                          ((T.codeFrame = b(g, A, { highlightCode: !0 })),
                          (T.message +=
                            `
` + T.codeFrame),
                          T)
                        );
                      }
                      throw T.stack;
                    }
                  }
                  n.exports = { parse: m, resolveParser: C };
                },
              }),
              Mi = Z({
                "src/main/options.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Pi(),
                    { UndefinedParserError: s } = Jt(),
                    { getSupportInfo: i } = Mn(),
                    r = em(),
                    { resolveParser: u } = Gn(),
                    a = {
                      astFormat: "estree",
                      printer: {},
                      originalText: void 0,
                      locStart: null,
                      locEnd: null,
                    };
                  function c(m) {
                    let g =
                        arguments.length > 1 && arguments[1] !== void 0
                          ? arguments[1]
                          : {},
                      p = Object.assign({}, m),
                      f = i({
                        plugins: m.plugins,
                        showUnreleased: !0,
                        showDeprecated: !0,
                      }).options,
                      h = Object.assign(
                        Object.assign({}, a),
                        Object.fromEntries(
                          f
                            .filter((v) => v.default !== void 0)
                            .map((v) => [v.name, v.default])
                        )
                      );
                    if (!p.parser) {
                      if (!p.filepath)
                        (g.logger || console).warn(
                          "No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."
                        ),
                          (p.parser = "babel");
                      else if (
                        ((p.parser = C(p.filepath, p.plugins)), !p.parser)
                      )
                        throw new s(
                          "No parser could be inferred for file: ".concat(
                            p.filepath
                          )
                        );
                    }
                    let N = u(
                      r.normalizeApiOptions(
                        p,
                        [f.find((v) => v.name === "parser")],
                        { passThrough: !0, logger: !1 }
                      )
                    );
                    (p.astFormat = N.astFormat),
                      (p.locEnd = N.locEnd),
                      (p.locStart = N.locStart);
                    let T = l(p);
                    p.printer = T.printers[p.astFormat];
                    let A = Object.fromEntries(
                        f
                          .filter(
                            (v) =>
                              v.pluginDefaults &&
                              v.pluginDefaults[T.name] !== void 0
                          )
                          .map((v) => [v.name, v.pluginDefaults[T.name]])
                      ),
                      b = Object.assign(Object.assign({}, h), A);
                    for (let [v, B] of Object.entries(b))
                      (p[v] === null || p[v] === void 0) && (p[v] = B);
                    return (
                      p.parser === "json" && (p.trailingComma = "none"),
                      r.normalizeApiOptions(
                        p,
                        f,
                        Object.assign({ passThrough: Object.keys(a) }, g)
                      )
                    );
                  }
                  function l(m) {
                    let { astFormat: g } = m;
                    if (!g)
                      throw new Error(
                        "getPlugin() requires astFormat to be set"
                      );
                    let p = m.plugins.find((f) => f.printers && f.printers[g]);
                    if (!p)
                      throw new Error(
                        `Couldn't find plugin for AST format "`.concat(g, '"')
                      );
                    return p;
                  }
                  function C(m, g) {
                    let p = t.basename(m).toLowerCase(),
                      h = i({ plugins: g })
                        .languages.filter((N) => N.since !== null)
                        .find(
                          (N) =>
                            (N.extensions &&
                              N.extensions.some((T) => p.endsWith(T))) ||
                            (N.filenames &&
                              N.filenames.some((T) => T.toLowerCase() === p))
                        );
                    return h && h.parsers[0];
                  }
                  n.exports = {
                    normalize: c,
                    hiddenDefaults: a,
                    inferParser: C,
                  };
                },
              }),
              nm = Z({
                "src/main/massage-ast.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s, i, r) {
                    if (Array.isArray(s))
                      return s.map((l) => t(l, i, r)).filter(Boolean);
                    if (!s || typeof s != "object") return s;
                    let u = i.printer.massageAstNode,
                      a;
                    u && u.ignoredProperties
                      ? (a = u.ignoredProperties)
                      : (a = new Set());
                    let c = {};
                    for (let [l, C] of Object.entries(s))
                      !a.has(l) &&
                        typeof C != "function" &&
                        (c[l] = t(C, i, s));
                    if (u) {
                      let l = u(s, c, r);
                      if (l === null) return;
                      if (l) return l;
                    }
                    return c;
                  }
                  n.exports = t;
                },
              }),
              Ut = Z({
                "scripts/build/shims/assert.cjs"(e, n) {
                  "use strict";
                  ae();
                  var t = () => {};
                  (t.ok = t), (t.strictEqual = t), (n.exports = t);
                },
              }),
              Qe = Z({
                "src/main/comments.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Ut(),
                    {
                      builders: {
                        line: s,
                        hardline: i,
                        breakParent: r,
                        indent: u,
                        lineSuffix: a,
                        join: c,
                        cursor: l,
                      },
                    } = Le(),
                    {
                      hasNewline: C,
                      skipNewline: m,
                      skipSpaces: g,
                      isPreviousLineEmpty: p,
                      addLeadingComment: f,
                      addDanglingComment: h,
                      addTrailingComment: N,
                    } = Ge(),
                    T = new WeakMap();
                  function A(O, R, M) {
                    if (!O) return;
                    let { printer: H, locStart: P, locEnd: G } = R;
                    if (M) {
                      if (H.canAttachComment && H.canAttachComment(O)) {
                        let $;
                        for (
                          $ = M.length - 1;
                          $ >= 0 && !(P(M[$]) <= P(O) && G(M[$]) <= G(O));
                          --$
                        );
                        M.splice($ + 1, 0, O);
                        return;
                      }
                    } else if (T.has(O)) return T.get(O);
                    let re =
                      (H.getCommentChildNodes &&
                        H.getCommentChildNodes(O, R)) ||
                      (typeof O == "object" &&
                        Object.entries(O)
                          .filter(($) => {
                            let [W] = $;
                            return (
                              W !== "enclosingNode" &&
                              W !== "precedingNode" &&
                              W !== "followingNode" &&
                              W !== "tokens" &&
                              W !== "comments" &&
                              W !== "parent"
                            );
                          })
                          .map(($) => {
                            let [, W] = $;
                            return W;
                          }));
                    if (!!re) {
                      M || ((M = []), T.set(O, M));
                      for (let $ of re) A($, R, M);
                      return M;
                    }
                  }
                  function b(O, R, M, H) {
                    let { locStart: P, locEnd: G } = M,
                      re = P(R),
                      $ = G(R),
                      W = A(O, M),
                      ee,
                      U,
                      ne = 0,
                      se = W.length;
                    for (; ne < se; ) {
                      let V = (ne + se) >> 1,
                        oe = W[V],
                        K = P(oe),
                        Ee = G(oe);
                      if (K <= re && $ <= Ee) return b(oe, R, M, oe);
                      if (Ee <= re) {
                        (ee = oe), (ne = V + 1);
                        continue;
                      }
                      if ($ <= K) {
                        (U = oe), (se = V);
                        continue;
                      }
                      throw new Error(
                        "Comment location overlaps with node location"
                      );
                    }
                    if (H && H.type === "TemplateLiteral") {
                      let { quasis: V } = H,
                        oe = y(V, R, M);
                      ee && y(V, ee, M) !== oe && (ee = null),
                        U && y(V, U, M) !== oe && (U = null);
                    }
                    return {
                      enclosingNode: H,
                      precedingNode: ee,
                      followingNode: U,
                    };
                  }
                  var v = () => !1;
                  function B(O, R, M, H) {
                    if (!Array.isArray(O)) return;
                    let P = [],
                      {
                        locStart: G,
                        locEnd: re,
                        printer: { handleComments: $ = {} },
                      } = H,
                      {
                        avoidAstMutation: W,
                        ownLine: ee = v,
                        endOfLine: U = v,
                        remaining: ne = v,
                      } = $,
                      se = O.map((V, oe) =>
                        Object.assign(
                          Object.assign({}, b(R, V, H)),
                          {},
                          {
                            comment: V,
                            text: M,
                            options: H,
                            ast: R,
                            isLastComment: O.length - 1 === oe,
                          }
                        )
                      );
                    for (let [V, oe] of se.entries()) {
                      let {
                        comment: K,
                        precedingNode: Ee,
                        enclosingNode: q,
                        followingNode: le,
                        text: ue,
                        options: Q,
                        ast: de,
                        isLastComment: ge,
                      } = oe;
                      if (
                        Q.parser === "json" ||
                        Q.parser === "json5" ||
                        Q.parser === "__js_expression" ||
                        Q.parser === "__vue_expression"
                      ) {
                        if (G(K) - G(de) <= 0) {
                          f(de, K);
                          continue;
                        }
                        if (re(K) - re(de) >= 0) {
                          N(de, K);
                          continue;
                        }
                      }
                      let ve;
                      if (
                        (W
                          ? (ve = [oe])
                          : ((K.enclosingNode = q),
                            (K.precedingNode = Ee),
                            (K.followingNode = le),
                            (ve = [K, ue, Q, de, ge])),
                        I(ue, Q, se, V))
                      )
                        (K.placement = "ownLine"),
                          ee(...ve) ||
                            (le ? f(le, K) : Ee ? N(Ee, K) : h(q || de, K));
                      else if (E(ue, Q, se, V))
                        (K.placement = "endOfLine"),
                          U(...ve) ||
                            (Ee ? N(Ee, K) : le ? f(le, K) : h(q || de, K));
                      else if (((K.placement = "remaining"), !ne(...ve)))
                        if (Ee && le) {
                          let xe = P.length;
                          xe > 0 &&
                            P[xe - 1].followingNode !== le &&
                            D(P, ue, Q),
                            P.push(oe);
                        } else Ee ? N(Ee, K) : le ? f(le, K) : h(q || de, K);
                    }
                    if ((D(P, M, H), !W))
                      for (let V of O)
                        delete V.precedingNode,
                          delete V.enclosingNode,
                          delete V.followingNode;
                  }
                  var w = (O) => !/[\S\n\u2028\u2029]/.test(O);
                  function I(O, R, M, H) {
                    let { comment: P, precedingNode: G } = M[H],
                      { locStart: re, locEnd: $ } = R,
                      W = re(P);
                    if (G)
                      for (let ee = H - 1; ee >= 0; ee--) {
                        let { comment: U, precedingNode: ne } = M[ee];
                        if (ne !== G || !w(O.slice($(U), W))) break;
                        W = re(U);
                      }
                    return C(O, W, { backwards: !0 });
                  }
                  function E(O, R, M, H) {
                    let { comment: P, followingNode: G } = M[H],
                      { locStart: re, locEnd: $ } = R,
                      W = $(P);
                    if (G)
                      for (let ee = H + 1; ee < M.length; ee++) {
                        let { comment: U, followingNode: ne } = M[ee];
                        if (ne !== G || !w(O.slice(W, re(U)))) break;
                        W = $(U);
                      }
                    return C(O, W);
                  }
                  function D(O, R, M) {
                    let H = O.length;
                    if (H === 0) return;
                    let {
                        precedingNode: P,
                        followingNode: G,
                        enclosingNode: re,
                      } = O[0],
                      $ =
                        (M.printer.getGapRegex && M.printer.getGapRegex(re)) ||
                        /^[\s(]*$/,
                      W = M.locStart(G),
                      ee;
                    for (ee = H; ee > 0; --ee) {
                      let {
                        comment: U,
                        precedingNode: ne,
                        followingNode: se,
                      } = O[ee - 1];
                      t.strictEqual(ne, P), t.strictEqual(se, G);
                      let V = R.slice(M.locEnd(U), W);
                      if ($.test(V)) W = M.locStart(U);
                      else break;
                    }
                    for (let [U, { comment: ne }] of O.entries())
                      U < ee ? N(P, ne) : f(G, ne);
                    for (let U of [P, G])
                      U.comments &&
                        U.comments.length > 1 &&
                        U.comments.sort(
                          (ne, se) => M.locStart(ne) - M.locStart(se)
                        );
                    O.length = 0;
                  }
                  function d(O, R) {
                    let M = O.getValue();
                    return (M.printed = !0), R.printer.printComment(O, R);
                  }
                  function y(O, R, M) {
                    let H = M.locStart(R) - 1;
                    for (let P = 1; P < O.length; ++P)
                      if (H < M.locStart(O[P])) return P - 1;
                    return 0;
                  }
                  function o(O, R) {
                    let M = O.getValue(),
                      H = [d(O, R)],
                      {
                        printer: P,
                        originalText: G,
                        locStart: re,
                        locEnd: $,
                      } = R;
                    if (P.isBlockComment && P.isBlockComment(M)) {
                      let U = C(G, $(M))
                        ? C(G, re(M), { backwards: !0 })
                          ? i
                          : s
                        : " ";
                      H.push(U);
                    } else H.push(i);
                    let ee = m(G, g(G, $(M)));
                    return ee !== !1 && C(G, ee) && H.push(i), H;
                  }
                  function x(O, R) {
                    let M = O.getValue(),
                      H = d(O, R),
                      { printer: P, originalText: G, locStart: re } = R,
                      $ = P.isBlockComment && P.isBlockComment(M);
                    if (C(G, re(M), { backwards: !0 })) {
                      let ee = p(G, M, re);
                      return a([i, ee ? i : "", H]);
                    }
                    let W = [" ", H];
                    return $ || (W = [a(W), r]), W;
                  }
                  function F(O, R, M, H) {
                    let P = [],
                      G = O.getValue();
                    return !G ||
                      !G.comments ||
                      (O.each(() => {
                        let re = O.getValue();
                        !re.leading &&
                          !re.trailing &&
                          (!H || H(re)) &&
                          P.push(d(O, R));
                      }, "comments"),
                      P.length === 0)
                      ? ""
                      : M
                      ? c(i, P)
                      : u([i, c(i, P)]);
                  }
                  function S(O, R, M) {
                    let H = O.getValue();
                    if (!H) return {};
                    let P = H.comments || [];
                    M && (P = P.filter((W) => !M.has(W)));
                    let G = H === R.cursorNode;
                    if (P.length === 0) {
                      let W = G ? l : "";
                      return { leading: W, trailing: W };
                    }
                    let re = [],
                      $ = [];
                    return (
                      O.each(() => {
                        let W = O.getValue();
                        if (M && M.has(W)) return;
                        let { leading: ee, trailing: U } = W;
                        ee ? re.push(o(O, R)) : U && $.push(x(O, R));
                      }, "comments"),
                      G && (re.unshift(l), $.push(l)),
                      { leading: re, trailing: $ }
                    );
                  }
                  function k(O, R, M, H) {
                    let { leading: P, trailing: G } = S(O, M, H);
                    return !P && !G ? R : [P, R, G];
                  }
                  function _(O) {
                    if (!!O)
                      for (let R of O) {
                        if (!R.printed)
                          throw new Error(
                            'Comment "' +
                              R.value.trim() +
                              '" was not printed. Please report this error!'
                          );
                        delete R.printed;
                      }
                  }
                  n.exports = {
                    attach: B,
                    printComments: k,
                    printCommentsSeparately: S,
                    printDanglingComments: F,
                    getSortedChildNodes: A,
                    ensureAllCommentsPrinted: _,
                  };
                },
              }),
              um = Z({
                "src/common/ast-path.js"(e, n) {
                  "use strict";
                  ae();
                  var t = st();
                  function s(u, a) {
                    let c = i(u.stack, a);
                    return c === -1 ? null : u.stack[c];
                  }
                  function i(u, a) {
                    for (let c = u.length - 1; c >= 0; c -= 2) {
                      let l = u[c];
                      if (l && !Array.isArray(l) && --a < 0) return c;
                    }
                    return -1;
                  }
                  var r = class {
                    constructor(u) {
                      this.stack = [u];
                    }
                    getName() {
                      let { stack: u } = this,
                        { length: a } = u;
                      return a > 1 ? u[a - 2] : null;
                    }
                    getValue() {
                      return t(this.stack);
                    }
                    getNode() {
                      let u =
                        arguments.length > 0 && arguments[0] !== void 0
                          ? arguments[0]
                          : 0;
                      return s(this, u);
                    }
                    getParentNode() {
                      let u =
                        arguments.length > 0 && arguments[0] !== void 0
                          ? arguments[0]
                          : 0;
                      return s(this, u + 1);
                    }
                    call(u) {
                      let { stack: a } = this,
                        { length: c } = a,
                        l = t(a);
                      for (
                        var C = arguments.length,
                          m = new Array(C > 1 ? C - 1 : 0),
                          g = 1;
                        g < C;
                        g++
                      )
                        m[g - 1] = arguments[g];
                      for (let f of m) (l = l[f]), a.push(f, l);
                      let p = u(this);
                      return (a.length = c), p;
                    }
                    callParent(u) {
                      let a =
                          arguments.length > 1 && arguments[1] !== void 0
                            ? arguments[1]
                            : 0,
                        c = i(this.stack, a + 1),
                        l = this.stack.splice(c + 1),
                        C = u(this);
                      return this.stack.push(...l), C;
                    }
                    each(u) {
                      let { stack: a } = this,
                        { length: c } = a,
                        l = t(a);
                      for (
                        var C = arguments.length,
                          m = new Array(C > 1 ? C - 1 : 0),
                          g = 1;
                        g < C;
                        g++
                      )
                        m[g - 1] = arguments[g];
                      for (let p of m) (l = l[p]), a.push(p, l);
                      for (let p = 0; p < l.length; ++p)
                        a.push(p, l[p]), u(this, p, l), (a.length -= 2);
                      a.length = c;
                    }
                    map(u) {
                      let a = [];
                      for (
                        var c = arguments.length,
                          l = new Array(c > 1 ? c - 1 : 0),
                          C = 1;
                        C < c;
                        C++
                      )
                        l[C - 1] = arguments[C];
                      return (
                        this.each((m, g, p) => {
                          a[g] = u(m, g, p);
                        }, ...l),
                        a
                      );
                    }
                    try(u) {
                      let { stack: a } = this,
                        c = [...a];
                      try {
                        return u();
                      } finally {
                        (a.length = 0), a.push(...c);
                      }
                    }
                    match() {
                      let u = this.stack.length - 1,
                        a = null,
                        c = this.stack[u--];
                      for (
                        var l = arguments.length, C = new Array(l), m = 0;
                        m < l;
                        m++
                      )
                        C[m] = arguments[m];
                      for (let g of C) {
                        if (c === void 0) return !1;
                        let p = null;
                        if (
                          (typeof a == "number" &&
                            ((p = a),
                            (a = this.stack[u--]),
                            (c = this.stack[u--])),
                          g && !g(c, a, p))
                        )
                          return !1;
                        (a = this.stack[u--]), (c = this.stack[u--]);
                      }
                      return !0;
                    }
                    findAncestor(u) {
                      let a = this.stack.length - 1,
                        c = null,
                        l = this.stack[a--];
                      for (; l; ) {
                        let C = null;
                        if (
                          (typeof c == "number" &&
                            ((C = c),
                            (c = this.stack[a--]),
                            (l = this.stack[a--])),
                          c !== null && u(l, c, C))
                        )
                          return l;
                        (c = this.stack[a--]), (l = this.stack[a--]);
                      }
                    }
                  };
                  n.exports = r;
                },
              }),
              sm = Z({
                "src/main/multiparser.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      utils: { stripTrailingHardline: t },
                    } = Le(),
                    { normalize: s } = Mi(),
                    i = Qe();
                  function r(a, c, l, C) {
                    if (
                      l.printer.embed &&
                      l.embeddedLanguageFormatting === "auto"
                    )
                      return l.printer.embed(
                        a,
                        c,
                        (m, g, p) => u(m, g, l, C, p),
                        l
                      );
                  }
                  function u(a, c, l, C) {
                    let { stripTrailingHardline: m = !1 } =
                        arguments.length > 4 && arguments[4] !== void 0
                          ? arguments[4]
                          : {},
                      g = s(
                        Object.assign(
                          Object.assign(Object.assign({}, l), c),
                          {},
                          { parentParser: l.parser, originalText: a }
                        ),
                        { passThrough: !0 }
                      ),
                      p = Gn().parse(a, g),
                      { ast: f } = p;
                    a = p.text;
                    let h = f.comments;
                    delete f.comments,
                      i.attach(h, f, a, g),
                      (g[Symbol.for("comments")] = h || []),
                      (g[Symbol.for("tokens")] = f.tokens || []);
                    let N = C(f, g);
                    return (
                      i.ensureAllCommentsPrinted(h),
                      m
                        ? typeof N == "string"
                          ? N.replace(/(?:\r?\n)*$/, "")
                          : t(N)
                        : N
                    );
                  }
                  n.exports = { printSubtree: r };
                },
              }),
              am = Z({
                "src/main/ast-to-doc.js"(e, n) {
                  "use strict";
                  ae();
                  var t = um(),
                    {
                      builders: { hardline: s, addAlignmentToDoc: i },
                      utils: { propagateBreaks: r },
                    } = Le(),
                    { printComments: u } = Qe(),
                    a = sm();
                  function c(m, g) {
                    let p =
                        arguments.length > 2 && arguments[2] !== void 0
                          ? arguments[2]
                          : 0,
                      { printer: f } = g;
                    f.preprocess && (m = f.preprocess(m, g));
                    let h = new Map(),
                      N = new t(m),
                      T = A();
                    return p > 0 && (T = i([s, T], p, g.tabWidth)), r(T), T;
                    function A(v, B) {
                      return v === void 0 || v === N
                        ? b(B)
                        : Array.isArray(v)
                        ? N.call(() => b(B), ...v)
                        : N.call(() => b(B), v);
                    }
                    function b(v) {
                      let B = N.getValue(),
                        w = B && typeof B == "object" && v === void 0;
                      if (w && h.has(B)) return h.get(B);
                      let I = C(N, g, A, v);
                      return w && h.set(B, I), I;
                    }
                  }
                  function l(m, g) {
                    let {
                        originalText: p,
                        [Symbol.for("comments")]: f,
                        locStart: h,
                        locEnd: N,
                      } = g,
                      T = h(m),
                      A = N(m),
                      b = new Set();
                    for (let v of f)
                      h(v) >= T && N(v) <= A && ((v.printed = !0), b.add(v));
                    return { doc: p.slice(T, A), printedComments: b };
                  }
                  function C(m, g, p, f) {
                    let h = m.getValue(),
                      { printer: N } = g,
                      T,
                      A;
                    if (N.hasPrettierIgnore && N.hasPrettierIgnore(m))
                      ({ doc: T, printedComments: A } = l(h, g));
                    else {
                      if (h)
                        try {
                          T = a.printSubtree(m, p, g, c);
                        } catch (b) {
                          if (globalThis.PRETTIER_DEBUG) throw b;
                        }
                      T || (T = N.print(m, g, p, f));
                    }
                    return (
                      (!N.willPrintOwnComments ||
                        !N.willPrintOwnComments(m, g)) &&
                        (T = u(m, T, g, A)),
                      T
                    );
                  }
                  n.exports = c;
                },
              }),
              im = Z({
                "src/main/range-util.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Ut(),
                    s = Qe(),
                    i = (f) => {
                      let { parser: h } = f;
                      return (
                        h === "json" || h === "json5" || h === "json-stringify"
                      );
                    };
                  function r(f, h) {
                    let N = [f.node, ...f.parentNodes],
                      T = new Set([h.node, ...h.parentNodes]);
                    return N.find((A) => C.has(A.type) && T.has(A));
                  }
                  function u(f) {
                    let h = f.length - 1;
                    for (;;) {
                      let N = f[h];
                      if (N && (N.type === "Program" || N.type === "File")) h--;
                      else break;
                    }
                    return f.slice(0, h + 1);
                  }
                  function a(f, h, N) {
                    let { locStart: T, locEnd: A } = N,
                      b = f.node,
                      v = h.node;
                    if (b === v) return { startNode: b, endNode: v };
                    let B = T(f.node);
                    for (let I of u(h.parentNodes))
                      if (T(I) >= B) v = I;
                      else break;
                    let w = A(h.node);
                    for (let I of u(f.parentNodes))
                      if (A(I) <= w) b = I;
                      else break;
                    return { startNode: b, endNode: v };
                  }
                  function c(f, h, N, T) {
                    let A =
                        arguments.length > 4 && arguments[4] !== void 0
                          ? arguments[4]
                          : [],
                      b = arguments.length > 5 ? arguments[5] : void 0,
                      { locStart: v, locEnd: B } = N,
                      w = v(f),
                      I = B(f);
                    if (
                      !(
                        h > I ||
                        h < w ||
                        (b === "rangeEnd" && h === w) ||
                        (b === "rangeStart" && h === I)
                      )
                    ) {
                      for (let E of s.getSortedChildNodes(f, N)) {
                        let D = c(E, h, N, T, [f, ...A], b);
                        if (D) return D;
                      }
                      if (!T || T(f, A[0])) return { node: f, parentNodes: A };
                    }
                  }
                  function l(f, h) {
                    return (
                      h !== "DeclareExportDeclaration" &&
                      f !== "TypeParameterDeclaration" &&
                      (f === "Directive" ||
                        f === "TypeAlias" ||
                        f === "TSExportAssignment" ||
                        f.startsWith("Declare") ||
                        f.startsWith("TSDeclare") ||
                        f.endsWith("Statement") ||
                        f.endsWith("Declaration"))
                    );
                  }
                  var C = new Set([
                      "ObjectExpression",
                      "ArrayExpression",
                      "StringLiteral",
                      "NumericLiteral",
                      "BooleanLiteral",
                      "NullLiteral",
                      "UnaryExpression",
                      "TemplateLiteral",
                    ]),
                    m = new Set([
                      "OperationDefinition",
                      "FragmentDefinition",
                      "VariableDefinition",
                      "TypeExtensionDefinition",
                      "ObjectTypeDefinition",
                      "FieldDefinition",
                      "DirectiveDefinition",
                      "EnumTypeDefinition",
                      "EnumValueDefinition",
                      "InputValueDefinition",
                      "InputObjectTypeDefinition",
                      "SchemaDefinition",
                      "OperationTypeDefinition",
                      "InterfaceTypeDefinition",
                      "UnionTypeDefinition",
                      "ScalarTypeDefinition",
                    ]);
                  function g(f, h, N) {
                    if (!h) return !1;
                    switch (f.parser) {
                      case "flow":
                      case "babel":
                      case "babel-flow":
                      case "babel-ts":
                      case "typescript":
                      case "acorn":
                      case "espree":
                      case "meriyah":
                      case "__babel_estree":
                        return l(h.type, N && N.type);
                      case "json":
                      case "json5":
                      case "json-stringify":
                        return C.has(h.type);
                      case "graphql":
                        return m.has(h.kind);
                      case "vue":
                        return h.tag !== "root";
                    }
                    return !1;
                  }
                  function p(f, h, N) {
                    let {
                      rangeStart: T,
                      rangeEnd: A,
                      locStart: b,
                      locEnd: v,
                    } = h;
                    t.ok(A > T);
                    let B = f.slice(T, A).search(/\S/),
                      w = B === -1;
                    if (!w) for (T += B; A > T && !/\S/.test(f[A - 1]); --A);
                    let I = c(N, T, h, (y, o) => g(h, y, o), [], "rangeStart"),
                      E = w ? I : c(N, A, h, (y) => g(h, y), [], "rangeEnd");
                    if (!I || !E) return { rangeStart: 0, rangeEnd: 0 };
                    let D, d;
                    if (i(h)) {
                      let y = r(I, E);
                      (D = y), (d = y);
                    } else ({ startNode: D, endNode: d } = a(I, E, h));
                    return {
                      rangeStart: Math.min(b(D), b(d)),
                      rangeEnd: Math.max(v(D), v(d)),
                    };
                  }
                  n.exports = { calculateRange: p, findNodeAtOffset: c };
                },
              }),
              om = Z({
                "src/main/core.js"(e, n) {
                  "use strict";
                  ae();
                  var { diffArrays: t } = rD(),
                    {
                      printer: { printDocToString: s },
                      debug: { printDocToDebug: i },
                    } = Le(),
                    { getAlignmentSize: r } = Ge(),
                    {
                      guessEndOfLine: u,
                      convertEndOfLineToChars: a,
                      countEndOfLineChars: c,
                      normalizeEndOfLine: l,
                    } = On(),
                    C = Mi().normalize,
                    m = nm(),
                    g = Qe(),
                    p = Gn(),
                    f = am(),
                    h = im(),
                    N = "\uFEFF",
                    T = Symbol("cursor");
                  function A(d, y, o) {
                    let x = y.comments;
                    return (
                      x && (delete y.comments, g.attach(x, y, d, o)),
                      (o[Symbol.for("comments")] = x || []),
                      (o[Symbol.for("tokens")] = y.tokens || []),
                      (o.originalText = d),
                      x
                    );
                  }
                  function b(d, y) {
                    let o =
                      arguments.length > 2 && arguments[2] !== void 0
                        ? arguments[2]
                        : 0;
                    if (!d || d.trim().length === 0)
                      return { formatted: "", cursorOffset: -1, comments: [] };
                    let { ast: x, text: F } = p.parse(d, y);
                    if (y.cursorOffset >= 0) {
                      let O = h.findNodeAtOffset(x, y.cursorOffset, y);
                      O && O.node && (y.cursorNode = O.node);
                    }
                    let S = A(F, x, y),
                      k = f(x, y, o),
                      _ = s(k, y);
                    if ((g.ensureAllCommentsPrinted(S), o > 0)) {
                      let O = _.formatted.trim();
                      _.cursorNodeStart !== void 0 &&
                        (_.cursorNodeStart -= _.formatted.indexOf(O)),
                        (_.formatted = O + a(y.endOfLine));
                    }
                    if (y.cursorOffset >= 0) {
                      let O, R, M, H, P;
                      if (
                        (y.cursorNode && _.cursorNodeText
                          ? ((O = y.locStart(y.cursorNode)),
                            (R = F.slice(O, y.locEnd(y.cursorNode))),
                            (M = y.cursorOffset - O),
                            (H = _.cursorNodeStart),
                            (P = _.cursorNodeText))
                          : ((O = 0),
                            (R = F),
                            (M = y.cursorOffset),
                            (H = 0),
                            (P = _.formatted)),
                        R === P)
                      )
                        return {
                          formatted: _.formatted,
                          cursorOffset: H + M,
                          comments: S,
                        };
                      let G = [...R];
                      G.splice(M, 0, T);
                      let re = [...P],
                        $ = t(G, re),
                        W = H;
                      for (let ee of $)
                        if (ee.removed) {
                          if (ee.value.includes(T)) break;
                        } else W += ee.count;
                      return {
                        formatted: _.formatted,
                        cursorOffset: W,
                        comments: S,
                      };
                    }
                    return {
                      formatted: _.formatted,
                      cursorOffset: -1,
                      comments: S,
                    };
                  }
                  function v(d, y) {
                    let { ast: o, text: x } = p.parse(d, y),
                      { rangeStart: F, rangeEnd: S } = h.calculateRange(
                        x,
                        y,
                        o
                      ),
                      k = x.slice(F, S),
                      _ = Math.min(
                        F,
                        x.lastIndexOf(
                          `
`,
                          F
                        ) + 1
                      ),
                      O = x.slice(_, F).match(/^\s*/)[0],
                      R = r(O, y.tabWidth),
                      M = b(
                        k,
                        Object.assign(
                          Object.assign({}, y),
                          {},
                          {
                            rangeStart: 0,
                            rangeEnd: Number.POSITIVE_INFINITY,
                            cursorOffset:
                              y.cursorOffset > F && y.cursorOffset <= S
                                ? y.cursorOffset - F
                                : -1,
                            endOfLine: "lf",
                          }
                        ),
                        R
                      ),
                      H = M.formatted.trimEnd(),
                      { cursorOffset: P } = y;
                    P > S
                      ? (P += H.length - k.length)
                      : M.cursorOffset >= 0 && (P = M.cursorOffset + F);
                    let G = x.slice(0, F) + H + x.slice(S);
                    if (y.endOfLine !== "lf") {
                      let re = a(y.endOfLine);
                      P >= 0 &&
                        re ===
                          `\r
` &&
                        (P += c(
                          G.slice(0, P),
                          `
`
                        )),
                        (G = G.replace(/\n/g, re));
                    }
                    return {
                      formatted: G,
                      cursorOffset: P,
                      comments: M.comments,
                    };
                  }
                  function B(d, y, o) {
                    return typeof y != "number" ||
                      Number.isNaN(y) ||
                      y < 0 ||
                      y > d.length
                      ? o
                      : y;
                  }
                  function w(d, y) {
                    let { cursorOffset: o, rangeStart: x, rangeEnd: F } = y;
                    return (
                      (o = B(d, o, -1)),
                      (x = B(d, x, 0)),
                      (F = B(d, F, d.length)),
                      Object.assign(
                        Object.assign({}, y),
                        {},
                        { cursorOffset: o, rangeStart: x, rangeEnd: F }
                      )
                    );
                  }
                  function I(d, y) {
                    let {
                        cursorOffset: o,
                        rangeStart: x,
                        rangeEnd: F,
                        endOfLine: S,
                      } = w(d, y),
                      k = d.charAt(0) === N;
                    if (
                      (k && ((d = d.slice(1)), o--, x--, F--),
                      S === "auto" && (S = u(d)),
                      d.includes("\r"))
                    ) {
                      let _ = (O) =>
                        c(
                          d.slice(0, Math.max(O, 0)),
                          `\r
`
                        );
                      (o -= _(o)), (x -= _(x)), (F -= _(F)), (d = l(d));
                    }
                    return {
                      hasBOM: k,
                      text: d,
                      options: w(
                        d,
                        Object.assign(
                          Object.assign({}, y),
                          {},
                          {
                            cursorOffset: o,
                            rangeStart: x,
                            rangeEnd: F,
                            endOfLine: S,
                          }
                        )
                      ),
                    };
                  }
                  function E(d, y) {
                    let o = p.resolveParser(y);
                    return !o.hasPragma || o.hasPragma(d);
                  }
                  function D(d, y) {
                    let { hasBOM: o, text: x, options: F } = I(d, C(y));
                    if (
                      (F.rangeStart >= F.rangeEnd && x !== "") ||
                      (F.requirePragma && !E(x, F))
                    )
                      return {
                        formatted: d,
                        cursorOffset: y.cursorOffset,
                        comments: [],
                      };
                    let S;
                    return (
                      F.rangeStart > 0 || F.rangeEnd < x.length
                        ? (S = v(x, F))
                        : (!F.requirePragma &&
                            F.insertPragma &&
                            F.printer.insertPragma &&
                            !E(x, F) &&
                            (x = F.printer.insertPragma(x)),
                          (S = b(x, F))),
                      o &&
                        ((S.formatted = N + S.formatted),
                        S.cursorOffset >= 0 && S.cursorOffset++),
                      S
                    );
                  }
                  n.exports = {
                    formatWithCursor: D,
                    parse(d, y, o) {
                      let { text: x, options: F } = I(d, C(y)),
                        S = p.parse(x, F);
                      return o && (S.ast = m(S.ast, F)), S;
                    },
                    formatAST(d, y) {
                      y = C(y);
                      let o = f(d, y);
                      return s(o, y);
                    },
                    formatDoc(d, y) {
                      return D(
                        i(d),
                        Object.assign(
                          Object.assign({}, y),
                          {},
                          { parser: "__js_expression" }
                        )
                      ).formatted;
                    },
                    printToDoc(d, y) {
                      y = C(y);
                      let { ast: o, text: x } = p.parse(d, y);
                      return A(x, o, y), f(o, y);
                    },
                    printDocToString(d, y) {
                      return s(d, C(y));
                    },
                  };
                },
              }),
              cm = Z({
                "src/common/util-shared.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                    getMaxContinuousCount: t,
                    getStringWidth: s,
                    getAlignmentSize: i,
                    getIndentSize: r,
                    skip: u,
                    skipWhitespace: a,
                    skipSpaces: c,
                    skipNewline: l,
                    skipToLineEnd: C,
                    skipEverythingButNewLine: m,
                    skipInlineComment: g,
                    skipTrailingComment: p,
                    hasNewline: f,
                    hasNewlineInRange: h,
                    hasSpaces: N,
                    isNextLineEmpty: T,
                    isNextLineEmptyAfterIndex: A,
                    isPreviousLineEmpty: b,
                    getNextNonSpaceNonCommentCharacterIndex: v,
                    makeString: B,
                    addLeadingComment: w,
                    addDanglingComment: I,
                    addTrailingComment: E,
                  } = Ge();
                  n.exports = {
                    getMaxContinuousCount: t,
                    getStringWidth: s,
                    getAlignmentSize: i,
                    getIndentSize: r,
                    skip: u,
                    skipWhitespace: a,
                    skipSpaces: c,
                    skipNewline: l,
                    skipToLineEnd: C,
                    skipEverythingButNewLine: m,
                    skipInlineComment: g,
                    skipTrailingComment: p,
                    hasNewline: f,
                    hasNewlineInRange: h,
                    hasSpaces: N,
                    isNextLineEmpty: T,
                    isNextLineEmptyAfterIndex: A,
                    isPreviousLineEmpty: b,
                    getNextNonSpaceNonCommentCharacterIndex: v,
                    makeString: B,
                    addLeadingComment: w,
                    addDanglingComment: I,
                    addTrailingComment: E,
                  };
                },
              }),
              bt = Z({
                "src/utils/create-language.js"(e, n) {
                  "use strict";
                  ae(),
                    (n.exports = function (t, s) {
                      let { languageId: i } = t,
                        r = _n(t, Kf);
                      return Object.assign(
                        Object.assign({ linguistLanguageId: i }, r),
                        s(t)
                      );
                    });
                },
              }),
              lm = Z({
                "node_modules/esutils/lib/ast.js"(e, n) {
                  ae(),
                    (function () {
                      "use strict";
                      function t(c) {
                        if (c == null) return !1;
                        switch (c.type) {
                          case "ArrayExpression":
                          case "AssignmentExpression":
                          case "BinaryExpression":
                          case "CallExpression":
                          case "ConditionalExpression":
                          case "FunctionExpression":
                          case "Identifier":
                          case "Literal":
                          case "LogicalExpression":
                          case "MemberExpression":
                          case "NewExpression":
                          case "ObjectExpression":
                          case "SequenceExpression":
                          case "ThisExpression":
                          case "UnaryExpression":
                          case "UpdateExpression":
                            return !0;
                        }
                        return !1;
                      }
                      function s(c) {
                        if (c == null) return !1;
                        switch (c.type) {
                          case "DoWhileStatement":
                          case "ForInStatement":
                          case "ForStatement":
                          case "WhileStatement":
                            return !0;
                        }
                        return !1;
                      }
                      function i(c) {
                        if (c == null) return !1;
                        switch (c.type) {
                          case "BlockStatement":
                          case "BreakStatement":
                          case "ContinueStatement":
                          case "DebuggerStatement":
                          case "DoWhileStatement":
                          case "EmptyStatement":
                          case "ExpressionStatement":
                          case "ForInStatement":
                          case "ForStatement":
                          case "IfStatement":
                          case "LabeledStatement":
                          case "ReturnStatement":
                          case "SwitchStatement":
                          case "ThrowStatement":
                          case "TryStatement":
                          case "VariableDeclaration":
                          case "WhileStatement":
                          case "WithStatement":
                            return !0;
                        }
                        return !1;
                      }
                      function r(c) {
                        return (
                          i(c) ||
                          (c != null && c.type === "FunctionDeclaration")
                        );
                      }
                      function u(c) {
                        switch (c.type) {
                          case "IfStatement":
                            return c.alternate != null
                              ? c.alternate
                              : c.consequent;
                          case "LabeledStatement":
                          case "ForStatement":
                          case "ForInStatement":
                          case "WhileStatement":
                          case "WithStatement":
                            return c.body;
                        }
                        return null;
                      }
                      function a(c) {
                        var l;
                        if (c.type !== "IfStatement" || c.alternate == null)
                          return !1;
                        l = c.consequent;
                        do {
                          if (l.type === "IfStatement" && l.alternate == null)
                            return !0;
                          l = u(l);
                        } while (l);
                        return !1;
                      }
                      n.exports = {
                        isExpression: t,
                        isStatement: i,
                        isIterationStatement: s,
                        isSourceElement: r,
                        isProblematicIfStatement: a,
                        trailingStatement: u,
                      };
                    })();
                },
              }),
              Ri = Z({
                "node_modules/esutils/lib/code.js"(e, n) {
                  ae(),
                    (function () {
                      "use strict";
                      var t, s, i, r, u, a;
                      (s = {
                        NonAsciiIdentifierStart:
                          /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
                        NonAsciiIdentifierPart:
                          /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
                      }),
                        (t = {
                          NonAsciiIdentifierStart:
                            /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
                          NonAsciiIdentifierPart:
                            /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
                        });
                      function c(A) {
                        return 48 <= A && A <= 57;
                      }
                      function l(A) {
                        return (
                          (48 <= A && A <= 57) ||
                          (97 <= A && A <= 102) ||
                          (65 <= A && A <= 70)
                        );
                      }
                      function C(A) {
                        return A >= 48 && A <= 55;
                      }
                      i = [
                        5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199,
                        8200, 8201, 8202, 8239, 8287, 12288, 65279,
                      ];
                      function m(A) {
                        return (
                          A === 32 ||
                          A === 9 ||
                          A === 11 ||
                          A === 12 ||
                          A === 160 ||
                          (A >= 5760 && i.indexOf(A) >= 0)
                        );
                      }
                      function g(A) {
                        return A === 10 || A === 13 || A === 8232 || A === 8233;
                      }
                      function p(A) {
                        if (A <= 65535) return String.fromCharCode(A);
                        var b = String.fromCharCode(
                            Math.floor((A - 65536) / 1024) + 55296
                          ),
                          v = String.fromCharCode(((A - 65536) % 1024) + 56320);
                        return b + v;
                      }
                      for (r = new Array(128), a = 0; a < 128; ++a)
                        r[a] =
                          (a >= 97 && a <= 122) ||
                          (a >= 65 && a <= 90) ||
                          a === 36 ||
                          a === 95;
                      for (u = new Array(128), a = 0; a < 128; ++a)
                        u[a] =
                          (a >= 97 && a <= 122) ||
                          (a >= 65 && a <= 90) ||
                          (a >= 48 && a <= 57) ||
                          a === 36 ||
                          a === 95;
                      function f(A) {
                        return A < 128
                          ? r[A]
                          : s.NonAsciiIdentifierStart.test(p(A));
                      }
                      function h(A) {
                        return A < 128
                          ? u[A]
                          : s.NonAsciiIdentifierPart.test(p(A));
                      }
                      function N(A) {
                        return A < 128
                          ? r[A]
                          : t.NonAsciiIdentifierStart.test(p(A));
                      }
                      function T(A) {
                        return A < 128
                          ? u[A]
                          : t.NonAsciiIdentifierPart.test(p(A));
                      }
                      n.exports = {
                        isDecimalDigit: c,
                        isHexDigit: l,
                        isOctalDigit: C,
                        isWhiteSpace: m,
                        isLineTerminator: g,
                        isIdentifierStartES5: f,
                        isIdentifierPartES5: h,
                        isIdentifierStartES6: N,
                        isIdentifierPartES6: T,
                      };
                    })();
                },
              }),
              pm = Z({
                "node_modules/esutils/lib/keyword.js"(e, n) {
                  ae(),
                    (function () {
                      "use strict";
                      var t = Ri();
                      function s(f) {
                        switch (f) {
                          case "implements":
                          case "interface":
                          case "package":
                          case "private":
                          case "protected":
                          case "public":
                          case "static":
                          case "let":
                            return !0;
                          default:
                            return !1;
                        }
                      }
                      function i(f, h) {
                        return !h && f === "yield" ? !1 : r(f, h);
                      }
                      function r(f, h) {
                        if (h && s(f)) return !0;
                        switch (f.length) {
                          case 2:
                            return f === "if" || f === "in" || f === "do";
                          case 3:
                            return (
                              f === "var" ||
                              f === "for" ||
                              f === "new" ||
                              f === "try"
                            );
                          case 4:
                            return (
                              f === "this" ||
                              f === "else" ||
                              f === "case" ||
                              f === "void" ||
                              f === "with" ||
                              f === "enum"
                            );
                          case 5:
                            return (
                              f === "while" ||
                              f === "break" ||
                              f === "catch" ||
                              f === "throw" ||
                              f === "const" ||
                              f === "yield" ||
                              f === "class" ||
                              f === "super"
                            );
                          case 6:
                            return (
                              f === "return" ||
                              f === "typeof" ||
                              f === "delete" ||
                              f === "switch" ||
                              f === "export" ||
                              f === "import"
                            );
                          case 7:
                            return (
                              f === "default" ||
                              f === "finally" ||
                              f === "extends"
                            );
                          case 8:
                            return (
                              f === "function" ||
                              f === "continue" ||
                              f === "debugger"
                            );
                          case 10:
                            return f === "instanceof";
                          default:
                            return !1;
                        }
                      }
                      function u(f, h) {
                        return (
                          f === "null" ||
                          f === "true" ||
                          f === "false" ||
                          i(f, h)
                        );
                      }
                      function a(f, h) {
                        return (
                          f === "null" ||
                          f === "true" ||
                          f === "false" ||
                          r(f, h)
                        );
                      }
                      function c(f) {
                        return f === "eval" || f === "arguments";
                      }
                      function l(f) {
                        var h, N, T;
                        if (
                          f.length === 0 ||
                          ((T = f.charCodeAt(0)), !t.isIdentifierStartES5(T))
                        )
                          return !1;
                        for (h = 1, N = f.length; h < N; ++h)
                          if (
                            ((T = f.charCodeAt(h)), !t.isIdentifierPartES5(T))
                          )
                            return !1;
                        return !0;
                      }
                      function C(f, h) {
                        return (f - 55296) * 1024 + (h - 56320) + 65536;
                      }
                      function m(f) {
                        var h, N, T, A, b;
                        if (f.length === 0) return !1;
                        for (
                          b = t.isIdentifierStartES6, h = 0, N = f.length;
                          h < N;
                          ++h
                        ) {
                          if (
                            ((T = f.charCodeAt(h)), 55296 <= T && T <= 56319)
                          ) {
                            if (
                              (++h,
                              h >= N ||
                                ((A = f.charCodeAt(h)),
                                !(56320 <= A && A <= 57343)))
                            )
                              return !1;
                            T = C(T, A);
                          }
                          if (!b(T)) return !1;
                          b = t.isIdentifierPartES6;
                        }
                        return !0;
                      }
                      function g(f, h) {
                        return l(f) && !u(f, h);
                      }
                      function p(f, h) {
                        return m(f) && !a(f, h);
                      }
                      n.exports = {
                        isKeywordES5: i,
                        isKeywordES6: r,
                        isReservedWordES5: u,
                        isReservedWordES6: a,
                        isRestrictedWord: c,
                        isIdentifierNameES5: l,
                        isIdentifierNameES6: m,
                        isIdentifierES5: g,
                        isIdentifierES6: p,
                      };
                    })();
                },
              }),
              fm = Z({
                "node_modules/esutils/lib/utils.js"(e) {
                  ae(),
                    (function () {
                      "use strict";
                      (e.ast = lm()), (e.code = Ri()), (e.keyword = pm());
                    })();
                },
              }),
              Pt = Z({
                "src/language-js/utils/is-block-comment.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s) {
                    return (
                      s.type === "Block" ||
                      s.type === "CommentBlock" ||
                      s.type === "MultiLine"
                    );
                  }
                  n.exports = t;
                },
              }),
              Xe = Z({
                "src/language-js/utils/index.js"(e, n) {
                  "use strict";
                  ae();
                  var t = fm().keyword.isIdentifierNameES5,
                    {
                      getLast: s,
                      hasNewline: i,
                      skipWhitespace: r,
                      isNonEmptyArray: u,
                      isNextLineEmptyAfterIndex: a,
                      getStringWidth: c,
                    } = Ge(),
                    { locStart: l, locEnd: C, hasSameLocStart: m } = nt(),
                    g = Pt(),
                    p = "(?:(?=.)\\s)",
                    f = new RegExp("^".concat(p, "*:")),
                    h = new RegExp("^".concat(p, "*::"));
                  function N(L) {
                    return (
                      L.extra &&
                      L.extra.parenthesized &&
                      u(L.trailingComments) &&
                      g(L.trailingComments[0]) &&
                      f.test(L.trailingComments[0].value)
                    );
                  }
                  function T(L) {
                    return u(L) && g(L[0]) && h.test(L[0].value);
                  }
                  function A(L, De) {
                    if (!L || typeof L != "object") return !1;
                    if (Array.isArray(L)) return L.some((We) => A(We, De));
                    let ke = De(L);
                    return typeof ke == "boolean"
                      ? ke
                      : Object.values(L).some((We) => A(We, De));
                  }
                  function b(L) {
                    return (
                      L.type === "AssignmentExpression" ||
                      L.type === "BinaryExpression" ||
                      L.type === "LogicalExpression" ||
                      L.type === "NGPipeExpression" ||
                      L.type === "ConditionalExpression" ||
                      Ee(L) ||
                      q(L) ||
                      L.type === "SequenceExpression" ||
                      L.type === "TaggedTemplateExpression" ||
                      L.type === "BindExpression" ||
                      (L.type === "UpdateExpression" && !L.prefix) ||
                      L.type === "TSAsExpression" ||
                      L.type === "TSNonNullExpression"
                    );
                  }
                  function v(L) {
                    return L.expressions
                      ? L.expressions[0]
                      : L.left ||
                          L.test ||
                          L.callee ||
                          L.object ||
                          L.tag ||
                          L.argument ||
                          L.expression;
                  }
                  function B(L, De) {
                    if (De.expressions) return ["expressions", 0];
                    if (De.left) return ["left"];
                    if (De.test) return ["test"];
                    if (De.object) return ["object"];
                    if (De.callee) return ["callee"];
                    if (De.tag) return ["tag"];
                    if (De.argument) return ["argument"];
                    if (De.expression) return ["expression"];
                    throw new Error("Unexpected node has no left side.");
                  }
                  function w(L) {
                    return (
                      L.type === "Line" ||
                      L.type === "CommentLine" ||
                      L.type === "SingleLine" ||
                      L.type === "HashbangComment" ||
                      L.type === "HTMLOpen" ||
                      L.type === "HTMLClose"
                    );
                  }
                  var I = new Set([
                    "ExportDefaultDeclaration",
                    "ExportDefaultSpecifier",
                    "DeclareExportDeclaration",
                    "ExportNamedDeclaration",
                    "ExportAllDeclaration",
                  ]);
                  function E(L) {
                    return L && I.has(L.type);
                  }
                  function D(L) {
                    let De = L.getParentNode();
                    return L.getName() === "declaration" && E(De) ? De : null;
                  }
                  function d(L) {
                    return (
                      L.type === "BooleanLiteral" ||
                      L.type === "DirectiveLiteral" ||
                      L.type === "Literal" ||
                      L.type === "NullLiteral" ||
                      L.type === "NumericLiteral" ||
                      L.type === "BigIntLiteral" ||
                      L.type === "DecimalLiteral" ||
                      L.type === "RegExpLiteral" ||
                      L.type === "StringLiteral" ||
                      L.type === "TemplateLiteral" ||
                      L.type === "TSTypeLiteral" ||
                      L.type === "JSXText"
                    );
                  }
                  function y(L) {
                    return (
                      L.type === "NumericLiteral" ||
                      (L.type === "Literal" && typeof L.value == "number")
                    );
                  }
                  function o(L) {
                    return (
                      L.type === "UnaryExpression" &&
                      (L.operator === "+" || L.operator === "-") &&
                      y(L.argument)
                    );
                  }
                  function x(L) {
                    return (
                      L.type === "StringLiteral" ||
                      (L.type === "Literal" && typeof L.value == "string")
                    );
                  }
                  function F(L) {
                    return (
                      L.type === "ObjectTypeAnnotation" ||
                      L.type === "TSTypeLiteral" ||
                      L.type === "TSMappedType"
                    );
                  }
                  function S(L) {
                    return (
                      L.type === "FunctionExpression" ||
                      L.type === "ArrowFunctionExpression"
                    );
                  }
                  function k(L) {
                    return (
                      L.type === "FunctionExpression" ||
                      (L.type === "ArrowFunctionExpression" &&
                        L.body.type === "BlockStatement")
                    );
                  }
                  function _(L) {
                    return L.type === "TemplateLiteral";
                  }
                  function O(L) {
                    return (
                      Ee(L) &&
                      L.callee.type === "Identifier" &&
                      ["async", "inject", "fakeAsync", "waitForAsync"].includes(
                        L.callee.name
                      )
                    );
                  }
                  function R(L) {
                    return L.type === "JSXElement" || L.type === "JSXFragment";
                  }
                  function M(L, De) {
                    if (
                      L.parentParser !== "markdown" &&
                      L.parentParser !== "mdx"
                    )
                      return !1;
                    let ke = De.getNode();
                    if (!ke.expression || !R(ke.expression)) return !1;
                    let We = De.getParentNode();
                    return We.type === "Program" && We.body.length === 1;
                  }
                  function H(L) {
                    return L.kind === "get" || L.kind === "set";
                  }
                  function P(L) {
                    return H(L) || m(L, L.value);
                  }
                  function G(L) {
                    return (
                      (L.type === "ObjectTypeProperty" ||
                        L.type === "ObjectTypeInternalSlot") &&
                      L.value.type === "FunctionTypeAnnotation" &&
                      !L.static &&
                      !P(L)
                    );
                  }
                  function re(L) {
                    return (
                      (L.type === "TypeAnnotation" ||
                        L.type === "TSTypeAnnotation") &&
                      L.typeAnnotation.type === "FunctionTypeAnnotation" &&
                      !L.static &&
                      !m(L, L.typeAnnotation)
                    );
                  }
                  var $ = new Set([
                    "BinaryExpression",
                    "LogicalExpression",
                    "NGPipeExpression",
                  ]);
                  function W(L) {
                    return $.has(L.type);
                  }
                  function ee(L) {
                    return (
                      q(L) || (L.type === "BindExpression" && Boolean(L.object))
                    );
                  }
                  var U = new Set([
                    "AnyTypeAnnotation",
                    "TSAnyKeyword",
                    "NullLiteralTypeAnnotation",
                    "TSNullKeyword",
                    "ThisTypeAnnotation",
                    "TSThisType",
                    "NumberTypeAnnotation",
                    "TSNumberKeyword",
                    "VoidTypeAnnotation",
                    "TSVoidKeyword",
                    "BooleanTypeAnnotation",
                    "TSBooleanKeyword",
                    "BigIntTypeAnnotation",
                    "TSBigIntKeyword",
                    "SymbolTypeAnnotation",
                    "TSSymbolKeyword",
                    "StringTypeAnnotation",
                    "TSStringKeyword",
                    "BooleanLiteralTypeAnnotation",
                    "StringLiteralTypeAnnotation",
                    "BigIntLiteralTypeAnnotation",
                    "NumberLiteralTypeAnnotation",
                    "TSLiteralType",
                    "TSTemplateLiteralType",
                    "EmptyTypeAnnotation",
                    "MixedTypeAnnotation",
                    "TSNeverKeyword",
                    "TSObjectKeyword",
                    "TSUndefinedKeyword",
                    "TSUnknownKeyword",
                  ]);
                  function ne(L) {
                    return L
                      ? !!(
                          ((L.type === "GenericTypeAnnotation" ||
                            L.type === "TSTypeReference") &&
                            !L.typeParameters) ||
                          U.has(L.type)
                        )
                      : !1;
                  }
                  var se = /^(?:skip|[fx]?(?:it|describe|test))$/;
                  function V(L) {
                    return (
                      q(L.callee) &&
                      L.callee.object.type === "Identifier" &&
                      L.callee.property.type === "Identifier" &&
                      se.test(L.callee.object.name) &&
                      (L.callee.property.name === "only" ||
                        L.callee.property.name === "skip")
                    );
                  }
                  function oe(L) {
                    let De = /^(?:before|after)(?:Each|All)$/;
                    return (
                      L.callee.type === "Identifier" &&
                      De.test(L.callee.name) &&
                      L.arguments.length === 1
                    );
                  }
                  function K(L, De) {
                    if (L.type !== "CallExpression") return !1;
                    if (L.arguments.length === 1) {
                      if (O(L) && De && K(De)) return S(L.arguments[0]);
                      if (oe(L)) return O(L.arguments[0]);
                    } else if (
                      (L.arguments.length === 2 || L.arguments.length === 3) &&
                      ((L.callee.type === "Identifier" &&
                        se.test(L.callee.name)) ||
                        V(L)) &&
                      (_(L.arguments[0]) || x(L.arguments[0]))
                    )
                      return L.arguments[2] && !y(L.arguments[2])
                        ? !1
                        : (L.arguments.length === 2
                            ? S(L.arguments[1])
                            : k(L.arguments[1]) &&
                              Ke(L.arguments[1]).length <= 1) ||
                            O(L.arguments[1]);
                    return !1;
                  }
                  function Ee(L) {
                    return (
                      L &&
                      (L.type === "CallExpression" ||
                        L.type === "OptionalCallExpression")
                    );
                  }
                  function q(L) {
                    return (
                      L &&
                      (L.type === "MemberExpression" ||
                        L.type === "OptionalMemberExpression")
                    );
                  }
                  function le(L) {
                    let De = "expressions";
                    L.type === "TSTemplateLiteralType" && (De = "types");
                    let ke = L[De];
                    return ke.length === 0
                      ? !1
                      : ke.every((We) => {
                          if (Me(We)) return !1;
                          if (
                            We.type === "Identifier" ||
                            We.type === "ThisExpression"
                          )
                            return !0;
                          if (q(We)) {
                            let $e = We;
                            for (; q($e); )
                              if (
                                ($e.property.type !== "Identifier" &&
                                  $e.property.type !== "Literal" &&
                                  $e.property.type !== "StringLiteral" &&
                                  $e.property.type !== "NumericLiteral") ||
                                (($e = $e.object), Me($e))
                              )
                                return !1;
                            return (
                              $e.type === "Identifier" ||
                              $e.type === "ThisExpression"
                            );
                          }
                          return !1;
                        });
                  }
                  function ue(L, De) {
                    return L === "+" ? "+" + De : L === "-" ? "-" + De : De;
                  }
                  function Q(L, De) {
                    let ke = l(De),
                      We = r(L, C(De));
                    return (
                      We !== !1 &&
                      L.slice(ke, ke + 2) === "/*" &&
                      L.slice(We, We + 2) === "*/"
                    );
                  }
                  function de(L, De) {
                    return R(De)
                      ? Ae(De)
                      : Me(De, Pe.Leading, (ke) => i(L, C(ke)));
                  }
                  function ge(L, De) {
                    return (
                      De.parser !== "json" &&
                      x(L.key) &&
                      J(L.key).slice(1, -1) === L.key.value &&
                      ((t(L.key.value) &&
                        !(
                          (De.parser === "babel-ts" &&
                            L.type === "ClassProperty") ||
                          (De.parser === "typescript" &&
                            L.type === "PropertyDefinition")
                        )) ||
                        (ve(L.key.value) &&
                          String(Number(L.key.value)) === L.key.value &&
                          (De.parser === "babel" ||
                            De.parser === "acorn" ||
                            De.parser === "espree" ||
                            De.parser === "meriyah" ||
                            De.parser === "__babel_estree")))
                    );
                  }
                  function ve(L) {
                    return /^(?:\d+|\d+\.\d+)$/.test(L);
                  }
                  function xe(L, De) {
                    let ke = /^[fx]?(?:describe|it|test)$/;
                    return (
                      De.type === "TaggedTemplateExpression" &&
                      De.quasi === L &&
                      De.tag.type === "MemberExpression" &&
                      De.tag.property.type === "Identifier" &&
                      De.tag.property.name === "each" &&
                      ((De.tag.object.type === "Identifier" &&
                        ke.test(De.tag.object.name)) ||
                        (De.tag.object.type === "MemberExpression" &&
                          De.tag.object.property.type === "Identifier" &&
                          (De.tag.object.property.name === "only" ||
                            De.tag.object.property.name === "skip") &&
                          De.tag.object.object.type === "Identifier" &&
                          ke.test(De.tag.object.object.name)))
                    );
                  }
                  function we(L) {
                    return L.quasis.some((De) =>
                      De.value.raw.includes(`
`)
                    );
                  }
                  function fe(L, De) {
                    return (
                      ((L.type === "TemplateLiteral" && we(L)) ||
                        (L.type === "TaggedTemplateExpression" &&
                          we(L.quasi))) &&
                      !i(De, l(L), { backwards: !0 })
                    );
                  }
                  function pe(L) {
                    if (!Me(L)) return !1;
                    let De = s(qe(L, Pe.Dangling));
                    return De && !g(De);
                  }
                  function me(L) {
                    if (L.length <= 1) return !1;
                    let De = 0;
                    for (let ke of L)
                      if (S(ke)) {
                        if (((De += 1), De > 1)) return !0;
                      } else if (Ee(ke)) {
                        for (let We of ke.arguments) if (S(We)) return !0;
                      }
                    return !1;
                  }
                  function ce(L) {
                    let De = L.getValue(),
                      ke = L.getParentNode();
                    return (
                      Ee(De) &&
                      Ee(ke) &&
                      ke.callee === De &&
                      De.arguments.length > ke.arguments.length &&
                      ke.arguments.length > 0
                    );
                  }
                  function he(L, De) {
                    if (De >= 2) return !1;
                    let ke = ($e) => he($e, De + 1),
                      We =
                        (L.type === "Literal" &&
                          "regex" in L &&
                          L.regex.pattern) ||
                        (L.type === "RegExpLiteral" && L.pattern);
                    return We && c(We) > 5
                      ? !1
                      : L.type === "Literal" ||
                        L.type === "BigIntLiteral" ||
                        L.type === "DecimalLiteral" ||
                        L.type === "BooleanLiteral" ||
                        L.type === "NullLiteral" ||
                        L.type === "NumericLiteral" ||
                        L.type === "RegExpLiteral" ||
                        L.type === "StringLiteral" ||
                        L.type === "Identifier" ||
                        L.type === "ThisExpression" ||
                        L.type === "Super" ||
                        L.type === "PrivateName" ||
                        L.type === "PrivateIdentifier" ||
                        L.type === "ArgumentPlaceholder" ||
                        L.type === "Import"
                      ? !0
                      : L.type === "TemplateLiteral"
                      ? L.quasis.every(
                          ($e) =>
                            !$e.value.raw.includes(`
`)
                        ) && L.expressions.every(ke)
                      : L.type === "ObjectExpression"
                      ? L.properties.every(
                          ($e) =>
                            !$e.computed &&
                            ($e.shorthand || ($e.value && ke($e.value)))
                        )
                      : L.type === "ArrayExpression"
                      ? L.elements.every(($e) => $e === null || ke($e))
                      : rt(L)
                      ? (L.type === "ImportExpression" || he(L.callee, De)) &&
                        Be(L).every(ke)
                      : q(L)
                      ? he(L.object, De) && he(L.property, De)
                      : L.type === "UnaryExpression" &&
                        (L.operator === "!" || L.operator === "-")
                      ? he(L.argument, De)
                      : L.type === "TSNonNullExpression"
                      ? he(L.expression, De)
                      : !1;
                  }
                  function J(L) {
                    return L.extra ? L.extra.raw : L.raw;
                  }
                  function ye(L) {
                    return L;
                  }
                  function X(L) {
                    return L.filepath && /\.tsx$/i.test(L.filepath);
                  }
                  function Y(L) {
                    let De =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : "es5";
                    return (
                      (L.trailingComma === "es5" && De === "es5") ||
                      (L.trailingComma === "all" &&
                        (De === "all" || De === "es5"))
                    );
                  }
                  function te(L, De) {
                    switch (((L = tt(L)), L.type)) {
                      case "FunctionExpression":
                      case "ClassExpression":
                      case "DoExpression":
                        return De;
                      case "ObjectExpression":
                        return !0;
                      case "MemberExpression":
                      case "OptionalMemberExpression":
                        return te(L.object, De);
                      case "TaggedTemplateExpression":
                        return L.tag.type === "FunctionExpression"
                          ? !1
                          : te(L.tag, De);
                      case "CallExpression":
                      case "OptionalCallExpression":
                        return L.callee.type === "FunctionExpression"
                          ? !1
                          : te(L.callee, De);
                      case "ConditionalExpression":
                        return te(L.test, De);
                      case "UpdateExpression":
                        return !L.prefix && te(L.argument, De);
                      case "BindExpression":
                        return L.object && te(L.object, De);
                      case "SequenceExpression":
                        return te(L.expressions[0], De);
                      case "TSAsExpression":
                      case "TSNonNullExpression":
                        return te(L.expression, De);
                      default:
                        return !1;
                    }
                  }
                  var z = { "==": !0, "!=": !0, "===": !0, "!==": !0 },
                    j = { "*": !0, "/": !0, "%": !0 },
                    Ce = { ">>": !0, ">>>": !0, "<<": !0 };
                  function Ne(L, De) {
                    return !(
                      Ue(De) !== Ue(L) ||
                      L === "**" ||
                      (z[L] && z[De]) ||
                      (De === "%" && j[L]) ||
                      (L === "%" && j[De]) ||
                      (De !== L && j[De] && j[L]) ||
                      (Ce[L] && Ce[De])
                    );
                  }
                  var je = {};
                  for (let [L, De] of [
                    ["|>"],
                    ["??"],
                    ["||"],
                    ["&&"],
                    ["|"],
                    ["^"],
                    ["&"],
                    ["==", "===", "!=", "!=="],
                    ["<", ">", "<=", ">=", "in", "instanceof"],
                    [">>", "<<", ">>>"],
                    ["+", "-"],
                    ["*", "/", "%"],
                    ["**"],
                  ].entries())
                    for (let ke of De) je[ke] = L;
                  function Ue(L) {
                    return je[L];
                  }
                  function tt(L) {
                    for (; L.left; ) L = L.left;
                    return L;
                  }
                  function Te(L) {
                    return (
                      Boolean(Ce[L]) || L === "|" || L === "^" || L === "&"
                    );
                  }
                  function _e(L) {
                    if (L.rest) return !0;
                    let De = Ke(L);
                    return De.length > 0 && s(De).type === "RestElement";
                  }
                  var Fe = new WeakMap();
                  function Ke(L) {
                    if (Fe.has(L)) return Fe.get(L);
                    let De = [];
                    return (
                      L.this && De.push(L.this),
                      Array.isArray(L.parameters)
                        ? De.push(...L.parameters)
                        : Array.isArray(L.params) && De.push(...L.params),
                      L.rest && De.push(L.rest),
                      Fe.set(L, De),
                      De
                    );
                  }
                  function Se(L, De) {
                    let ke = L.getValue(),
                      We = 0,
                      $e = (ut) => De(ut, We++);
                    ke.this && L.call($e, "this"),
                      Array.isArray(ke.parameters)
                        ? L.each($e, "parameters")
                        : Array.isArray(ke.params) && L.each($e, "params"),
                      ke.rest && L.call($e, "rest");
                  }
                  var ze = new WeakMap();
                  function Be(L) {
                    if (ze.has(L)) return ze.get(L);
                    let De = L.arguments;
                    return (
                      L.type === "ImportExpression" &&
                        ((De = [L.source]),
                        L.attributes && De.push(L.attributes)),
                      ze.set(L, De),
                      De
                    );
                  }
                  function Ie(L, De) {
                    let ke = L.getValue();
                    ke.type === "ImportExpression"
                      ? (L.call((We) => De(We, 0), "source"),
                        ke.attributes &&
                          L.call((We) => De(We, 1), "attributes"))
                      : L.each(De, "arguments");
                  }
                  function Ve(L) {
                    return L.value.trim() === "prettier-ignore" && !L.unignore;
                  }
                  function Ae(L) {
                    return L && (L.prettierIgnore || Me(L, Pe.PrettierIgnore));
                  }
                  function Oe(L) {
                    let De = L.getValue();
                    return Ae(De);
                  }
                  var Pe = {
                      Leading: 1 << 1,
                      Trailing: 1 << 2,
                      Dangling: 1 << 3,
                      Block: 1 << 4,
                      Line: 1 << 5,
                      PrettierIgnore: 1 << 6,
                      First: 1 << 7,
                      Last: 1 << 8,
                    },
                    ie = (L, De) => {
                      if (
                        (typeof L == "function" && ((De = L), (L = 0)), L || De)
                      )
                        return (ke, We, $e) =>
                          !(
                            (L & Pe.Leading && !ke.leading) ||
                            (L & Pe.Trailing && !ke.trailing) ||
                            (L & Pe.Dangling && (ke.leading || ke.trailing)) ||
                            (L & Pe.Block && !g(ke)) ||
                            (L & Pe.Line && !w(ke)) ||
                            (L & Pe.First && We !== 0) ||
                            (L & Pe.Last && We !== $e.length - 1) ||
                            (L & Pe.PrettierIgnore && !Ve(ke)) ||
                            (De && !De(ke))
                          );
                    };
                  function Me(L, De, ke) {
                    if (!L || !u(L.comments)) return !1;
                    let We = ie(De, ke);
                    return We ? L.comments.some(We) : !0;
                  }
                  function qe(L, De, ke) {
                    if (!L || !Array.isArray(L.comments)) return [];
                    let We = ie(De, ke);
                    return We ? L.comments.filter(We) : L.comments;
                  }
                  var Je = (L, De) => {
                    let { originalText: ke } = De;
                    return a(ke, C(L));
                  };
                  function rt(L) {
                    return (
                      Ee(L) ||
                      L.type === "NewExpression" ||
                      L.type === "ImportExpression"
                    );
                  }
                  function Ze(L) {
                    return (
                      L &&
                      (L.type === "ObjectProperty" ||
                        (L.type === "Property" &&
                          !L.method &&
                          L.kind === "init"))
                    );
                  }
                  function ct(L) {
                    return Boolean(L.__isUsingHackPipeline);
                  }
                  var qt = Symbol("ifWithoutBlockAndSameLineComment");
                  n.exports = {
                    getFunctionParameters: Ke,
                    iterateFunctionParametersPath: Se,
                    getCallArguments: Be,
                    iterateCallArgumentsPath: Ie,
                    hasRestParameter: _e,
                    getLeftSide: v,
                    getLeftSidePathName: B,
                    getParentExportDeclaration: D,
                    getTypeScriptMappedTypeModifier: ue,
                    hasFlowAnnotationComment: T,
                    hasFlowShorthandAnnotationComment: N,
                    hasLeadingOwnLineComment: de,
                    hasNakedLeftSide: b,
                    hasNode: A,
                    hasIgnoreComment: Oe,
                    hasNodeIgnoreComment: Ae,
                    identity: ye,
                    isBinaryish: W,
                    isCallLikeExpression: rt,
                    isEnabledHackPipeline: ct,
                    isLineComment: w,
                    isPrettierIgnoreComment: Ve,
                    isCallExpression: Ee,
                    isMemberExpression: q,
                    isExportDeclaration: E,
                    isFlowAnnotationComment: Q,
                    isFunctionCompositionArgs: me,
                    isFunctionNotation: P,
                    isFunctionOrArrowExpression: S,
                    isGetterOrSetter: H,
                    isJestEachTemplateLiteral: xe,
                    isJsxNode: R,
                    isLiteral: d,
                    isLongCurriedCallExpression: ce,
                    isSimpleCallArgument: he,
                    isMemberish: ee,
                    isNumericLiteral: y,
                    isSignedNumericLiteral: o,
                    isObjectProperty: Ze,
                    isObjectType: F,
                    isObjectTypePropertyAFunction: G,
                    isSimpleType: ne,
                    isSimpleNumber: ve,
                    isSimpleTemplateLiteral: le,
                    isStringLiteral: x,
                    isStringPropSafeToUnquote: ge,
                    isTemplateOnItsOwnLine: fe,
                    isTestCall: K,
                    isTheOnlyJsxElementInMarkdown: M,
                    isTSXFile: X,
                    isTypeAnnotationAFunction: re,
                    isNextLineEmpty: Je,
                    needsHardlineAfterDanglingComment: pe,
                    rawText: J,
                    shouldPrintComma: Y,
                    isBitwiseOperator: Te,
                    shouldFlatten: Ne,
                    startsWithNoLookaheadToken: te,
                    getPrecedence: Ue,
                    hasComment: Me,
                    getComments: qe,
                    CommentCheckFlags: Pe,
                    markerForIfWithoutBlockAndSameLineComment: qt,
                  };
                },
              }),
              It = Z({
                "src/language-js/print/template-literal.js"(e, n) {
                  "use strict";
                  ae();
                  var t = st(),
                    { getStringWidth: s, getIndentSize: i } = Ge(),
                    {
                      builders: {
                        join: r,
                        hardline: u,
                        softline: a,
                        group: c,
                        indent: l,
                        align: C,
                        lineSuffixBoundary: m,
                        addAlignmentToDoc: g,
                      },
                      printer: { printDocToString: p },
                      utils: { mapDoc: f },
                    } = Le(),
                    {
                      isBinaryish: h,
                      isJestEachTemplateLiteral: N,
                      isSimpleTemplateLiteral: T,
                      hasComment: A,
                      isMemberExpression: b,
                    } = Xe();
                  function v(d, y, o) {
                    let x = d.getValue();
                    if (
                      x.type === "TemplateLiteral" &&
                      N(x, d.getParentNode())
                    ) {
                      let R = B(d, o, y);
                      if (R) return R;
                    }
                    let S = "expressions";
                    x.type === "TSTemplateLiteralType" && (S = "types");
                    let k = [],
                      _ = d.map(y, S),
                      O = T(x);
                    return (
                      O &&
                        (_ = _.map(
                          (R) =>
                            p(
                              R,
                              Object.assign(
                                Object.assign({}, o),
                                {},
                                { printWidth: Number.POSITIVE_INFINITY }
                              )
                            ).formatted
                        )),
                      k.push(m, "`"),
                      d.each((R) => {
                        let M = R.getName();
                        if ((k.push(y()), M < _.length)) {
                          let { tabWidth: H } = o,
                            P = R.getValue(),
                            G = i(P.value.raw, H),
                            re = _[M];
                          if (!O) {
                            let W = x[S][M];
                            (A(W) ||
                              b(W) ||
                              W.type === "ConditionalExpression" ||
                              W.type === "SequenceExpression" ||
                              W.type === "TSAsExpression" ||
                              h(W)) &&
                              (re = [l([a, re]), a]);
                          }
                          let $ =
                            G === 0 &&
                            P.value.raw.endsWith(`
`)
                              ? C(Number.NEGATIVE_INFINITY, re)
                              : g(re, G, H);
                          k.push(c(["${", $, m, "}"]));
                        }
                      }, "quasis"),
                      k.push("`"),
                      k
                    );
                  }
                  function B(d, y, o) {
                    let x = d.getNode(),
                      F = x.quasis[0].value.raw.trim().split(/\s*\|\s*/);
                    if (F.length > 1 || F.some((S) => S.length > 0)) {
                      y.__inJestEach = !0;
                      let S = d.map(o, "expressions");
                      y.__inJestEach = !1;
                      let k = [],
                        _ = S.map(
                          (P) =>
                            "${" +
                            p(
                              P,
                              Object.assign(
                                Object.assign({}, y),
                                {},
                                {
                                  printWidth: Number.POSITIVE_INFINITY,
                                  endOfLine: "lf",
                                }
                              )
                            ).formatted +
                            "}"
                        ),
                        O = [{ hasLineBreak: !1, cells: [] }];
                      for (let P = 1; P < x.quasis.length; P++) {
                        let G = t(O),
                          re = _[P - 1];
                        G.cells.push(re),
                          re.includes(`
`) && (G.hasLineBreak = !0),
                          x.quasis[P].value.raw.includes(`
`) && O.push({ hasLineBreak: !1, cells: [] });
                      }
                      let R = Math.max(
                          F.length,
                          ...O.map((P) => P.cells.length)
                        ),
                        M = Array.from({ length: R }).fill(0),
                        H = [
                          { cells: F },
                          ...O.filter((P) => P.cells.length > 0),
                        ];
                      for (let { cells: P } of H.filter((G) => !G.hasLineBreak))
                        for (let [G, re] of P.entries())
                          M[G] = Math.max(M[G], s(re));
                      return (
                        k.push(
                          m,
                          "`",
                          l([
                            u,
                            r(
                              u,
                              H.map((P) =>
                                r(
                                  " | ",
                                  P.cells.map((G, re) =>
                                    P.hasLineBreak
                                      ? G
                                      : G + " ".repeat(M[re] - s(G))
                                  )
                                )
                              )
                            ),
                          ]),
                          u,
                          "`"
                        ),
                        k
                      );
                    }
                  }
                  function w(d, y) {
                    let o = d.getValue(),
                      x = y();
                    return A(o) && (x = c([l([a, x]), a])), ["${", x, m, "}"];
                  }
                  function I(d, y) {
                    return d.map((o) => w(o, y), "expressions");
                  }
                  function E(d, y) {
                    return f(d, (o) =>
                      typeof o == "string"
                        ? y
                          ? o.replace(/(\\*)`/g, "$1$1\\`")
                          : D(o)
                        : o
                    );
                  }
                  function D(d) {
                    return d.replace(/([\\`]|\${)/g, "\\$1");
                  }
                  n.exports = {
                    printTemplateLiteral: v,
                    printTemplateExpressions: I,
                    escapeTemplateCharacters: E,
                    uncookTemplateElementValue: D,
                  };
                },
              }),
              Dm = Z({
                "src/language-js/embed/markdown.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: {
                        indent: t,
                        softline: s,
                        literalline: i,
                        dedentToRoot: r,
                      },
                    } = Le(),
                    { escapeTemplateCharacters: u } = It();
                  function a(l, C, m) {
                    let p = l
                        .getValue()
                        .quasis[0].value.raw.replace(
                          /((?:\\\\)*)\\`/g,
                          (T, A) => "\\".repeat(A.length / 2) + "`"
                        ),
                      f = c(p),
                      h = f !== "";
                    h && (p = p.replace(new RegExp("^".concat(f), "gm"), ""));
                    let N = u(
                      m(
                        p,
                        { parser: "markdown", __inJsTemplate: !0 },
                        { stripTrailingHardline: !0 }
                      ),
                      !0
                    );
                    return ["`", h ? t([s, N]) : [i, r(N)], s, "`"];
                  }
                  function c(l) {
                    let C = l.match(/^([^\S\n]*)\S/m);
                    return C === null ? "" : C[1];
                  }
                  n.exports = a;
                },
              }),
              mm = Z({
                "src/language-js/embed/css.js"(e, n) {
                  "use strict";
                  ae();
                  var { isNonEmptyArray: t } = Ge(),
                    {
                      builders: { indent: s, hardline: i, softline: r },
                      utils: { mapDoc: u, replaceEndOfLine: a, cleanDoc: c },
                    } = Le(),
                    { printTemplateExpressions: l } = It();
                  function C(p, f, h) {
                    let N = p.getValue(),
                      T = N.quasis.map((w) => w.value.raw),
                      A = 0,
                      b = T.reduce(
                        (w, I, E) =>
                          E === 0
                            ? I
                            : w + "@prettier-placeholder-" + A++ + "-id" + I,
                        ""
                      ),
                      v = h(
                        b,
                        { parser: "scss" },
                        { stripTrailingHardline: !0 }
                      ),
                      B = l(p, f);
                    return m(v, N, B);
                  }
                  function m(p, f, h) {
                    if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
                      return "``";
                    let T = g(p, h);
                    if (!T)
                      throw new Error("Couldn't insert all the expressions");
                    return ["`", s([i, T]), r, "`"];
                  }
                  function g(p, f) {
                    if (!t(f)) return p;
                    let h = 0,
                      N = u(c(p), (T) =>
                        typeof T != "string" ||
                        !T.includes("@prettier-placeholder")
                          ? T
                          : T.split(/@prettier-placeholder-(\d+)-id/).map(
                              (A, b) => (b % 2 === 0 ? a(A) : (h++, f[A]))
                            )
                      );
                    return f.length === h ? N : null;
                  }
                  n.exports = C;
                },
              }),
              dm = Z({
                "src/language-js/embed/graphql.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: { indent: t, join: s, hardline: i },
                    } = Le(),
                    {
                      escapeTemplateCharacters: r,
                      printTemplateExpressions: u,
                    } = It();
                  function a(l, C, m) {
                    let g = l.getValue(),
                      p = g.quasis.length;
                    if (p === 1 && g.quasis[0].value.raw.trim() === "")
                      return "``";
                    let f = u(l, C),
                      h = [];
                    for (let N = 0; N < p; N++) {
                      let T = g.quasis[N],
                        A = N === 0,
                        b = N === p - 1,
                        v = T.value.cooked,
                        B = v.split(`
`),
                        w = B.length,
                        I = f[N],
                        E = w > 2 && B[0].trim() === "" && B[1].trim() === "",
                        D =
                          w > 2 &&
                          B[w - 1].trim() === "" &&
                          B[w - 2].trim() === "",
                        d = B.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
                      if (!b && /#[^\n\r]*$/.test(B[w - 1])) return null;
                      let y = null;
                      d
                        ? (y = c(B))
                        : (y = m(
                            v,
                            { parser: "graphql" },
                            { stripTrailingHardline: !0 }
                          )),
                        y
                          ? ((y = r(y, !1)),
                            !A && E && h.push(""),
                            h.push(y),
                            !b && D && h.push(""))
                          : !A && !b && E && h.push(""),
                        I && h.push(I);
                    }
                    return ["`", t([i, s(i, h)]), i, "`"];
                  }
                  function c(l) {
                    let C = [],
                      m = !1,
                      g = l.map((p) => p.trim());
                    for (let [p, f] of g.entries())
                      f !== "" &&
                        (g[p - 1] === "" && m ? C.push([i, f]) : C.push(f),
                        (m = !0));
                    return C.length === 0 ? null : s(i, C);
                  }
                  n.exports = a;
                },
              }),
              gm = Z({
                "src/language-js/embed/html.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: { indent: t, line: s, hardline: i, group: r },
                      utils: { mapDoc: u },
                    } = Le(),
                    {
                      printTemplateExpressions: a,
                      uncookTemplateElementValue: c,
                    } = It(),
                    l = 0;
                  function C(m, g, p, f, h) {
                    let { parser: N } = h,
                      T = m.getValue(),
                      A = l;
                    l = (l + 1) >>> 0;
                    let b = (x) =>
                        "PRETTIER_HTML_PLACEHOLDER_"
                          .concat(x, "_")
                          .concat(A, "_IN_JS"),
                      v = T.quasis
                        .map((x, F, S) =>
                          F === S.length - 1
                            ? x.value.cooked
                            : x.value.cooked + b(F)
                        )
                        .join(""),
                      B = a(m, g);
                    if (B.length === 0 && v.trim().length === 0) return "``";
                    let w = new RegExp(b("(\\d+)"), "g"),
                      I = 0,
                      E = p(
                        v,
                        {
                          parser: N,
                          __onHtmlRoot(x) {
                            I = x.children.length;
                          },
                        },
                        { stripTrailingHardline: !0 }
                      ),
                      D = u(E, (x) => {
                        if (typeof x != "string") return x;
                        let F = [],
                          S = x.split(w);
                        for (let k = 0; k < S.length; k++) {
                          let _ = S[k];
                          if (k % 2 === 0) {
                            _ &&
                              ((_ = c(_)),
                              f.__embeddedInHtml &&
                                (_ = _.replace(/<\/(script)\b/gi, "<\\/$1")),
                              F.push(_));
                            continue;
                          }
                          let O = Number(_);
                          F.push(B[O]);
                        }
                        return F;
                      }),
                      d = /^\s/.test(v) ? " " : "",
                      y = /\s$/.test(v) ? " " : "",
                      o =
                        f.htmlWhitespaceSensitivity === "ignore"
                          ? i
                          : d && y
                          ? s
                          : null;
                    return r(
                      o
                        ? ["`", t([o, r(D)]), o, "`"]
                        : ["`", d, I > 1 ? t(r(D)) : r(D), y, "`"]
                    );
                  }
                  n.exports = C;
                },
              }),
              ym = Z({
                "src/language-js/embed.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      hasComment: t,
                      CommentCheckFlags: s,
                      isObjectProperty: i,
                    } = Xe(),
                    r = Dm(),
                    u = mm(),
                    a = dm(),
                    c = gm();
                  function l(E) {
                    if (g(E) || N(E) || T(E) || p(E)) return "css";
                    if (v(E)) return "graphql";
                    if (w(E)) return "html";
                    if (f(E)) return "angular";
                    if (m(E)) return "markdown";
                  }
                  function C(E, D, d, y) {
                    let o = E.getValue();
                    if (o.type !== "TemplateLiteral" || I(o)) return;
                    let x = l(E);
                    if (!!x) {
                      if (x === "markdown") return r(E, D, d);
                      if (x === "css") return u(E, D, d);
                      if (x === "graphql") return a(E, D, d);
                      if (x === "html" || x === "angular")
                        return c(E, D, d, y, { parser: x });
                    }
                  }
                  function m(E) {
                    let D = E.getValue(),
                      d = E.getParentNode();
                    return (
                      d &&
                      d.type === "TaggedTemplateExpression" &&
                      D.quasis.length === 1 &&
                      d.tag.type === "Identifier" &&
                      (d.tag.name === "md" || d.tag.name === "markdown")
                    );
                  }
                  function g(E) {
                    let D = E.getValue(),
                      d = E.getParentNode(),
                      y = E.getParentNode(1);
                    return (
                      (y &&
                        D.quasis &&
                        d.type === "JSXExpressionContainer" &&
                        y.type === "JSXElement" &&
                        y.openingElement.name.name === "style" &&
                        y.openingElement.attributes.some(
                          (o) => o.name.name === "jsx"
                        )) ||
                      (d &&
                        d.type === "TaggedTemplateExpression" &&
                        d.tag.type === "Identifier" &&
                        d.tag.name === "css") ||
                      (d &&
                        d.type === "TaggedTemplateExpression" &&
                        d.tag.type === "MemberExpression" &&
                        d.tag.object.name === "css" &&
                        (d.tag.property.name === "global" ||
                          d.tag.property.name === "resolve"))
                    );
                  }
                  function p(E) {
                    return E.match(
                      (D) => D.type === "TemplateLiteral",
                      (D, d) =>
                        D.type === "ArrayExpression" && d === "elements",
                      (D, d) =>
                        i(D) &&
                        D.key.type === "Identifier" &&
                        D.key.name === "styles" &&
                        d === "value",
                      ...h
                    );
                  }
                  function f(E) {
                    return E.match(
                      (D) => D.type === "TemplateLiteral",
                      (D, d) =>
                        i(D) &&
                        D.key.type === "Identifier" &&
                        D.key.name === "template" &&
                        d === "value",
                      ...h
                    );
                  }
                  var h = [
                    (E, D) =>
                      E.type === "ObjectExpression" && D === "properties",
                    (E, D) =>
                      E.type === "CallExpression" &&
                      E.callee.type === "Identifier" &&
                      E.callee.name === "Component" &&
                      D === "arguments",
                    (E, D) => E.type === "Decorator" && D === "expression",
                  ];
                  function N(E) {
                    let D = E.getParentNode();
                    if (!D || D.type !== "TaggedTemplateExpression") return !1;
                    let d =
                      D.tag.type === "ParenthesizedExpression"
                        ? D.tag.expression
                        : D.tag;
                    switch (d.type) {
                      case "MemberExpression":
                        return A(d.object) || b(d);
                      case "CallExpression":
                        return (
                          A(d.callee) ||
                          (d.callee.type === "MemberExpression" &&
                            ((d.callee.object.type === "MemberExpression" &&
                              (A(d.callee.object.object) ||
                                b(d.callee.object))) ||
                              (d.callee.object.type === "CallExpression" &&
                                A(d.callee.object.callee))))
                        );
                      case "Identifier":
                        return d.name === "css";
                      default:
                        return !1;
                    }
                  }
                  function T(E) {
                    let D = E.getParentNode(),
                      d = E.getParentNode(1);
                    return (
                      d &&
                      D.type === "JSXExpressionContainer" &&
                      d.type === "JSXAttribute" &&
                      d.name.type === "JSXIdentifier" &&
                      d.name.name === "css"
                    );
                  }
                  function A(E) {
                    return E.type === "Identifier" && E.name === "styled";
                  }
                  function b(E) {
                    return (
                      /^[A-Z]/.test(E.object.name) &&
                      E.property.name === "extend"
                    );
                  }
                  function v(E) {
                    let D = E.getValue(),
                      d = E.getParentNode();
                    return (
                      B(D, "GraphQL") ||
                      (d &&
                        ((d.type === "TaggedTemplateExpression" &&
                          ((d.tag.type === "MemberExpression" &&
                            d.tag.object.name === "graphql" &&
                            d.tag.property.name === "experimental") ||
                            (d.tag.type === "Identifier" &&
                              (d.tag.name === "gql" ||
                                d.tag.name === "graphql")))) ||
                          (d.type === "CallExpression" &&
                            d.callee.type === "Identifier" &&
                            d.callee.name === "graphql")))
                    );
                  }
                  function B(E, D) {
                    return t(E, s.Block | s.Leading, (d) => {
                      let { value: y } = d;
                      return y === " ".concat(D, " ");
                    });
                  }
                  function w(E) {
                    return (
                      B(E.getValue(), "HTML") ||
                      E.match(
                        (D) => D.type === "TemplateLiteral",
                        (D, d) =>
                          D.type === "TaggedTemplateExpression" &&
                          D.tag.type === "Identifier" &&
                          D.tag.name === "html" &&
                          d === "quasi"
                      )
                    );
                  }
                  function I(E) {
                    let { quasis: D } = E;
                    return D.some((d) => {
                      let {
                        value: { cooked: y },
                      } = d;
                      return y === null;
                    });
                  }
                  n.exports = C;
                },
              }),
              hm = Z({
                "src/language-js/clean.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Pt(),
                    s = new Set([
                      "range",
                      "raw",
                      "comments",
                      "leadingComments",
                      "trailingComments",
                      "innerComments",
                      "extra",
                      "start",
                      "end",
                      "loc",
                      "flags",
                      "errors",
                      "tokens",
                    ]),
                    i = (u) => {
                      for (let a of u.quasis) delete a.value;
                    };
                  function r(u, a, c) {
                    if (
                      (u.type === "Program" && delete a.sourceType,
                      (u.type === "BigIntLiteral" ||
                        u.type === "BigIntLiteralTypeAnnotation") &&
                        a.value &&
                        (a.value = a.value.toLowerCase()),
                      (u.type === "BigIntLiteral" || u.type === "Literal") &&
                        a.bigint &&
                        (a.bigint = a.bigint.toLowerCase()),
                      u.type === "DecimalLiteral" &&
                        (a.value = Number(a.value)),
                      u.type === "Literal" &&
                        a.decimal &&
                        (a.decimal = Number(a.decimal)),
                      u.type === "EmptyStatement" ||
                        u.type === "JSXText" ||
                        (u.type === "JSXExpressionContainer" &&
                          (u.expression.type === "Literal" ||
                            u.expression.type === "StringLiteral") &&
                          u.expression.value === " "))
                    )
                      return null;
                    if (
                      ((u.type === "Property" ||
                        u.type === "ObjectProperty" ||
                        u.type === "MethodDefinition" ||
                        u.type === "ClassProperty" ||
                        u.type === "ClassMethod" ||
                        u.type === "PropertyDefinition" ||
                        u.type === "TSDeclareMethod" ||
                        u.type === "TSPropertySignature" ||
                        u.type === "ObjectTypeProperty") &&
                        typeof u.key == "object" &&
                        u.key &&
                        (u.key.type === "Literal" ||
                          u.key.type === "NumericLiteral" ||
                          u.key.type === "StringLiteral" ||
                          u.key.type === "Identifier") &&
                        delete a.key,
                      u.type === "JSXElement" &&
                        u.openingElement.name.name === "style" &&
                        u.openingElement.attributes.some(
                          (C) => C.name.name === "jsx"
                        ))
                    )
                      for (let { type: C, expression: m } of a.children)
                        C === "JSXExpressionContainer" &&
                          m.type === "TemplateLiteral" &&
                          i(m);
                    u.type === "JSXAttribute" &&
                      u.name.name === "css" &&
                      u.value.type === "JSXExpressionContainer" &&
                      u.value.expression.type === "TemplateLiteral" &&
                      i(a.value.expression),
                      u.type === "JSXAttribute" &&
                        u.value &&
                        u.value.type === "Literal" &&
                        /["']|&quot;|&apos;/.test(u.value.value) &&
                        (a.value.value = a.value.value.replace(
                          /["']|&quot;|&apos;/g,
                          '"'
                        ));
                    let l = u.expression || u.callee;
                    if (
                      u.type === "Decorator" &&
                      l.type === "CallExpression" &&
                      l.callee.name === "Component" &&
                      l.arguments.length === 1
                    ) {
                      let C = u.expression.arguments[0].properties;
                      for (let [
                        m,
                        g,
                      ] of a.expression.arguments[0].properties.entries())
                        switch (C[m].key.name) {
                          case "styles":
                            g.value.type === "ArrayExpression" &&
                              i(g.value.elements[0]);
                            break;
                          case "template":
                            g.value.type === "TemplateLiteral" && i(g.value);
                            break;
                        }
                    }
                    if (
                      (u.type === "TaggedTemplateExpression" &&
                        (u.tag.type === "MemberExpression" ||
                          (u.tag.type === "Identifier" &&
                            (u.tag.name === "gql" ||
                              u.tag.name === "graphql" ||
                              u.tag.name === "css" ||
                              u.tag.name === "md" ||
                              u.tag.name === "markdown" ||
                              u.tag.name === "html")) ||
                          u.tag.type === "CallExpression") &&
                        i(a.quasi),
                      u.type === "TemplateLiteral" &&
                        ((u.leadingComments &&
                          u.leadingComments.some(
                            (m) =>
                              t(m) &&
                              ["GraphQL", "HTML"].some(
                                (g) => m.value === " ".concat(g, " ")
                              )
                          )) ||
                          (c.type === "CallExpression" &&
                            c.callee.name === "graphql") ||
                          !u.leadingComments) &&
                        i(a),
                      u.type === "InterpreterDirective" &&
                        (a.value = a.value.trimEnd()),
                      (u.type === "TSIntersectionType" ||
                        u.type === "TSUnionType") &&
                        u.types.length === 1)
                    )
                      return a.types[0];
                  }
                  (r.ignoredProperties = s), (n.exports = r);
                },
              }),
              Vi = {};
            kn(Vi, {
              EOL: () => wn,
              arch: () => Cm,
              cpus: () => zi,
              default: () => Zi,
              endianness: () => Wi,
              freemem: () => Ji,
              getNetworkInterfaces: () => Qi,
              hostname: () => $i,
              loadavg: () => Hi,
              networkInterfaces: () => Yi,
              platform: () => Em,
              release: () => Ki,
              tmpDir: () => Bn,
              tmpdir: () => Nn,
              totalmem: () => Ui,
              type: () => Xi,
              uptime: () => Gi,
            });
            function Wi() {
              if (typeof Fr > "u") {
                var e = new ArrayBuffer(2),
                  n = new Uint8Array(e),
                  t = new Uint16Array(e);
                if (((n[0] = 1), (n[1] = 2), t[0] === 258)) Fr = "BE";
                else if (t[0] === 513) Fr = "LE";
                else throw new Error("unable to figure out endianess");
              }
              return Fr;
            }
            function $i() {
              return typeof globalThis.location < "u"
                ? globalThis.location.hostname
                : "";
            }
            function Hi() {
              return [];
            }
            function Gi() {
              return 0;
            }
            function Ji() {
              return Number.MAX_VALUE;
            }
            function Ui() {
              return Number.MAX_VALUE;
            }
            function zi() {
              return [];
            }
            function Xi() {
              return "Browser";
            }
            function Ki() {
              return typeof globalThis.navigator < "u"
                ? globalThis.navigator.appVersion
                : "";
            }
            function Yi() {}
            function Qi() {}
            function Cm() {
              return "javascript";
            }
            function Em() {
              return "browser";
            }
            function Bn() {
              return "/tmp";
            }
            var Fr,
              Nn,
              wn,
              Zi,
              vm = br({
                "node-modules-polyfills:os"() {
                  ae(),
                    (Nn = Bn),
                    (wn = `
`),
                    (Zi = {
                      EOL: wn,
                      tmpdir: Nn,
                      tmpDir: Bn,
                      networkInterfaces: Yi,
                      getNetworkInterfaces: Qi,
                      release: Ki,
                      type: Xi,
                      cpus: zi,
                      totalmem: Ui,
                      freemem: Ji,
                      uptime: Gi,
                      loadavg: Hi,
                      hostname: $i,
                      endianness: Wi,
                    });
                },
              }),
              Fm = Z({
                "node-modules-polyfills-commonjs:os"(e, n) {
                  ae();
                  var t = (vm(), pt(Vi));
                  if (t && t.default) {
                    n.exports = t.default;
                    for (let s in t) n.exports[s] = t[s];
                  } else t && (n.exports = t);
                },
              }),
              Am = Z({
                "node_modules/detect-newline/index.js"(e, n) {
                  "use strict";
                  ae();
                  var t = (s) => {
                    if (typeof s != "string")
                      throw new TypeError("Expected a string");
                    let i = s.match(/(?:\r?\n)/g) || [];
                    if (i.length === 0) return;
                    let r = i.filter(
                        (a) =>
                          a ===
                          `\r
`
                      ).length,
                      u = i.length - r;
                    return r > u
                      ? `\r
`
                      : `
`;
                  };
                  (n.exports = t),
                    (n.exports.graceful = (s) =>
                      (typeof s == "string" && t(s)) ||
                      `
`);
                },
              }),
              Sm = Z({
                "node_modules/jest-docblock/build/index.js"(e) {
                  "use strict";
                  ae(),
                    Object.defineProperty(e, "__esModule", { value: !0 }),
                    (e.extract = p),
                    (e.parse = h),
                    (e.parseWithComments = N),
                    (e.print = T),
                    (e.strip = f);
                  function n() {
                    let b = Fm();
                    return (
                      (n = function () {
                        return b;
                      }),
                      b
                    );
                  }
                  function t() {
                    let b = s(Am());
                    return (
                      (t = function () {
                        return b;
                      }),
                      b
                    );
                  }
                  function s(b) {
                    return b && b.__esModule ? b : { default: b };
                  }
                  var i = /\*\/$/,
                    r = /^\/\*\*/,
                    u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
                    a = /(^|\s+)\/\/([^\r\n]*)/g,
                    c = /^(\r?\n)+/,
                    l =
                      /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
                    C = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
                    m = /(\r?\n|^) *\* ?/g,
                    g = [];
                  function p(b) {
                    let v = b.match(u);
                    return v ? v[0].trimLeft() : "";
                  }
                  function f(b) {
                    let v = b.match(u);
                    return v && v[0] ? b.substring(v[0].length) : b;
                  }
                  function h(b) {
                    return N(b).pragmas;
                  }
                  function N(b) {
                    let v = (0, t().default)(b) || n().EOL;
                    b = b.replace(r, "").replace(i, "").replace(m, "$1");
                    let B = "";
                    for (; B !== b; )
                      (B = b),
                        (b = b.replace(l, "".concat(v, "$1 $2").concat(v)));
                    b = b.replace(c, "").trimRight();
                    let w = Object.create(null),
                      I = b.replace(C, "").replace(c, "").trimRight(),
                      E;
                    for (; (E = C.exec(b)); ) {
                      let D = E[2].replace(a, "");
                      typeof w[E[1]] == "string" || Array.isArray(w[E[1]])
                        ? (w[E[1]] = g.concat(w[E[1]], D))
                        : (w[E[1]] = D);
                    }
                    return { comments: I, pragmas: w };
                  }
                  function T(b) {
                    let { comments: v = "", pragmas: B = {} } = b,
                      w = (0, t().default)(v) || n().EOL,
                      I = "/**",
                      E = " *",
                      D = " */",
                      d = Object.keys(B),
                      y = d
                        .map((x) => A(x, B[x]))
                        .reduce((x, F) => x.concat(F), [])
                        .map((x) => E + " " + x + w)
                        .join("");
                    if (!v) {
                      if (d.length === 0) return "";
                      if (d.length === 1 && !Array.isArray(B[d[0]])) {
                        let x = B[d[0]];
                        return ""
                          .concat(I, " ")
                          .concat(A(d[0], x)[0])
                          .concat(D);
                      }
                    }
                    let o =
                      v
                        .split(w)
                        .map((x) => "".concat(E, " ").concat(x))
                        .join(w) + w;
                    return (
                      I +
                      w +
                      (v ? o : "") +
                      (v && d.length ? E + w : "") +
                      y +
                      D
                    );
                  }
                  function A(b, v) {
                    return g
                      .concat(v)
                      .map((B) => "@".concat(b, " ").concat(B).trim());
                  }
                },
              }),
              xm = Z({
                "src/language-js/utils/get-shebang.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s) {
                    if (!s.startsWith("#!")) return "";
                    let i = s.indexOf(`
`);
                    return i === -1 ? s : s.slice(0, i);
                  }
                  n.exports = t;
                },
              }),
              eo = Z({
                "src/language-js/pragma.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      parseWithComments: t,
                      strip: s,
                      extract: i,
                      print: r,
                    } = Sm(),
                    { normalizeEndOfLine: u } = On(),
                    a = xm();
                  function c(m) {
                    let g = a(m);
                    g && (m = m.slice(g.length + 1));
                    let p = i(m),
                      { pragmas: f, comments: h } = t(p);
                    return { shebang: g, text: m, pragmas: f, comments: h };
                  }
                  function l(m) {
                    let g = Object.keys(c(m).pragmas);
                    return g.includes("prettier") || g.includes("format");
                  }
                  function C(m) {
                    let { shebang: g, text: p, pragmas: f, comments: h } = c(m),
                      N = s(p),
                      T = r({
                        pragmas: Object.assign({ format: "" }, f),
                        comments: h.trimStart(),
                      });
                    return (
                      (g
                        ? "".concat(
                            g,
                            `
`
                          )
                        : "") +
                      u(T) +
                      (N.startsWith(`
`)
                        ? `
`
                        : `

`) +
                      N
                    );
                  }
                  n.exports = { hasPragma: l, insertPragma: C };
                },
              }),
              to = Z({
                "src/language-js/comments.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      getLast: t,
                      hasNewline: s,
                      getNextNonSpaceNonCommentCharacterIndexWithStartIndex: i,
                      getNextNonSpaceNonCommentCharacter: r,
                      hasNewlineInRange: u,
                      addLeadingComment: a,
                      addTrailingComment: c,
                      addDanglingComment: l,
                      getNextNonSpaceNonCommentCharacterIndex: C,
                      isNonEmptyArray: m,
                    } = Ge(),
                    {
                      getFunctionParameters: g,
                      isPrettierIgnoreComment: p,
                      isJsxNode: f,
                      hasFlowShorthandAnnotationComment: h,
                      hasFlowAnnotationComment: N,
                      hasIgnoreComment: T,
                      isCallLikeExpression: A,
                      getCallArguments: b,
                      isCallExpression: v,
                      isMemberExpression: B,
                      isObjectProperty: w,
                      isLineComment: I,
                      getComments: E,
                      CommentCheckFlags: D,
                      markerForIfWithoutBlockAndSameLineComment: d,
                    } = Xe(),
                    { locStart: y, locEnd: o } = nt(),
                    x = Pt();
                  function F(X) {
                    return [
                      fe,
                      V,
                      G,
                      M,
                      H,
                      P,
                      W,
                      oe,
                      de,
                      le,
                      Q,
                      ge,
                      ve,
                      ee,
                      K,
                      Ee,
                    ].some((Y) => Y(X));
                  }
                  function S(X) {
                    return [
                      R,
                      V,
                      re,
                      oe,
                      M,
                      H,
                      P,
                      W,
                      K,
                      q,
                      ue,
                      Q,
                      xe,
                      Ee,
                      me,
                    ].some((Y) => Y(X));
                  }
                  function k(X) {
                    return [fe, M, H, $, se, ee, Q, ne, U, pe, Ee, we].some(
                      (Y) => Y(X)
                    );
                  }
                  function _(X, Y) {
                    let te = (X.body || X.properties).find((z) => {
                      let { type: j } = z;
                      return j !== "EmptyStatement";
                    });
                    te ? a(te, Y) : l(X, Y);
                  }
                  function O(X, Y) {
                    X.type === "BlockStatement" ? _(X, Y) : a(X, Y);
                  }
                  function R(X) {
                    let { comment: Y, followingNode: te } = X;
                    return te && J(Y) ? (a(te, Y), !0) : !1;
                  }
                  function M(X) {
                    let {
                      comment: Y,
                      precedingNode: te,
                      enclosingNode: z,
                      followingNode: j,
                      text: Ce,
                    } = X;
                    if (!z || z.type !== "IfStatement" || !j) return !1;
                    if (r(Ce, Y, o) === ")") return c(te, Y), !0;
                    if (te === z.consequent && j === z.alternate) {
                      if (te.type === "BlockStatement") c(te, Y);
                      else {
                        let je =
                            Y.type === "SingleLine" ||
                            Y.loc.start.line === Y.loc.end.line,
                          Ue = Y.loc.start.line === te.loc.start.line;
                        je && Ue ? l(te, Y, d) : l(z, Y);
                      }
                      return !0;
                    }
                    return j.type === "BlockStatement"
                      ? (_(j, Y), !0)
                      : j.type === "IfStatement"
                      ? (O(j.consequent, Y), !0)
                      : z.consequent === j
                      ? (a(j, Y), !0)
                      : !1;
                  }
                  function H(X) {
                    let {
                      comment: Y,
                      precedingNode: te,
                      enclosingNode: z,
                      followingNode: j,
                      text: Ce,
                    } = X;
                    return !z || z.type !== "WhileStatement" || !j
                      ? !1
                      : r(Ce, Y, o) === ")"
                      ? (c(te, Y), !0)
                      : j.type === "BlockStatement"
                      ? (_(j, Y), !0)
                      : z.body === j
                      ? (a(j, Y), !0)
                      : !1;
                  }
                  function P(X) {
                    let {
                      comment: Y,
                      precedingNode: te,
                      enclosingNode: z,
                      followingNode: j,
                    } = X;
                    return !z ||
                      (z.type !== "TryStatement" && z.type !== "CatchClause") ||
                      !j
                      ? !1
                      : z.type === "CatchClause" && te
                      ? (c(te, Y), !0)
                      : j.type === "BlockStatement"
                      ? (_(j, Y), !0)
                      : j.type === "TryStatement"
                      ? (O(j.finalizer, Y), !0)
                      : j.type === "CatchClause"
                      ? (O(j.body, Y), !0)
                      : !1;
                  }
                  function G(X) {
                    let { comment: Y, enclosingNode: te, followingNode: z } = X;
                    return B(te) && z && z.type === "Identifier"
                      ? (a(te, Y), !0)
                      : !1;
                  }
                  function re(X) {
                    let {
                        comment: Y,
                        precedingNode: te,
                        enclosingNode: z,
                        followingNode: j,
                        text: Ce,
                      } = X,
                      Ne = te && !u(Ce, o(te), y(Y));
                    return (!te || !Ne) &&
                      z &&
                      (z.type === "ConditionalExpression" ||
                        z.type === "TSConditionalType") &&
                      j
                      ? (a(j, Y), !0)
                      : !1;
                  }
                  function $(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z } = X;
                    return w(z) &&
                      z.shorthand &&
                      z.key === te &&
                      z.value.type === "AssignmentPattern"
                      ? (c(z.value.left, Y), !0)
                      : !1;
                  }
                  function W(X) {
                    let {
                      comment: Y,
                      precedingNode: te,
                      enclosingNode: z,
                      followingNode: j,
                    } = X;
                    if (
                      z &&
                      (z.type === "ClassDeclaration" ||
                        z.type === "ClassExpression" ||
                        z.type === "DeclareClass" ||
                        z.type === "DeclareInterface" ||
                        z.type === "InterfaceDeclaration" ||
                        z.type === "TSInterfaceDeclaration")
                    ) {
                      if (m(z.decorators) && !(j && j.type === "Decorator"))
                        return c(t(z.decorators), Y), !0;
                      if (z.body && j === z.body) return _(z.body, Y), !0;
                      if (j) {
                        if (
                          z.superClass &&
                          j === z.superClass &&
                          te &&
                          (te === z.id || te === z.typeParameters)
                        )
                          return c(te, Y), !0;
                        for (let Ce of ["implements", "extends", "mixins"])
                          if (z[Ce] && j === z[Ce][0])
                            return (
                              te &&
                              (te === z.id ||
                                te === z.typeParameters ||
                                te === z.superClass)
                                ? c(te, Y)
                                : l(z, Y, Ce),
                              !0
                            );
                      }
                    }
                    return !1;
                  }
                  function ee(X) {
                    let {
                      comment: Y,
                      precedingNode: te,
                      enclosingNode: z,
                      text: j,
                    } = X;
                    return (z &&
                      te &&
                      r(j, Y, o) === "(" &&
                      (z.type === "Property" ||
                        z.type === "TSDeclareMethod" ||
                        z.type === "TSAbstractMethodDefinition") &&
                      te.type === "Identifier" &&
                      z.key === te &&
                      r(j, te, o) !== ":") ||
                      (te &&
                        z &&
                        te.type === "Decorator" &&
                        (z.type === "ClassMethod" ||
                          z.type === "ClassProperty" ||
                          z.type === "PropertyDefinition" ||
                          z.type === "TSAbstractPropertyDefinition" ||
                          z.type === "TSAbstractMethodDefinition" ||
                          z.type === "TSDeclareMethod" ||
                          z.type === "MethodDefinition"))
                      ? (c(te, Y), !0)
                      : !1;
                  }
                  function U(X) {
                    let {
                      comment: Y,
                      precedingNode: te,
                      enclosingNode: z,
                      text: j,
                    } = X;
                    return r(j, Y, o) !== "("
                      ? !1
                      : te &&
                        z &&
                        (z.type === "FunctionDeclaration" ||
                          z.type === "FunctionExpression" ||
                          z.type === "ClassMethod" ||
                          z.type === "MethodDefinition" ||
                          z.type === "ObjectMethod")
                      ? (c(te, Y), !0)
                      : !1;
                  }
                  function ne(X) {
                    let { comment: Y, enclosingNode: te, text: z } = X;
                    if (!(te && te.type === "ArrowFunctionExpression"))
                      return !1;
                    let j = C(z, Y, o);
                    return j !== !1 && z.slice(j, j + 2) === "=>"
                      ? (l(te, Y), !0)
                      : !1;
                  }
                  function se(X) {
                    let { comment: Y, enclosingNode: te, text: z } = X;
                    return r(z, Y, o) !== ")"
                      ? !1
                      : te &&
                        ((ce(te) && g(te).length === 0) ||
                          (A(te) && b(te).length === 0))
                      ? (l(te, Y), !0)
                      : te &&
                        (te.type === "MethodDefinition" ||
                          te.type === "TSAbstractMethodDefinition") &&
                        g(te.value).length === 0
                      ? (l(te.value, Y), !0)
                      : !1;
                  }
                  function V(X) {
                    let {
                      comment: Y,
                      precedingNode: te,
                      enclosingNode: z,
                      followingNode: j,
                      text: Ce,
                    } = X;
                    if (
                      (te &&
                        te.type === "FunctionTypeParam" &&
                        z &&
                        z.type === "FunctionTypeAnnotation" &&
                        j &&
                        j.type !== "FunctionTypeParam") ||
                      (te &&
                        (te.type === "Identifier" ||
                          te.type === "AssignmentPattern") &&
                        z &&
                        ce(z) &&
                        r(Ce, Y, o) === ")")
                    )
                      return c(te, Y), !0;
                    if (
                      z &&
                      z.type === "FunctionDeclaration" &&
                      j &&
                      j.type === "BlockStatement"
                    ) {
                      let Ne = (() => {
                        let je = g(z);
                        if (je.length > 0) return i(Ce, o(t(je)));
                        let Ue = i(Ce, o(z.id));
                        return Ue !== !1 && i(Ce, Ue + 1);
                      })();
                      if (y(Y) > Ne) return _(j, Y), !0;
                    }
                    return !1;
                  }
                  function oe(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return te && te.type === "ImportSpecifier"
                      ? (a(te, Y), !0)
                      : !1;
                  }
                  function K(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return te && te.type === "LabeledStatement"
                      ? (a(te, Y), !0)
                      : !1;
                  }
                  function Ee(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return te &&
                      (te.type === "ContinueStatement" ||
                        te.type === "BreakStatement") &&
                      !te.label
                      ? (c(te, Y), !0)
                      : !1;
                  }
                  function q(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z } = X;
                    return v(z) &&
                      te &&
                      z.callee === te &&
                      z.arguments.length > 0
                      ? (a(z.arguments[0], Y), !0)
                      : !1;
                  }
                  function le(X) {
                    let {
                      comment: Y,
                      precedingNode: te,
                      enclosingNode: z,
                      followingNode: j,
                    } = X;
                    return z &&
                      (z.type === "UnionTypeAnnotation" ||
                        z.type === "TSUnionType")
                      ? (p(Y) && ((j.prettierIgnore = !0), (Y.unignore = !0)),
                        te ? (c(te, Y), !0) : !1)
                      : (j &&
                          (j.type === "UnionTypeAnnotation" ||
                            j.type === "TSUnionType") &&
                          p(Y) &&
                          ((j.types[0].prettierIgnore = !0), (Y.unignore = !0)),
                        !1);
                  }
                  function ue(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return w(te) ? (a(te, Y), !0) : !1;
                  }
                  function Q(X) {
                    let {
                      comment: Y,
                      enclosingNode: te,
                      followingNode: z,
                      ast: j,
                      isLastComment: Ce,
                    } = X;
                    return j && j.body && j.body.length === 0
                      ? (Ce ? l(j, Y) : a(j, Y), !0)
                      : te &&
                        te.type === "Program" &&
                        te.body.length === 0 &&
                        !m(te.directives)
                      ? (Ce ? l(te, Y) : a(te, Y), !0)
                      : z &&
                        z.type === "Program" &&
                        z.body.length === 0 &&
                        te &&
                        te.type === "ModuleExpression"
                      ? (l(z, Y), !0)
                      : !1;
                  }
                  function de(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return te &&
                      (te.type === "ForInStatement" ||
                        te.type === "ForOfStatement")
                      ? (a(te, Y), !0)
                      : !1;
                  }
                  function ge(X) {
                    let {
                      comment: Y,
                      precedingNode: te,
                      enclosingNode: z,
                      text: j,
                    } = X;
                    return te &&
                      te.type === "ImportSpecifier" &&
                      z &&
                      z.type === "ImportDeclaration" &&
                      s(j, o(Y))
                      ? (c(te, Y), !0)
                      : !1;
                  }
                  function ve(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return te && te.type === "AssignmentPattern"
                      ? (a(te, Y), !0)
                      : !1;
                  }
                  function xe(X) {
                    let { comment: Y, enclosingNode: te, followingNode: z } = X;
                    return te &&
                      (te.type === "VariableDeclarator" ||
                        te.type === "AssignmentExpression" ||
                        te.type === "TypeAlias" ||
                        te.type === "TSTypeAliasDeclaration") &&
                      z &&
                      (z.type === "ObjectExpression" ||
                        z.type === "ArrayExpression" ||
                        z.type === "TemplateLiteral" ||
                        z.type === "TaggedTemplateExpression" ||
                        z.type === "ObjectTypeAnnotation" ||
                        z.type === "TSTypeLiteral" ||
                        x(Y))
                      ? (a(z, Y), !0)
                      : !1;
                  }
                  function we(X) {
                    let {
                      comment: Y,
                      enclosingNode: te,
                      followingNode: z,
                      text: j,
                    } = X;
                    return !z &&
                      te &&
                      (te.type === "TSMethodSignature" ||
                        te.type === "TSDeclareFunction" ||
                        te.type === "TSAbstractMethodDefinition") &&
                      r(j, Y, o) === ";"
                      ? (c(te, Y), !0)
                      : !1;
                  }
                  function fe(X) {
                    let { comment: Y, enclosingNode: te, followingNode: z } = X;
                    if (
                      p(Y) &&
                      te &&
                      te.type === "TSMappedType" &&
                      z &&
                      z.type === "TSTypeParameter" &&
                      z.constraint
                    )
                      return (te.prettierIgnore = !0), (Y.unignore = !0), !0;
                  }
                  function pe(X) {
                    let {
                      comment: Y,
                      precedingNode: te,
                      enclosingNode: z,
                      followingNode: j,
                    } = X;
                    return !z || z.type !== "TSMappedType"
                      ? !1
                      : j && j.type === "TSTypeParameter" && j.name
                      ? (a(j.name, Y), !0)
                      : te && te.type === "TSTypeParameter" && te.constraint
                      ? (c(te.constraint, Y), !0)
                      : !1;
                  }
                  function me(X) {
                    let { comment: Y, enclosingNode: te, followingNode: z } = X;
                    return !te || te.type !== "SwitchCase" || te.test
                      ? !1
                      : (z.type === "BlockStatement" && I(Y)
                          ? _(z, Y)
                          : l(te, Y),
                        !0);
                  }
                  function ce(X) {
                    return (
                      X.type === "ArrowFunctionExpression" ||
                      X.type === "FunctionExpression" ||
                      X.type === "FunctionDeclaration" ||
                      X.type === "ObjectMethod" ||
                      X.type === "ClassMethod" ||
                      X.type === "TSDeclareFunction" ||
                      X.type === "TSCallSignatureDeclaration" ||
                      X.type === "TSConstructSignatureDeclaration" ||
                      X.type === "TSMethodSignature" ||
                      X.type === "TSConstructorType" ||
                      X.type === "TSFunctionType" ||
                      X.type === "TSDeclareMethod"
                    );
                  }
                  function he(X, Y) {
                    if (
                      (Y.parser === "typescript" ||
                        Y.parser === "flow" ||
                        Y.parser === "acorn" ||
                        Y.parser === "espree" ||
                        Y.parser === "meriyah" ||
                        Y.parser === "__babel_estree") &&
                      X.type === "MethodDefinition" &&
                      X.value &&
                      X.value.type === "FunctionExpression" &&
                      g(X.value).length === 0 &&
                      !X.value.returnType &&
                      !m(X.value.typeParameters) &&
                      X.value.body
                    )
                      return [...(X.decorators || []), X.key, X.value.body];
                  }
                  function J(X) {
                    return (
                      x(X) && X.value[0] === "*" && /@type\b/.test(X.value)
                    );
                  }
                  function ye(X) {
                    let Y = X.getValue(),
                      te = X.getParentNode(),
                      z = (j) => N(E(j, D.Leading)) || N(E(j, D.Trailing));
                    return (
                      ((Y && (f(Y) || h(Y) || (v(te) && z(Y)))) ||
                        (te &&
                          (te.type === "JSXSpreadAttribute" ||
                            te.type === "JSXSpreadChild" ||
                            te.type === "UnionTypeAnnotation" ||
                            te.type === "TSUnionType" ||
                            ((te.type === "ClassDeclaration" ||
                              te.type === "ClassExpression") &&
                              te.superClass === Y)))) &&
                      (!T(X) ||
                        te.type === "UnionTypeAnnotation" ||
                        te.type === "TSUnionType")
                    );
                  }
                  n.exports = {
                    handleOwnLineComment: F,
                    handleEndOfLineComment: S,
                    handleRemainingComment: k,
                    isTypeCastComment: J,
                    getCommentChildNodes: he,
                    willPrintOwnComments: ye,
                  };
                },
              }),
              kt = Z({
                "src/language-js/needs-parens.js"(e, n) {
                  "use strict";
                  ae();
                  var t = st(),
                    s = Rn(),
                    {
                      getFunctionParameters: i,
                      getLeftSidePathName: r,
                      hasFlowShorthandAnnotationComment: u,
                      hasNakedLeftSide: a,
                      hasNode: c,
                      isBitwiseOperator: l,
                      startsWithNoLookaheadToken: C,
                      shouldFlatten: m,
                      getPrecedence: g,
                      isCallExpression: p,
                      isMemberExpression: f,
                      isObjectProperty: h,
                    } = Xe();
                  function N(I, E) {
                    let D = I.getParentNode();
                    if (!D) return !1;
                    let d = I.getName(),
                      y = I.getNode();
                    if (
                      E.__isInHtmlInterpolation &&
                      !E.bracketSpacing &&
                      v(y) &&
                      B(I)
                    )
                      return !0;
                    if (T(y)) return !1;
                    if (E.parser !== "flow" && u(I.getValue())) return !0;
                    if (y.type === "Identifier")
                      return !!(
                        (y.extra &&
                          y.extra.parenthesized &&
                          /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(
                            y.name
                          )) ||
                        (d === "left" &&
                          y.name === "async" &&
                          D.type === "ForOfStatement" &&
                          !D.await)
                      );
                    switch (D.type) {
                      case "ParenthesizedExpression":
                        return !1;
                      case "ClassDeclaration":
                      case "ClassExpression": {
                        if (
                          d === "superClass" &&
                          (y.type === "ArrowFunctionExpression" ||
                            y.type === "AssignmentExpression" ||
                            y.type === "AwaitExpression" ||
                            y.type === "BinaryExpression" ||
                            y.type === "ConditionalExpression" ||
                            y.type === "LogicalExpression" ||
                            y.type === "NewExpression" ||
                            y.type === "ObjectExpression" ||
                            y.type === "SequenceExpression" ||
                            y.type === "TaggedTemplateExpression" ||
                            y.type === "UnaryExpression" ||
                            y.type === "UpdateExpression" ||
                            y.type === "YieldExpression" ||
                            y.type === "TSNonNullExpression")
                        )
                          return !0;
                        break;
                      }
                      case "ExportDefaultDeclaration":
                        return w(I, E) || y.type === "SequenceExpression";
                      case "Decorator": {
                        if (d === "expression") {
                          let o = !1,
                            x = !1,
                            F = y;
                          for (; F; )
                            switch (F.type) {
                              case "MemberExpression":
                                (x = !0), (F = F.object);
                                break;
                              case "CallExpression":
                                if (x || o) return E.parser !== "typescript";
                                (o = !0), (F = F.callee);
                                break;
                              case "Identifier":
                                return !1;
                              case "TaggedTemplateExpression":
                                return E.parser !== "typescript";
                              default:
                                return !0;
                            }
                          return !0;
                        }
                        break;
                      }
                      case "ExpressionStatement": {
                        if (C(y, !0)) return !0;
                        break;
                      }
                      case "ArrowFunctionExpression": {
                        if (
                          d === "body" &&
                          y.type !== "SequenceExpression" &&
                          C(y, !1)
                        )
                          return !0;
                        break;
                      }
                    }
                    switch (y.type) {
                      case "UpdateExpression":
                        if (D.type === "UnaryExpression")
                          return (
                            y.prefix &&
                            ((y.operator === "++" && D.operator === "+") ||
                              (y.operator === "--" && D.operator === "-"))
                          );
                      case "UnaryExpression":
                        switch (D.type) {
                          case "UnaryExpression":
                            return (
                              y.operator === D.operator &&
                              (y.operator === "+" || y.operator === "-")
                            );
                          case "BindExpression":
                            return !0;
                          case "MemberExpression":
                          case "OptionalMemberExpression":
                            return d === "object";
                          case "TaggedTemplateExpression":
                            return !0;
                          case "NewExpression":
                          case "CallExpression":
                          case "OptionalCallExpression":
                            return d === "callee";
                          case "BinaryExpression":
                            return d === "left" && D.operator === "**";
                          case "TSNonNullExpression":
                            return !0;
                          default:
                            return !1;
                        }
                      case "BinaryExpression": {
                        if (
                          D.type === "UpdateExpression" ||
                          (y.operator === "in" && A(I))
                        )
                          return !0;
                        if (
                          y.operator === "|>" &&
                          y.extra &&
                          y.extra.parenthesized
                        ) {
                          let o = I.getParentNode(1);
                          if (
                            o.type === "BinaryExpression" &&
                            o.operator === "|>"
                          )
                            return !0;
                        }
                      }
                      case "TSTypeAssertion":
                      case "TSAsExpression":
                      case "LogicalExpression":
                        switch (D.type) {
                          case "TSAsExpression":
                            return y.type !== "TSAsExpression";
                          case "ConditionalExpression":
                            return y.type === "TSAsExpression";
                          case "CallExpression":
                          case "NewExpression":
                          case "OptionalCallExpression":
                            return d === "callee";
                          case "ClassExpression":
                          case "ClassDeclaration":
                            return d === "superClass";
                          case "TSTypeAssertion":
                          case "TaggedTemplateExpression":
                          case "UnaryExpression":
                          case "JSXSpreadAttribute":
                          case "SpreadElement":
                          case "SpreadProperty":
                          case "BindExpression":
                          case "AwaitExpression":
                          case "TSNonNullExpression":
                          case "UpdateExpression":
                            return !0;
                          case "MemberExpression":
                          case "OptionalMemberExpression":
                            return d === "object";
                          case "AssignmentExpression":
                          case "AssignmentPattern":
                            return (
                              d === "left" &&
                              (y.type === "TSTypeAssertion" ||
                                y.type === "TSAsExpression")
                            );
                          case "LogicalExpression":
                            if (y.type === "LogicalExpression")
                              return D.operator !== y.operator;
                          case "BinaryExpression": {
                            let { operator: o, type: x } = y;
                            if (!o && x !== "TSTypeAssertion") return !0;
                            let F = g(o),
                              S = D.operator,
                              k = g(S);
                            return k > F ||
                              (d === "right" && k === F) ||
                              (k === F && !m(S, o))
                              ? !0
                              : k < F && o === "%"
                              ? S === "+" || S === "-"
                              : !!l(S);
                          }
                          default:
                            return !1;
                        }
                      case "SequenceExpression":
                        switch (D.type) {
                          case "ReturnStatement":
                            return !1;
                          case "ForStatement":
                            return !1;
                          case "ExpressionStatement":
                            return d !== "expression";
                          case "ArrowFunctionExpression":
                            return d !== "body";
                          default:
                            return !0;
                        }
                      case "YieldExpression":
                        if (
                          D.type === "UnaryExpression" ||
                          D.type === "AwaitExpression" ||
                          D.type === "TSAsExpression" ||
                          D.type === "TSNonNullExpression"
                        )
                          return !0;
                      case "AwaitExpression":
                        switch (D.type) {
                          case "TaggedTemplateExpression":
                          case "UnaryExpression":
                          case "LogicalExpression":
                          case "SpreadElement":
                          case "SpreadProperty":
                          case "TSAsExpression":
                          case "TSNonNullExpression":
                          case "BindExpression":
                            return !0;
                          case "MemberExpression":
                          case "OptionalMemberExpression":
                            return d === "object";
                          case "NewExpression":
                          case "CallExpression":
                          case "OptionalCallExpression":
                            return d === "callee";
                          case "ConditionalExpression":
                            return d === "test";
                          case "BinaryExpression":
                            return !(!y.argument && D.operator === "|>");
                          default:
                            return !1;
                        }
                      case "TSConditionalType":
                        if (
                          d === "extendsType" &&
                          D.type === "TSConditionalType"
                        )
                          return !0;
                      case "TSFunctionType":
                      case "TSConstructorType":
                        if (d === "checkType" && D.type === "TSConditionalType")
                          return !0;
                      case "TSUnionType":
                      case "TSIntersectionType":
                        if (
                          (D.type === "TSUnionType" ||
                            D.type === "TSIntersectionType") &&
                          D.types.length > 1 &&
                          (!y.types || y.types.length > 1)
                        )
                          return !0;
                      case "TSInferType":
                        if (y.type === "TSInferType" && D.type === "TSRestType")
                          return !1;
                      case "TSTypeOperator":
                        return (
                          D.type === "TSArrayType" ||
                          D.type === "TSOptionalType" ||
                          D.type === "TSRestType" ||
                          (d === "objectType" &&
                            D.type === "TSIndexedAccessType") ||
                          D.type === "TSTypeOperator" ||
                          (D.type === "TSTypeAnnotation" &&
                            I.getParentNode(1).type.startsWith("TSJSDoc"))
                        );
                      case "ArrayTypeAnnotation":
                        return D.type === "NullableTypeAnnotation";
                      case "IntersectionTypeAnnotation":
                      case "UnionTypeAnnotation":
                        return (
                          D.type === "ArrayTypeAnnotation" ||
                          D.type === "NullableTypeAnnotation" ||
                          D.type === "IntersectionTypeAnnotation" ||
                          D.type === "UnionTypeAnnotation" ||
                          (d === "objectType" &&
                            (D.type === "IndexedAccessType" ||
                              D.type === "OptionalIndexedAccessType"))
                        );
                      case "NullableTypeAnnotation":
                        return (
                          D.type === "ArrayTypeAnnotation" ||
                          (d === "objectType" &&
                            (D.type === "IndexedAccessType" ||
                              D.type === "OptionalIndexedAccessType"))
                        );
                      case "FunctionTypeAnnotation": {
                        let o =
                          D.type === "NullableTypeAnnotation"
                            ? I.getParentNode(1)
                            : D;
                        return (
                          o.type === "UnionTypeAnnotation" ||
                          o.type === "IntersectionTypeAnnotation" ||
                          o.type === "ArrayTypeAnnotation" ||
                          (d === "objectType" &&
                            (o.type === "IndexedAccessType" ||
                              o.type === "OptionalIndexedAccessType")) ||
                          o.type === "NullableTypeAnnotation" ||
                          (D.type === "FunctionTypeParam" &&
                            D.name === null &&
                            i(y).some(
                              (x) =>
                                x.typeAnnotation &&
                                x.typeAnnotation.type ===
                                  "NullableTypeAnnotation"
                            ))
                        );
                      }
                      case "OptionalIndexedAccessType":
                        return (
                          d === "objectType" && D.type === "IndexedAccessType"
                        );
                      case "TypeofTypeAnnotation":
                        return (
                          d === "objectType" &&
                          (D.type === "IndexedAccessType" ||
                            D.type === "OptionalIndexedAccessType")
                        );
                      case "StringLiteral":
                      case "NumericLiteral":
                      case "Literal":
                        if (
                          typeof y.value == "string" &&
                          D.type === "ExpressionStatement" &&
                          !D.directive
                        ) {
                          let o = I.getParentNode(1);
                          return (
                            o.type === "Program" || o.type === "BlockStatement"
                          );
                        }
                        return (
                          d === "object" &&
                          D.type === "MemberExpression" &&
                          typeof y.value == "number"
                        );
                      case "AssignmentExpression": {
                        let o = I.getParentNode(1);
                        return d === "body" &&
                          D.type === "ArrowFunctionExpression"
                          ? !0
                          : (d === "key" &&
                              (D.type === "ClassProperty" ||
                                D.type === "PropertyDefinition") &&
                              D.computed) ||
                            ((d === "init" || d === "update") &&
                              D.type === "ForStatement")
                          ? !1
                          : D.type === "ExpressionStatement"
                          ? y.left.type === "ObjectPattern"
                          : !(
                              (d === "key" &&
                                D.type === "TSPropertySignature") ||
                              D.type === "AssignmentExpression" ||
                              (D.type === "SequenceExpression" &&
                                o &&
                                o.type === "ForStatement" &&
                                (o.init === D || o.update === D)) ||
                              (d === "value" &&
                                D.type === "Property" &&
                                o &&
                                o.type === "ObjectPattern" &&
                                o.properties.includes(D)) ||
                              D.type === "NGChainedExpression"
                            );
                      }
                      case "ConditionalExpression":
                        switch (D.type) {
                          case "TaggedTemplateExpression":
                          case "UnaryExpression":
                          case "SpreadElement":
                          case "SpreadProperty":
                          case "BinaryExpression":
                          case "LogicalExpression":
                          case "NGPipeExpression":
                          case "ExportDefaultDeclaration":
                          case "AwaitExpression":
                          case "JSXSpreadAttribute":
                          case "TSTypeAssertion":
                          case "TypeCastExpression":
                          case "TSAsExpression":
                          case "TSNonNullExpression":
                            return !0;
                          case "NewExpression":
                          case "CallExpression":
                          case "OptionalCallExpression":
                            return d === "callee";
                          case "ConditionalExpression":
                            return d === "test";
                          case "MemberExpression":
                          case "OptionalMemberExpression":
                            return d === "object";
                          default:
                            return !1;
                        }
                      case "FunctionExpression":
                        switch (D.type) {
                          case "NewExpression":
                          case "CallExpression":
                          case "OptionalCallExpression":
                            return d === "callee";
                          case "TaggedTemplateExpression":
                            return !0;
                          default:
                            return !1;
                        }
                      case "ArrowFunctionExpression":
                        switch (D.type) {
                          case "BinaryExpression":
                            return (
                              D.operator !== "|>" ||
                              (y.extra && y.extra.parenthesized)
                            );
                          case "NewExpression":
                          case "CallExpression":
                          case "OptionalCallExpression":
                            return d === "callee";
                          case "MemberExpression":
                          case "OptionalMemberExpression":
                            return d === "object";
                          case "TSAsExpression":
                          case "TSNonNullExpression":
                          case "BindExpression":
                          case "TaggedTemplateExpression":
                          case "UnaryExpression":
                          case "LogicalExpression":
                          case "AwaitExpression":
                          case "TSTypeAssertion":
                            return !0;
                          case "ConditionalExpression":
                            return d === "test";
                          default:
                            return !1;
                        }
                      case "ClassExpression":
                        if (s(y.decorators)) return !0;
                        switch (D.type) {
                          case "NewExpression":
                            return d === "callee";
                          default:
                            return !1;
                        }
                      case "OptionalMemberExpression":
                      case "OptionalCallExpression": {
                        let o = I.getParentNode(1);
                        if (
                          (d === "object" && D.type === "MemberExpression") ||
                          (d === "callee" &&
                            (D.type === "CallExpression" ||
                              D.type === "NewExpression")) ||
                          (D.type === "TSNonNullExpression" &&
                            o.type === "MemberExpression" &&
                            o.object === D)
                        )
                          return !0;
                      }
                      case "CallExpression":
                      case "MemberExpression":
                      case "TaggedTemplateExpression":
                      case "TSNonNullExpression":
                        if (
                          d === "callee" &&
                          (D.type === "BindExpression" ||
                            D.type === "NewExpression")
                        ) {
                          let o = y;
                          for (; o; )
                            switch (o.type) {
                              case "CallExpression":
                              case "OptionalCallExpression":
                                return !0;
                              case "MemberExpression":
                              case "OptionalMemberExpression":
                              case "BindExpression":
                                o = o.object;
                                break;
                              case "TaggedTemplateExpression":
                                o = o.tag;
                                break;
                              case "TSNonNullExpression":
                                o = o.expression;
                                break;
                              default:
                                return !1;
                            }
                        }
                        return !1;
                      case "BindExpression":
                        return (
                          (d === "callee" &&
                            (D.type === "BindExpression" ||
                              D.type === "NewExpression")) ||
                          (d === "object" && f(D))
                        );
                      case "NGPipeExpression":
                        return !(
                          D.type === "NGRoot" ||
                          D.type === "NGMicrosyntaxExpression" ||
                          (D.type === "ObjectProperty" &&
                            !(y.extra && y.extra.parenthesized)) ||
                          D.type === "ArrayExpression" ||
                          (p(D) && D.arguments[d] === y) ||
                          (d === "right" && D.type === "NGPipeExpression") ||
                          (d === "property" && D.type === "MemberExpression") ||
                          D.type === "AssignmentExpression"
                        );
                      case "JSXFragment":
                      case "JSXElement":
                        return (
                          d === "callee" ||
                          (d === "left" &&
                            D.type === "BinaryExpression" &&
                            D.operator === "<") ||
                          (D.type !== "ArrayExpression" &&
                            D.type !== "ArrowFunctionExpression" &&
                            D.type !== "AssignmentExpression" &&
                            D.type !== "AssignmentPattern" &&
                            D.type !== "BinaryExpression" &&
                            D.type !== "NewExpression" &&
                            D.type !== "ConditionalExpression" &&
                            D.type !== "ExpressionStatement" &&
                            D.type !== "JsExpressionRoot" &&
                            D.type !== "JSXAttribute" &&
                            D.type !== "JSXElement" &&
                            D.type !== "JSXExpressionContainer" &&
                            D.type !== "JSXFragment" &&
                            D.type !== "LogicalExpression" &&
                            !p(D) &&
                            !h(D) &&
                            D.type !== "ReturnStatement" &&
                            D.type !== "ThrowStatement" &&
                            D.type !== "TypeCastExpression" &&
                            D.type !== "VariableDeclarator" &&
                            D.type !== "YieldExpression")
                        );
                      case "TypeAnnotation":
                        return (
                          d === "returnType" &&
                          D.type === "ArrowFunctionExpression" &&
                          b(y)
                        );
                    }
                    return !1;
                  }
                  function T(I) {
                    return (
                      I.type === "BlockStatement" ||
                      I.type === "BreakStatement" ||
                      I.type === "ClassBody" ||
                      I.type === "ClassDeclaration" ||
                      I.type === "ClassMethod" ||
                      I.type === "ClassProperty" ||
                      I.type === "PropertyDefinition" ||
                      I.type === "ClassPrivateProperty" ||
                      I.type === "ContinueStatement" ||
                      I.type === "DebuggerStatement" ||
                      I.type === "DeclareClass" ||
                      I.type === "DeclareExportAllDeclaration" ||
                      I.type === "DeclareExportDeclaration" ||
                      I.type === "DeclareFunction" ||
                      I.type === "DeclareInterface" ||
                      I.type === "DeclareModule" ||
                      I.type === "DeclareModuleExports" ||
                      I.type === "DeclareVariable" ||
                      I.type === "DoWhileStatement" ||
                      I.type === "EnumDeclaration" ||
                      I.type === "ExportAllDeclaration" ||
                      I.type === "ExportDefaultDeclaration" ||
                      I.type === "ExportNamedDeclaration" ||
                      I.type === "ExpressionStatement" ||
                      I.type === "ForInStatement" ||
                      I.type === "ForOfStatement" ||
                      I.type === "ForStatement" ||
                      I.type === "FunctionDeclaration" ||
                      I.type === "IfStatement" ||
                      I.type === "ImportDeclaration" ||
                      I.type === "InterfaceDeclaration" ||
                      I.type === "LabeledStatement" ||
                      I.type === "MethodDefinition" ||
                      I.type === "ReturnStatement" ||
                      I.type === "SwitchStatement" ||
                      I.type === "ThrowStatement" ||
                      I.type === "TryStatement" ||
                      I.type === "TSDeclareFunction" ||
                      I.type === "TSEnumDeclaration" ||
                      I.type === "TSImportEqualsDeclaration" ||
                      I.type === "TSInterfaceDeclaration" ||
                      I.type === "TSModuleDeclaration" ||
                      I.type === "TSNamespaceExportDeclaration" ||
                      I.type === "TypeAlias" ||
                      I.type === "VariableDeclaration" ||
                      I.type === "WhileStatement" ||
                      I.type === "WithStatement"
                    );
                  }
                  function A(I) {
                    let E = 0,
                      D = I.getValue();
                    for (; D; ) {
                      let d = I.getParentNode(E++);
                      if (d && d.type === "ForStatement" && d.init === D)
                        return !0;
                      D = d;
                    }
                    return !1;
                  }
                  function b(I) {
                    return c(
                      I,
                      (E) =>
                        (E.type === "ObjectTypeAnnotation" &&
                          c(
                            E,
                            (D) => D.type === "FunctionTypeAnnotation" || void 0
                          )) ||
                        void 0
                    );
                  }
                  function v(I) {
                    switch (I.type) {
                      case "ObjectExpression":
                        return !0;
                      default:
                        return !1;
                    }
                  }
                  function B(I) {
                    let E = I.getValue(),
                      D = I.getParentNode(),
                      d = I.getName();
                    switch (D.type) {
                      case "NGPipeExpression":
                        if (
                          typeof d == "number" &&
                          D.arguments[d] === E &&
                          D.arguments.length - 1 === d
                        )
                          return I.callParent(B);
                        break;
                      case "ObjectProperty":
                        if (d === "value") {
                          let y = I.getParentNode(1);
                          return t(y.properties) === D;
                        }
                        break;
                      case "BinaryExpression":
                      case "LogicalExpression":
                        if (d === "right") return I.callParent(B);
                        break;
                      case "ConditionalExpression":
                        if (d === "alternate") return I.callParent(B);
                        break;
                      case "UnaryExpression":
                        if (D.prefix) return I.callParent(B);
                        break;
                    }
                    return !1;
                  }
                  function w(I, E) {
                    let D = I.getValue(),
                      d = I.getParentNode();
                    return D.type === "FunctionExpression" ||
                      D.type === "ClassExpression"
                      ? d.type === "ExportDefaultDeclaration" || !N(I, E)
                      : !a(D) ||
                        (d.type !== "ExportDefaultDeclaration" && N(I, E))
                      ? !1
                      : I.call((y) => w(y, E), ...r(I, D));
                  }
                  n.exports = N;
                },
              }),
              ro = Z({
                "src/language-js/print-preprocess.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s, i) {
                    switch (i.parser) {
                      case "json":
                      case "json5":
                      case "json-stringify":
                      case "__js_expression":
                      case "__vue_expression":
                        return Object.assign(
                          Object.assign({}, s),
                          {},
                          {
                            type: i.parser.startsWith("__")
                              ? "JsExpressionRoot"
                              : "JsonRoot",
                            node: s,
                            comments: [],
                            rootMarker: i.rootMarker,
                          }
                        );
                      default:
                        return s;
                    }
                  }
                  n.exports = t;
                },
              }),
              bm = Z({
                "src/language-js/print/html-binding.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                    builders: {
                      join: t,
                      line: s,
                      group: i,
                      softline: r,
                      indent: u,
                    },
                  } = Le();
                  function a(l, C, m) {
                    let g = l.getValue();
                    if (
                      (C.__onHtmlBindingRoot &&
                        l.getName() === null &&
                        C.__onHtmlBindingRoot(g, C),
                      g.type === "File")
                    ) {
                      if (C.__isVueForBindingLeft)
                        return l.call(
                          (p) => {
                            let f = t([",", s], p.map(m, "params")),
                              { params: h } = p.getValue();
                            return h.length === 1
                              ? f
                              : ["(", u([r, i(f)]), r, ")"];
                          },
                          "program",
                          "body",
                          0
                        );
                      if (C.__isVueBindings)
                        return l.call(
                          (p) => t([",", s], p.map(m, "params")),
                          "program",
                          "body",
                          0
                        );
                    }
                  }
                  function c(l) {
                    switch (l.type) {
                      case "MemberExpression":
                        switch (l.property.type) {
                          case "Identifier":
                          case "NumericLiteral":
                          case "StringLiteral":
                            return c(l.object);
                        }
                        return !1;
                      case "Identifier":
                        return !0;
                      default:
                        return !1;
                    }
                  }
                  n.exports = {
                    isVueEventBindingExpression: c,
                    printHtmlBinding: a,
                  };
                },
              }),
              Jn = Z({
                "src/language-js/print/binaryish.js"(e, n) {
                  "use strict";
                  ae();
                  var { printComments: t } = Qe(),
                    { getLast: s } = Ge(),
                    {
                      builders: {
                        join: i,
                        line: r,
                        softline: u,
                        group: a,
                        indent: c,
                        align: l,
                        ifBreak: C,
                        indentIfBreak: m,
                      },
                      utils: { cleanDoc: g, getDocParts: p, isConcat: f },
                    } = Le(),
                    {
                      hasLeadingOwnLineComment: h,
                      isBinaryish: N,
                      isJsxNode: T,
                      shouldFlatten: A,
                      hasComment: b,
                      CommentCheckFlags: v,
                      isCallExpression: B,
                      isMemberExpression: w,
                      isObjectProperty: I,
                      isEnabledHackPipeline: E,
                    } = Xe(),
                    D = 0;
                  function d(x, F, S) {
                    let k = x.getValue(),
                      _ = x.getParentNode(),
                      O = x.getParentNode(1),
                      R =
                        k !== _.body &&
                        (_.type === "IfStatement" ||
                          _.type === "WhileStatement" ||
                          _.type === "SwitchStatement" ||
                          _.type === "DoWhileStatement"),
                      M = E(F) && k.operator === "|>",
                      H = y(x, S, F, !1, R);
                    if (R) return H;
                    if (M) return a(H);
                    if (
                      (B(_) && _.callee === k) ||
                      _.type === "UnaryExpression" ||
                      (w(_) && !_.computed)
                    )
                      return a([c([u, ...H]), u]);
                    let P =
                        _.type === "ReturnStatement" ||
                        _.type === "ThrowStatement" ||
                        (_.type === "JSXExpressionContainer" &&
                          O.type === "JSXAttribute") ||
                        (k.operator !== "|" && _.type === "JsExpressionRoot") ||
                        (k.type !== "NGPipeExpression" &&
                          ((_.type === "NGRoot" &&
                            F.parser === "__ng_binding") ||
                            (_.type === "NGMicrosyntaxExpression" &&
                              O.type === "NGMicrosyntax" &&
                              O.body.length === 1))) ||
                        (k === _.body &&
                          _.type === "ArrowFunctionExpression") ||
                        (k !== _.body && _.type === "ForStatement") ||
                        (_.type === "ConditionalExpression" &&
                          O.type !== "ReturnStatement" &&
                          O.type !== "ThrowStatement" &&
                          !B(O)) ||
                        _.type === "TemplateLiteral",
                      G =
                        _.type === "AssignmentExpression" ||
                        _.type === "VariableDeclarator" ||
                        _.type === "ClassProperty" ||
                        _.type === "PropertyDefinition" ||
                        _.type === "TSAbstractPropertyDefinition" ||
                        _.type === "ClassPrivateProperty" ||
                        I(_),
                      re = N(k.left) && A(k.operator, k.left.operator);
                    if (P || (o(k) && !re) || (!o(k) && G)) return a(H);
                    if (H.length === 0) return "";
                    let $ = T(k.right),
                      W = H.findIndex(
                        (oe) =>
                          typeof oe != "string" &&
                          !Array.isArray(oe) &&
                          oe.type === "group"
                      ),
                      ee = H.slice(0, W === -1 ? 1 : W + 1),
                      U = H.slice(ee.length, $ ? -1 : void 0),
                      ne = Symbol("logicalChain-" + ++D),
                      se = a([...ee, c(U)], { id: ne });
                    if (!$) return se;
                    let V = s(H);
                    return a([se, m(V, { groupId: ne })]);
                  }
                  function y(x, F, S, k, _) {
                    let O = x.getValue();
                    if (!N(O)) return [a(F())];
                    let R = [];
                    A(O.operator, O.left.operator)
                      ? (R = x.call((U) => y(U, F, S, !0, _), "left"))
                      : R.push(a(F("left")));
                    let M = o(O),
                      H =
                        (O.operator === "|>" ||
                          O.type === "NGPipeExpression" ||
                          (O.operator === "|" &&
                            S.parser === "__vue_expression")) &&
                        !h(S.originalText, O.right),
                      P = O.type === "NGPipeExpression" ? "|" : O.operator,
                      G =
                        O.type === "NGPipeExpression" && O.arguments.length > 0
                          ? a(
                              c([
                                u,
                                ": ",
                                i(
                                  [u, ":", C(" ")],
                                  x.map(F, "arguments").map((U) => l(2, a(U)))
                                ),
                              ])
                            )
                          : "",
                      re;
                    if (M) re = [P, " ", F("right"), G];
                    else {
                      let ne =
                        E(S) && P === "|>"
                          ? x.call((se) => y(se, F, S, !0, _), "right")
                          : F("right");
                      re = [H ? r : "", P, H ? " " : r, ne, G];
                    }
                    let $ = x.getParentNode(),
                      W = b(O.left, v.Trailing | v.Line),
                      ee =
                        W ||
                        (!(_ && O.type === "LogicalExpression") &&
                          $.type !== O.type &&
                          O.left.type !== O.type &&
                          O.right.type !== O.type);
                    if (
                      (R.push(
                        H ? "" : " ",
                        ee ? a(re, { shouldBreak: W }) : re
                      ),
                      k && b(O))
                    ) {
                      let U = g(t(x, R, S));
                      return f(U) || U.type === "fill" ? p(U) : [U];
                    }
                    return R;
                  }
                  function o(x) {
                    return x.type !== "LogicalExpression"
                      ? !1
                      : !!(
                          (x.right.type === "ObjectExpression" &&
                            x.right.properties.length > 0) ||
                          (x.right.type === "ArrayExpression" &&
                            x.right.elements.length > 0) ||
                          T(x.right)
                        );
                  }
                  n.exports = {
                    printBinaryishExpression: d,
                    shouldInlineLogicalExpression: o,
                  };
                },
              }),
              Tm = Z({
                "src/language-js/print/angular.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: { join: t, line: s, group: i },
                    } = Le(),
                    { hasNode: r, hasComment: u, getComments: a } = Xe(),
                    { printBinaryishExpression: c } = Jn();
                  function l(g, p, f) {
                    let h = g.getValue();
                    if (!!h.type.startsWith("NG"))
                      switch (h.type) {
                        case "NGRoot":
                          return [
                            f("node"),
                            u(h.node)
                              ? " //" + a(h.node)[0].value.trimEnd()
                              : "",
                          ];
                        case "NGPipeExpression":
                          return c(g, p, f);
                        case "NGChainedExpression":
                          return i(
                            t(
                              [";", s],
                              g.map(
                                (N) => (m(N) ? f() : ["(", f(), ")"]),
                                "expressions"
                              )
                            )
                          );
                        case "NGEmptyExpression":
                          return "";
                        case "NGQuotedExpression":
                          return [h.prefix, ": ", h.value.trim()];
                        case "NGMicrosyntax":
                          return g.map(
                            (N, T) => [
                              T === 0
                                ? ""
                                : C(N.getValue(), T, h)
                                ? " "
                                : [";", s],
                              f(),
                            ],
                            "body"
                          );
                        case "NGMicrosyntaxKey":
                          return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(
                            h.name
                          )
                            ? h.name
                            : JSON.stringify(h.name);
                        case "NGMicrosyntaxExpression":
                          return [
                            f("expression"),
                            h.alias === null ? "" : [" as ", f("alias")],
                          ];
                        case "NGMicrosyntaxKeyedExpression": {
                          let N = g.getName(),
                            T = g.getParentNode(),
                            A =
                              C(h, N, T) ||
                              (((N === 1 &&
                                (h.key.name === "then" ||
                                  h.key.name === "else")) ||
                                (N === 2 &&
                                  h.key.name === "else" &&
                                  T.body[N - 1].type ===
                                    "NGMicrosyntaxKeyedExpression" &&
                                  T.body[N - 1].key.name === "then")) &&
                                T.body[0].type === "NGMicrosyntaxExpression");
                          return [f("key"), A ? " " : ": ", f("expression")];
                        }
                        case "NGMicrosyntaxLet":
                          return [
                            "let ",
                            f("key"),
                            h.value === null ? "" : [" = ", f("value")],
                          ];
                        case "NGMicrosyntaxAs":
                          return [f("key"), " as ", f("alias")];
                        default:
                          throw new Error(
                            "Unknown Angular node type: ".concat(
                              JSON.stringify(h.type),
                              "."
                            )
                          );
                      }
                  }
                  function C(g, p, f) {
                    return (
                      g.type === "NGMicrosyntaxKeyedExpression" &&
                      g.key.name === "of" &&
                      p === 1 &&
                      f.body[0].type === "NGMicrosyntaxLet" &&
                      f.body[0].value === null
                    );
                  }
                  function m(g) {
                    return r(g.getValue(), (p) => {
                      switch (p.type) {
                        case void 0:
                          return !1;
                        case "CallExpression":
                        case "OptionalCallExpression":
                        case "AssignmentExpression":
                          return !0;
                      }
                    });
                  }
                  n.exports = { printAngular: l };
                },
              }),
              Bm = Z({
                "src/language-js/print/jsx.js"(e, n) {
                  "use strict";
                  ae();
                  var { printComments: t, printDanglingComments: s } = Qe(),
                    {
                      builders: {
                        line: i,
                        hardline: r,
                        softline: u,
                        group: a,
                        indent: c,
                        conditionalGroup: l,
                        fill: C,
                        ifBreak: m,
                        lineSuffixBoundary: g,
                        join: p,
                      },
                      utils: { willBreak: f },
                    } = Le(),
                    { getLast: h, getPreferredQuote: N } = Ge(),
                    {
                      isJsxNode: T,
                      rawText: A,
                      isLiteral: b,
                      isCallExpression: v,
                      isStringLiteral: B,
                      isBinaryish: w,
                      hasComment: I,
                      CommentCheckFlags: E,
                      hasNodeIgnoreComment: D,
                    } = Xe(),
                    d = kt(),
                    { willPrintOwnComments: y } = to(),
                    o = (q) => q === "" || q === i || q === r || q === u;
                  function x(q, le, ue) {
                    let Q = q.getValue();
                    if (Q.type === "JSXElement" && V(Q))
                      return [ue("openingElement"), ue("closingElement")];
                    let de =
                        Q.type === "JSXElement"
                          ? ue("openingElement")
                          : ue("openingFragment"),
                      ge =
                        Q.type === "JSXElement"
                          ? ue("closingElement")
                          : ue("closingFragment");
                    if (
                      Q.children.length === 1 &&
                      Q.children[0].type === "JSXExpressionContainer" &&
                      (Q.children[0].expression.type === "TemplateLiteral" ||
                        Q.children[0].expression.type ===
                          "TaggedTemplateExpression")
                    )
                      return [de, ...q.map(ue, "children"), ge];
                    Q.children = Q.children.map((z) =>
                      K(z) ? { type: "JSXText", value: " ", raw: " " } : z
                    );
                    let ve = Q.children.some(T),
                      xe =
                        Q.children.filter(
                          (z) => z.type === "JSXExpressionContainer"
                        ).length > 1,
                      we =
                        Q.type === "JSXElement" &&
                        Q.openingElement.attributes.length > 1,
                      fe = f(de) || ve || we || xe,
                      pe = q.getParentNode().rootMarker === "mdx",
                      me = le.singleQuote ? "{' '}" : '{" "}',
                      ce = pe ? " " : m([me, u], " "),
                      he =
                        Q.openingElement &&
                        Q.openingElement.name &&
                        Q.openingElement.name.name === "fbt",
                      J = F(q, le, ue, ce, he),
                      ye = Q.children.some((z) => oe(z));
                    for (let z = J.length - 2; z >= 0; z--) {
                      let j = J[z] === "" && J[z + 1] === "",
                        Ce = J[z] === r && J[z + 1] === "" && J[z + 2] === r,
                        Ne =
                          (J[z] === u || J[z] === r) &&
                          J[z + 1] === "" &&
                          J[z + 2] === ce,
                        je =
                          J[z] === ce &&
                          J[z + 1] === "" &&
                          (J[z + 2] === u || J[z + 2] === r),
                        Ue = J[z] === ce && J[z + 1] === "" && J[z + 2] === ce,
                        tt =
                          (J[z] === u && J[z + 1] === "" && J[z + 2] === r) ||
                          (J[z] === r && J[z + 1] === "" && J[z + 2] === u);
                      (Ce && ye) || j || Ne || Ue || tt
                        ? J.splice(z, 2)
                        : je && J.splice(z + 1, 2);
                    }
                    for (; J.length > 0 && o(h(J)); ) J.pop();
                    for (; J.length > 1 && o(J[0]) && o(J[1]); )
                      J.shift(), J.shift();
                    let X = [];
                    for (let [z, j] of J.entries()) {
                      if (j === ce) {
                        if (z === 1 && J[z - 1] === "") {
                          if (J.length === 2) {
                            X.push(me);
                            continue;
                          }
                          X.push([me, r]);
                          continue;
                        } else if (z === J.length - 1) {
                          X.push(me);
                          continue;
                        } else if (J[z - 1] === "" && J[z - 2] === r) {
                          X.push(me);
                          continue;
                        }
                      }
                      X.push(j), f(j) && (fe = !0);
                    }
                    let Y = ye ? C(X) : a(X, { shouldBreak: !0 });
                    if (pe) return Y;
                    let te = a([de, c([r, Y]), r, ge]);
                    return fe ? te : l([a([de, ...J, ge]), te]);
                  }
                  function F(q, le, ue, Q, de) {
                    let ge = [];
                    return (
                      q.each((ve, xe, we) => {
                        let fe = ve.getValue();
                        if (b(fe)) {
                          let pe = A(fe);
                          if (oe(fe)) {
                            let me = pe.split(U);
                            if (me[0] === "") {
                              if ((ge.push(""), me.shift(), /\n/.test(me[0]))) {
                                let he = we[xe + 1];
                                ge.push(k(de, me[1], fe, he));
                              } else ge.push(Q);
                              me.shift();
                            }
                            let ce;
                            if (
                              (h(me) === "" && (me.pop(), (ce = me.pop())),
                              me.length === 0)
                            )
                              return;
                            for (let [he, J] of me.entries())
                              he % 2 === 1 ? ge.push(i) : ge.push(J);
                            if (ce !== void 0)
                              if (/\n/.test(ce)) {
                                let he = we[xe + 1];
                                ge.push(k(de, h(ge), fe, he));
                              } else ge.push(Q);
                            else {
                              let he = we[xe + 1];
                              ge.push(S(de, h(ge), fe, he));
                            }
                          } else
                            /\n/.test(pe)
                              ? pe.match(/\n/g).length > 1 && ge.push("", r)
                              : ge.push("", Q);
                        } else {
                          let pe = ue();
                          ge.push(pe);
                          let me = we[xe + 1];
                          if (me && oe(me)) {
                            let he = se(A(me)).split(U)[0];
                            ge.push(S(de, he, fe, me));
                          } else ge.push(r);
                        }
                      }, "children"),
                      ge
                    );
                  }
                  function S(q, le, ue, Q) {
                    return q
                      ? ""
                      : (ue.type === "JSXElement" && !ue.closingElement) ||
                        (Q && Q.type === "JSXElement" && !Q.closingElement)
                      ? le.length === 1
                        ? u
                        : r
                      : u;
                  }
                  function k(q, le, ue, Q) {
                    return q
                      ? r
                      : le.length === 1
                      ? (ue.type === "JSXElement" && !ue.closingElement) ||
                        (Q && Q.type === "JSXElement" && !Q.closingElement)
                        ? r
                        : u
                      : r;
                  }
                  function _(q, le, ue) {
                    let Q = q.getParentNode();
                    if (
                      !Q ||
                      {
                        ArrayExpression: !0,
                        JSXAttribute: !0,
                        JSXElement: !0,
                        JSXExpressionContainer: !0,
                        JSXFragment: !0,
                        ExpressionStatement: !0,
                        CallExpression: !0,
                        OptionalCallExpression: !0,
                        ConditionalExpression: !0,
                        JsExpressionRoot: !0,
                      }[Q.type]
                    )
                      return le;
                    let ge = q.match(
                        void 0,
                        (xe) => xe.type === "ArrowFunctionExpression",
                        v,
                        (xe) => xe.type === "JSXExpressionContainer"
                      ),
                      ve = d(q, ue);
                    return a(
                      [ve ? "" : m("("), c([u, le]), u, ve ? "" : m(")")],
                      { shouldBreak: ge }
                    );
                  }
                  function O(q, le, ue) {
                    let Q = q.getValue(),
                      de = [];
                    if ((de.push(ue("name")), Q.value)) {
                      let ge;
                      if (B(Q.value)) {
                        let xe = A(Q.value)
                            .slice(1, -1)
                            .replace(/&apos;/g, "'")
                            .replace(/&quot;/g, '"'),
                          {
                            escaped: we,
                            quote: fe,
                            regex: pe,
                          } = N(xe, le.jsxSingleQuote ? "'" : '"');
                        (xe = xe.replace(pe, we)), (ge = [fe, xe, fe]);
                      } else ge = ue("value");
                      de.push("=", ge);
                    }
                    return de;
                  }
                  function R(q, le, ue) {
                    let Q = q.getValue(),
                      de = (ge, ve) =>
                        ge.type === "JSXEmptyExpression" ||
                        (!I(ge) &&
                          (ge.type === "ArrayExpression" ||
                            ge.type === "ObjectExpression" ||
                            ge.type === "ArrowFunctionExpression" ||
                            (ge.type === "AwaitExpression" &&
                              (de(ge.argument, ge) ||
                                ge.argument.type === "JSXElement")) ||
                            v(ge) ||
                            ge.type === "FunctionExpression" ||
                            ge.type === "TemplateLiteral" ||
                            ge.type === "TaggedTemplateExpression" ||
                            ge.type === "DoExpression" ||
                            (T(ve) &&
                              (ge.type === "ConditionalExpression" || w(ge)))));
                    return de(Q.expression, q.getParentNode(0))
                      ? a(["{", ue("expression"), g, "}"])
                      : a(["{", c([u, ue("expression")]), u, g, "}"]);
                  }
                  function M(q, le, ue) {
                    let Q = q.getValue(),
                      de =
                        (Q.name && I(Q.name)) ||
                        (Q.typeParameters && I(Q.typeParameters));
                    if (Q.selfClosing && Q.attributes.length === 0 && !de)
                      return ["<", ue("name"), ue("typeParameters"), " />"];
                    if (
                      Q.attributes &&
                      Q.attributes.length === 1 &&
                      Q.attributes[0].value &&
                      B(Q.attributes[0].value) &&
                      !Q.attributes[0].value.value.includes(`
`) &&
                      !de &&
                      !I(Q.attributes[0])
                    )
                      return a([
                        "<",
                        ue("name"),
                        ue("typeParameters"),
                        " ",
                        ...q.map(ue, "attributes"),
                        Q.selfClosing ? " />" : ">",
                      ]);
                    let ge =
                        Q.attributes.length > 0 &&
                        I(h(Q.attributes), E.Trailing),
                      ve =
                        (Q.attributes.length === 0 && !de) ||
                        ((le.bracketSameLine || le.jsxBracketSameLine) &&
                          (!de || Q.attributes.length > 0) &&
                          !ge),
                      xe =
                        Q.attributes &&
                        Q.attributes.some(
                          (fe) =>
                            fe.value &&
                            B(fe.value) &&
                            fe.value.value.includes(`
`)
                        ),
                      we =
                        le.singleAttributePerLine && Q.attributes.length > 1
                          ? r
                          : i;
                    return a(
                      [
                        "<",
                        ue("name"),
                        ue("typeParameters"),
                        c(q.map(() => [we, ue()], "attributes")),
                        Q.selfClosing ? i : ve ? ">" : u,
                        Q.selfClosing ? "/>" : ve ? "" : ">",
                      ],
                      { shouldBreak: xe }
                    );
                  }
                  function H(q, le, ue) {
                    let Q = q.getValue(),
                      de = [];
                    de.push("</");
                    let ge = ue("name");
                    return (
                      I(Q.name, E.Leading | E.Line)
                        ? de.push(c([r, ge]), r)
                        : I(Q.name, E.Leading | E.Block)
                        ? de.push(" ", ge)
                        : de.push(ge),
                      de.push(">"),
                      de
                    );
                  }
                  function P(q, le) {
                    let ue = q.getValue(),
                      Q = I(ue),
                      de = I(ue, E.Line),
                      ge = ue.type === "JSXOpeningFragment";
                    return [
                      ge ? "<" : "</",
                      c([de ? r : Q && !ge ? " " : "", s(q, le, !0)]),
                      de ? r : "",
                      ">",
                    ];
                  }
                  function G(q, le, ue) {
                    let Q = t(q, x(q, le, ue), le);
                    return _(q, Q, le);
                  }
                  function re(q, le) {
                    let ue = q.getValue(),
                      Q = I(ue, E.Line);
                    return [s(q, le, !Q), Q ? r : ""];
                  }
                  function $(q, le, ue) {
                    let Q = q.getValue();
                    return [
                      "{",
                      q.call(
                        (de) => {
                          let ge = ["...", ue()],
                            ve = de.getValue();
                          return !I(ve) || !y(de)
                            ? ge
                            : [c([u, t(de, ge, le)]), u];
                        },
                        Q.type === "JSXSpreadAttribute"
                          ? "argument"
                          : "expression"
                      ),
                      "}",
                    ];
                  }
                  function W(q, le, ue) {
                    let Q = q.getValue();
                    if (!!Q.type.startsWith("JSX"))
                      switch (Q.type) {
                        case "JSXAttribute":
                          return O(q, le, ue);
                        case "JSXIdentifier":
                          return String(Q.name);
                        case "JSXNamespacedName":
                          return p(":", [ue("namespace"), ue("name")]);
                        case "JSXMemberExpression":
                          return p(".", [ue("object"), ue("property")]);
                        case "JSXSpreadAttribute":
                          return $(q, le, ue);
                        case "JSXSpreadChild":
                          return $(q, le, ue);
                        case "JSXExpressionContainer":
                          return R(q, le, ue);
                        case "JSXFragment":
                        case "JSXElement":
                          return G(q, le, ue);
                        case "JSXOpeningElement":
                          return M(q, le, ue);
                        case "JSXClosingElement":
                          return H(q, le, ue);
                        case "JSXOpeningFragment":
                        case "JSXClosingFragment":
                          return P(q, le);
                        case "JSXEmptyExpression":
                          return re(q, le);
                        case "JSXText":
                          throw new Error(
                            "JSXTest should be handled by JSXElement"
                          );
                        default:
                          throw new Error(
                            "Unknown JSX node type: ".concat(
                              JSON.stringify(Q.type),
                              "."
                            )
                          );
                      }
                  }
                  var ee = ` 
\r	`,
                    U = new RegExp("([" + ee + "]+)"),
                    ne = new RegExp("[^" + ee + "]"),
                    se = (q) =>
                      q.replace(
                        new RegExp("(?:^" + U.source + "|" + U.source + "$)"),
                        ""
                      );
                  function V(q) {
                    if (q.children.length === 0) return !0;
                    if (q.children.length > 1) return !1;
                    let le = q.children[0];
                    return b(le) && !oe(le);
                  }
                  function oe(q) {
                    return b(q) && (ne.test(A(q)) || !/\n/.test(A(q)));
                  }
                  function K(q) {
                    return (
                      q.type === "JSXExpressionContainer" &&
                      b(q.expression) &&
                      q.expression.value === " " &&
                      !I(q.expression)
                    );
                  }
                  function Ee(q) {
                    let le = q.getValue(),
                      ue = q.getParentNode();
                    if (!ue || !le || !T(le) || !T(ue)) return !1;
                    let Q = ue.children.indexOf(le),
                      de = null;
                    for (let ge = Q; ge > 0; ge--) {
                      let ve = ue.children[ge - 1];
                      if (!(ve.type === "JSXText" && !oe(ve))) {
                        de = ve;
                        break;
                      }
                    }
                    return (
                      de &&
                      de.type === "JSXExpressionContainer" &&
                      de.expression.type === "JSXEmptyExpression" &&
                      D(de.expression)
                    );
                  }
                  n.exports = { hasJsxIgnoreComment: Ee, printJsx: W };
                },
              }),
              ot = Z({
                "src/language-js/print/misc.js"(e, n) {
                  "use strict";
                  ae();
                  var { isNonEmptyArray: t } = Ge(),
                    {
                      builders: { indent: s, join: i, line: r },
                    } = Le(),
                    { isFlowAnnotationComment: u } = Xe();
                  function a(h) {
                    let N = h.getValue();
                    return !N.optional ||
                      (N.type === "Identifier" && N === h.getParentNode().key)
                      ? ""
                      : N.type === "OptionalCallExpression" ||
                        (N.type === "OptionalMemberExpression" && N.computed)
                      ? "?."
                      : "?";
                  }
                  function c(h) {
                    return h.getValue().definite ||
                      h.match(
                        void 0,
                        (N, T) =>
                          T === "id" &&
                          N.type === "VariableDeclarator" &&
                          N.definite
                      )
                      ? "!"
                      : "";
                  }
                  function l(h, N, T) {
                    let A = h.getValue();
                    return A.typeArguments
                      ? T("typeArguments")
                      : A.typeParameters
                      ? T("typeParameters")
                      : "";
                  }
                  function C(h, N, T) {
                    let A = h.getValue();
                    if (!A.typeAnnotation) return "";
                    let b = h.getParentNode(),
                      v = b.type === "DeclareFunction" && b.id === A;
                    return u(N.originalText, A.typeAnnotation)
                      ? [" /*: ", T("typeAnnotation"), " */"]
                      : [v ? "" : ": ", T("typeAnnotation")];
                  }
                  function m(h, N, T) {
                    return ["::", T("callee")];
                  }
                  function g(h, N, T) {
                    let A = h.getValue();
                    return t(A.modifiers)
                      ? [i(" ", h.map(T, "modifiers")), " "]
                      : "";
                  }
                  function p(h, N, T) {
                    return h.type === "EmptyStatement"
                      ? ";"
                      : h.type === "BlockStatement" || T
                      ? [" ", N]
                      : s([r, N]);
                  }
                  function f(h, N, T) {
                    return ["...", T("argument"), C(h, N, T)];
                  }
                  n.exports = {
                    printOptionalToken: a,
                    printDefiniteToken: c,
                    printFunctionTypeParameters: l,
                    printBindExpressionCallee: m,
                    printTypeScriptModifiers: g,
                    printTypeAnnotation: C,
                    printRestSpread: f,
                    adjustClause: p,
                  };
                },
              }),
              zt = Z({
                "src/language-js/print/array.js"(e, n) {
                  "use strict";
                  ae();
                  var { printDanglingComments: t } = Qe(),
                    {
                      builders: {
                        line: s,
                        softline: i,
                        hardline: r,
                        group: u,
                        indent: a,
                        ifBreak: c,
                        fill: l,
                      },
                    } = Le(),
                    { getLast: C, hasNewline: m } = Ge(),
                    {
                      shouldPrintComma: g,
                      hasComment: p,
                      CommentCheckFlags: f,
                      isNextLineEmpty: h,
                      isNumericLiteral: N,
                      isSignedNumericLiteral: T,
                    } = Xe(),
                    { locStart: A } = nt(),
                    { printOptionalToken: b, printTypeAnnotation: v } = ot();
                  function B(D, d, y) {
                    let o = D.getValue(),
                      x = [],
                      F = o.type === "TupleExpression" ? "#[" : "[",
                      S = "]";
                    if (o.elements.length === 0)
                      p(o, f.Dangling)
                        ? x.push(u([F, t(D, d), i, S]))
                        : x.push(F, S);
                    else {
                      let k = C(o.elements),
                        _ = !(k && k.type === "RestElement"),
                        O = k === null,
                        R = Symbol("array"),
                        M =
                          !d.__inJestEach &&
                          o.elements.length > 1 &&
                          o.elements.every((G, re, $) => {
                            let W = G && G.type;
                            if (
                              W !== "ArrayExpression" &&
                              W !== "ObjectExpression"
                            )
                              return !1;
                            let ee = $[re + 1];
                            if (ee && W !== ee.type) return !1;
                            let U =
                              W === "ArrayExpression"
                                ? "elements"
                                : "properties";
                            return G[U] && G[U].length > 1;
                          }),
                        H = w(o, d),
                        P = _
                          ? O
                            ? ","
                            : g(d)
                            ? H
                              ? c(",", "", { groupId: R })
                              : c(",")
                            : ""
                          : "";
                      x.push(
                        u(
                          [
                            F,
                            a([
                              i,
                              H ? E(D, d, y, P) : [I(D, d, "elements", y), P],
                              t(D, d, !0),
                            ]),
                            i,
                            S,
                          ],
                          { shouldBreak: M, id: R }
                        )
                      );
                    }
                    return x.push(b(D), v(D, d, y)), x;
                  }
                  function w(D, d) {
                    return (
                      D.elements.length > 1 &&
                      D.elements.every(
                        (y) =>
                          y &&
                          (N(y) || (T(y) && !p(y.argument))) &&
                          !p(
                            y,
                            f.Trailing | f.Line,
                            (o) => !m(d.originalText, A(o), { backwards: !0 })
                          )
                      )
                    );
                  }
                  function I(D, d, y, o) {
                    let x = [],
                      F = [];
                    return (
                      D.each((S) => {
                        x.push(F, u(o())),
                          (F = [",", s]),
                          S.getValue() && h(S.getValue(), d) && F.push(i);
                      }, y),
                      x
                    );
                  }
                  function E(D, d, y, o) {
                    let x = [];
                    return (
                      D.each((F, S, k) => {
                        let _ = S === k.length - 1;
                        x.push([y(), _ ? o : ","]),
                          _ ||
                            x.push(
                              h(F.getValue(), d)
                                ? [r, r]
                                : p(k[S + 1], f.Leading | f.Line)
                                ? r
                                : s
                            );
                      }, "elements"),
                      l(x)
                    );
                  }
                  n.exports = {
                    printArray: B,
                    printArrayItems: I,
                    isConciselyPrintedArray: w,
                  };
                },
              }),
              no = Z({
                "src/language-js/print/call-arguments.js"(e, n) {
                  "use strict";
                  ae();
                  var { printDanglingComments: t } = Qe(),
                    { getLast: s, getPenultimate: i } = Ge(),
                    {
                      getFunctionParameters: r,
                      hasComment: u,
                      CommentCheckFlags: a,
                      isFunctionCompositionArgs: c,
                      isJsxNode: l,
                      isLongCurriedCallExpression: C,
                      shouldPrintComma: m,
                      getCallArguments: g,
                      iterateCallArgumentsPath: p,
                      isNextLineEmpty: f,
                      isCallExpression: h,
                      isStringLiteral: N,
                      isObjectProperty: T,
                    } = Xe(),
                    {
                      builders: {
                        line: A,
                        hardline: b,
                        softline: v,
                        group: B,
                        indent: w,
                        conditionalGroup: I,
                        ifBreak: E,
                        breakParent: D,
                      },
                      utils: { willBreak: d },
                    } = Le(),
                    { ArgExpansionBailout: y } = Jt(),
                    { isConciselyPrintedArray: o } = zt();
                  function x(M, H, P) {
                    let G = M.getValue(),
                      re = G.type === "ImportExpression",
                      $ = g(G);
                    if ($.length === 0) return ["(", t(M, H, !0), ")"];
                    if (_($))
                      return [
                        "(",
                        P(["arguments", 0]),
                        ", ",
                        P(["arguments", 1]),
                        ")",
                      ];
                    let W = !1,
                      ee = !1,
                      U = $.length - 1,
                      ne = [];
                    p(M, (q, le) => {
                      let ue = q.getNode(),
                        Q = [P()];
                      le === U ||
                        (f(ue, H)
                          ? (le === 0 && (ee = !0), (W = !0), Q.push(",", b, b))
                          : Q.push(",", A)),
                        ne.push(Q);
                    });
                    let se =
                      !(re || (G.callee && G.callee.type === "Import")) &&
                      m(H, "all")
                        ? ","
                        : "";
                    function V() {
                      return B(["(", w([A, ...ne]), se, A, ")"], {
                        shouldBreak: !0,
                      });
                    }
                    if (W || (M.getParentNode().type !== "Decorator" && c($)))
                      return V();
                    let oe = k($),
                      K = S($, H);
                    if (oe || K) {
                      if (oe ? ne.slice(1).some(d) : ne.slice(0, -1).some(d))
                        return V();
                      let q = [];
                      try {
                        M.try(() => {
                          p(M, (le, ue) => {
                            oe &&
                              ue === 0 &&
                              (q = [
                                [
                                  P([], { expandFirstArg: !0 }),
                                  ne.length > 1 ? "," : "",
                                  ee ? b : A,
                                  ee ? b : "",
                                ],
                                ...ne.slice(1),
                              ]),
                              K &&
                                ue === U &&
                                (q = [
                                  ...ne.slice(0, -1),
                                  P([], { expandLastArg: !0 }),
                                ]);
                          });
                        });
                      } catch (le) {
                        if (le instanceof y) return V();
                        throw le;
                      }
                      return [
                        ne.some(d) ? D : "",
                        I([
                          ["(", ...q, ")"],
                          oe
                            ? [
                                "(",
                                B(q[0], { shouldBreak: !0 }),
                                ...q.slice(1),
                                ")",
                              ]
                            : [
                                "(",
                                ...ne.slice(0, -1),
                                B(s(q), { shouldBreak: !0 }),
                                ")",
                              ],
                          V(),
                        ]),
                      ];
                    }
                    let Ee = ["(", w([v, ...ne]), E(se), v, ")"];
                    return C(M) ? Ee : B(Ee, { shouldBreak: ne.some(d) || W });
                  }
                  function F(M) {
                    let H =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : !1;
                    return (
                      (M.type === "ObjectExpression" &&
                        (M.properties.length > 0 || u(M))) ||
                      (M.type === "ArrayExpression" &&
                        (M.elements.length > 0 || u(M))) ||
                      (M.type === "TSTypeAssertion" && F(M.expression)) ||
                      (M.type === "TSAsExpression" && F(M.expression)) ||
                      M.type === "FunctionExpression" ||
                      (M.type === "ArrowFunctionExpression" &&
                        (!M.returnType ||
                          !M.returnType.typeAnnotation ||
                          M.returnType.typeAnnotation.type !==
                            "TSTypeReference" ||
                          O(M.body)) &&
                        (M.body.type === "BlockStatement" ||
                          (M.body.type === "ArrowFunctionExpression" &&
                            F(M.body, !0)) ||
                          M.body.type === "ObjectExpression" ||
                          M.body.type === "ArrayExpression" ||
                          (!H &&
                            (h(M.body) ||
                              M.body.type === "ConditionalExpression")) ||
                          l(M.body))) ||
                      M.type === "DoExpression" ||
                      M.type === "ModuleExpression"
                    );
                  }
                  function S(M, H) {
                    let P = s(M),
                      G = i(M);
                    return (
                      !u(P, a.Leading) &&
                      !u(P, a.Trailing) &&
                      F(P) &&
                      (!G || G.type !== P.type) &&
                      (M.length !== 2 ||
                        G.type !== "ArrowFunctionExpression" ||
                        P.type !== "ArrayExpression") &&
                      !(M.length > 1 && P.type === "ArrayExpression" && o(P, H))
                    );
                  }
                  function k(M) {
                    if (M.length !== 2) return !1;
                    let [H, P] = M;
                    return H.type === "ModuleExpression" && R(P)
                      ? !0
                      : !u(H) &&
                          (H.type === "FunctionExpression" ||
                            (H.type === "ArrowFunctionExpression" &&
                              H.body.type === "BlockStatement")) &&
                          P.type !== "FunctionExpression" &&
                          P.type !== "ArrowFunctionExpression" &&
                          P.type !== "ConditionalExpression" &&
                          !F(P);
                  }
                  function _(M) {
                    return (
                      M.length === 2 &&
                      M[0].type === "ArrowFunctionExpression" &&
                      r(M[0]).length === 0 &&
                      M[0].body.type === "BlockStatement" &&
                      M[1].type === "ArrayExpression" &&
                      !M.some((H) => u(H))
                    );
                  }
                  function O(M) {
                    return (
                      M.type === "BlockStatement" &&
                      (M.body.some((H) => H.type !== "EmptyStatement") ||
                        u(M, a.Dangling))
                    );
                  }
                  function R(M) {
                    return (
                      M.type === "ObjectExpression" &&
                      M.properties.length === 1 &&
                      T(M.properties[0]) &&
                      M.properties[0].key.type === "Identifier" &&
                      M.properties[0].key.name === "type" &&
                      N(M.properties[0].value) &&
                      M.properties[0].value.value === "module"
                    );
                  }
                  n.exports = x;
                },
              }),
              uo = Z({
                "src/language-js/print/member.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: { softline: t, group: s, indent: i, label: r },
                    } = Le(),
                    {
                      isNumericLiteral: u,
                      isMemberExpression: a,
                      isCallExpression: c,
                    } = Xe(),
                    { printOptionalToken: l } = ot();
                  function C(g, p, f) {
                    let h = g.getValue(),
                      N = g.getParentNode(),
                      T,
                      A = 0;
                    do (T = g.getParentNode(A)), A++;
                    while (T && (a(T) || T.type === "TSNonNullExpression"));
                    let b = f("object"),
                      v = m(g, p, f),
                      B =
                        (T &&
                          (T.type === "NewExpression" ||
                            T.type === "BindExpression" ||
                            (T.type === "AssignmentExpression" &&
                              T.left.type !== "Identifier"))) ||
                        h.computed ||
                        (h.object.type === "Identifier" &&
                          h.property.type === "Identifier" &&
                          !a(N)) ||
                        ((N.type === "AssignmentExpression" ||
                          N.type === "VariableDeclarator") &&
                          ((c(h.object) && h.object.arguments.length > 0) ||
                            (h.object.type === "TSNonNullExpression" &&
                              c(h.object.expression) &&
                              h.object.expression.arguments.length > 0) ||
                            b.label === "member-chain"));
                    return r(
                      b.label === "member-chain" ? "member-chain" : "member",
                      [b, B ? v : s(i([t, v]))]
                    );
                  }
                  function m(g, p, f) {
                    let h = f("property"),
                      N = g.getValue(),
                      T = l(g);
                    return N.computed
                      ? !N.property || u(N.property)
                        ? [T, "[", h, "]"]
                        : s([T, "[", i([t, h]), t, "]"])
                      : [T, ".", h];
                  }
                  n.exports = {
                    printMemberExpression: C,
                    printMemberLookup: m,
                  };
                },
              }),
              Nm = Z({
                "src/language-js/print/member-chain.js"(e, n) {
                  "use strict";
                  ae();
                  var { printComments: t } = Qe(),
                    {
                      getLast: s,
                      isNextLineEmptyAfterIndex: i,
                      getNextNonSpaceNonCommentCharacterIndex: r,
                    } = Ge(),
                    u = kt(),
                    {
                      isCallExpression: a,
                      isMemberExpression: c,
                      isFunctionOrArrowExpression: l,
                      isLongCurriedCallExpression: C,
                      isMemberish: m,
                      isNumericLiteral: g,
                      isSimpleCallArgument: p,
                      hasComment: f,
                      CommentCheckFlags: h,
                      isNextLineEmpty: N,
                    } = Xe(),
                    { locEnd: T } = nt(),
                    {
                      builders: {
                        join: A,
                        hardline: b,
                        group: v,
                        indent: B,
                        conditionalGroup: w,
                        breakParent: I,
                        label: E,
                      },
                      utils: { willBreak: D },
                    } = Le(),
                    d = no(),
                    { printMemberLookup: y } = uo(),
                    {
                      printOptionalToken: o,
                      printFunctionTypeParameters: x,
                      printBindExpressionCallee: F,
                    } = ot();
                  function S(k, _, O) {
                    let R = k.getParentNode(),
                      M = !R || R.type === "ExpressionStatement",
                      H = [];
                    function P(me) {
                      let { originalText: ce } = _,
                        he = r(ce, me, T);
                      return ce.charAt(he) === ")"
                        ? he !== !1 && i(ce, he + 1)
                        : N(me, _);
                    }
                    function G(me) {
                      let ce = me.getValue();
                      a(ce) && (m(ce.callee) || a(ce.callee))
                        ? (H.unshift({
                            node: ce,
                            printed: [
                              t(me, [o(me), x(me, _, O), d(me, _, O)], _),
                              P(ce) ? b : "",
                            ],
                          }),
                          me.call((he) => G(he), "callee"))
                        : m(ce)
                        ? (H.unshift({
                            node: ce,
                            needsParens: u(me, _),
                            printed: t(
                              me,
                              c(ce) ? y(me, _, O) : F(me, _, O),
                              _
                            ),
                          }),
                          me.call((he) => G(he), "object"))
                        : ce.type === "TSNonNullExpression"
                        ? (H.unshift({ node: ce, printed: t(me, "!", _) }),
                          me.call((he) => G(he), "expression"))
                        : H.unshift({ node: ce, printed: O() });
                    }
                    let re = k.getValue();
                    H.unshift({
                      node: re,
                      printed: [o(k), x(k, _, O), d(k, _, O)],
                    }),
                      re.callee && k.call((me) => G(me), "callee");
                    let $ = [],
                      W = [H[0]],
                      ee = 1;
                    for (
                      ;
                      ee < H.length &&
                      (H[ee].node.type === "TSNonNullExpression" ||
                        a(H[ee].node) ||
                        (c(H[ee].node) &&
                          H[ee].node.computed &&
                          g(H[ee].node.property)));
                      ++ee
                    )
                      W.push(H[ee]);
                    if (!a(H[0].node))
                      for (
                        ;
                        ee + 1 < H.length && m(H[ee].node) && m(H[ee + 1].node);
                        ++ee
                      )
                        W.push(H[ee]);
                    $.push(W), (W = []);
                    let U = !1;
                    for (; ee < H.length; ++ee) {
                      if (U && m(H[ee].node)) {
                        if (H[ee].node.computed && g(H[ee].node.property)) {
                          W.push(H[ee]);
                          continue;
                        }
                        $.push(W), (W = []), (U = !1);
                      }
                      (a(H[ee].node) ||
                        H[ee].node.type === "ImportExpression") &&
                        (U = !0),
                        W.push(H[ee]),
                        f(H[ee].node, h.Trailing) &&
                          ($.push(W), (W = []), (U = !1));
                    }
                    W.length > 0 && $.push(W);
                    function ne(me) {
                      return /^[A-Z]|^[$_]+$/.test(me);
                    }
                    function se(me) {
                      return me.length <= _.tabWidth;
                    }
                    function V(me) {
                      let ce = me[1].length > 0 && me[1][0].node.computed;
                      if (me[0].length === 1) {
                        let J = me[0][0].node;
                        return (
                          J.type === "ThisExpression" ||
                          (J.type === "Identifier" &&
                            (ne(J.name) || (M && se(J.name)) || ce))
                        );
                      }
                      let he = s(me[0]).node;
                      return (
                        c(he) &&
                        he.property.type === "Identifier" &&
                        (ne(he.property.name) || ce)
                      );
                    }
                    let oe = $.length >= 2 && !f($[1][0].node) && V($);
                    function K(me) {
                      let ce = me.map((he) => he.printed);
                      return me.length > 0 && s(me).needsParens
                        ? ["(", ...ce, ")"]
                        : ce;
                    }
                    function Ee(me) {
                      return me.length === 0 ? "" : B(v([b, A(b, me.map(K))]));
                    }
                    let q = $.map(K),
                      le = q,
                      ue = oe ? 3 : 2,
                      Q = $.flat(),
                      de =
                        Q.slice(1, -1).some((me) => f(me.node, h.Leading)) ||
                        Q.slice(0, -1).some((me) => f(me.node, h.Trailing)) ||
                        ($[ue] && f($[ue][0].node, h.Leading));
                    if ($.length <= ue && !de) return C(k) ? le : v(le);
                    let ge = s($[oe ? 1 : 0]).node,
                      ve = !a(ge) && P(ge),
                      xe = [
                        K($[0]),
                        oe ? $.slice(1, 2).map(K) : "",
                        ve ? b : "",
                        Ee($.slice(oe ? 2 : 1)),
                      ],
                      we = H.map((me) => {
                        let { node: ce } = me;
                        return ce;
                      }).filter(a);
                    function fe() {
                      let me = s(s($)).node,
                        ce = s(q);
                      return (
                        a(me) &&
                        D(ce) &&
                        we.slice(0, -1).some((he) => he.arguments.some(l))
                      );
                    }
                    let pe;
                    return (
                      de ||
                      (we.length > 2 &&
                        we.some(
                          (me) => !me.arguments.every((ce) => p(ce, 0))
                        )) ||
                      q.slice(0, -1).some(D) ||
                      fe()
                        ? (pe = v(xe))
                        : (pe = [D(le) || ve ? I : "", w([le, xe])]),
                      E("member-chain", pe)
                    );
                  }
                  n.exports = S;
                },
              }),
              so = Z({
                "src/language-js/print/call-expression.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: { join: t, group: s },
                    } = Le(),
                    i = kt(),
                    {
                      getCallArguments: r,
                      hasFlowAnnotationComment: u,
                      isCallExpression: a,
                      isMemberish: c,
                      isStringLiteral: l,
                      isTemplateOnItsOwnLine: C,
                      isTestCall: m,
                      iterateCallArgumentsPath: g,
                    } = Xe(),
                    p = Nm(),
                    f = no(),
                    { printOptionalToken: h, printFunctionTypeParameters: N } =
                      ot();
                  function T(b, v, B) {
                    let w = b.getValue(),
                      I = b.getParentNode(),
                      E = w.type === "NewExpression",
                      D = w.type === "ImportExpression",
                      d = h(b),
                      y = r(w);
                    if (
                      y.length > 0 &&
                      ((!D && !E && A(w, I)) ||
                        (y.length === 1 && C(y[0], v.originalText)) ||
                        (!E && m(w, I)))
                    ) {
                      let F = [];
                      return (
                        g(b, () => {
                          F.push(B());
                        }),
                        [
                          E ? "new " : "",
                          B("callee"),
                          d,
                          N(b, v, B),
                          "(",
                          t(", ", F),
                          ")",
                        ]
                      );
                    }
                    let o =
                      (v.parser === "babel" || v.parser === "babel-flow") &&
                      w.callee &&
                      w.callee.type === "Identifier" &&
                      u(w.callee.trailingComments);
                    if (
                      (o && (w.callee.trailingComments[0].printed = !0),
                      !D &&
                        !E &&
                        c(w.callee) &&
                        !b.call((F) => i(F, v), "callee"))
                    )
                      return p(b, v, B);
                    let x = [
                      E ? "new " : "",
                      D ? "import" : B("callee"),
                      d,
                      o
                        ? "/*:: ".concat(
                            w.callee.trailingComments[0].value.slice(2).trim(),
                            " */"
                          )
                        : "",
                      N(b, v, B),
                      f(b, v, B),
                    ];
                    return D || a(w.callee) ? s(x) : x;
                  }
                  function A(b, v) {
                    if (b.callee.type !== "Identifier") return !1;
                    if (b.callee.name === "require") return !0;
                    if (b.callee.name === "define") {
                      let B = r(b);
                      return (
                        v.type === "ExpressionStatement" &&
                        (B.length === 1 ||
                          (B.length === 2 && B[0].type === "ArrayExpression") ||
                          (B.length === 3 &&
                            l(B[0]) &&
                            B[1].type === "ArrayExpression"))
                      );
                    }
                    return !1;
                  }
                  n.exports = { printCallExpression: T };
                },
              }),
              Xt = Z({
                "src/language-js/print/assignment.js"(e, n) {
                  "use strict";
                  ae();
                  var { isNonEmptyArray: t, getStringWidth: s } = Ge(),
                    {
                      builders: {
                        line: i,
                        group: r,
                        indent: u,
                        indentIfBreak: a,
                        lineSuffixBoundary: c,
                      },
                      utils: { cleanDoc: l, willBreak: C, canBreak: m },
                    } = Le(),
                    {
                      hasLeadingOwnLineComment: g,
                      isBinaryish: p,
                      isStringLiteral: f,
                      isLiteral: h,
                      isNumericLiteral: N,
                      isCallExpression: T,
                      isMemberExpression: A,
                      getCallArguments: b,
                      rawText: v,
                      hasComment: B,
                      isSignedNumericLiteral: w,
                      isObjectProperty: I,
                    } = Xe(),
                    { shouldInlineLogicalExpression: E } = Jn(),
                    { printCallExpression: D } = so();
                  function d(V, oe, K, Ee, q, le) {
                    let ue = x(V, oe, K, Ee, le),
                      Q = K(le, { assignmentLayout: ue });
                    switch (ue) {
                      case "break-after-operator":
                        return r([r(Ee), q, r(u([i, Q]))]);
                      case "never-break-after-operator":
                        return r([r(Ee), q, " ", Q]);
                      case "fluid": {
                        let de = Symbol("assignment");
                        return r([
                          r(Ee),
                          q,
                          r(u(i), { id: de }),
                          c,
                          a(Q, { groupId: de }),
                        ]);
                      }
                      case "break-lhs":
                        return r([Ee, q, " ", r(Q)]);
                      case "chain":
                        return [r(Ee), q, i, Q];
                      case "chain-tail":
                        return [r(Ee), q, u([i, Q])];
                      case "chain-tail-arrow-chain":
                        return [r(Ee), q, Q];
                      case "only-left":
                        return Ee;
                    }
                  }
                  function y(V, oe, K) {
                    let Ee = V.getValue();
                    return d(V, oe, K, K("left"), [" ", Ee.operator], "right");
                  }
                  function o(V, oe, K) {
                    return d(V, oe, K, K("id"), " =", "init");
                  }
                  function x(V, oe, K, Ee, q) {
                    let le = V.getValue(),
                      ue = le[q];
                    if (!ue) return "only-left";
                    let Q = !k(ue);
                    if (
                      V.match(
                        k,
                        _,
                        (xe) =>
                          !Q ||
                          (xe.type !== "ExpressionStatement" &&
                            xe.type !== "VariableDeclaration")
                      )
                    )
                      return Q
                        ? ue.type === "ArrowFunctionExpression" &&
                          ue.body.type === "ArrowFunctionExpression"
                          ? "chain-tail-arrow-chain"
                          : "chain-tail"
                        : "chain";
                    if ((!Q && k(ue.right)) || g(oe.originalText, ue))
                      return "break-after-operator";
                    if (
                      (ue.type === "CallExpression" &&
                        ue.callee.name === "require") ||
                      oe.parser === "json5" ||
                      oe.parser === "json"
                    )
                      return "never-break-after-operator";
                    if (S(le) || O(le) || H(le) || (P(le) && m(Ee)))
                      return "break-lhs";
                    let ve = U(le, Ee, oe);
                    return V.call(() => F(V, oe, K, ve), q)
                      ? "break-after-operator"
                      : ve ||
                        ue.type === "TemplateLiteral" ||
                        ue.type === "TaggedTemplateExpression" ||
                        ue.type === "BooleanLiteral" ||
                        N(ue) ||
                        ue.type === "ClassExpression"
                      ? "never-break-after-operator"
                      : "fluid";
                  }
                  function F(V, oe, K, Ee) {
                    let q = V.getValue();
                    if (p(q) && !E(q)) return !0;
                    switch (q.type) {
                      case "StringLiteralTypeAnnotation":
                      case "SequenceExpression":
                        return !0;
                      case "ConditionalExpression": {
                        let { test: Q } = q;
                        return p(Q) && !E(Q);
                      }
                      case "ClassExpression":
                        return t(q.decorators);
                    }
                    if (Ee) return !1;
                    let le = q,
                      ue = [];
                    for (;;)
                      if (le.type === "UnaryExpression")
                        (le = le.argument), ue.push("argument");
                      else if (le.type === "TSNonNullExpression")
                        (le = le.expression), ue.push("expression");
                      else break;
                    return !!(f(le) || V.call(() => $(V, oe, K), ...ue));
                  }
                  function S(V) {
                    if (_(V)) {
                      let oe = V.left || V.id;
                      return (
                        oe.type === "ObjectPattern" &&
                        oe.properties.length > 2 &&
                        oe.properties.some(
                          (K) =>
                            I(K) &&
                            (!K.shorthand ||
                              (K.value && K.value.type === "AssignmentPattern"))
                        )
                      );
                    }
                    return !1;
                  }
                  function k(V) {
                    return V.type === "AssignmentExpression";
                  }
                  function _(V) {
                    return k(V) || V.type === "VariableDeclarator";
                  }
                  function O(V) {
                    let oe = R(V);
                    if (t(oe)) {
                      let K =
                        V.type === "TSTypeAliasDeclaration"
                          ? "constraint"
                          : "bound";
                      if (oe.length > 1 && oe.some((Ee) => Ee[K] || Ee.default))
                        return !0;
                    }
                    return !1;
                  }
                  function R(V) {
                    return M(V) && V.typeParameters && V.typeParameters.params
                      ? V.typeParameters.params
                      : null;
                  }
                  function M(V) {
                    return (
                      V.type === "TSTypeAliasDeclaration" ||
                      V.type === "TypeAlias"
                    );
                  }
                  function H(V) {
                    if (V.type !== "VariableDeclarator") return !1;
                    let { typeAnnotation: oe } = V.id;
                    if (!oe || !oe.typeAnnotation) return !1;
                    let K = G(oe.typeAnnotation);
                    return (
                      t(K) &&
                      K.length > 1 &&
                      K.some(
                        (Ee) => t(G(Ee)) || Ee.type === "TSConditionalType"
                      )
                    );
                  }
                  function P(V) {
                    return (
                      V.type === "VariableDeclarator" &&
                      V.init &&
                      V.init.type === "ArrowFunctionExpression"
                    );
                  }
                  function G(V) {
                    return re(V) && V.typeParameters && V.typeParameters.params
                      ? V.typeParameters.params
                      : null;
                  }
                  function re(V) {
                    return (
                      V.type === "TSTypeReference" ||
                      V.type === "GenericTypeAnnotation"
                    );
                  }
                  function $(V, oe, K) {
                    let Ee =
                        arguments.length > 3 && arguments[3] !== void 0
                          ? arguments[3]
                          : !1,
                      q = V.getValue(),
                      le = () => $(V, oe, K, !0);
                    if (q.type === "TSNonNullExpression")
                      return V.call(le, "expression");
                    if (T(q)) {
                      if (D(V, oe, K).label === "member-chain") return !1;
                      let Q = b(q);
                      return !(
                        Q.length === 0 ||
                        (Q.length === 1 && ee(Q[0], oe))
                      ) || ne(q, K)
                        ? !1
                        : V.call(le, "callee");
                    }
                    return A(q)
                      ? V.call(le, "object")
                      : Ee &&
                          (q.type === "Identifier" ||
                            q.type === "ThisExpression");
                  }
                  var W = 0.25;
                  function ee(V, oe) {
                    let { printWidth: K } = oe;
                    if (B(V)) return !1;
                    let Ee = K * W;
                    if (
                      V.type === "ThisExpression" ||
                      (V.type === "Identifier" && V.name.length <= Ee) ||
                      (w(V) && !B(V.argument))
                    )
                      return !0;
                    let q =
                      (V.type === "Literal" &&
                        "regex" in V &&
                        V.regex.pattern) ||
                      (V.type === "RegExpLiteral" && V.pattern);
                    return q
                      ? q.length <= Ee
                      : f(V)
                      ? v(V).length <= Ee
                      : V.type === "TemplateLiteral"
                      ? V.expressions.length === 0 &&
                        V.quasis[0].value.raw.length <= Ee &&
                        !V.quasis[0].value.raw.includes(`
`)
                      : h(V);
                  }
                  function U(V, oe, K) {
                    if (!I(V)) return !1;
                    oe = l(oe);
                    let Ee = 3;
                    return typeof oe == "string" && s(oe) < K.tabWidth + Ee;
                  }
                  function ne(V, oe) {
                    let K = se(V);
                    if (t(K)) {
                      if (K.length > 1) return !0;
                      if (K.length === 1) {
                        let q = K[0];
                        if (
                          q.type === "TSUnionType" ||
                          q.type === "UnionTypeAnnotation" ||
                          q.type === "TSIntersectionType" ||
                          q.type === "IntersectionTypeAnnotation" ||
                          q.type === "TSTypeLiteral" ||
                          q.type === "ObjectTypeAnnotation"
                        )
                          return !0;
                      }
                      let Ee = V.typeParameters
                        ? "typeParameters"
                        : "typeArguments";
                      if (C(oe(Ee))) return !0;
                    }
                    return !1;
                  }
                  function se(V) {
                    return (
                      (V.typeParameters && V.typeParameters.params) ||
                      (V.typeArguments && V.typeArguments.params)
                    );
                  }
                  n.exports = {
                    printVariableDeclarator: o,
                    printAssignmentExpression: y,
                    printAssignment: d,
                    isArrowFunctionVariableDeclarator: P,
                  };
                },
              }),
              wr = Z({
                "src/language-js/print/function-parameters.js"(e, n) {
                  "use strict";
                  ae();
                  var { getNextNonSpaceNonCommentCharacter: t } = Ge(),
                    { printDanglingComments: s } = Qe(),
                    {
                      builders: {
                        line: i,
                        hardline: r,
                        softline: u,
                        group: a,
                        indent: c,
                        ifBreak: l,
                      },
                      utils: { removeLines: C, willBreak: m },
                    } = Le(),
                    {
                      getFunctionParameters: g,
                      iterateFunctionParametersPath: p,
                      isSimpleType: f,
                      isTestCall: h,
                      isTypeAnnotationAFunction: N,
                      isObjectType: T,
                      isObjectTypePropertyAFunction: A,
                      hasRestParameter: b,
                      shouldPrintComma: v,
                      hasComment: B,
                      isNextLineEmpty: w,
                    } = Xe(),
                    { locEnd: I } = nt(),
                    { ArgExpansionBailout: E } = Jt(),
                    { printFunctionTypeParameters: D } = ot();
                  function d(F, S, k, _, O) {
                    let R = F.getValue(),
                      M = g(R),
                      H = O ? D(F, k, S) : "";
                    if (M.length === 0)
                      return [
                        H,
                        "(",
                        s(F, k, !0, (U) => t(k.originalText, U, I) === ")"),
                        ")",
                      ];
                    let P = F.getParentNode(),
                      G = h(P),
                      re = y(R),
                      $ = [];
                    if (
                      (p(F, (U, ne) => {
                        let se = ne === M.length - 1;
                        se && R.rest && $.push("..."),
                          $.push(S()),
                          !se &&
                            ($.push(","),
                            G || re
                              ? $.push(" ")
                              : w(M[ne], k)
                              ? $.push(r, r)
                              : $.push(i));
                      }),
                      _)
                    ) {
                      if (m(H) || m($)) throw new E();
                      return a([C(H), "(", C($), ")"]);
                    }
                    let W = M.every((U) => !U.decorators);
                    return re && W
                      ? [H, "(", ...$, ")"]
                      : G
                      ? [H, "(", ...$, ")"]
                      : (A(P) ||
                          N(P) ||
                          P.type === "TypeAlias" ||
                          P.type === "UnionTypeAnnotation" ||
                          P.type === "TSUnionType" ||
                          P.type === "IntersectionTypeAnnotation" ||
                          (P.type === "FunctionTypeAnnotation" &&
                            P.returnType === R)) &&
                        M.length === 1 &&
                        M[0].name === null &&
                        R.this !== M[0] &&
                        M[0].typeAnnotation &&
                        R.typeParameters === null &&
                        f(M[0].typeAnnotation) &&
                        !R.rest
                      ? k.arrowParens === "always"
                        ? ["(", ...$, ")"]
                        : $
                      : [
                          H,
                          "(",
                          c([u, ...$]),
                          l(!b(R) && v(k, "all") ? "," : ""),
                          u,
                          ")",
                        ];
                  }
                  function y(F) {
                    if (!F) return !1;
                    let S = g(F);
                    if (S.length !== 1) return !1;
                    let [k] = S;
                    return (
                      !B(k) &&
                      (k.type === "ObjectPattern" ||
                        k.type === "ArrayPattern" ||
                        (k.type === "Identifier" &&
                          k.typeAnnotation &&
                          (k.typeAnnotation.type === "TypeAnnotation" ||
                            k.typeAnnotation.type === "TSTypeAnnotation") &&
                          T(k.typeAnnotation.typeAnnotation)) ||
                        (k.type === "FunctionTypeParam" &&
                          T(k.typeAnnotation)) ||
                        (k.type === "AssignmentPattern" &&
                          (k.left.type === "ObjectPattern" ||
                            k.left.type === "ArrayPattern") &&
                          (k.right.type === "Identifier" ||
                            (k.right.type === "ObjectExpression" &&
                              k.right.properties.length === 0) ||
                            (k.right.type === "ArrayExpression" &&
                              k.right.elements.length === 0))))
                    );
                  }
                  function o(F) {
                    let S;
                    return (
                      F.returnType
                        ? ((S = F.returnType),
                          S.typeAnnotation && (S = S.typeAnnotation))
                        : F.typeAnnotation && (S = F.typeAnnotation),
                      S
                    );
                  }
                  function x(F, S) {
                    let k = o(F);
                    if (!k) return !1;
                    let _ = F.typeParameters && F.typeParameters.params;
                    if (_) {
                      if (_.length > 1) return !1;
                      if (_.length === 1) {
                        let O = _[0];
                        if (O.constraint || O.default) return !1;
                      }
                    }
                    return g(F).length === 1 && (T(k) || m(S));
                  }
                  n.exports = {
                    printFunctionParameters: d,
                    shouldHugFunctionParameters: y,
                    shouldGroupFunctionParameters: x,
                  };
                },
              }),
              _r = Z({
                "src/language-js/print/type-annotation.js"(e, n) {
                  "use strict";
                  ae();
                  var { printComments: t, printDanglingComments: s } = Qe(),
                    { isNonEmptyArray: i } = Ge(),
                    {
                      builders: {
                        group: r,
                        join: u,
                        line: a,
                        softline: c,
                        indent: l,
                        align: C,
                        ifBreak: m,
                      },
                    } = Le(),
                    g = kt(),
                    { locStart: p } = nt(),
                    {
                      isSimpleType: f,
                      isObjectType: h,
                      hasLeadingOwnLineComment: N,
                      isObjectTypePropertyAFunction: T,
                      shouldPrintComma: A,
                    } = Xe(),
                    { printAssignment: b } = Xt(),
                    {
                      printFunctionParameters: v,
                      shouldGroupFunctionParameters: B,
                    } = wr(),
                    { printArrayItems: w } = zt();
                  function I(S) {
                    if (f(S) || h(S)) return !0;
                    if (
                      S.type === "UnionTypeAnnotation" ||
                      S.type === "TSUnionType"
                    ) {
                      let k = S.types.filter(
                          (O) =>
                            O.type === "VoidTypeAnnotation" ||
                            O.type === "TSVoidKeyword" ||
                            O.type === "NullLiteralTypeAnnotation" ||
                            O.type === "TSNullKeyword"
                        ).length,
                        _ = S.types.some(
                          (O) =>
                            O.type === "ObjectTypeAnnotation" ||
                            O.type === "TSTypeLiteral" ||
                            O.type === "GenericTypeAnnotation" ||
                            O.type === "TSTypeReference"
                        );
                      if (S.types.length - 1 === k && _) return !0;
                    }
                    return !1;
                  }
                  function E(S, k, _) {
                    let O = k.semi ? ";" : "",
                      R = S.getValue(),
                      M = [];
                    return (
                      M.push("opaque type ", _("id"), _("typeParameters")),
                      R.supertype && M.push(": ", _("supertype")),
                      R.impltype && M.push(" = ", _("impltype")),
                      M.push(O),
                      M
                    );
                  }
                  function D(S, k, _) {
                    let O = k.semi ? ";" : "",
                      R = S.getValue(),
                      M = [];
                    R.declare && M.push("declare "),
                      M.push("type ", _("id"), _("typeParameters"));
                    let H =
                      R.type === "TSTypeAliasDeclaration"
                        ? "typeAnnotation"
                        : "right";
                    return [b(S, k, _, M, " =", H), O];
                  }
                  function d(S, k, _) {
                    let O = S.getValue(),
                      R = S.map(_, "types"),
                      M = [],
                      H = !1;
                    for (let P = 0; P < R.length; ++P)
                      P === 0
                        ? M.push(R[P])
                        : h(O.types[P - 1]) && h(O.types[P])
                        ? M.push([" & ", H ? l(R[P]) : R[P]])
                        : !h(O.types[P - 1]) && !h(O.types[P])
                        ? M.push(l([" &", a, R[P]]))
                        : (P > 1 && (H = !0),
                          M.push(" & ", P > 1 ? l(R[P]) : R[P]));
                    return r(M);
                  }
                  function y(S, k, _) {
                    let O = S.getValue(),
                      R = S.getParentNode(),
                      M =
                        R.type !== "TypeParameterInstantiation" &&
                        R.type !== "TSTypeParameterInstantiation" &&
                        R.type !== "GenericTypeAnnotation" &&
                        R.type !== "TSTypeReference" &&
                        R.type !== "TSTypeAssertion" &&
                        R.type !== "TupleTypeAnnotation" &&
                        R.type !== "TSTupleType" &&
                        !(
                          R.type === "FunctionTypeParam" &&
                          !R.name &&
                          S.getParentNode(1).this !== R
                        ) &&
                        !(
                          (R.type === "TypeAlias" ||
                            R.type === "VariableDeclarator" ||
                            R.type === "TSTypeAliasDeclaration") &&
                          N(k.originalText, O)
                        ),
                      H = I(O),
                      P = S.map(($) => {
                        let W = _();
                        return H || (W = C(2, W)), t($, W, k);
                      }, "types");
                    if (H) return u(" | ", P);
                    let G = M && !N(k.originalText, O),
                      re = [m([G ? a : "", "| "]), u([a, "| "], P)];
                    return g(S, k)
                      ? r([l(re), c])
                      : (R.type === "TupleTypeAnnotation" &&
                          R.types.length > 1) ||
                        (R.type === "TSTupleType" && R.elementTypes.length > 1)
                      ? r([l([m(["(", c]), re]), c, m(")")])
                      : r(M ? l(re) : re);
                  }
                  function o(S, k, _) {
                    let O = S.getValue(),
                      R = [],
                      M = S.getParentNode(0),
                      H = S.getParentNode(1),
                      P = S.getParentNode(2),
                      G =
                        O.type === "TSFunctionType" ||
                        !(
                          ((M.type === "ObjectTypeProperty" ||
                            M.type === "ObjectTypeInternalSlot") &&
                            !M.variance &&
                            !M.optional &&
                            p(M) === p(O)) ||
                          M.type === "ObjectTypeCallProperty" ||
                          (P && P.type === "DeclareFunction")
                        ),
                      re =
                        G &&
                        (M.type === "TypeAnnotation" ||
                          M.type === "TSTypeAnnotation"),
                      $ =
                        re &&
                        G &&
                        (M.type === "TypeAnnotation" ||
                          M.type === "TSTypeAnnotation") &&
                        H.type === "ArrowFunctionExpression";
                    T(M) && ((G = !0), (re = !0)), $ && R.push("(");
                    let W = v(S, _, k, !1, !0),
                      ee =
                        O.returnType || O.predicate || O.typeAnnotation
                          ? [
                              G ? " => " : ": ",
                              _("returnType"),
                              _("predicate"),
                              _("typeAnnotation"),
                            ]
                          : "",
                      U = B(O, ee);
                    return (
                      R.push(U ? r(W) : W),
                      ee && R.push(ee),
                      $ && R.push(")"),
                      r(R)
                    );
                  }
                  function x(S, k, _) {
                    let O = S.getValue(),
                      R = O.type === "TSTupleType" ? "elementTypes" : "types",
                      M = O[R],
                      H = i(M),
                      P = H ? c : "";
                    return r([
                      "[",
                      l([P, w(S, k, R, _)]),
                      m(H && A(k, "all") ? "," : ""),
                      s(S, k, !0),
                      P,
                      "]",
                    ]);
                  }
                  function F(S, k, _) {
                    let O = S.getValue(),
                      R =
                        O.type === "OptionalIndexedAccessType" && O.optional
                          ? "?.["
                          : "[";
                    return [_("objectType"), R, _("indexType"), "]"];
                  }
                  n.exports = {
                    printOpaqueType: E,
                    printTypeAlias: D,
                    printIntersectionType: d,
                    printUnionType: y,
                    printFunctionType: o,
                    printTupleType: x,
                    printIndexedAccessType: F,
                    shouldHugType: I,
                  };
                },
              }),
              Pr = Z({
                "src/language-js/print/type-parameters.js"(e, n) {
                  "use strict";
                  ae();
                  var { printDanglingComments: t } = Qe(),
                    {
                      builders: {
                        join: s,
                        line: i,
                        hardline: r,
                        softline: u,
                        group: a,
                        indent: c,
                        ifBreak: l,
                      },
                    } = Le(),
                    {
                      isTestCall: C,
                      hasComment: m,
                      CommentCheckFlags: g,
                      isTSXFile: p,
                      shouldPrintComma: f,
                      getFunctionParameters: h,
                      isObjectType: N,
                    } = Xe(),
                    { createGroupIdMapper: T } = Ge(),
                    { shouldHugType: A } = _r(),
                    { isArrowFunctionVariableDeclarator: b } = Xt(),
                    v = T("typeParameters");
                  function B(E, D, d, y) {
                    let o = E.getValue();
                    if (!o[y]) return "";
                    if (!Array.isArray(o[y])) return d(y);
                    let x = E.getNode(2),
                      F = x && C(x);
                    if (
                      !E.match(
                        (O) => !(O[y].length === 1 && N(O[y][0])),
                        void 0,
                        (O, R) => R === "typeAnnotation",
                        (O) => O.type === "Identifier",
                        b
                      ) &&
                      (F ||
                        o[y].length === 0 ||
                        (o[y].length === 1 &&
                          (o[y][0].type === "NullableTypeAnnotation" ||
                            A(o[y][0]))))
                    )
                      return ["<", s(", ", E.map(d, y)), w(E, D), ">"];
                    let _ =
                      o.type === "TSTypeParameterInstantiation"
                        ? ""
                        : h(o).length === 1 &&
                          p(D) &&
                          !o[y][0].constraint &&
                          E.getParentNode().type === "ArrowFunctionExpression"
                        ? ","
                        : f(D, "all")
                        ? l(",")
                        : "";
                    return a(
                      ["<", c([u, s([",", i], E.map(d, y))]), _, u, ">"],
                      { id: v(o) }
                    );
                  }
                  function w(E, D) {
                    let d = E.getValue();
                    if (!m(d, g.Dangling)) return "";
                    let y = !m(d, g.Line),
                      o = t(E, D, y);
                    return y ? o : [o, r];
                  }
                  function I(E, D, d) {
                    let y = E.getValue(),
                      o = [],
                      x = E.getParentNode();
                    return x.type === "TSMappedType"
                      ? (o.push("[", d("name")),
                        y.constraint && o.push(" in ", d("constraint")),
                        x.nameType &&
                          o.push(
                            " as ",
                            E.callParent(() => d("nameType"))
                          ),
                        o.push("]"),
                        o)
                      : (y.variance && o.push(d("variance")),
                        o.push(d("name")),
                        y.bound && o.push(": ", d("bound")),
                        y.constraint && o.push(" extends ", d("constraint")),
                        y.default && o.push(" = ", d("default")),
                        o);
                  }
                  n.exports = {
                    printTypeParameter: I,
                    printTypeParameters: B,
                    getTypeParametersGroupId: v,
                  };
                },
              }),
              Kt = Z({
                "src/language-js/print/property.js"(e, n) {
                  "use strict";
                  ae();
                  var { printComments: t } = Qe(),
                    { printString: s, printNumber: i } = Ge(),
                    {
                      isNumericLiteral: r,
                      isSimpleNumber: u,
                      isStringLiteral: a,
                      isStringPropSafeToUnquote: c,
                      rawText: l,
                    } = Xe(),
                    { printAssignment: C } = Xt(),
                    m = new WeakMap();
                  function g(f, h, N) {
                    let T = f.getNode();
                    if (T.computed) return ["[", N("key"), "]"];
                    let A = f.getParentNode(),
                      { key: b } = T;
                    if (
                      T.type === "ClassPrivateProperty" &&
                      b.type === "Identifier"
                    )
                      return ["#", N("key")];
                    if (h.quoteProps === "consistent" && !m.has(A)) {
                      let v = (A.properties || A.body || A.members).some(
                        (B) => !B.computed && B.key && a(B.key) && !c(B, h)
                      );
                      m.set(A, v);
                    }
                    if (
                      (b.type === "Identifier" ||
                        (r(b) &&
                          u(i(l(b))) &&
                          String(b.value) === i(l(b)) &&
                          !(
                            h.parser === "typescript" || h.parser === "babel-ts"
                          ))) &&
                      (h.parser === "json" ||
                        (h.quoteProps === "consistent" && m.get(A)))
                    ) {
                      let v = s(
                        JSON.stringify(
                          b.type === "Identifier" ? b.name : b.value.toString()
                        ),
                        h
                      );
                      return f.call((B) => t(B, v, h), "key");
                    }
                    return c(T, h) &&
                      (h.quoteProps === "as-needed" ||
                        (h.quoteProps === "consistent" && !m.get(A)))
                      ? f.call(
                          (v) =>
                            t(v, /^\d/.test(b.value) ? i(b.value) : b.value, h),
                          "key"
                        )
                      : N("key");
                  }
                  function p(f, h, N) {
                    return f.getValue().shorthand
                      ? N("value")
                      : C(f, h, N, g(f, h, N), ":", "value");
                  }
                  n.exports = { printProperty: p, printPropertyKey: g };
                },
              }),
              Ir = Z({
                "src/language-js/print/function.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Ut(),
                    { printDanglingComments: s, printCommentsSeparately: i } =
                      Qe(),
                    r = st(),
                    { getNextNonSpaceNonCommentCharacterIndex: u } = Ge(),
                    {
                      builders: {
                        line: a,
                        softline: c,
                        group: l,
                        indent: C,
                        ifBreak: m,
                        hardline: g,
                        join: p,
                        indentIfBreak: f,
                      },
                      utils: { removeLines: h, willBreak: N },
                    } = Le(),
                    { ArgExpansionBailout: T } = Jt(),
                    {
                      getFunctionParameters: A,
                      hasLeadingOwnLineComment: b,
                      isFlowAnnotationComment: v,
                      isJsxNode: B,
                      isTemplateOnItsOwnLine: w,
                      shouldPrintComma: I,
                      startsWithNoLookaheadToken: E,
                      isBinaryish: D,
                      isLineComment: d,
                      hasComment: y,
                      getComments: o,
                      CommentCheckFlags: x,
                      isCallLikeExpression: F,
                      isCallExpression: S,
                      getCallArguments: k,
                      hasNakedLeftSide: _,
                      getLeftSide: O,
                    } = Xe(),
                    { locEnd: R } = nt(),
                    {
                      printFunctionParameters: M,
                      shouldGroupFunctionParameters: H,
                    } = wr(),
                    { printPropertyKey: P } = Kt(),
                    { printFunctionTypeParameters: G } = ot();
                  function re(ue, Q, de, ge) {
                    let ve = ue.getValue(),
                      xe = !1;
                    if (
                      (ve.type === "FunctionDeclaration" ||
                        ve.type === "FunctionExpression") &&
                      ge &&
                      ge.expandLastArg
                    ) {
                      let ce = ue.getParentNode();
                      S(ce) && k(ce).length > 1 && (xe = !0);
                    }
                    let we = [];
                    ve.type === "TSDeclareFunction" &&
                      ve.declare &&
                      we.push("declare "),
                      ve.async && we.push("async "),
                      ve.generator
                        ? we.push("function* ")
                        : we.push("function "),
                      ve.id && we.push(Q("id"));
                    let fe = M(ue, Q, de, xe),
                      pe = oe(ue, Q, de),
                      me = H(ve, pe);
                    return (
                      we.push(
                        G(ue, de, Q),
                        l([me ? l(fe) : fe, pe]),
                        ve.body ? " " : "",
                        Q("body")
                      ),
                      de.semi && (ve.declare || !ve.body) && we.push(";"),
                      we
                    );
                  }
                  function $(ue, Q, de) {
                    let ge = ue.getNode(),
                      { kind: ve } = ge,
                      xe = ge.value || ge,
                      we = [];
                    return (
                      !ve ||
                      ve === "init" ||
                      ve === "method" ||
                      ve === "constructor"
                        ? xe.async && we.push("async ")
                        : (t.ok(ve === "get" || ve === "set"),
                          we.push(ve, " ")),
                      xe.generator && we.push("*"),
                      we.push(
                        P(ue, Q, de),
                        ge.optional || ge.key.optional ? "?" : ""
                      ),
                      ge === xe
                        ? we.push(W(ue, Q, de))
                        : xe.type === "FunctionExpression"
                        ? we.push(ue.call((fe) => W(fe, Q, de), "value"))
                        : we.push(de("value")),
                      we
                    );
                  }
                  function W(ue, Q, de) {
                    let ge = ue.getNode(),
                      ve = M(ue, de, Q),
                      xe = oe(ue, de, Q),
                      we = H(ge, xe),
                      fe = [G(ue, Q, de), l([we ? l(ve) : ve, xe])];
                    return (
                      ge.body
                        ? fe.push(" ", de("body"))
                        : fe.push(Q.semi ? ";" : ""),
                      fe
                    );
                  }
                  function ee(ue, Q, de, ge) {
                    let ve = ue.getValue(),
                      xe = [];
                    if ((ve.async && xe.push("async "), V(ue, Q)))
                      xe.push(de(["params", 0]));
                    else {
                      let fe = ge && (ge.expandLastArg || ge.expandFirstArg),
                        pe = oe(ue, de, Q);
                      if (fe) {
                        if (N(pe)) throw new T();
                        pe = l(h(pe));
                      }
                      xe.push(l([M(ue, de, Q, fe, !0), pe]));
                    }
                    let we = s(ue, Q, !0, (fe) => {
                      let pe = u(Q.originalText, fe, R);
                      return (
                        pe !== !1 && Q.originalText.slice(pe, pe + 2) === "=>"
                      );
                    });
                    return we && xe.push(" ", we), xe;
                  }
                  function U(ue, Q, de, ge, ve, xe) {
                    let we = ue.getName(),
                      fe = ue.getParentNode(),
                      pe = F(fe) && we === "callee",
                      me = Boolean(Q && Q.assignmentLayout),
                      ce =
                        xe.body.type !== "BlockStatement" &&
                        xe.body.type !== "ObjectExpression" &&
                        xe.body.type !== "SequenceExpression",
                      he =
                        (pe && ce) ||
                        (Q && Q.assignmentLayout === "chain-tail-arrow-chain"),
                      J = Symbol("arrow-chain");
                    return (
                      xe.body.type === "SequenceExpression" &&
                        (ve = l(["(", C([c, ve]), c, ")"])),
                      l([
                        l(
                          C([
                            pe || me ? c : "",
                            l(p([" =>", a], de), { shouldBreak: ge }),
                          ]),
                          { id: J, shouldBreak: he }
                        ),
                        " =>",
                        f(ce ? C([a, ve]) : [" ", ve], { groupId: J }),
                        pe ? m(c, "", { groupId: J }) : "",
                      ])
                    );
                  }
                  function ne(ue, Q, de, ge) {
                    let ve = ue.getValue(),
                      xe = [],
                      we = [],
                      fe = !1;
                    if (
                      ((function J() {
                        let ye = ee(ue, Q, de, ge);
                        if (xe.length === 0) xe.push(ye);
                        else {
                          let { leading: X, trailing: Y } = i(ue, Q);
                          xe.push([X, ye]), we.unshift(Y);
                        }
                        (fe =
                          fe ||
                          (ve.returnType && A(ve).length > 0) ||
                          ve.typeParameters ||
                          A(ve).some((X) => X.type !== "Identifier")),
                          ve.body.type !== "ArrowFunctionExpression" ||
                          (ge && ge.expandLastArg)
                            ? we.unshift(de("body", ge))
                            : ((ve = ve.body), ue.call(J, "body"));
                      })(),
                      xe.length > 1)
                    )
                      return U(ue, ge, xe, fe, we, ve);
                    let pe = xe;
                    if (
                      (pe.push(" =>"),
                      !b(Q.originalText, ve.body) &&
                        (ve.body.type === "ArrayExpression" ||
                          ve.body.type === "ObjectExpression" ||
                          ve.body.type === "BlockStatement" ||
                          B(ve.body) ||
                          w(ve.body, Q.originalText) ||
                          ve.body.type === "ArrowFunctionExpression" ||
                          ve.body.type === "DoExpression"))
                    )
                      return l([...pe, " ", we]);
                    if (ve.body.type === "SequenceExpression")
                      return l([...pe, l([" (", C([c, we]), c, ")"])]);
                    let me =
                        ((ge && ge.expandLastArg) ||
                          ue.getParentNode().type ===
                            "JSXExpressionContainer") &&
                        !y(ve),
                      ce = ge && ge.expandLastArg && I(Q, "all"),
                      he =
                        ve.body.type === "ConditionalExpression" &&
                        !E(ve.body, !1);
                    return l([
                      ...pe,
                      l([
                        C([a, he ? m("", "(") : "", we, he ? m("", ")") : ""]),
                        me ? [m(ce ? "," : ""), c] : "",
                      ]),
                    ]);
                  }
                  function se(ue) {
                    let Q = A(ue);
                    return (
                      Q.length === 1 &&
                      !ue.typeParameters &&
                      !y(ue, x.Dangling) &&
                      Q[0].type === "Identifier" &&
                      !Q[0].typeAnnotation &&
                      !y(Q[0]) &&
                      !Q[0].optional &&
                      !ue.predicate &&
                      !ue.returnType
                    );
                  }
                  function V(ue, Q) {
                    if (Q.arrowParens === "always") return !1;
                    if (Q.arrowParens === "avoid") {
                      let de = ue.getValue();
                      return se(de);
                    }
                    return !1;
                  }
                  function oe(ue, Q, de) {
                    let ge = ue.getValue(),
                      ve = Q("returnType");
                    if (ge.returnType && v(de.originalText, ge.returnType))
                      return [" /*: ", ve, " */"];
                    let xe = [ve];
                    return (
                      ge.returnType &&
                        ge.returnType.typeAnnotation &&
                        xe.unshift(": "),
                      ge.predicate &&
                        xe.push(ge.returnType ? " " : ": ", Q("predicate")),
                      xe
                    );
                  }
                  function K(ue, Q, de) {
                    let ge = ue.getValue(),
                      ve = Q.semi ? ";" : "",
                      xe = [];
                    ge.argument &&
                      (le(Q, ge.argument)
                        ? xe.push([" (", C([g, de("argument")]), g, ")"])
                        : D(ge.argument) ||
                          ge.argument.type === "SequenceExpression"
                        ? xe.push(
                            l([m(" (", " "), C([c, de("argument")]), c, m(")")])
                          )
                        : xe.push(" ", de("argument")));
                    let we = o(ge),
                      fe = r(we),
                      pe = fe && d(fe);
                    return (
                      pe && xe.push(ve),
                      y(ge, x.Dangling) && xe.push(" ", s(ue, Q, !0)),
                      pe || xe.push(ve),
                      xe
                    );
                  }
                  function Ee(ue, Q, de) {
                    return ["return", K(ue, Q, de)];
                  }
                  function q(ue, Q, de) {
                    return ["throw", K(ue, Q, de)];
                  }
                  function le(ue, Q) {
                    if (b(ue.originalText, Q)) return !0;
                    if (_(Q)) {
                      let de = Q,
                        ge;
                      for (; (ge = O(de)); )
                        if (((de = ge), b(ue.originalText, de))) return !0;
                    }
                    return !1;
                  }
                  n.exports = {
                    printFunction: re,
                    printArrowFunction: ne,
                    printMethod: $,
                    printReturnStatement: Ee,
                    printThrowStatement: q,
                    printMethodInternal: W,
                    shouldPrintParamsWithoutParens: V,
                  };
                },
              }),
              Un = Z({
                "src/language-js/print/decorators.js"(e, n) {
                  "use strict";
                  ae();
                  var { isNonEmptyArray: t, hasNewline: s } = Ge(),
                    {
                      builders: {
                        line: i,
                        hardline: r,
                        join: u,
                        breakParent: a,
                        group: c,
                      },
                    } = Le(),
                    { locStart: l, locEnd: C } = nt(),
                    { getParentExportDeclaration: m } = Xe();
                  function g(T, A, b) {
                    let v = T.getValue();
                    return c([u(i, T.map(b, "decorators")), h(v, A) ? r : i]);
                  }
                  function p(T, A, b) {
                    return [u(r, T.map(b, "declaration", "decorators")), r];
                  }
                  function f(T, A, b) {
                    let v = T.getValue(),
                      { decorators: B } = v;
                    if (!t(B) || N(T.getParentNode())) return;
                    let w =
                      v.type === "ClassExpression" ||
                      v.type === "ClassDeclaration" ||
                      h(v, A);
                    return [
                      m(T) ? r : w ? a : "",
                      u(i, T.map(b, "decorators")),
                      i,
                    ];
                  }
                  function h(T, A) {
                    return T.decorators.some((b) => s(A.originalText, C(b)));
                  }
                  function N(T) {
                    if (
                      T.type !== "ExportDefaultDeclaration" &&
                      T.type !== "ExportNamedDeclaration" &&
                      T.type !== "DeclareExportDeclaration"
                    )
                      return !1;
                    let A = T.declaration && T.declaration.decorators;
                    return t(A) && l(T, { ignoreDecorators: !0 }) > l(A[0]);
                  }
                  n.exports = {
                    printDecorators: f,
                    printClassMemberDecorators: g,
                    printDecoratorsBeforeExport: p,
                    hasDecoratorsBeforeExport: N,
                  };
                },
              }),
              Yt = Z({
                "src/language-js/print/class.js"(e, n) {
                  "use strict";
                  ae();
                  var { isNonEmptyArray: t, createGroupIdMapper: s } = Ge(),
                    { printComments: i, printDanglingComments: r } = Qe(),
                    {
                      builders: {
                        join: u,
                        line: a,
                        hardline: c,
                        softline: l,
                        group: C,
                        indent: m,
                        ifBreak: g,
                      },
                    } = Le(),
                    { hasComment: p, CommentCheckFlags: f } = Xe(),
                    { getTypeParametersGroupId: h } = Pr(),
                    { printMethod: N } = Ir(),
                    {
                      printOptionalToken: T,
                      printTypeAnnotation: A,
                      printDefiniteToken: b,
                    } = ot(),
                    { printPropertyKey: v } = Kt(),
                    { printAssignment: B } = Xt(),
                    { printClassMemberDecorators: w } = Un();
                  function I(k, _, O) {
                    let R = k.getValue(),
                      M = [];
                    R.declare && M.push("declare "),
                      R.abstract && M.push("abstract "),
                      M.push("class");
                    let H =
                        (R.id && p(R.id, f.Trailing)) ||
                        (R.typeParameters && p(R.typeParameters, f.Trailing)) ||
                        (R.superClass && p(R.superClass)) ||
                        t(R.extends) ||
                        t(R.mixins) ||
                        t(R.implements),
                      P = [],
                      G = [];
                    if (
                      (R.id && P.push(" ", O("id")),
                      P.push(O("typeParameters")),
                      R.superClass)
                    ) {
                      let re = [x(k, _, O), O("superTypeParameters")],
                        $ = k.call(
                          (W) => ["extends ", i(W, re, _)],
                          "superClass"
                        );
                      H ? G.push(a, C($)) : G.push(" ", $);
                    } else G.push(o(k, _, O, "extends"));
                    if (
                      (G.push(o(k, _, O, "mixins"), o(k, _, O, "implements")),
                      H)
                    ) {
                      let re;
                      y(R) ? (re = [...P, m(G)]) : (re = m([...P, G])),
                        M.push(C(re, { id: E(R) }));
                    } else M.push(...P, ...G);
                    return M.push(" ", O("body")), M;
                  }
                  var E = s("heritageGroup");
                  function D(k) {
                    return g(c, "", { groupId: E(k) });
                  }
                  function d(k) {
                    return (
                      ["superClass", "extends", "mixins", "implements"].filter(
                        (_) => Boolean(k[_])
                      ).length > 1
                    );
                  }
                  function y(k) {
                    return (
                      k.typeParameters &&
                      !p(k.typeParameters, f.Trailing | f.Line) &&
                      !d(k)
                    );
                  }
                  function o(k, _, O, R) {
                    let M = k.getValue();
                    if (!t(M[R])) return "";
                    let H = r(k, _, !0, (P) => {
                      let { marker: G } = P;
                      return G === R;
                    });
                    return [
                      y(M) ? g(" ", a, { groupId: h(M.typeParameters) }) : a,
                      H,
                      H && c,
                      R,
                      C(m([a, u([",", a], k.map(O, R))])),
                    ];
                  }
                  function x(k, _, O) {
                    let R = O("superClass");
                    return k.getParentNode().type === "AssignmentExpression"
                      ? C(g(["(", m([l, R]), l, ")"], R))
                      : R;
                  }
                  function F(k, _, O) {
                    let R = k.getValue(),
                      M = [];
                    return (
                      t(R.decorators) && M.push(w(k, _, O)),
                      R.accessibility && M.push(R.accessibility + " "),
                      R.readonly && M.push("readonly "),
                      R.declare && M.push("declare "),
                      R.static && M.push("static "),
                      (R.type === "TSAbstractMethodDefinition" || R.abstract) &&
                        M.push("abstract "),
                      R.override && M.push("override "),
                      M.push(N(k, _, O)),
                      M
                    );
                  }
                  function S(k, _, O) {
                    let R = k.getValue(),
                      M = [],
                      H = _.semi ? ";" : "";
                    return (
                      t(R.decorators) && M.push(w(k, _, O)),
                      R.accessibility && M.push(R.accessibility + " "),
                      R.declare && M.push("declare "),
                      R.static && M.push("static "),
                      (R.type === "TSAbstractPropertyDefinition" ||
                        R.abstract) &&
                        M.push("abstract "),
                      R.override && M.push("override "),
                      R.readonly && M.push("readonly "),
                      R.variance && M.push(O("variance")),
                      R.type === "ClassAccessorProperty" && M.push("accessor "),
                      M.push(v(k, _, O), T(k), b(k), A(k, _, O)),
                      [B(k, _, O, M, " =", "value"), H]
                    );
                  }
                  n.exports = {
                    printClass: I,
                    printClassMethod: F,
                    printClassProperty: S,
                    printHardlineAfterHeritage: D,
                  };
                },
              }),
              ao = Z({
                "src/language-js/print/interface.js"(e, n) {
                  "use strict";
                  ae();
                  var { isNonEmptyArray: t } = Ge(),
                    {
                      builders: {
                        join: s,
                        line: i,
                        group: r,
                        indent: u,
                        ifBreak: a,
                      },
                    } = Le(),
                    { hasComment: c, identity: l, CommentCheckFlags: C } = Xe(),
                    { getTypeParametersGroupId: m } = Pr(),
                    { printTypeScriptModifiers: g } = ot();
                  function p(f, h, N) {
                    let T = f.getValue(),
                      A = [];
                    T.declare && A.push("declare "),
                      T.type === "TSInterfaceDeclaration" &&
                        A.push(T.abstract ? "abstract " : "", g(f, h, N)),
                      A.push("interface");
                    let b = [],
                      v = [];
                    T.type !== "InterfaceTypeAnnotation" &&
                      b.push(" ", N("id"), N("typeParameters"));
                    let B =
                      T.typeParameters &&
                      !c(T.typeParameters, C.Trailing | C.Line);
                    return (
                      t(T.extends) &&
                        v.push(
                          B ? a(" ", i, { groupId: m(T.typeParameters) }) : i,
                          "extends ",
                          (T.extends.length === 1 ? l : u)(
                            s([",", i], f.map(N, "extends"))
                          )
                        ),
                      (T.id && c(T.id, C.Trailing)) || t(T.extends)
                        ? B
                          ? A.push(r([...b, u(v)]))
                          : A.push(r(u([...b, ...v])))
                        : A.push(...b, ...v),
                      A.push(" ", N("body")),
                      r(A)
                    );
                  }
                  n.exports = { printInterface: p };
                },
              }),
              io = Z({
                "src/language-js/print/module.js"(e, n) {
                  "use strict";
                  ae();
                  var { isNonEmptyArray: t } = Ge(),
                    {
                      builders: {
                        softline: s,
                        group: i,
                        indent: r,
                        join: u,
                        line: a,
                        ifBreak: c,
                        hardline: l,
                      },
                    } = Le(),
                    { printDanglingComments: C } = Qe(),
                    {
                      hasComment: m,
                      CommentCheckFlags: g,
                      shouldPrintComma: p,
                      needsHardlineAfterDanglingComment: f,
                      isStringLiteral: h,
                      rawText: N,
                    } = Xe(),
                    { locStart: T, hasSameLoc: A } = nt(),
                    {
                      hasDecoratorsBeforeExport: b,
                      printDecoratorsBeforeExport: v,
                    } = Un();
                  function B(S, k, _) {
                    let O = S.getValue(),
                      R = k.semi ? ";" : "",
                      M = [],
                      { importKind: H } = O;
                    return (
                      M.push("import"),
                      H && H !== "value" && M.push(" ", H),
                      M.push(d(S, k, _), D(S, k, _), o(S, k, _), R),
                      M
                    );
                  }
                  function w(S, k, _) {
                    let O = S.getValue(),
                      R = [];
                    b(O) && R.push(v(S, k, _));
                    let { type: M, exportKind: H, declaration: P } = O;
                    return (
                      R.push("export"),
                      (O.default || M === "ExportDefaultDeclaration") &&
                        R.push(" default"),
                      m(O, g.Dangling) &&
                        (R.push(" ", C(S, k, !0)), f(O) && R.push(l)),
                      P
                        ? R.push(" ", _("declaration"))
                        : R.push(
                            H === "type" ? " type" : "",
                            d(S, k, _),
                            D(S, k, _),
                            o(S, k, _)
                          ),
                      E(O, k) && R.push(";"),
                      R
                    );
                  }
                  function I(S, k, _) {
                    let O = S.getValue(),
                      R = k.semi ? ";" : "",
                      M = [],
                      { exportKind: H, exported: P } = O;
                    return (
                      M.push("export"),
                      H === "type" && M.push(" type"),
                      M.push(" *"),
                      P && M.push(" as ", _("exported")),
                      M.push(D(S, k, _), o(S, k, _), R),
                      M
                    );
                  }
                  function E(S, k) {
                    if (!k.semi) return !1;
                    let { type: _, declaration: O } = S,
                      R = S.default || _ === "ExportDefaultDeclaration";
                    if (!O) return !0;
                    let { type: M } = O;
                    return !!(
                      R &&
                      M !== "ClassDeclaration" &&
                      M !== "FunctionDeclaration" &&
                      M !== "TSInterfaceDeclaration" &&
                      M !== "DeclareClass" &&
                      M !== "DeclareFunction" &&
                      M !== "TSDeclareFunction" &&
                      M !== "EnumDeclaration"
                    );
                  }
                  function D(S, k, _) {
                    let O = S.getValue();
                    if (!O.source) return "";
                    let R = [];
                    return (
                      y(O, k) || R.push(" from"), R.push(" ", _("source")), R
                    );
                  }
                  function d(S, k, _) {
                    let O = S.getValue();
                    if (y(O, k)) return "";
                    let R = [" "];
                    if (t(O.specifiers)) {
                      let M = [],
                        H = [];
                      S.each(() => {
                        let P = S.getValue().type;
                        if (
                          P === "ExportNamespaceSpecifier" ||
                          P === "ExportDefaultSpecifier" ||
                          P === "ImportNamespaceSpecifier" ||
                          P === "ImportDefaultSpecifier"
                        )
                          M.push(_());
                        else if (
                          P === "ExportSpecifier" ||
                          P === "ImportSpecifier"
                        )
                          H.push(_());
                        else
                          throw new Error(
                            "Unknown specifier type ".concat(JSON.stringify(P))
                          );
                      }, "specifiers"),
                        R.push(u(", ", M)),
                        H.length > 0 &&
                          (M.length > 0 && R.push(", "),
                          H.length > 1 ||
                          M.length > 0 ||
                          O.specifiers.some((G) => m(G))
                            ? R.push(
                                i([
                                  "{",
                                  r([k.bracketSpacing ? a : s, u([",", a], H)]),
                                  c(p(k) ? "," : ""),
                                  k.bracketSpacing ? a : s,
                                  "}",
                                ])
                              )
                            : R.push([
                                "{",
                                k.bracketSpacing ? " " : "",
                                ...H,
                                k.bracketSpacing ? " " : "",
                                "}",
                              ]));
                    } else R.push("{}");
                    return R;
                  }
                  function y(S, k) {
                    let {
                      type: _,
                      importKind: O,
                      source: R,
                      specifiers: M,
                    } = S;
                    return _ !== "ImportDeclaration" || t(M) || O === "type"
                      ? !1
                      : !/{\s*}/.test(k.originalText.slice(T(S), T(R)));
                  }
                  function o(S, k, _) {
                    let O = S.getNode();
                    return t(O.assertions)
                      ? [
                          " assert {",
                          k.bracketSpacing ? " " : "",
                          u(", ", S.map(_, "assertions")),
                          k.bracketSpacing ? " " : "",
                          "}",
                        ]
                      : "";
                  }
                  function x(S, k, _) {
                    let O = S.getNode(),
                      { type: R } = O,
                      M = [],
                      H = R === "ImportSpecifier" ? O.importKind : O.exportKind;
                    H && H !== "value" && M.push(H, " ");
                    let P = R.startsWith("Import"),
                      G = P ? "imported" : "local",
                      re = P ? "local" : "exported",
                      $ = O[G],
                      W = O[re],
                      ee = "",
                      U = "";
                    return (
                      R === "ExportNamespaceSpecifier" ||
                      R === "ImportNamespaceSpecifier"
                        ? (ee = "*")
                        : $ && (ee = _(G)),
                      W && !F(O) && (U = _(re)),
                      M.push(ee, ee && U ? " as " : "", U),
                      M
                    );
                  }
                  function F(S) {
                    if (
                      S.type !== "ImportSpecifier" &&
                      S.type !== "ExportSpecifier"
                    )
                      return !1;
                    let {
                      local: k,
                      [S.type === "ImportSpecifier" ? "imported" : "exported"]:
                        _,
                    } = S;
                    if (k.type !== _.type || !A(k, _)) return !1;
                    if (h(k)) return k.value === _.value && N(k) === N(_);
                    switch (k.type) {
                      case "Identifier":
                        return k.name === _.name;
                      default:
                        return !1;
                    }
                  }
                  n.exports = {
                    printImportDeclaration: B,
                    printExportDeclaration: w,
                    printExportAllDeclaration: I,
                    printModuleSpecifier: x,
                  };
                },
              }),
              zn = Z({
                "src/language-js/print/object.js"(e, n) {
                  "use strict";
                  ae();
                  var { printDanglingComments: t } = Qe(),
                    {
                      builders: {
                        line: s,
                        softline: i,
                        group: r,
                        indent: u,
                        ifBreak: a,
                        hardline: c,
                      },
                    } = Le(),
                    {
                      getLast: l,
                      hasNewlineInRange: C,
                      hasNewline: m,
                      isNonEmptyArray: g,
                    } = Ge(),
                    {
                      shouldPrintComma: p,
                      hasComment: f,
                      getComments: h,
                      CommentCheckFlags: N,
                      isNextLineEmpty: T,
                    } = Xe(),
                    { locStart: A, locEnd: b } = nt(),
                    { printOptionalToken: v, printTypeAnnotation: B } = ot(),
                    { shouldHugFunctionParameters: w } = wr(),
                    { shouldHugType: I } = _r(),
                    { printHardlineAfterHeritage: E } = Yt();
                  function D(d, y, o) {
                    let x = y.semi ? ";" : "",
                      F = d.getValue(),
                      S;
                    F.type === "TSTypeLiteral"
                      ? (S = "members")
                      : F.type === "TSInterfaceBody"
                      ? (S = "body")
                      : (S = "properties");
                    let k = F.type === "ObjectTypeAnnotation",
                      _ = [S];
                    k && _.push("indexers", "callProperties", "internalSlots");
                    let O = _.map((V) => F[V][0]).sort(
                        (V, oe) => A(V) - A(oe)
                      )[0],
                      R = d.getParentNode(0),
                      M =
                        k &&
                        R &&
                        (R.type === "InterfaceDeclaration" ||
                          R.type === "DeclareInterface" ||
                          R.type === "DeclareClass") &&
                        d.getName() === "body",
                      H =
                        F.type === "TSInterfaceBody" ||
                        M ||
                        (F.type === "ObjectPattern" &&
                          R.type !== "FunctionDeclaration" &&
                          R.type !== "FunctionExpression" &&
                          R.type !== "ArrowFunctionExpression" &&
                          R.type !== "ObjectMethod" &&
                          R.type !== "ClassMethod" &&
                          R.type !== "ClassPrivateMethod" &&
                          R.type !== "AssignmentPattern" &&
                          R.type !== "CatchClause" &&
                          F.properties.some(
                            (V) =>
                              V.value &&
                              (V.value.type === "ObjectPattern" ||
                                V.value.type === "ArrayPattern")
                          )) ||
                        (F.type !== "ObjectPattern" &&
                          O &&
                          C(y.originalText, A(F), A(O))),
                      P = M
                        ? ";"
                        : F.type === "TSInterfaceBody" ||
                          F.type === "TSTypeLiteral"
                        ? a(x, ";")
                        : ",",
                      G =
                        F.type === "RecordExpression"
                          ? "#{"
                          : F.exact
                          ? "{|"
                          : "{",
                      re = F.exact ? "|}" : "}",
                      $ = [];
                    for (let V of _)
                      d.each((oe) => {
                        let K = oe.getValue();
                        $.push({ node: K, printed: o(), loc: A(K) });
                      }, V);
                    _.length > 1 && $.sort((V, oe) => V.loc - oe.loc);
                    let W = [],
                      ee = $.map((V) => {
                        let oe = [...W, r(V.printed)];
                        return (
                          (W = [P, s]),
                          (V.node.type === "TSPropertySignature" ||
                            V.node.type === "TSMethodSignature" ||
                            V.node.type ===
                              "TSConstructSignatureDeclaration") &&
                            f(V.node, N.PrettierIgnore) &&
                            W.shift(),
                          T(V.node, y) && W.push(c),
                          oe
                        );
                      });
                    if (F.inexact) {
                      let V;
                      if (f(F, N.Dangling)) {
                        let oe = f(F, N.Line);
                        V = [
                          t(d, y, !0),
                          oe || m(y.originalText, b(l(h(F)))) ? c : s,
                          "...",
                        ];
                      } else V = ["..."];
                      ee.push([...W, ...V]);
                    }
                    let U = l(F[S]),
                      ne = !(
                        F.inexact ||
                        (U && U.type === "RestElement") ||
                        (U &&
                          (U.type === "TSPropertySignature" ||
                            U.type === "TSCallSignatureDeclaration" ||
                            U.type === "TSMethodSignature" ||
                            U.type === "TSConstructSignatureDeclaration") &&
                          f(U, N.PrettierIgnore))
                      ),
                      se;
                    if (ee.length === 0) {
                      if (!f(F, N.Dangling)) return [G, re, B(d, y, o)];
                      se = r([G, t(d, y), i, re, v(d), B(d, y, o)]);
                    } else
                      se = [
                        M && g(F.properties) ? E(R) : "",
                        G,
                        u([y.bracketSpacing ? s : i, ...ee]),
                        a(ne && (P !== "," || p(y)) ? P : ""),
                        y.bracketSpacing ? s : i,
                        re,
                        v(d),
                        B(d, y, o),
                      ];
                    return d.match(
                      (V) => V.type === "ObjectPattern" && !V.decorators,
                      (V, oe, K) =>
                        w(V) &&
                        (oe === "params" ||
                          oe === "parameters" ||
                          oe === "this" ||
                          oe === "rest") &&
                        K === 0
                    ) ||
                      d.match(
                        I,
                        (V, oe) => oe === "typeAnnotation",
                        (V, oe) => oe === "typeAnnotation",
                        (V, oe, K) =>
                          w(V) &&
                          (oe === "params" ||
                            oe === "parameters" ||
                            oe === "this" ||
                            oe === "rest") &&
                          K === 0
                      ) ||
                      (!H &&
                        d.match(
                          (V) => V.type === "ObjectPattern",
                          (V) =>
                            V.type === "AssignmentExpression" ||
                            V.type === "VariableDeclarator"
                        ))
                      ? se
                      : r(se, { shouldBreak: H });
                  }
                  n.exports = { printObject: D };
                },
              }),
              wm = Z({
                "src/language-js/print/flow.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Ut(),
                    { printDanglingComments: s } = Qe(),
                    { printString: i, printNumber: r } = Ge(),
                    {
                      builders: {
                        hardline: u,
                        softline: a,
                        group: c,
                        indent: l,
                      },
                    } = Le(),
                    {
                      getParentExportDeclaration: C,
                      isFunctionNotation: m,
                      isGetterOrSetter: g,
                      rawText: p,
                      shouldPrintComma: f,
                    } = Xe(),
                    { locStart: h, locEnd: N } = nt(),
                    { printClass: T } = Yt(),
                    {
                      printOpaqueType: A,
                      printTypeAlias: b,
                      printIntersectionType: v,
                      printUnionType: B,
                      printFunctionType: w,
                      printTupleType: I,
                      printIndexedAccessType: E,
                    } = _r(),
                    { printInterface: D } = ao(),
                    { printTypeParameter: d, printTypeParameters: y } = Pr(),
                    {
                      printExportDeclaration: o,
                      printExportAllDeclaration: x,
                    } = io(),
                    { printArrayItems: F } = zt(),
                    { printObject: S } = zn(),
                    { printPropertyKey: k } = Kt(),
                    {
                      printOptionalToken: _,
                      printTypeAnnotation: O,
                      printRestSpread: R,
                    } = ot();
                  function M(P, G, re) {
                    let $ = P.getValue(),
                      W = G.semi ? ";" : "",
                      ee = [];
                    switch ($.type) {
                      case "DeclareClass":
                        return H(P, T(P, G, re));
                      case "DeclareFunction":
                        return H(P, [
                          "function ",
                          re("id"),
                          $.predicate ? " " : "",
                          re("predicate"),
                          W,
                        ]);
                      case "DeclareModule":
                        return H(P, ["module ", re("id"), " ", re("body")]);
                      case "DeclareModuleExports":
                        return H(P, [
                          "module.exports",
                          ": ",
                          re("typeAnnotation"),
                          W,
                        ]);
                      case "DeclareVariable":
                        return H(P, ["var ", re("id"), W]);
                      case "DeclareOpaqueType":
                        return H(P, A(P, G, re));
                      case "DeclareInterface":
                        return H(P, D(P, G, re));
                      case "DeclareTypeAlias":
                        return H(P, b(P, G, re));
                      case "DeclareExportDeclaration":
                        return H(P, o(P, G, re));
                      case "DeclareExportAllDeclaration":
                        return H(P, x(P, G, re));
                      case "OpaqueType":
                        return A(P, G, re);
                      case "TypeAlias":
                        return b(P, G, re);
                      case "IntersectionTypeAnnotation":
                        return v(P, G, re);
                      case "UnionTypeAnnotation":
                        return B(P, G, re);
                      case "FunctionTypeAnnotation":
                        return w(P, G, re);
                      case "TupleTypeAnnotation":
                        return I(P, G, re);
                      case "GenericTypeAnnotation":
                        return [re("id"), y(P, G, re, "typeParameters")];
                      case "IndexedAccessType":
                      case "OptionalIndexedAccessType":
                        return E(P, G, re);
                      case "TypeAnnotation":
                        return re("typeAnnotation");
                      case "TypeParameter":
                        return d(P, G, re);
                      case "TypeofTypeAnnotation":
                        return ["typeof ", re("argument")];
                      case "ExistsTypeAnnotation":
                        return "*";
                      case "EmptyTypeAnnotation":
                        return "empty";
                      case "MixedTypeAnnotation":
                        return "mixed";
                      case "ArrayTypeAnnotation":
                        return [re("elementType"), "[]"];
                      case "BooleanLiteralTypeAnnotation":
                        return String($.value);
                      case "EnumDeclaration":
                        return ["enum ", re("id"), " ", re("body")];
                      case "EnumBooleanBody":
                      case "EnumNumberBody":
                      case "EnumStringBody":
                      case "EnumSymbolBody": {
                        if ($.type === "EnumSymbolBody" || $.explicitType) {
                          let U = null;
                          switch ($.type) {
                            case "EnumBooleanBody":
                              U = "boolean";
                              break;
                            case "EnumNumberBody":
                              U = "number";
                              break;
                            case "EnumStringBody":
                              U = "string";
                              break;
                            case "EnumSymbolBody":
                              U = "symbol";
                              break;
                          }
                          ee.push("of ", U, " ");
                        }
                        if ($.members.length === 0 && !$.hasUnknownMembers)
                          ee.push(c(["{", s(P, G), a, "}"]));
                        else {
                          let U =
                            $.members.length > 0
                              ? [
                                  u,
                                  F(P, G, "members", re),
                                  $.hasUnknownMembers || f(G) ? "," : "",
                                ]
                              : [];
                          ee.push(
                            c([
                              "{",
                              l([
                                ...U,
                                ...($.hasUnknownMembers ? [u, "..."] : []),
                              ]),
                              s(P, G, !0),
                              u,
                              "}",
                            ])
                          );
                        }
                        return ee;
                      }
                      case "EnumBooleanMember":
                      case "EnumNumberMember":
                      case "EnumStringMember":
                        return [
                          re("id"),
                          " = ",
                          typeof $.init == "object"
                            ? re("init")
                            : String($.init),
                        ];
                      case "EnumDefaultedMember":
                        return re("id");
                      case "FunctionTypeParam": {
                        let U = $.name
                          ? re("name")
                          : P.getParentNode().this === $
                          ? "this"
                          : "";
                        return [U, _(P), U ? ": " : "", re("typeAnnotation")];
                      }
                      case "InterfaceDeclaration":
                      case "InterfaceTypeAnnotation":
                        return D(P, G, re);
                      case "ClassImplements":
                      case "InterfaceExtends":
                        return [re("id"), re("typeParameters")];
                      case "NullableTypeAnnotation":
                        return ["?", re("typeAnnotation")];
                      case "Variance": {
                        let { kind: U } = $;
                        return (
                          t.ok(U === "plus" || U === "minus"),
                          U === "plus" ? "+" : "-"
                        );
                      }
                      case "ObjectTypeCallProperty":
                        return (
                          $.static && ee.push("static "),
                          ee.push(re("value")),
                          ee
                        );
                      case "ObjectTypeIndexer":
                        return [
                          $.static ? "static " : "",
                          $.variance ? re("variance") : "",
                          "[",
                          re("id"),
                          $.id ? ": " : "",
                          re("key"),
                          "]: ",
                          re("value"),
                        ];
                      case "ObjectTypeProperty": {
                        let U = "";
                        return (
                          $.proto
                            ? (U = "proto ")
                            : $.static && (U = "static "),
                          [
                            U,
                            g($) ? $.kind + " " : "",
                            $.variance ? re("variance") : "",
                            k(P, G, re),
                            _(P),
                            m($) ? "" : ": ",
                            re("value"),
                          ]
                        );
                      }
                      case "ObjectTypeAnnotation":
                        return S(P, G, re);
                      case "ObjectTypeInternalSlot":
                        return [
                          $.static ? "static " : "",
                          "[[",
                          re("id"),
                          "]]",
                          _(P),
                          $.method ? "" : ": ",
                          re("value"),
                        ];
                      case "ObjectTypeSpreadProperty":
                        return R(P, G, re);
                      case "QualifiedTypeofIdentifier":
                      case "QualifiedTypeIdentifier":
                        return [re("qualification"), ".", re("id")];
                      case "StringLiteralTypeAnnotation":
                        return i(p($), G);
                      case "NumberLiteralTypeAnnotation":
                        t.strictEqual(typeof $.value, "number");
                      case "BigIntLiteralTypeAnnotation":
                        return $.extra ? r($.extra.raw) : r($.raw);
                      case "TypeCastExpression":
                        return ["(", re("expression"), O(P, G, re), ")"];
                      case "TypeParameterDeclaration":
                      case "TypeParameterInstantiation": {
                        let U = y(P, G, re, "params");
                        if (G.parser === "flow") {
                          let ne = h($),
                            se = N($),
                            V = G.originalText.lastIndexOf("/*", ne),
                            oe = G.originalText.indexOf("*/", se);
                          if (V !== -1 && oe !== -1) {
                            let K = G.originalText.slice(V + 2, oe).trim();
                            if (
                              K.startsWith("::") &&
                              !K.includes("/*") &&
                              !K.includes("*/")
                            )
                              return ["/*:: ", U, " */"];
                          }
                        }
                        return U;
                      }
                      case "InferredPredicate":
                        return "%checks";
                      case "DeclaredPredicate":
                        return ["%checks(", re("value"), ")"];
                      case "AnyTypeAnnotation":
                        return "any";
                      case "BooleanTypeAnnotation":
                        return "boolean";
                      case "BigIntTypeAnnotation":
                        return "bigint";
                      case "NullLiteralTypeAnnotation":
                        return "null";
                      case "NumberTypeAnnotation":
                        return "number";
                      case "SymbolTypeAnnotation":
                        return "symbol";
                      case "StringTypeAnnotation":
                        return "string";
                      case "VoidTypeAnnotation":
                        return "void";
                      case "ThisTypeAnnotation":
                        return "this";
                      case "Node":
                      case "Printable":
                      case "SourceLocation":
                      case "Position":
                      case "Statement":
                      case "Function":
                      case "Pattern":
                      case "Expression":
                      case "Declaration":
                      case "Specifier":
                      case "NamedSpecifier":
                      case "Comment":
                      case "MemberTypeAnnotation":
                      case "Type":
                        throw new Error(
                          "unprintable type: " + JSON.stringify($.type)
                        );
                    }
                  }
                  function H(P, G) {
                    let re = C(P);
                    return re
                      ? (t.strictEqual(re.type, "DeclareExportDeclaration"), G)
                      : ["declare ", G];
                  }
                  n.exports = { printFlow: M };
                },
              }),
              _m = Z({
                "src/language-js/utils/is-ts-keyword-type.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s) {
                    let { type: i } = s;
                    return i.startsWith("TS") && i.endsWith("Keyword");
                  }
                  n.exports = t;
                },
              }),
              oo = Z({
                "src/language-js/print/ternary.js"(e, n) {
                  "use strict";
                  ae();
                  var { hasNewlineInRange: t } = Ge(),
                    {
                      isJsxNode: s,
                      getComments: i,
                      isCallExpression: r,
                      isMemberExpression: u,
                    } = Xe(),
                    { locStart: a, locEnd: c } = nt(),
                    l = Pt(),
                    {
                      builders: {
                        line: C,
                        softline: m,
                        group: g,
                        indent: p,
                        align: f,
                        ifBreak: h,
                        dedent: N,
                        breakParent: T,
                      },
                    } = Le();
                  function A(I) {
                    let E = [I];
                    for (let D = 0; D < E.length; D++) {
                      let d = E[D];
                      for (let y of ["test", "consequent", "alternate"]) {
                        let o = d[y];
                        if (s(o)) return !0;
                        o.type === "ConditionalExpression" && E.push(o);
                      }
                    }
                    return !1;
                  }
                  function b(I, E, D) {
                    let d = I.getValue(),
                      y = d.type === "ConditionalExpression",
                      o = y ? "alternate" : "falseType",
                      x = I.getParentNode(),
                      F = y
                        ? D("test")
                        : [
                            D("checkType"),
                            " ",
                            "extends",
                            " ",
                            D("extendsType"),
                          ];
                    return x.type === d.type && x[o] === d ? f(2, F) : F;
                  }
                  var v = new Map([
                    ["AssignmentExpression", "right"],
                    ["VariableDeclarator", "init"],
                    ["ReturnStatement", "argument"],
                    ["ThrowStatement", "argument"],
                    ["UnaryExpression", "argument"],
                    ["YieldExpression", "argument"],
                  ]);
                  function B(I) {
                    let E = I.getValue();
                    if (E.type !== "ConditionalExpression") return !1;
                    let D,
                      d = E;
                    for (let y = 0; !D; y++) {
                      let o = I.getParentNode(y);
                      if (
                        (r(o) && o.callee === d) ||
                        (u(o) && o.object === d) ||
                        (o.type === "TSNonNullExpression" && o.expression === d)
                      ) {
                        d = o;
                        continue;
                      }
                      (o.type === "NewExpression" && o.callee === d) ||
                      (o.type === "TSAsExpression" && o.expression === d)
                        ? ((D = I.getParentNode(y + 1)), (d = o))
                        : (D = o);
                    }
                    return d === E ? !1 : D[v.get(D.type)] === d;
                  }
                  function w(I, E, D) {
                    let d = I.getValue(),
                      y = d.type === "ConditionalExpression",
                      o = y ? "consequent" : "trueType",
                      x = y ? "alternate" : "falseType",
                      F = y ? ["test"] : ["checkType", "extendsType"],
                      S = d[o],
                      k = d[x],
                      _ = [],
                      O = !1,
                      R = I.getParentNode(),
                      M = R.type === d.type && F.some((K) => R[K] === d),
                      H = R.type === d.type && !M,
                      P,
                      G,
                      re = 0;
                    do (G = P || d), (P = I.getParentNode(re)), re++;
                    while (
                      P &&
                      P.type === d.type &&
                      F.every((K) => P[K] !== G)
                    );
                    let $ = P || R,
                      W = G;
                    if (y && (s(d[F[0]]) || s(S) || s(k) || A(W))) {
                      (O = !0), (H = !0);
                      let K = (q) => [h("("), p([m, q]), m, h(")")],
                        Ee = (q) =>
                          q.type === "NullLiteral" ||
                          (q.type === "Literal" && q.value === null) ||
                          (q.type === "Identifier" && q.name === "undefined");
                      _.push(
                        " ? ",
                        Ee(S) ? D(o) : K(D(o)),
                        " : ",
                        k.type === d.type || Ee(k) ? D(x) : K(D(x))
                      );
                    } else {
                      let K = [
                        C,
                        "? ",
                        S.type === d.type ? h("", "(") : "",
                        f(2, D(o)),
                        S.type === d.type ? h("", ")") : "",
                        C,
                        ": ",
                        k.type === d.type ? D(x) : f(2, D(x)),
                      ];
                      _.push(
                        R.type !== d.type || R[x] === d || M
                          ? K
                          : E.useTabs
                          ? N(p(K))
                          : f(Math.max(0, E.tabWidth - 2), K)
                      );
                    }
                    let U = [...F.map((K) => i(d[K])), i(S), i(k)]
                        .flat()
                        .some((K) => l(K) && t(E.originalText, a(K), c(K))),
                      ne = (K) =>
                        R === $ ? g(K, { shouldBreak: U }) : U ? [K, T] : K,
                      se =
                        !O &&
                        (u(R) ||
                          (R.type === "NGPipeExpression" && R.left === d)) &&
                        !R.computed,
                      V = B(I),
                      oe = ne([
                        b(I, E, D),
                        H ? _ : p(_),
                        y && se && !V ? m : "",
                      ]);
                    return M || V ? g([p([m, oe]), m]) : oe;
                  }
                  n.exports = { printTernary: w };
                },
              }),
              co = Z({
                "src/language-js/print/statement.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: { hardline: t },
                    } = Le(),
                    s = kt(),
                    {
                      getLeftSidePathName: i,
                      hasNakedLeftSide: r,
                      isJsxNode: u,
                      isTheOnlyJsxElementInMarkdown: a,
                      hasComment: c,
                      CommentCheckFlags: l,
                      isNextLineEmpty: C,
                    } = Xe(),
                    { shouldPrintParamsWithoutParens: m } = Ir();
                  function g(v, B, w, I) {
                    let E = v.getValue(),
                      D = [],
                      d = E.type === "ClassBody",
                      y = p(E[I]);
                    return (
                      v.each((o, x, F) => {
                        let S = o.getValue();
                        if (S.type === "EmptyStatement") return;
                        let k = w();
                        !B.semi && !d && !a(B, o) && f(o, B)
                          ? c(S, l.Leading)
                            ? D.push(w([], { needsSemi: !0 }))
                            : D.push(";", k)
                          : D.push(k),
                          !B.semi && d && A(S) && b(S, F[x + 1]) && D.push(";"),
                          S !== y && (D.push(t), C(S, B) && D.push(t));
                      }, I),
                      D
                    );
                  }
                  function p(v) {
                    for (let B = v.length - 1; B >= 0; B--) {
                      let w = v[B];
                      if (w.type !== "EmptyStatement") return w;
                    }
                  }
                  function f(v, B) {
                    return v.getNode().type !== "ExpressionStatement"
                      ? !1
                      : v.call((I) => h(I, B), "expression");
                  }
                  function h(v, B) {
                    let w = v.getValue();
                    switch (w.type) {
                      case "ParenthesizedExpression":
                      case "TypeCastExpression":
                      case "ArrayExpression":
                      case "ArrayPattern":
                      case "TemplateLiteral":
                      case "TemplateElement":
                      case "RegExpLiteral":
                        return !0;
                      case "ArrowFunctionExpression": {
                        if (!m(v, B)) return !0;
                        break;
                      }
                      case "UnaryExpression": {
                        let { prefix: I, operator: E } = w;
                        if (I && (E === "+" || E === "-")) return !0;
                        break;
                      }
                      case "BindExpression": {
                        if (!w.object) return !0;
                        break;
                      }
                      case "Literal": {
                        if (w.regex) return !0;
                        break;
                      }
                      default:
                        if (u(w)) return !0;
                    }
                    return s(v, B)
                      ? !0
                      : r(w)
                      ? v.call((I) => h(I, B), ...i(v, w))
                      : !1;
                  }
                  function N(v, B, w) {
                    return g(v, B, w, "body");
                  }
                  function T(v, B, w) {
                    return g(v, B, w, "consequent");
                  }
                  var A = (v) => {
                    let { type: B } = v;
                    return (
                      B === "ClassProperty" ||
                      B === "PropertyDefinition" ||
                      B === "ClassPrivateProperty" ||
                      B === "ClassAccessorProperty"
                    );
                  };
                  function b(v, B) {
                    let w = v.key && v.key.name;
                    if (
                      (w === "static" || w === "get" || w === "set") &&
                      !v.value &&
                      !v.typeAnnotation
                    )
                      return !0;
                    if (!B || B.static || B.accessibility) return !1;
                    if (!B.computed) {
                      let I = B.key && B.key.name;
                      if (I === "in" || I === "instanceof") return !0;
                    }
                    if (A(B) && B.variance && !B.static && !B.declare)
                      return !0;
                    switch (B.type) {
                      case "ClassProperty":
                      case "PropertyDefinition":
                      case "TSAbstractPropertyDefinition":
                        return B.computed;
                      case "MethodDefinition":
                      case "TSAbstractMethodDefinition":
                      case "ClassMethod":
                      case "ClassPrivateMethod": {
                        if (
                          (B.value ? B.value.async : B.async) ||
                          B.kind === "get" ||
                          B.kind === "set"
                        )
                          return !1;
                        let E = B.value ? B.value.generator : B.generator;
                        return !!(B.computed || E);
                      }
                      case "TSIndexSignature":
                        return !0;
                    }
                    return !1;
                  }
                  n.exports = { printBody: N, printSwitchCaseConsequent: T };
                },
              }),
              lo = Z({
                "src/language-js/print/block.js"(e, n) {
                  "use strict";
                  ae();
                  var { printDanglingComments: t } = Qe(),
                    { isNonEmptyArray: s } = Ge(),
                    {
                      builders: { hardline: i, indent: r },
                    } = Le(),
                    {
                      hasComment: u,
                      CommentCheckFlags: a,
                      isNextLineEmpty: c,
                    } = Xe(),
                    { printHardlineAfterHeritage: l } = Yt(),
                    { printBody: C } = co();
                  function m(p, f, h) {
                    let N = p.getValue(),
                      T = [];
                    if (
                      (N.type === "StaticBlock" && T.push("static "),
                      N.type === "ClassBody" && s(N.body))
                    ) {
                      let b = p.getParentNode();
                      T.push(l(b));
                    }
                    T.push("{");
                    let A = g(p, f, h);
                    if (A) T.push(r([i, A]), i);
                    else {
                      let b = p.getParentNode(),
                        v = p.getParentNode(1);
                      b.type === "ArrowFunctionExpression" ||
                        b.type === "FunctionExpression" ||
                        b.type === "FunctionDeclaration" ||
                        b.type === "ObjectMethod" ||
                        b.type === "ClassMethod" ||
                        b.type === "ClassPrivateMethod" ||
                        b.type === "ForStatement" ||
                        b.type === "WhileStatement" ||
                        b.type === "DoWhileStatement" ||
                        b.type === "DoExpression" ||
                        (b.type === "CatchClause" && !v.finalizer) ||
                        b.type === "TSModuleDeclaration" ||
                        b.type === "TSDeclareFunction" ||
                        N.type === "StaticBlock" ||
                        N.type === "ClassBody" ||
                        T.push(i);
                    }
                    return T.push("}"), T;
                  }
                  function g(p, f, h) {
                    let N = p.getValue(),
                      T = s(N.directives),
                      A = N.body.some((B) => B.type !== "EmptyStatement"),
                      b = u(N, a.Dangling);
                    if (!T && !A && !b) return "";
                    let v = [];
                    if (
                      (T &&
                        p.each((B, w, I) => {
                          v.push(h()),
                            (w < I.length - 1 || A || b) &&
                              (v.push(i), c(B.getValue(), f) && v.push(i));
                        }, "directives"),
                      A && v.push(C(p, f, h)),
                      b && v.push(t(p, f, !0)),
                      N.type === "Program")
                    ) {
                      let B = p.getParentNode();
                      (!B || B.type !== "ModuleExpression") && v.push(i);
                    }
                    return v;
                  }
                  n.exports = { printBlock: m, printBlockBody: g };
                },
              }),
              Pm = Z({
                "src/language-js/print/typescript.js"(e, n) {
                  "use strict";
                  ae();
                  var { printDanglingComments: t } = Qe(),
                    { hasNewlineInRange: s } = Ge(),
                    {
                      builders: {
                        join: i,
                        line: r,
                        hardline: u,
                        softline: a,
                        group: c,
                        indent: l,
                        conditionalGroup: C,
                        ifBreak: m,
                      },
                    } = Le(),
                    {
                      isLiteral: g,
                      getTypeScriptMappedTypeModifier: p,
                      shouldPrintComma: f,
                      isCallExpression: h,
                      isMemberExpression: N,
                    } = Xe(),
                    T = _m(),
                    { locStart: A, locEnd: b } = nt(),
                    { printOptionalToken: v, printTypeScriptModifiers: B } =
                      ot(),
                    { printTernary: w } = oo(),
                    {
                      printFunctionParameters: I,
                      shouldGroupFunctionParameters: E,
                    } = wr(),
                    { printTemplateLiteral: D } = It(),
                    { printArrayItems: d } = zt(),
                    { printObject: y } = zn(),
                    { printClassProperty: o, printClassMethod: x } = Yt(),
                    { printTypeParameter: F, printTypeParameters: S } = Pr(),
                    { printPropertyKey: k } = Kt(),
                    { printFunction: _, printMethodInternal: O } = Ir(),
                    { printInterface: R } = ao(),
                    { printBlock: M } = lo(),
                    {
                      printTypeAlias: H,
                      printIntersectionType: P,
                      printUnionType: G,
                      printFunctionType: re,
                      printTupleType: $,
                      printIndexedAccessType: W,
                    } = _r();
                  function ee(U, ne, se) {
                    let V = U.getValue();
                    if (!V.type.startsWith("TS")) return;
                    if (T(V)) return V.type.slice(2, -7).toLowerCase();
                    let oe = ne.semi ? ";" : "",
                      K = [];
                    switch (V.type) {
                      case "TSThisType":
                        return "this";
                      case "TSTypeAssertion": {
                        let Ee = !(
                            V.expression.type === "ArrayExpression" ||
                            V.expression.type === "ObjectExpression"
                          ),
                          q = c(["<", l([a, se("typeAnnotation")]), a, ">"]),
                          le = [m("("), l([a, se("expression")]), a, m(")")];
                        return Ee
                          ? C([
                              [q, se("expression")],
                              [q, c(le, { shouldBreak: !0 })],
                              [q, se("expression")],
                            ])
                          : c([q, se("expression")]);
                      }
                      case "TSDeclareFunction":
                        return _(U, se, ne);
                      case "TSExportAssignment":
                        return ["export = ", se("expression"), oe];
                      case "TSModuleBlock":
                        return M(U, ne, se);
                      case "TSInterfaceBody":
                      case "TSTypeLiteral":
                        return y(U, ne, se);
                      case "TSTypeAliasDeclaration":
                        return H(U, ne, se);
                      case "TSQualifiedName":
                        return i(".", [se("left"), se("right")]);
                      case "TSAbstractMethodDefinition":
                      case "TSDeclareMethod":
                        return x(U, ne, se);
                      case "TSAbstractPropertyDefinition":
                        return o(U, ne, se);
                      case "TSInterfaceHeritage":
                      case "TSExpressionWithTypeArguments":
                        return (
                          K.push(se("expression")),
                          V.typeParameters && K.push(se("typeParameters")),
                          K
                        );
                      case "TSTemplateLiteralType":
                        return D(U, se, ne);
                      case "TSNamedTupleMember":
                        return [
                          se("label"),
                          V.optional ? "?" : "",
                          ": ",
                          se("elementType"),
                        ];
                      case "TSRestType":
                        return ["...", se("typeAnnotation")];
                      case "TSOptionalType":
                        return [se("typeAnnotation"), "?"];
                      case "TSInterfaceDeclaration":
                        return R(U, ne, se);
                      case "TSClassImplements":
                        return [se("expression"), se("typeParameters")];
                      case "TSTypeParameterDeclaration":
                      case "TSTypeParameterInstantiation":
                        return S(U, ne, se, "params");
                      case "TSTypeParameter":
                        return F(U, ne, se);
                      case "TSAsExpression": {
                        K.push(se("expression"), " as ", se("typeAnnotation"));
                        let Ee = U.getParentNode();
                        return (h(Ee) && Ee.callee === V) ||
                          (N(Ee) && Ee.object === V)
                          ? c([l([a, ...K]), a])
                          : K;
                      }
                      case "TSArrayType":
                        return [se("elementType"), "[]"];
                      case "TSPropertySignature":
                        return (
                          V.readonly && K.push("readonly "),
                          K.push(k(U, ne, se), v(U)),
                          V.typeAnnotation &&
                            K.push(": ", se("typeAnnotation")),
                          V.initializer && K.push(" = ", se("initializer")),
                          K
                        );
                      case "TSParameterProperty":
                        return (
                          V.accessibility && K.push(V.accessibility + " "),
                          V.export && K.push("export "),
                          V.static && K.push("static "),
                          V.override && K.push("override "),
                          V.readonly && K.push("readonly "),
                          K.push(se("parameter")),
                          K
                        );
                      case "TSTypeQuery":
                        return ["typeof ", se("exprName")];
                      case "TSIndexSignature": {
                        let Ee = U.getParentNode(),
                          q =
                            V.parameters.length > 1 ? m(f(ne) ? "," : "") : "",
                          le = c([
                            l([a, i([", ", a], U.map(se, "parameters"))]),
                            q,
                            a,
                          ]);
                        return [
                          V.export ? "export " : "",
                          V.accessibility ? [V.accessibility, " "] : "",
                          V.static ? "static " : "",
                          V.readonly ? "readonly " : "",
                          V.declare ? "declare " : "",
                          "[",
                          V.parameters ? le : "",
                          V.typeAnnotation ? "]: " : "]",
                          V.typeAnnotation ? se("typeAnnotation") : "",
                          Ee.type === "ClassBody" ? oe : "",
                        ];
                      }
                      case "TSTypePredicate":
                        return [
                          V.asserts ? "asserts " : "",
                          se("parameterName"),
                          V.typeAnnotation
                            ? [" is ", se("typeAnnotation")]
                            : "",
                        ];
                      case "TSNonNullExpression":
                        return [se("expression"), "!"];
                      case "TSImportType":
                        return [
                          V.isTypeOf ? "typeof " : "",
                          "import(",
                          se(V.parameter ? "parameter" : "argument"),
                          ")",
                          V.qualifier ? [".", se("qualifier")] : "",
                          S(U, ne, se, "typeParameters"),
                        ];
                      case "TSLiteralType":
                        return se("literal");
                      case "TSIndexedAccessType":
                        return W(U, ne, se);
                      case "TSConstructSignatureDeclaration":
                      case "TSCallSignatureDeclaration":
                      case "TSConstructorType": {
                        if (
                          (V.type === "TSConstructorType" &&
                            V.abstract &&
                            K.push("abstract "),
                          V.type !== "TSCallSignatureDeclaration" &&
                            K.push("new "),
                          K.push(c(I(U, se, ne, !1, !0))),
                          V.returnType || V.typeAnnotation)
                        ) {
                          let Ee = V.type === "TSConstructorType";
                          K.push(
                            Ee ? " => " : ": ",
                            se("returnType"),
                            se("typeAnnotation")
                          );
                        }
                        return K;
                      }
                      case "TSTypeOperator":
                        return [V.operator, " ", se("typeAnnotation")];
                      case "TSMappedType": {
                        let Ee = s(ne.originalText, A(V), b(V));
                        return c(
                          [
                            "{",
                            l([
                              ne.bracketSpacing ? r : a,
                              V.readonly
                                ? [p(V.readonly, "readonly"), " "]
                                : "",
                              B(U, ne, se),
                              se("typeParameter"),
                              V.optional ? p(V.optional, "?") : "",
                              V.typeAnnotation ? ": " : "",
                              se("typeAnnotation"),
                              m(oe),
                            ]),
                            t(U, ne, !0),
                            ne.bracketSpacing ? r : a,
                            "}",
                          ],
                          { shouldBreak: Ee }
                        );
                      }
                      case "TSMethodSignature": {
                        let Ee =
                          V.kind && V.kind !== "method"
                            ? "".concat(V.kind, " ")
                            : "";
                        K.push(
                          V.accessibility ? [V.accessibility, " "] : "",
                          Ee,
                          V.export ? "export " : "",
                          V.static ? "static " : "",
                          V.readonly ? "readonly " : "",
                          V.abstract ? "abstract " : "",
                          V.declare ? "declare " : "",
                          V.computed ? "[" : "",
                          se("key"),
                          V.computed ? "]" : "",
                          v(U)
                        );
                        let q = I(U, se, ne, !1, !0),
                          le = V.returnType ? "returnType" : "typeAnnotation",
                          ue = V[le],
                          Q = ue ? se(le) : "",
                          de = E(V, Q);
                        return (
                          K.push(de ? c(q) : q), ue && K.push(": ", c(Q)), c(K)
                        );
                      }
                      case "TSNamespaceExportDeclaration":
                        return (
                          K.push("export as namespace ", se("id")),
                          ne.semi && K.push(";"),
                          c(K)
                        );
                      case "TSEnumDeclaration":
                        return (
                          V.declare && K.push("declare "),
                          V.modifiers && K.push(B(U, ne, se)),
                          V.const && K.push("const "),
                          K.push("enum ", se("id"), " "),
                          V.members.length === 0
                            ? K.push(c(["{", t(U, ne), a, "}"]))
                            : K.push(
                                c([
                                  "{",
                                  l([
                                    u,
                                    d(U, ne, "members", se),
                                    f(ne, "es5") ? "," : "",
                                  ]),
                                  t(U, ne, !0),
                                  u,
                                  "}",
                                ])
                              ),
                          K
                        );
                      case "TSEnumMember":
                        return (
                          K.push(se("id")),
                          V.initializer && K.push(" = ", se("initializer")),
                          K
                        );
                      case "TSImportEqualsDeclaration":
                        return (
                          V.isExport && K.push("export "),
                          K.push("import "),
                          V.importKind &&
                            V.importKind !== "value" &&
                            K.push(V.importKind, " "),
                          K.push(se("id"), " = ", se("moduleReference")),
                          ne.semi && K.push(";"),
                          c(K)
                        );
                      case "TSExternalModuleReference":
                        return ["require(", se("expression"), ")"];
                      case "TSModuleDeclaration": {
                        let Ee = U.getParentNode(),
                          q = g(V.id),
                          le = Ee.type === "TSModuleDeclaration",
                          ue = V.body && V.body.type === "TSModuleDeclaration";
                        if (le) K.push(".");
                        else {
                          V.declare && K.push("declare "), K.push(B(U, ne, se));
                          let Q = ne.originalText.slice(A(V), A(V.id));
                          (V.id.type === "Identifier" &&
                            V.id.name === "global" &&
                            !/namespace|module/.test(Q)) ||
                            K.push(
                              q || /(?:^|\s)module(?:\s|$)/.test(Q)
                                ? "module "
                                : "namespace "
                            );
                        }
                        return (
                          K.push(se("id")),
                          ue
                            ? K.push(se("body"))
                            : V.body
                            ? K.push(" ", c(se("body")))
                            : K.push(oe),
                          K
                        );
                      }
                      case "TSConditionalType":
                        return w(U, ne, se);
                      case "TSInferType":
                        return ["infer", " ", se("typeParameter")];
                      case "TSIntersectionType":
                        return P(U, ne, se);
                      case "TSUnionType":
                        return G(U, ne, se);
                      case "TSFunctionType":
                        return re(U, ne, se);
                      case "TSTupleType":
                        return $(U, ne, se);
                      case "TSTypeReference":
                        return [se("typeName"), S(U, ne, se, "typeParameters")];
                      case "TSTypeAnnotation":
                        return se("typeAnnotation");
                      case "TSEmptyBodyFunctionExpression":
                        return O(U, ne, se);
                      case "TSJSDocAllType":
                        return "*";
                      case "TSJSDocUnknownType":
                        return "?";
                      case "TSJSDocNullableType":
                        return ["?", se("typeAnnotation")];
                      case "TSJSDocNonNullableType":
                        return ["!", se("typeAnnotation")];
                      default:
                        throw new Error(
                          "Unknown TypeScript node type: ".concat(
                            JSON.stringify(V.type),
                            "."
                          )
                        );
                    }
                  }
                  n.exports = { printTypescript: ee };
                },
              }),
              Im = Z({
                "src/language-js/print/comment.js"(e, n) {
                  "use strict";
                  ae();
                  var { hasNewline: t } = Ge(),
                    {
                      builders: { join: s, hardline: i },
                      utils: { replaceTextEndOfLine: r },
                    } = Le(),
                    { isLineComment: u } = Xe(),
                    { locStart: a, locEnd: c } = nt(),
                    l = Pt();
                  function C(p, f) {
                    let h = p.getValue();
                    if (u(h)) return f.originalText.slice(a(h), c(h)).trimEnd();
                    if (l(h)) {
                      if (m(h)) {
                        let A = g(h);
                        return h.trailing &&
                          !t(f.originalText, a(h), { backwards: !0 })
                          ? [i, A]
                          : A;
                      }
                      let N = c(h),
                        T = f.originalText.slice(N - 3, N) === "*-/";
                      return ["/*", r(h.value), T ? "*-/" : "*/"];
                    }
                    throw new Error("Not a comment: " + JSON.stringify(h));
                  }
                  function m(p) {
                    let f = "*".concat(p.value, "*").split(`
`);
                    return f.length > 1 && f.every((h) => h.trim()[0] === "*");
                  }
                  function g(p) {
                    let f = p.value.split(`
`);
                    return [
                      "/*",
                      s(
                        i,
                        f.map((h, N) =>
                          N === 0
                            ? h.trimEnd()
                            : " " +
                              (N < f.length - 1 ? h.trim() : h.trimStart())
                        )
                      ),
                      "*/",
                    ];
                  }
                  n.exports = { printComment: C };
                },
              }),
              km = Z({
                "src/language-js/print/literal.js"(e, n) {
                  "use strict";
                  ae();
                  var { printString: t, printNumber: s } = Ge();
                  function i(a, c) {
                    let l = a.getNode();
                    switch (l.type) {
                      case "RegExpLiteral":
                        return u(l);
                      case "BigIntLiteral":
                        return r(l.bigint || l.extra.raw);
                      case "NumericLiteral":
                        return s(l.extra.raw);
                      case "StringLiteral":
                        return t(l.extra.raw, c);
                      case "NullLiteral":
                        return "null";
                      case "BooleanLiteral":
                        return String(l.value);
                      case "DecimalLiteral":
                        return s(l.value) + "m";
                      case "Literal": {
                        if (l.regex) return u(l.regex);
                        if (l.bigint) return r(l.raw);
                        if (l.decimal) return s(l.decimal) + "m";
                        let { value: C } = l;
                        return typeof C == "number"
                          ? s(l.raw)
                          : typeof C == "string"
                          ? t(l.raw, c)
                          : String(C);
                      }
                    }
                  }
                  function r(a) {
                    return a.toLowerCase();
                  }
                  function u(a) {
                    let { pattern: c, flags: l } = a;
                    return (
                      (l = [...l].sort().join("")), "/".concat(c, "/").concat(l)
                    );
                  }
                  n.exports = { printLiteral: i };
                },
              }),
              Lm = Z({
                "src/language-js/printer-estree.js"(e, n) {
                  "use strict";
                  ae();
                  var { printDanglingComments: t } = Qe(),
                    { hasNewline: s } = Ge(),
                    {
                      builders: {
                        join: i,
                        line: r,
                        hardline: u,
                        softline: a,
                        group: c,
                        indent: l,
                      },
                      utils: { replaceTextEndOfLine: C },
                    } = Le(),
                    m = ym(),
                    g = hm(),
                    { insertPragma: p } = eo(),
                    f = to(),
                    h = kt(),
                    N = ro(),
                    {
                      hasFlowShorthandAnnotationComment: T,
                      hasComment: A,
                      CommentCheckFlags: b,
                      isTheOnlyJsxElementInMarkdown: v,
                      isLineComment: B,
                      isNextLineEmpty: w,
                      needsHardlineAfterDanglingComment: I,
                      rawText: E,
                      hasIgnoreComment: D,
                      isCallExpression: d,
                      isMemberExpression: y,
                      markerForIfWithoutBlockAndSameLineComment: o,
                    } = Xe(),
                    { locStart: x, locEnd: F } = nt(),
                    S = Pt(),
                    { printHtmlBinding: k, isVueEventBindingExpression: _ } =
                      bm(),
                    { printAngular: O } = Tm(),
                    { printJsx: R, hasJsxIgnoreComment: M } = Bm(),
                    { printFlow: H } = wm(),
                    { printTypescript: P } = Pm(),
                    {
                      printOptionalToken: G,
                      printBindExpressionCallee: re,
                      printTypeAnnotation: $,
                      adjustClause: W,
                      printRestSpread: ee,
                      printDefiniteToken: U,
                    } = ot(),
                    {
                      printImportDeclaration: ne,
                      printExportDeclaration: se,
                      printExportAllDeclaration: V,
                      printModuleSpecifier: oe,
                    } = io(),
                    { printTernary: K } = oo(),
                    { printTemplateLiteral: Ee } = It(),
                    { printArray: q } = zt(),
                    { printObject: le } = zn(),
                    {
                      printClass: ue,
                      printClassMethod: Q,
                      printClassProperty: de,
                    } = Yt(),
                    { printProperty: ge } = Kt(),
                    {
                      printFunction: ve,
                      printArrowFunction: xe,
                      printMethod: we,
                      printReturnStatement: fe,
                      printThrowStatement: pe,
                    } = Ir(),
                    { printCallExpression: me } = so(),
                    {
                      printVariableDeclarator: ce,
                      printAssignmentExpression: he,
                    } = Xt(),
                    { printBinaryishExpression: J } = Jn(),
                    { printSwitchCaseConsequent: ye } = co(),
                    { printMemberExpression: X } = uo(),
                    { printBlock: Y, printBlockBody: te } = lo(),
                    { printComment: z } = Im(),
                    { printLiteral: j } = km(),
                    { printDecorators: Ce } = Un();
                  function Ne(Te, _e, Fe, Ke) {
                    let Se = je(Te, _e, Fe, Ke);
                    if (!Se) return "";
                    let ze = Te.getValue(),
                      { type: Be } = ze;
                    if (
                      Be === "ClassMethod" ||
                      Be === "ClassPrivateMethod" ||
                      Be === "ClassProperty" ||
                      Be === "ClassAccessorProperty" ||
                      Be === "PropertyDefinition" ||
                      Be === "TSAbstractPropertyDefinition" ||
                      Be === "ClassPrivateProperty" ||
                      Be === "MethodDefinition" ||
                      Be === "TSAbstractMethodDefinition" ||
                      Be === "TSDeclareMethod"
                    )
                      return Se;
                    let Ie = [Se],
                      Ve = Ce(Te, _e, Fe),
                      Ae = ze.type === "ClassExpression" && Ve;
                    if (Ve && ((Ie = [...Ve, Se]), !Ae)) return c(Ie);
                    if (!h(Te, _e))
                      return (
                        Ke && Ke.needsSemi && Ie.unshift(";"),
                        Ie.length === 1 && Ie[0] === Se ? Se : Ie
                      );
                    if (
                      (Ae && (Ie = [l([r, ...Ie])]),
                      Ie.unshift("("),
                      Ke && Ke.needsSemi && Ie.unshift(";"),
                      T(ze))
                    ) {
                      let [Pe] = ze.trailingComments;
                      Ie.push(" /*", Pe.value.trimStart(), "*/"),
                        (Pe.printed = !0);
                    }
                    return Ae && Ie.push(r), Ie.push(")"), Ie;
                  }
                  function je(Te, _e, Fe, Ke) {
                    let Se = Te.getValue(),
                      ze = _e.semi ? ";" : "";
                    if (!Se) return "";
                    if (typeof Se == "string") return Se;
                    for (let Ie of [j, k, O, R, H, P]) {
                      let Ve = Ie(Te, _e, Fe);
                      if (typeof Ve < "u") return Ve;
                    }
                    let Be = [];
                    switch (Se.type) {
                      case "JsExpressionRoot":
                        return Fe("node");
                      case "JsonRoot":
                        return [Fe("node"), u];
                      case "File":
                        return (
                          Se.program &&
                            Se.program.interpreter &&
                            Be.push(Fe(["program", "interpreter"])),
                          Be.push(Fe("program")),
                          Be
                        );
                      case "Program":
                        return te(Te, _e, Fe);
                      case "EmptyStatement":
                        return "";
                      case "ExpressionStatement": {
                        if (Se.directive) return [Ue(Se.expression, _e), ze];
                        if (_e.parser === "__vue_event_binding") {
                          let Ve = Te.getParentNode();
                          if (
                            Ve.type === "Program" &&
                            Ve.body.length === 1 &&
                            Ve.body[0] === Se
                          )
                            return [
                              Fe("expression"),
                              _(Se.expression) ? ";" : "",
                            ];
                        }
                        let Ie = t(Te, _e, !0, (Ve) => {
                          let { marker: Ae } = Ve;
                          return Ae === o;
                        });
                        return [
                          Fe("expression"),
                          v(_e, Te) ? "" : ze,
                          Ie ? [" ", Ie] : "",
                        ];
                      }
                      case "ParenthesizedExpression":
                        return !A(Se.expression) &&
                          (Se.expression.type === "ObjectExpression" ||
                            Se.expression.type === "ArrayExpression")
                          ? ["(", Fe("expression"), ")"]
                          : c(["(", l([a, Fe("expression")]), a, ")"]);
                      case "AssignmentExpression":
                        return he(Te, _e, Fe);
                      case "VariableDeclarator":
                        return ce(Te, _e, Fe);
                      case "BinaryExpression":
                      case "LogicalExpression":
                        return J(Te, _e, Fe);
                      case "AssignmentPattern":
                        return [Fe("left"), " = ", Fe("right")];
                      case "OptionalMemberExpression":
                      case "MemberExpression":
                        return X(Te, _e, Fe);
                      case "MetaProperty":
                        return [Fe("meta"), ".", Fe("property")];
                      case "BindExpression":
                        return (
                          Se.object && Be.push(Fe("object")),
                          Be.push(c(l([a, re(Te, _e, Fe)]))),
                          Be
                        );
                      case "Identifier":
                        return [Se.name, G(Te), U(Te), $(Te, _e, Fe)];
                      case "V8IntrinsicIdentifier":
                        return ["%", Se.name];
                      case "SpreadElement":
                      case "SpreadElementPattern":
                      case "SpreadProperty":
                      case "SpreadPropertyPattern":
                      case "RestElement":
                        return ee(Te, _e, Fe);
                      case "FunctionDeclaration":
                      case "FunctionExpression":
                        return ve(Te, Fe, _e, Ke);
                      case "ArrowFunctionExpression":
                        return xe(Te, _e, Fe, Ke);
                      case "YieldExpression":
                        return (
                          Be.push("yield"),
                          Se.delegate && Be.push("*"),
                          Se.argument && Be.push(" ", Fe("argument")),
                          Be
                        );
                      case "AwaitExpression": {
                        if ((Be.push("await"), Se.argument)) {
                          Be.push(" ", Fe("argument"));
                          let Ie = Te.getParentNode();
                          if (
                            (d(Ie) && Ie.callee === Se) ||
                            (y(Ie) && Ie.object === Se)
                          ) {
                            Be = [l([a, ...Be]), a];
                            let Ve = Te.findAncestor(
                              (Ae) =>
                                Ae.type === "AwaitExpression" ||
                                Ae.type === "BlockStatement"
                            );
                            if (!Ve || Ve.type !== "AwaitExpression")
                              return c(Be);
                          }
                        }
                        return Be;
                      }
                      case "ExportDefaultDeclaration":
                      case "ExportNamedDeclaration":
                        return se(Te, _e, Fe);
                      case "ExportAllDeclaration":
                        return V(Te, _e, Fe);
                      case "ImportDeclaration":
                        return ne(Te, _e, Fe);
                      case "ImportSpecifier":
                      case "ExportSpecifier":
                      case "ImportNamespaceSpecifier":
                      case "ExportNamespaceSpecifier":
                      case "ImportDefaultSpecifier":
                      case "ExportDefaultSpecifier":
                        return oe(Te, _e, Fe);
                      case "ImportAttribute":
                        return [Fe("key"), ": ", Fe("value")];
                      case "Import":
                        return "import";
                      case "BlockStatement":
                      case "StaticBlock":
                      case "ClassBody":
                        return Y(Te, _e, Fe);
                      case "ThrowStatement":
                        return pe(Te, _e, Fe);
                      case "ReturnStatement":
                        return fe(Te, _e, Fe);
                      case "NewExpression":
                      case "ImportExpression":
                      case "OptionalCallExpression":
                      case "CallExpression":
                        return me(Te, _e, Fe);
                      case "ObjectExpression":
                      case "ObjectPattern":
                      case "RecordExpression":
                        return le(Te, _e, Fe);
                      case "ObjectProperty":
                      case "Property":
                        return Se.method ||
                          Se.kind === "get" ||
                          Se.kind === "set"
                          ? we(Te, _e, Fe)
                          : ge(Te, _e, Fe);
                      case "ObjectMethod":
                        return we(Te, _e, Fe);
                      case "Decorator":
                        return ["@", Fe("expression")];
                      case "ArrayExpression":
                      case "ArrayPattern":
                      case "TupleExpression":
                        return q(Te, _e, Fe);
                      case "SequenceExpression": {
                        let Ie = Te.getParentNode(0);
                        if (
                          Ie.type === "ExpressionStatement" ||
                          Ie.type === "ForStatement"
                        ) {
                          let Ve = [];
                          return (
                            Te.each((Ae, Oe) => {
                              Oe === 0
                                ? Ve.push(Fe())
                                : Ve.push(",", l([r, Fe()]));
                            }, "expressions"),
                            c(Ve)
                          );
                        }
                        return c(i([",", r], Te.map(Fe, "expressions")));
                      }
                      case "ThisExpression":
                        return "this";
                      case "Super":
                        return "super";
                      case "Directive":
                        return [Fe("value"), ze];
                      case "DirectiveLiteral":
                        return Ue(Se, _e);
                      case "UnaryExpression":
                        return (
                          Be.push(Se.operator),
                          /[a-z]$/.test(Se.operator) && Be.push(" "),
                          A(Se.argument)
                            ? Be.push(c(["(", l([a, Fe("argument")]), a, ")"]))
                            : Be.push(Fe("argument")),
                          Be
                        );
                      case "UpdateExpression":
                        return (
                          Be.push(Fe("argument"), Se.operator),
                          Se.prefix && Be.reverse(),
                          Be
                        );
                      case "ConditionalExpression":
                        return K(Te, _e, Fe);
                      case "VariableDeclaration": {
                        let Ie = Te.map(Fe, "declarations"),
                          Ve = Te.getParentNode(),
                          Ae =
                            Ve.type === "ForStatement" ||
                            Ve.type === "ForInStatement" ||
                            Ve.type === "ForOfStatement",
                          Oe = Se.declarations.some((ie) => ie.init),
                          Pe;
                        return (
                          Ie.length === 1 && !A(Se.declarations[0])
                            ? (Pe = Ie[0])
                            : Ie.length > 0 && (Pe = l(Ie[0])),
                          (Be = [
                            Se.declare ? "declare " : "",
                            Se.kind,
                            Pe ? [" ", Pe] : "",
                            l(
                              Ie.slice(1).map((ie) => [
                                ",",
                                Oe && !Ae ? u : r,
                                ie,
                              ])
                            ),
                          ]),
                          (Ae && Ve.body !== Se) || Be.push(ze),
                          c(Be)
                        );
                      }
                      case "WithStatement":
                        return c([
                          "with (",
                          Fe("object"),
                          ")",
                          W(Se.body, Fe("body")),
                        ]);
                      case "IfStatement": {
                        let Ie = W(Se.consequent, Fe("consequent")),
                          Ve = c(["if (", c([l([a, Fe("test")]), a]), ")", Ie]);
                        if ((Be.push(Ve), Se.alternate)) {
                          let Ae =
                              A(Se.consequent, b.Trailing | b.Line) || I(Se),
                            Oe = Se.consequent.type === "BlockStatement" && !Ae;
                          Be.push(Oe ? " " : u),
                            A(Se, b.Dangling) &&
                              Be.push(t(Te, _e, !0), Ae ? u : " "),
                            Be.push(
                              "else",
                              c(
                                W(
                                  Se.alternate,
                                  Fe("alternate"),
                                  Se.alternate.type === "IfStatement"
                                )
                              )
                            );
                        }
                        return Be;
                      }
                      case "ForStatement": {
                        let Ie = W(Se.body, Fe("body")),
                          Ve = t(Te, _e, !0),
                          Ae = Ve ? [Ve, a] : "";
                        return !Se.init && !Se.test && !Se.update
                          ? [Ae, c(["for (;;)", Ie])]
                          : [
                              Ae,
                              c([
                                "for (",
                                c([
                                  l([
                                    a,
                                    Fe("init"),
                                    ";",
                                    r,
                                    Fe("test"),
                                    ";",
                                    r,
                                    Fe("update"),
                                  ]),
                                  a,
                                ]),
                                ")",
                                Ie,
                              ]),
                            ];
                      }
                      case "WhileStatement":
                        return c([
                          "while (",
                          c([l([a, Fe("test")]), a]),
                          ")",
                          W(Se.body, Fe("body")),
                        ]);
                      case "ForInStatement":
                        return c([
                          "for (",
                          Fe("left"),
                          " in ",
                          Fe("right"),
                          ")",
                          W(Se.body, Fe("body")),
                        ]);
                      case "ForOfStatement":
                        return c([
                          "for",
                          Se.await ? " await" : "",
                          " (",
                          Fe("left"),
                          " of ",
                          Fe("right"),
                          ")",
                          W(Se.body, Fe("body")),
                        ]);
                      case "DoWhileStatement": {
                        let Ie = W(Se.body, Fe("body"));
                        return (
                          (Be = [c(["do", Ie])]),
                          Se.body.type === "BlockStatement"
                            ? Be.push(" ")
                            : Be.push(u),
                          Be.push(
                            "while (",
                            c([l([a, Fe("test")]), a]),
                            ")",
                            ze
                          ),
                          Be
                        );
                      }
                      case "DoExpression":
                        return [Se.async ? "async " : "", "do ", Fe("body")];
                      case "BreakStatement":
                        return (
                          Be.push("break"),
                          Se.label && Be.push(" ", Fe("label")),
                          Be.push(ze),
                          Be
                        );
                      case "ContinueStatement":
                        return (
                          Be.push("continue"),
                          Se.label && Be.push(" ", Fe("label")),
                          Be.push(ze),
                          Be
                        );
                      case "LabeledStatement":
                        return Se.body.type === "EmptyStatement"
                          ? [Fe("label"), ":;"]
                          : [Fe("label"), ": ", Fe("body")];
                      case "TryStatement":
                        return [
                          "try ",
                          Fe("block"),
                          Se.handler ? [" ", Fe("handler")] : "",
                          Se.finalizer ? [" finally ", Fe("finalizer")] : "",
                        ];
                      case "CatchClause":
                        if (Se.param) {
                          let Ie = A(
                              Se.param,
                              (Ae) =>
                                !S(Ae) ||
                                (Ae.leading && s(_e.originalText, F(Ae))) ||
                                (Ae.trailing &&
                                  s(_e.originalText, x(Ae), { backwards: !0 }))
                            ),
                            Ve = Fe("param");
                          return [
                            "catch ",
                            Ie ? ["(", l([a, Ve]), a, ") "] : ["(", Ve, ") "],
                            Fe("body"),
                          ];
                        }
                        return ["catch ", Fe("body")];
                      case "SwitchStatement":
                        return [
                          c(["switch (", l([a, Fe("discriminant")]), a, ")"]),
                          " {",
                          Se.cases.length > 0
                            ? l([
                                u,
                                i(
                                  u,
                                  Te.map((Ie, Ve, Ae) => {
                                    let Oe = Ie.getValue();
                                    return [
                                      Fe(),
                                      Ve !== Ae.length - 1 && w(Oe, _e)
                                        ? u
                                        : "",
                                    ];
                                  }, "cases")
                                ),
                              ])
                            : "",
                          u,
                          "}",
                        ];
                      case "SwitchCase": {
                        Se.test
                          ? Be.push("case ", Fe("test"), ":")
                          : Be.push("default:"),
                          A(Se, b.Dangling) && Be.push(" ", t(Te, _e, !0));
                        let Ie = Se.consequent.filter(
                          (Ve) => Ve.type !== "EmptyStatement"
                        );
                        if (Ie.length > 0) {
                          let Ve = ye(Te, _e, Fe);
                          Be.push(
                            Ie.length === 1 && Ie[0].type === "BlockStatement"
                              ? [" ", Ve]
                              : l([u, Ve])
                          );
                        }
                        return Be;
                      }
                      case "DebuggerStatement":
                        return ["debugger", ze];
                      case "ClassDeclaration":
                      case "ClassExpression":
                        return ue(Te, _e, Fe);
                      case "ClassMethod":
                      case "ClassPrivateMethod":
                      case "MethodDefinition":
                        return Q(Te, _e, Fe);
                      case "ClassProperty":
                      case "PropertyDefinition":
                      case "ClassPrivateProperty":
                      case "ClassAccessorProperty":
                        return de(Te, _e, Fe);
                      case "TemplateElement":
                        return C(Se.value.raw);
                      case "TemplateLiteral":
                        return Ee(Te, Fe, _e);
                      case "TaggedTemplateExpression":
                        return [Fe("tag"), Fe("typeParameters"), Fe("quasi")];
                      case "PrivateIdentifier":
                        return ["#", Fe("name")];
                      case "PrivateName":
                        return ["#", Fe("id")];
                      case "InterpreterDirective":
                        return (
                          Be.push("#!", Se.value, u),
                          w(Se, _e) && Be.push(u),
                          Be
                        );
                      case "TopicReference":
                        return "%";
                      case "ArgumentPlaceholder":
                        return "?";
                      case "ModuleExpression": {
                        Be.push("module {");
                        let Ie = Fe("body");
                        return Ie && Be.push(l([u, Ie]), u), Be.push("}"), Be;
                      }
                      default:
                        throw new Error(
                          "unknown type: " + JSON.stringify(Se.type)
                        );
                    }
                  }
                  function Ue(Te, _e) {
                    let Fe = E(Te),
                      Ke = Fe.slice(1, -1);
                    if (Ke.includes('"') || Ke.includes("'")) return Fe;
                    let Se = _e.singleQuote ? "'" : '"';
                    return Se + Ke + Se;
                  }
                  function tt(Te) {
                    return (
                      Te.type &&
                      !S(Te) &&
                      !B(Te) &&
                      Te.type !== "EmptyStatement" &&
                      Te.type !== "TemplateElement" &&
                      Te.type !== "Import" &&
                      Te.type !== "TSEmptyBodyFunctionExpression"
                    );
                  }
                  n.exports = {
                    preprocess: N,
                    print: Ne,
                    embed: m,
                    insertPragma: p,
                    massageAstNode: g,
                    hasPrettierIgnore(Te) {
                      return D(Te) || M(Te);
                    },
                    willPrintOwnComments: f.willPrintOwnComments,
                    canAttachComment: tt,
                    printComment: z,
                    isBlockComment: S,
                    handleComments: {
                      avoidAstMutation: !0,
                      ownLine: f.handleOwnLineComment,
                      endOfLine: f.handleEndOfLineComment,
                      remaining: f.handleRemainingComment,
                    },
                    getCommentChildNodes: f.getCommentChildNodes,
                  };
                },
              }),
              Om = Z({
                "src/language-js/printer-estree-json.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: { hardline: t, indent: s, join: i },
                    } = Le(),
                    r = ro();
                  function u(l, C, m) {
                    let g = l.getValue();
                    switch (g.type) {
                      case "JsonRoot":
                        return [m("node"), t];
                      case "ArrayExpression": {
                        if (g.elements.length === 0) return "[]";
                        let p = l.map(
                          () => (l.getValue() === null ? "null" : m()),
                          "elements"
                        );
                        return ["[", s([t, i([",", t], p)]), t, "]"];
                      }
                      case "ObjectExpression":
                        return g.properties.length === 0
                          ? "{}"
                          : [
                              "{",
                              s([t, i([",", t], l.map(m, "properties"))]),
                              t,
                              "}",
                            ];
                      case "ObjectProperty":
                        return [m("key"), ": ", m("value")];
                      case "UnaryExpression":
                        return [
                          g.operator === "+" ? "" : g.operator,
                          m("argument"),
                        ];
                      case "NullLiteral":
                        return "null";
                      case "BooleanLiteral":
                        return g.value ? "true" : "false";
                      case "StringLiteral":
                      case "NumericLiteral":
                        return JSON.stringify(g.value);
                      case "Identifier": {
                        let p = l.getParentNode();
                        return p && p.type === "ObjectProperty" && p.key === g
                          ? JSON.stringify(g.name)
                          : g.name;
                      }
                      case "TemplateLiteral":
                        return m(["quasis", 0]);
                      case "TemplateElement":
                        return JSON.stringify(g.value.cooked);
                      default:
                        throw new Error(
                          "unknown type: " + JSON.stringify(g.type)
                        );
                    }
                  }
                  var a = new Set([
                    "start",
                    "end",
                    "extra",
                    "loc",
                    "comments",
                    "leadingComments",
                    "trailingComments",
                    "innerComments",
                    "errors",
                    "range",
                    "tokens",
                  ]);
                  function c(l, C) {
                    let { type: m } = l;
                    if (m === "ObjectProperty" && l.key.type === "Identifier") {
                      C.key = { type: "StringLiteral", value: l.key.name };
                      return;
                    }
                    if (m === "UnaryExpression" && l.operator === "+")
                      return C.argument;
                    if (m === "ArrayExpression") {
                      for (let [g, p] of l.elements.entries())
                        p === null &&
                          C.elements.splice(g, 0, { type: "NullLiteral" });
                      return;
                    }
                    if (m === "TemplateLiteral")
                      return {
                        type: "StringLiteral",
                        value: l.quasis[0].value.cooked,
                      };
                  }
                  (c.ignoredProperties = a),
                    (n.exports = {
                      preprocess: r,
                      print: u,
                      massageAstNode: c,
                    });
                },
              }),
              Lt = Z({
                "src/common/common-options.js"(e, n) {
                  "use strict";
                  ae();
                  var t = "Common";
                  n.exports = {
                    bracketSpacing: {
                      since: "0.0.0",
                      category: t,
                      type: "boolean",
                      default: !0,
                      description: "Print spaces between brackets.",
                      oppositeDescription:
                        "Do not print spaces between brackets.",
                    },
                    singleQuote: {
                      since: "0.0.0",
                      category: t,
                      type: "boolean",
                      default: !1,
                      description:
                        "Use single quotes instead of double quotes.",
                    },
                    proseWrap: {
                      since: "1.8.2",
                      category: t,
                      type: "choice",
                      default: [
                        { since: "1.8.2", value: !0 },
                        { since: "1.9.0", value: "preserve" },
                      ],
                      description: "How to wrap prose.",
                      choices: [
                        {
                          since: "1.9.0",
                          value: "always",
                          description:
                            "Wrap prose if it exceeds the print width.",
                        },
                        {
                          since: "1.9.0",
                          value: "never",
                          description: "Do not wrap prose.",
                        },
                        {
                          since: "1.9.0",
                          value: "preserve",
                          description: "Wrap prose as-is.",
                        },
                      ],
                    },
                    bracketSameLine: {
                      since: "2.4.0",
                      category: t,
                      type: "boolean",
                      default: !1,
                      description:
                        "Put > of opening tags on the last line instead of on a new line.",
                    },
                    singleAttributePerLine: {
                      since: "2.6.0",
                      category: t,
                      type: "boolean",
                      default: !1,
                      description:
                        "Enforce single attribute per line in HTML, Vue and JSX.",
                    },
                  };
                },
              }),
              jm = Z({
                "src/language-js/options.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Lt(),
                    s = "JavaScript";
                  n.exports = {
                    arrowParens: {
                      since: "1.9.0",
                      category: s,
                      type: "choice",
                      default: [
                        { since: "1.9.0", value: "avoid" },
                        { since: "2.0.0", value: "always" },
                      ],
                      description:
                        "Include parentheses around a sole arrow function parameter.",
                      choices: [
                        {
                          value: "always",
                          description:
                            "Always include parens. Example: `(x) => x`",
                        },
                        {
                          value: "avoid",
                          description:
                            "Omit parens when possible. Example: `x => x`",
                        },
                      ],
                    },
                    bracketSameLine: t.bracketSameLine,
                    bracketSpacing: t.bracketSpacing,
                    jsxBracketSameLine: {
                      since: "0.17.0",
                      category: s,
                      type: "boolean",
                      description:
                        "Put > on the last line instead of at a new line.",
                      deprecated: "2.4.0",
                    },
                    semi: {
                      since: "1.0.0",
                      category: s,
                      type: "boolean",
                      default: !0,
                      description: "Print semicolons.",
                      oppositeDescription:
                        "Do not print semicolons, except at the beginning of lines which may need them.",
                    },
                    singleQuote: t.singleQuote,
                    jsxSingleQuote: {
                      since: "1.15.0",
                      category: s,
                      type: "boolean",
                      default: !1,
                      description: "Use single quotes in JSX.",
                    },
                    quoteProps: {
                      since: "1.17.0",
                      category: s,
                      type: "choice",
                      default: "as-needed",
                      description:
                        "Change when properties in objects are quoted.",
                      choices: [
                        {
                          value: "as-needed",
                          description:
                            "Only add quotes around object properties where required.",
                        },
                        {
                          value: "consistent",
                          description:
                            "If at least one property in an object requires quotes, quote all properties.",
                        },
                        {
                          value: "preserve",
                          description:
                            "Respect the input use of quotes in object properties.",
                        },
                      ],
                    },
                    trailingComma: {
                      since: "0.0.0",
                      category: s,
                      type: "choice",
                      default: [
                        { since: "0.0.0", value: !1 },
                        { since: "0.19.0", value: "none" },
                        { since: "2.0.0", value: "es5" },
                      ],
                      description:
                        "Print trailing commas wherever possible when multi-line.",
                      choices: [
                        {
                          value: "es5",
                          description:
                            "Trailing commas where valid in ES5 (objects, arrays, etc.)",
                        },
                        { value: "none", description: "No trailing commas." },
                        {
                          value: "all",
                          description:
                            "Trailing commas wherever possible (including function arguments).",
                        },
                      ],
                    },
                    singleAttributePerLine: t.singleAttributePerLine,
                  };
                },
              }),
              qm = Z({
                "src/language-js/parse/parsers.js"() {
                  ae();
                },
              }),
              Fn = Z({
                "node_modules/linguist-languages/data/JavaScript.json"(e, n) {
                  n.exports = {
                    name: "JavaScript",
                    type: "programming",
                    tmScope: "source.js",
                    aceMode: "javascript",
                    codemirrorMode: "javascript",
                    codemirrorMimeType: "text/javascript",
                    color: "#f1e05a",
                    aliases: ["js", "node"],
                    extensions: [
                      ".js",
                      "._js",
                      ".bones",
                      ".cjs",
                      ".es",
                      ".es6",
                      ".frag",
                      ".gs",
                      ".jake",
                      ".jsb",
                      ".jscad",
                      ".jsfl",
                      ".jsm",
                      ".jss",
                      ".jsx",
                      ".mjs",
                      ".njs",
                      ".pac",
                      ".sjs",
                      ".ssjs",
                      ".xsjs",
                      ".xsjslib",
                    ],
                    filenames: ["Jakefile"],
                    interpreters: [
                      "chakra",
                      "d8",
                      "gjs",
                      "js",
                      "node",
                      "nodejs",
                      "qjs",
                      "rhino",
                      "v8",
                      "v8-shell",
                    ],
                    languageId: 183,
                  };
                },
              }),
              Mm = Z({
                "node_modules/linguist-languages/data/TypeScript.json"(e, n) {
                  n.exports = {
                    name: "TypeScript",
                    type: "programming",
                    color: "#2b7489",
                    aliases: ["ts"],
                    interpreters: ["deno", "ts-node"],
                    extensions: [".ts"],
                    tmScope: "source.ts",
                    aceMode: "typescript",
                    codemirrorMode: "javascript",
                    codemirrorMimeType: "application/typescript",
                    languageId: 378,
                  };
                },
              }),
              Rm = Z({
                "node_modules/linguist-languages/data/TSX.json"(e, n) {
                  n.exports = {
                    name: "TSX",
                    type: "programming",
                    group: "TypeScript",
                    extensions: [".tsx"],
                    tmScope: "source.tsx",
                    aceMode: "javascript",
                    codemirrorMode: "jsx",
                    codemirrorMimeType: "text/jsx",
                    languageId: 94901924,
                  };
                },
              }),
              mi = Z({
                "node_modules/linguist-languages/data/JSON.json"(e, n) {
                  n.exports = {
                    name: "JSON",
                    type: "data",
                    tmScope: "source.json",
                    aceMode: "json",
                    codemirrorMode: "javascript",
                    codemirrorMimeType: "application/json",
                    extensions: [
                      ".json",
                      ".avsc",
                      ".geojson",
                      ".gltf",
                      ".har",
                      ".ice",
                      ".JSON-tmLanguage",
                      ".jsonl",
                      ".mcmeta",
                      ".tfstate",
                      ".tfstate.backup",
                      ".topojson",
                      ".webapp",
                      ".webmanifest",
                      ".yy",
                      ".yyp",
                    ],
                    filenames: [
                      ".arcconfig",
                      ".htmlhintrc",
                      ".imgbotconfig",
                      ".tern-config",
                      ".tern-project",
                      ".watchmanconfig",
                      "Pipfile.lock",
                      "composer.lock",
                      "mcmod.info",
                    ],
                    languageId: 174,
                  };
                },
              }),
              Vm = Z({
                "node_modules/linguist-languages/data/JSON with Comments.json"(
                  e,
                  n
                ) {
                  n.exports = {
                    name: "JSON with Comments",
                    type: "data",
                    group: "JSON",
                    tmScope: "source.js",
                    aceMode: "javascript",
                    codemirrorMode: "javascript",
                    codemirrorMimeType: "text/javascript",
                    aliases: ["jsonc"],
                    extensions: [
                      ".jsonc",
                      ".sublime-build",
                      ".sublime-commands",
                      ".sublime-completions",
                      ".sublime-keymap",
                      ".sublime-macro",
                      ".sublime-menu",
                      ".sublime-mousemap",
                      ".sublime-project",
                      ".sublime-settings",
                      ".sublime-theme",
                      ".sublime-workspace",
                      ".sublime_metrics",
                      ".sublime_session",
                    ],
                    filenames: [
                      ".babelrc",
                      ".eslintrc.json",
                      ".jscsrc",
                      ".jshintrc",
                      ".jslintrc",
                      "api-extractor.json",
                      "devcontainer.json",
                      "jsconfig.json",
                      "language-configuration.json",
                      "tsconfig.json",
                      "tslint.json",
                    ],
                    languageId: 423,
                  };
                },
              }),
              Wm = Z({
                "node_modules/linguist-languages/data/JSON5.json"(e, n) {
                  n.exports = {
                    name: "JSON5",
                    type: "data",
                    extensions: [".json5"],
                    tmScope: "source.js",
                    aceMode: "javascript",
                    codemirrorMode: "javascript",
                    codemirrorMimeType: "application/json",
                    languageId: 175,
                  };
                },
              }),
              $m = Z({
                "src/language-js/index.js"(e, n) {
                  "use strict";
                  ae();
                  var t = bt(),
                    s = Lm(),
                    i = Om(),
                    r = jm(),
                    u = qm(),
                    a = [
                      t(Fn(), (l) => ({
                        since: "0.0.0",
                        parsers: [
                          "babel",
                          "acorn",
                          "espree",
                          "meriyah",
                          "babel-flow",
                          "babel-ts",
                          "flow",
                          "typescript",
                        ],
                        vscodeLanguageIds: ["javascript", "mongo"],
                        interpreters: [...l.interpreters, "zx"],
                        extensions: [
                          ...l.extensions.filter((C) => C !== ".jsx"),
                          ".wxs",
                        ],
                      })),
                      t(Fn(), () => ({
                        name: "Flow",
                        since: "0.0.0",
                        parsers: ["flow", "babel-flow"],
                        vscodeLanguageIds: ["javascript"],
                        aliases: [],
                        filenames: [],
                        extensions: [".js.flow"],
                      })),
                      t(Fn(), () => ({
                        name: "JSX",
                        since: "0.0.0",
                        parsers: [
                          "babel",
                          "babel-flow",
                          "babel-ts",
                          "flow",
                          "typescript",
                          "espree",
                          "meriyah",
                        ],
                        vscodeLanguageIds: ["javascriptreact"],
                        aliases: void 0,
                        filenames: void 0,
                        extensions: [".jsx"],
                        group: "JavaScript",
                        interpreters: void 0,
                        tmScope: "source.js.jsx",
                        aceMode: "javascript",
                        codemirrorMode: "jsx",
                        codemirrorMimeType: "text/jsx",
                        color: void 0,
                      })),
                      t(Mm(), (l) => ({
                        since: "1.4.0",
                        parsers: ["typescript", "babel-ts"],
                        vscodeLanguageIds: ["typescript"],
                        extensions: [...l.extensions, ".mts", ".cts"],
                      })),
                      t(Rm(), () => ({
                        since: "1.4.0",
                        parsers: ["typescript", "babel-ts"],
                        vscodeLanguageIds: ["typescriptreact"],
                      })),
                      t(mi(), () => ({
                        name: "JSON.stringify",
                        since: "1.13.0",
                        parsers: ["json-stringify"],
                        vscodeLanguageIds: ["json"],
                        extensions: [],
                        filenames: [
                          "package.json",
                          "package-lock.json",
                          "composer.json",
                        ],
                      })),
                      t(mi(), (l) => ({
                        since: "1.5.0",
                        parsers: ["json"],
                        vscodeLanguageIds: ["json"],
                        extensions: l.extensions.filter((C) => C !== ".jsonl"),
                      })),
                      t(Vm(), (l) => ({
                        since: "1.5.0",
                        parsers: ["json"],
                        vscodeLanguageIds: ["jsonc"],
                        filenames: [...l.filenames, ".eslintrc", ".swcrc"],
                      })),
                      t(Wm(), () => ({
                        since: "1.13.0",
                        parsers: ["json5"],
                        vscodeLanguageIds: ["json5"],
                      })),
                    ],
                    c = { estree: s, "estree-json": i };
                  n.exports = {
                    languages: a,
                    options: r,
                    printers: c,
                    parsers: u,
                  };
                },
              }),
              Hm = Z({
                "src/language-css/clean.js"(e, n) {
                  "use strict";
                  ae();
                  var { isFrontMatterNode: t } = Ge(),
                    s = st(),
                    i = new Set([
                      "raw",
                      "raws",
                      "sourceIndex",
                      "source",
                      "before",
                      "after",
                      "trailingComma",
                    ]);
                  function r(a, c, l) {
                    if (
                      (t(a) && a.lang === "yaml" && delete c.value,
                      a.type === "css-comment" &&
                        l.type === "css-root" &&
                        l.nodes.length > 0 &&
                        (((l.nodes[0] === a ||
                          (t(l.nodes[0]) && l.nodes[1] === a)) &&
                          (delete c.text,
                          /^\*\s*@(?:format|prettier)\s*$/.test(a.text))) ||
                          (l.type === "css-root" && s(l.nodes) === a)))
                    )
                      return null;
                    if (
                      (a.type === "value-root" && delete c.text,
                      (a.type === "media-query" ||
                        a.type === "media-query-list" ||
                        a.type === "media-feature-expression") &&
                        delete c.value,
                      a.type === "css-rule" && delete c.params,
                      a.type === "selector-combinator" &&
                        (c.value = c.value.replace(/\s+/g, " ")),
                      a.type === "media-feature" &&
                        (c.value = c.value.replace(/ /g, "")),
                      ((a.type === "value-word" &&
                        ((a.isColor && a.isHex) ||
                          ["initial", "inherit", "unset", "revert"].includes(
                            c.value.replace().toLowerCase()
                          ))) ||
                        a.type === "media-feature" ||
                        a.type === "selector-root-invalid" ||
                        a.type === "selector-pseudo") &&
                        (c.value = c.value.toLowerCase()),
                      a.type === "css-decl" && (c.prop = c.prop.toLowerCase()),
                      (a.type === "css-atrule" || a.type === "css-import") &&
                        (c.name = c.name.toLowerCase()),
                      a.type === "value-number" &&
                        (c.unit = c.unit.toLowerCase()),
                      (a.type === "media-feature" ||
                        a.type === "media-keyword" ||
                        a.type === "media-type" ||
                        a.type === "media-unknown" ||
                        a.type === "media-url" ||
                        a.type === "media-value" ||
                        a.type === "selector-attribute" ||
                        a.type === "selector-string" ||
                        a.type === "selector-class" ||
                        a.type === "selector-combinator" ||
                        a.type === "value-string") &&
                        c.value &&
                        (c.value = u(c.value)),
                      a.type === "selector-attribute" &&
                        ((c.attribute = c.attribute.trim()),
                        c.namespace &&
                          typeof c.namespace == "string" &&
                          ((c.namespace = c.namespace.trim()),
                          c.namespace.length === 0 && (c.namespace = !0)),
                        c.value &&
                          ((c.value = c.value
                            .trim()
                            .replace(/^["']|["']$/g, "")),
                          delete c.quoted)),
                      (a.type === "media-value" ||
                        a.type === "media-type" ||
                        a.type === "value-number" ||
                        a.type === "selector-root-invalid" ||
                        a.type === "selector-class" ||
                        a.type === "selector-combinator" ||
                        a.type === "selector-tag") &&
                        c.value &&
                        (c.value = c.value.replace(
                          /([\d+.Ee-]+)([A-Za-z]*)/g,
                          (C, m, g) => {
                            let p = Number(m);
                            return Number.isNaN(p) ? C : p + g.toLowerCase();
                          }
                        )),
                      a.type === "selector-tag")
                    ) {
                      let C = a.value.toLowerCase();
                      ["from", "to"].includes(C) && (c.value = C);
                    }
                    if (
                      (a.type === "css-atrule" &&
                        a.name.toLowerCase() === "supports" &&
                        delete c.value,
                      a.type === "selector-unknown" && delete c.value,
                      a.type === "value-comma_group")
                    ) {
                      let C = a.groups.findIndex(
                        (m) => m.type === "value-number" && m.unit === "..."
                      );
                      C !== -1 &&
                        ((c.groups[C].unit = ""),
                        c.groups.splice(C + 1, 0, {
                          type: "value-word",
                          value: "...",
                          isColor: !1,
                          isHex: !1,
                        }));
                    }
                  }
                  r.ignoredProperties = i;
                  function u(a) {
                    return a
                      .replace(/'/g, '"')
                      .replace(/\\([^\dA-Fa-f])/g, "$1");
                  }
                  n.exports = r;
                },
              }),
              Xn = Z({
                "src/utils/front-matter/print.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                    builders: { hardline: t, markAsRoot: s },
                  } = Le();
                  function i(r, u) {
                    if (r.lang === "yaml") {
                      let a = r.value.trim(),
                        c = a
                          ? u(
                              a,
                              { parser: "yaml" },
                              { stripTrailingHardline: !0 }
                            )
                          : "";
                      return s([
                        r.startDelimiter,
                        t,
                        c,
                        c ? t : "",
                        r.endDelimiter,
                      ]);
                    }
                  }
                  n.exports = i;
                },
              }),
              Gm = Z({
                "src/language-css/embed.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: { hardline: t },
                    } = Le(),
                    s = Xn();
                  function i(r, u, a) {
                    let c = r.getValue();
                    if (c.type === "front-matter") {
                      let l = s(c, a);
                      return l ? [l, t] : "";
                    }
                  }
                  n.exports = i;
                },
              }),
              po = Z({
                "src/utils/front-matter/parse.js"(e, n) {
                  "use strict";
                  ae();
                  var t = new RegExp(
                    "^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)",
                    "s"
                  );
                  function s(i) {
                    let r = i.match(t);
                    if (!r) return { content: i };
                    let {
                        startDelimiter: u,
                        language: a,
                        value: c = "",
                        endDelimiter: l,
                      } = r.groups,
                      C = a.trim() || "yaml";
                    if ((u === "+++" && (C = "toml"), C !== "yaml" && u !== l))
                      return { content: i };
                    let [m] = r;
                    return {
                      frontMatter: {
                        type: "front-matter",
                        lang: C,
                        value: c,
                        startDelimiter: u,
                        endDelimiter: l,
                        raw: m.replace(/\n$/, ""),
                      },
                      content: m.replace(/[^\n]/g, " ") + i.slice(m.length),
                    };
                  }
                  n.exports = s;
                },
              }),
              Jm = Z({
                "src/language-css/pragma.js"(e, n) {
                  "use strict";
                  ae();
                  var t = eo(),
                    s = po();
                  function i(u) {
                    return t.hasPragma(s(u).content);
                  }
                  function r(u) {
                    let { frontMatter: a, content: c } = s(u);
                    return (
                      (a
                        ? a.raw +
                          `

`
                        : "") + t.insertPragma(c)
                    );
                  }
                  n.exports = { hasPragma: i, insertPragma: r };
                },
              }),
              Um = Z({
                "src/language-css/utils/index.js"(e, n) {
                  "use strict";
                  ae();
                  var t = new Set([
                    "red",
                    "green",
                    "blue",
                    "alpha",
                    "a",
                    "rgb",
                    "hue",
                    "h",
                    "saturation",
                    "s",
                    "lightness",
                    "l",
                    "whiteness",
                    "w",
                    "blackness",
                    "b",
                    "tint",
                    "shade",
                    "blend",
                    "blenda",
                    "contrast",
                    "hsl",
                    "hsla",
                    "hwb",
                    "hwba",
                  ]);
                  function s(q, le) {
                    let ue = Array.isArray(le) ? le : [le],
                      Q = -1,
                      de;
                    for (; (de = q.getParentNode(++Q)); )
                      if (ue.includes(de.type)) return Q;
                    return -1;
                  }
                  function i(q, le) {
                    let ue = s(q, le);
                    return ue === -1 ? null : q.getParentNode(ue);
                  }
                  function r(q) {
                    let le = i(q, "css-decl");
                    return le && le.prop && le.prop.toLowerCase();
                  }
                  function u(q) {
                    return ["initial", "inherit", "unset", "revert"].includes(
                      q.toLowerCase()
                    );
                  }
                  function a(q, le) {
                    let ue = i(q, "css-atrule");
                    return (
                      ue &&
                      ue.name &&
                      ue.name.toLowerCase().endsWith("keyframes") &&
                      ["from", "to"].includes(le.toLowerCase())
                    );
                  }
                  function c(q) {
                    return q.includes("$") ||
                      q.includes("@") ||
                      q.includes("#") ||
                      q.startsWith("%") ||
                      q.startsWith("--") ||
                      q.startsWith(":--") ||
                      (q.includes("(") && q.includes(")"))
                      ? q
                      : q.toLowerCase();
                  }
                  function l(q, le) {
                    let ue = i(q, "value-func");
                    return ue && ue.value && ue.value.toLowerCase() === le;
                  }
                  function C(q) {
                    let le = i(q, "css-rule");
                    return (
                      le &&
                      le.raws &&
                      le.raws.selector &&
                      (le.raws.selector.startsWith(":import") ||
                        le.raws.selector.startsWith(":export"))
                    );
                  }
                  function m(q, le) {
                    let ue = Array.isArray(le) ? le : [le],
                      Q = i(q, "css-atrule");
                    return Q && ue.includes(Q.name.toLowerCase());
                  }
                  function g(q) {
                    let le = q.getValue(),
                      ue = i(q, "css-atrule");
                    return (
                      ue &&
                      ue.name === "import" &&
                      le.groups[0].value === "url" &&
                      le.groups.length === 2
                    );
                  }
                  function p(q) {
                    return (
                      q.type === "value-func" && q.value.toLowerCase() === "url"
                    );
                  }
                  function f(q, le) {
                    let ue = q.getParentNode();
                    if (!ue) return !1;
                    let { nodes: Q } = ue;
                    return Q && Q.indexOf(le) === Q.length - 1;
                  }
                  function h(q) {
                    return q.selector
                      ? (typeof q.selector == "string" &&
                          /^@.+:.*$/.test(q.selector)) ||
                          (q.selector.value &&
                            /^@.+:.*$/.test(q.selector.value))
                      : !1;
                  }
                  function N(q) {
                    return (
                      q.type === "value-word" &&
                      ["from", "through", "end"].includes(q.value)
                    );
                  }
                  function T(q) {
                    return (
                      q.type === "value-word" &&
                      ["and", "or", "not"].includes(q.value)
                    );
                  }
                  function A(q) {
                    return q.type === "value-word" && q.value === "in";
                  }
                  function b(q) {
                    return q.type === "value-operator" && q.value === "*";
                  }
                  function v(q) {
                    return q.type === "value-operator" && q.value === "/";
                  }
                  function B(q) {
                    return q.type === "value-operator" && q.value === "+";
                  }
                  function w(q) {
                    return q.type === "value-operator" && q.value === "-";
                  }
                  function I(q) {
                    return q.type === "value-operator" && q.value === "%";
                  }
                  function E(q) {
                    return b(q) || v(q) || B(q) || w(q) || I(q);
                  }
                  function D(q) {
                    return (
                      q.type === "value-word" && ["==", "!="].includes(q.value)
                    );
                  }
                  function d(q) {
                    return (
                      q.type === "value-word" &&
                      ["<", ">", "<=", ">="].includes(q.value)
                    );
                  }
                  function y(q) {
                    return (
                      q.type === "css-atrule" &&
                      ["if", "else", "for", "each", "while"].includes(q.name)
                    );
                  }
                  function o(q) {
                    return (
                      q.raws && q.raws.params && /^\(\s*\)$/.test(q.raws.params)
                    );
                  }
                  function x(q) {
                    return q.name.startsWith("prettier-placeholder");
                  }
                  function F(q) {
                    return q.prop.startsWith("@prettier-placeholder");
                  }
                  function S(q, le) {
                    return (
                      q.value === "$$" &&
                      q.type === "value-func" &&
                      le &&
                      le.type === "value-word" &&
                      !le.raws.before
                    );
                  }
                  function k(q) {
                    return (
                      q.value &&
                      q.value.type === "value-root" &&
                      q.value.group &&
                      q.value.group.type === "value-value" &&
                      q.prop.toLowerCase() === "composes"
                    );
                  }
                  function _(q) {
                    return (
                      q.value &&
                      q.value.group &&
                      q.value.group.group &&
                      q.value.group.group.type === "value-paren_group" &&
                      q.value.group.group.open !== null &&
                      q.value.group.group.close !== null
                    );
                  }
                  function O(q) {
                    return q.raws && q.raws.before === "";
                  }
                  function R(q) {
                    return (
                      q.type === "value-comma_group" &&
                      q.groups &&
                      q.groups[1] &&
                      q.groups[1].type === "value-colon"
                    );
                  }
                  function M(q) {
                    return (
                      q.type === "value-paren_group" &&
                      q.groups &&
                      q.groups[0] &&
                      R(q.groups[0])
                    );
                  }
                  function H(q) {
                    let le = q.getValue();
                    if (le.groups.length === 0) return !1;
                    let ue = q.getParentNode(1);
                    if (!M(le) && !(ue && M(ue))) return !1;
                    let Q = i(q, "css-decl");
                    return !!(
                      (Q && Q.prop && Q.prop.startsWith("$")) ||
                      M(ue) ||
                      ue.type === "value-func"
                    );
                  }
                  function P(q) {
                    return q.type === "value-comment" && q.inline;
                  }
                  function G(q) {
                    return q.type === "value-word" && q.value === "#";
                  }
                  function re(q) {
                    return q.type === "value-word" && q.value === "{";
                  }
                  function $(q) {
                    return q.type === "value-word" && q.value === "}";
                  }
                  function W(q) {
                    return ["value-word", "value-atword"].includes(q.type);
                  }
                  function ee(q) {
                    return q && q.type === "value-colon";
                  }
                  function U(q, le) {
                    if (!R(le)) return !1;
                    let { groups: ue } = le,
                      Q = ue.indexOf(q);
                    return Q === -1 ? !1 : ee(ue[Q + 1]);
                  }
                  function ne(q) {
                    return (
                      q.value &&
                      ["not", "and", "or"].includes(q.value.toLowerCase())
                    );
                  }
                  function se(q) {
                    return q.type !== "value-func"
                      ? !1
                      : t.has(q.value.toLowerCase());
                  }
                  function V(q) {
                    return /\/\//.test(q.split(/[\n\r]/).pop());
                  }
                  function oe(q) {
                    return (
                      q &&
                      q.type === "value-atword" &&
                      q.value.startsWith("prettier-placeholder-")
                    );
                  }
                  function K(q, le) {
                    if (
                      !q.open ||
                      q.open.value !== "(" ||
                      !q.close ||
                      q.close.value !== ")" ||
                      q.groups.some((ue) => ue.type !== "value-comma_group")
                    )
                      return !1;
                    if (le.type === "value-comma_group") {
                      let ue = le.groups.indexOf(q) - 1,
                        Q = le.groups[ue];
                      if (Q && Q.type === "value-word" && Q.value === "with")
                        return !0;
                    }
                    return !1;
                  }
                  function Ee(q) {
                    return (
                      q.type === "value-paren_group" &&
                      q.open &&
                      q.open.value === "(" &&
                      q.close &&
                      q.close.value === ")"
                    );
                  }
                  n.exports = {
                    getAncestorCounter: s,
                    getAncestorNode: i,
                    getPropOfDeclNode: r,
                    maybeToLowerCase: c,
                    insideValueFunctionNode: l,
                    insideICSSRuleNode: C,
                    insideAtRuleNode: m,
                    insideURLFunctionInImportAtRuleNode: g,
                    isKeyframeAtRuleKeywords: a,
                    isWideKeywords: u,
                    isLastNode: f,
                    isSCSSControlDirectiveNode: y,
                    isDetachedRulesetDeclarationNode: h,
                    isRelationalOperatorNode: d,
                    isEqualityOperatorNode: D,
                    isMultiplicationNode: b,
                    isDivisionNode: v,
                    isAdditionNode: B,
                    isSubtractionNode: w,
                    isModuloNode: I,
                    isMathOperatorNode: E,
                    isEachKeywordNode: A,
                    isForKeywordNode: N,
                    isURLFunctionNode: p,
                    isIfElseKeywordNode: T,
                    hasComposesNode: k,
                    hasParensAroundNode: _,
                    hasEmptyRawBefore: O,
                    isDetachedRulesetCallNode: o,
                    isTemplatePlaceholderNode: x,
                    isTemplatePropNode: F,
                    isPostcssSimpleVarNode: S,
                    isKeyValuePairNode: R,
                    isKeyValuePairInParenGroupNode: M,
                    isKeyInValuePairNode: U,
                    isSCSSMapItemNode: H,
                    isInlineValueCommentNode: P,
                    isHashNode: G,
                    isLeftCurlyBraceNode: re,
                    isRightCurlyBraceNode: $,
                    isWordNode: W,
                    isColonNode: ee,
                    isMediaAndSupportsKeywords: ne,
                    isColorAdjusterFuncNode: se,
                    lastLineHasInlineComment: V,
                    isAtWordPlaceholderNode: oe,
                    isConfigurationNode: K,
                    isParenGroupNode: Ee,
                  };
                },
              }),
              zm = Z({
                "src/utils/line-column-to-index.js"(e, n) {
                  "use strict";
                  ae(),
                    (n.exports = function (t, s) {
                      let i = 0;
                      for (let r = 0; r < t.line - 1; ++r)
                        i =
                          s.indexOf(
                            `
`,
                            i
                          ) + 1;
                      return i + t.column;
                    });
                },
              }),
              Xm = Z({
                "src/language-css/loc.js"(e, n) {
                  "use strict";
                  ae();
                  var { skipEverythingButNewLine: t } = Tr(),
                    s = st(),
                    i = zm();
                  function r(p, f) {
                    return typeof p.sourceIndex == "number"
                      ? p.sourceIndex
                      : p.source
                      ? i(p.source.start, f) - 1
                      : null;
                  }
                  function u(p, f) {
                    if (p.type === "css-comment" && p.inline)
                      return t(f, p.source.startOffset);
                    let h = p.nodes && s(p.nodes);
                    return (
                      h && p.source && !p.source.end && (p = h),
                      p.source && p.source.end ? i(p.source.end, f) : null
                    );
                  }
                  function a(p, f) {
                    p.source &&
                      ((p.source.startOffset = r(p, f)),
                      (p.source.endOffset = u(p, f)));
                    for (let h in p) {
                      let N = p[h];
                      h === "source" ||
                        !N ||
                        typeof N != "object" ||
                        (N.type === "value-root" || N.type === "value-unknown"
                          ? c(N, l(p), N.text || N.value)
                          : a(N, f));
                    }
                  }
                  function c(p, f, h) {
                    p.source &&
                      ((p.source.startOffset = r(p, h) + f),
                      (p.source.endOffset = u(p, h) + f));
                    for (let N in p) {
                      let T = p[N];
                      N === "source" ||
                        !T ||
                        typeof T != "object" ||
                        c(T, f, h);
                    }
                  }
                  function l(p) {
                    let f = p.source.startOffset;
                    return (
                      typeof p.prop == "string" && (f += p.prop.length),
                      p.type === "css-atrule" &&
                        typeof p.name == "string" &&
                        (f +=
                          1 +
                          p.name.length +
                          p.raws.afterName.match(/^\s*:?\s*/)[0].length),
                      p.type !== "css-atrule" &&
                        p.raws &&
                        typeof p.raws.between == "string" &&
                        (f += p.raws.between.length),
                      f
                    );
                  }
                  function C(p) {
                    let f = "initial",
                      h = "initial",
                      N,
                      T = !1,
                      A = [];
                    for (let b = 0; b < p.length; b++) {
                      let v = p[b];
                      switch (f) {
                        case "initial":
                          if (v === "'") {
                            f = "single-quotes";
                            continue;
                          }
                          if (v === '"') {
                            f = "double-quotes";
                            continue;
                          }
                          if (
                            (v === "u" || v === "U") &&
                            p.slice(b, b + 4).toLowerCase() === "url("
                          ) {
                            (f = "url"), (b += 3);
                            continue;
                          }
                          if (v === "*" && p[b - 1] === "/") {
                            f = "comment-block";
                            continue;
                          }
                          if (v === "/" && p[b - 1] === "/") {
                            (f = "comment-inline"), (N = b - 1);
                            continue;
                          }
                          continue;
                        case "single-quotes":
                          if (
                            (v === "'" &&
                              p[b - 1] !== "\\" &&
                              ((f = h), (h = "initial")),
                            v ===
                              `
` || v === "\r")
                          )
                            return p;
                          continue;
                        case "double-quotes":
                          if (
                            (v === '"' &&
                              p[b - 1] !== "\\" &&
                              ((f = h), (h = "initial")),
                            v ===
                              `
` || v === "\r")
                          )
                            return p;
                          continue;
                        case "url":
                          if (
                            (v === ")" && (f = "initial"),
                            v ===
                              `
` || v === "\r")
                          )
                            return p;
                          if (v === "'") {
                            (f = "single-quotes"), (h = "url");
                            continue;
                          }
                          if (v === '"') {
                            (f = "double-quotes"), (h = "url");
                            continue;
                          }
                          continue;
                        case "comment-block":
                          v === "/" && p[b - 1] === "*" && (f = "initial");
                          continue;
                        case "comment-inline":
                          (v === '"' || v === "'" || v === "*") && (T = !0),
                            (v ===
                              `
` ||
                              v === "\r") &&
                              (T && A.push([N, b]), (f = "initial"), (T = !1));
                          continue;
                      }
                    }
                    for (let [b, v] of A)
                      p =
                        p.slice(0, b) +
                        p.slice(b, v).replace(/["'*]/g, " ") +
                        p.slice(v);
                    return p;
                  }
                  function m(p) {
                    return p.source.startOffset;
                  }
                  function g(p) {
                    return p.source.endOffset;
                  }
                  n.exports = {
                    locStart: m,
                    locEnd: g,
                    calculateLoc: a,
                    replaceQuotesInInlineComments: C,
                  };
                },
              }),
              Km = Z({
                "src/language-css/utils/is-less-parser.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s) {
                    return s.parser === "css" || s.parser === "less";
                  }
                  n.exports = t;
                },
              }),
              Ym = Z({
                "src/language-css/utils/is-scss.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s, i) {
                    return s === "less" || s === "scss"
                      ? s === "scss"
                      : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(i);
                  }
                  n.exports = t;
                },
              }),
              Qm = Z({
                "src/language-css/utils/css-units.evaluate.js"(e, n) {
                  n.exports = {
                    em: "em",
                    rem: "rem",
                    ex: "ex",
                    rex: "rex",
                    cap: "cap",
                    rcap: "rcap",
                    ch: "ch",
                    rch: "rch",
                    ic: "ic",
                    ric: "ric",
                    lh: "lh",
                    rlh: "rlh",
                    vw: "vw",
                    vh: "vh",
                    vi: "vi",
                    vb: "vb",
                    vmin: "vmin",
                    vmax: "vmax",
                    cm: "cm",
                    mm: "mm",
                    q: "Q",
                    in: "in",
                    pt: "pt",
                    pc: "pc",
                    px: "px",
                    deg: "deg",
                    grad: "grad",
                    rad: "rad",
                    turn: "turn",
                    s: "s",
                    ms: "ms",
                    hz: "Hz",
                    khz: "kHz",
                    dpi: "dpi",
                    dpcm: "dpcm",
                    dppx: "dppx",
                    x: "x",
                  };
                },
              }),
              Zm = Z({
                "src/language-css/utils/print-unit.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Qm();
                  function s(i) {
                    let r = i.toLowerCase();
                    return Object.prototype.hasOwnProperty.call(t, r)
                      ? t[r]
                      : i;
                  }
                  n.exports = s;
                },
              }),
              ed = Z({
                "src/language-css/printer-postcss.js"(e, n) {
                  "use strict";
                  ae();
                  var t = st(),
                    {
                      printNumber: s,
                      printString: i,
                      hasNewline: r,
                      isFrontMatterNode: u,
                      isNextLineEmpty: a,
                      isNonEmptyArray: c,
                    } = Ge(),
                    {
                      builders: {
                        join: l,
                        line: C,
                        hardline: m,
                        softline: g,
                        group: p,
                        fill: f,
                        indent: h,
                        dedent: N,
                        ifBreak: T,
                        breakParent: A,
                      },
                      utils: { removeLines: b, getDocParts: v },
                    } = Le(),
                    B = Hm(),
                    w = Gm(),
                    { insertPragma: I } = Jm(),
                    {
                      getAncestorNode: E,
                      getPropOfDeclNode: D,
                      maybeToLowerCase: d,
                      insideValueFunctionNode: y,
                      insideICSSRuleNode: o,
                      insideAtRuleNode: x,
                      insideURLFunctionInImportAtRuleNode: F,
                      isKeyframeAtRuleKeywords: S,
                      isWideKeywords: k,
                      isLastNode: _,
                      isSCSSControlDirectiveNode: O,
                      isDetachedRulesetDeclarationNode: R,
                      isRelationalOperatorNode: M,
                      isEqualityOperatorNode: H,
                      isMultiplicationNode: P,
                      isDivisionNode: G,
                      isAdditionNode: re,
                      isSubtractionNode: $,
                      isMathOperatorNode: W,
                      isEachKeywordNode: ee,
                      isForKeywordNode: U,
                      isURLFunctionNode: ne,
                      isIfElseKeywordNode: se,
                      hasComposesNode: V,
                      hasParensAroundNode: oe,
                      hasEmptyRawBefore: K,
                      isKeyValuePairNode: Ee,
                      isKeyInValuePairNode: q,
                      isDetachedRulesetCallNode: le,
                      isTemplatePlaceholderNode: ue,
                      isTemplatePropNode: Q,
                      isPostcssSimpleVarNode: de,
                      isSCSSMapItemNode: ge,
                      isInlineValueCommentNode: ve,
                      isHashNode: xe,
                      isLeftCurlyBraceNode: we,
                      isRightCurlyBraceNode: fe,
                      isWordNode: pe,
                      isColonNode: me,
                      isMediaAndSupportsKeywords: ce,
                      isColorAdjusterFuncNode: he,
                      lastLineHasInlineComment: J,
                      isAtWordPlaceholderNode: ye,
                      isConfigurationNode: X,
                      isParenGroupNode: Y,
                    } = Um(),
                    { locStart: te, locEnd: z } = Xm(),
                    j = Km(),
                    Ce = Ym(),
                    Ne = Zm();
                  function je(Ae) {
                    return (
                      Ae.trailingComma === "es5" || Ae.trailingComma === "all"
                    );
                  }
                  function Ue(Ae, Oe, Pe) {
                    let ie = Ae.getValue();
                    if (!ie) return "";
                    if (typeof ie == "string") return ie;
                    switch (ie.type) {
                      case "front-matter":
                        return [ie.raw, m];
                      case "css-root": {
                        let Me = tt(Ae, Oe, Pe),
                          qe = ie.raws.after.trim();
                        return [
                          Me,
                          qe ? " ".concat(qe) : "",
                          v(Me).length > 0 ? m : "",
                        ];
                      }
                      case "css-comment": {
                        let Me = ie.inline || ie.raws.inline,
                          qe = Oe.originalText.slice(te(ie), z(ie));
                        return Me ? qe.trimEnd() : qe;
                      }
                      case "css-rule":
                        return [
                          Pe("selector"),
                          ie.important ? " !important" : "",
                          ie.nodes
                            ? [
                                ie.selector &&
                                ie.selector.type === "selector-unknown" &&
                                J(ie.selector.value)
                                  ? C
                                  : " ",
                                "{",
                                ie.nodes.length > 0
                                  ? h([m, tt(Ae, Oe, Pe)])
                                  : "",
                                m,
                                "}",
                                R(ie) ? ";" : "",
                              ]
                            : ";",
                        ];
                      case "css-decl": {
                        let Me = Ae.getParentNode(),
                          { between: qe } = ie.raws,
                          Je = qe.trim(),
                          rt = Je === ":",
                          Ze = V(ie) ? b(Pe("value")) : Pe("value");
                        return (
                          !rt && J(Je) && (Ze = h([m, N(Ze)])),
                          [
                            ie.raws.before.replace(/[\s;]/g, ""),
                            o(Ae) ? ie.prop : d(ie.prop),
                            Je.startsWith("//") ? " " : "",
                            Je,
                            ie.extend ? "" : " ",
                            j(Oe) && ie.extend && ie.selector
                              ? ["extend(", Pe("selector"), ")"]
                              : "",
                            Ze,
                            ie.raws.important
                              ? ie.raws.important.replace(
                                  /\s*!\s*important/i,
                                  " !important"
                                )
                              : ie.important
                              ? " !important"
                              : "",
                            ie.raws.scssDefault
                              ? ie.raws.scssDefault.replace(
                                  /\s*!default/i,
                                  " !default"
                                )
                              : ie.scssDefault
                              ? " !default"
                              : "",
                            ie.raws.scssGlobal
                              ? ie.raws.scssGlobal.replace(
                                  /\s*!global/i,
                                  " !global"
                                )
                              : ie.scssGlobal
                              ? " !global"
                              : "",
                            ie.nodes
                              ? [" {", h([g, tt(Ae, Oe, Pe)]), g, "}"]
                              : Q(ie) &&
                                !Me.raws.semicolon &&
                                Oe.originalText[z(ie) - 1] !== ";"
                              ? ""
                              : Oe.__isHTMLStyleAttribute && _(Ae, ie)
                              ? T(";")
                              : ";",
                          ]
                        );
                      }
                      case "css-atrule": {
                        let Me = Ae.getParentNode(),
                          qe =
                            ue(ie) &&
                            !Me.raws.semicolon &&
                            Oe.originalText[z(ie) - 1] !== ";";
                        if (j(Oe)) {
                          if (ie.mixin)
                            return [
                              Pe("selector"),
                              ie.important ? " !important" : "",
                              qe ? "" : ";",
                            ];
                          if (ie.function)
                            return [ie.name, Pe("params"), qe ? "" : ";"];
                          if (ie.variable)
                            return [
                              "@",
                              ie.name,
                              ": ",
                              ie.value ? Pe("value") : "",
                              ie.raws.between.trim()
                                ? ie.raws.between.trim() + " "
                                : "",
                              ie.nodes
                                ? [
                                    "{",
                                    h([
                                      ie.nodes.length > 0 ? g : "",
                                      tt(Ae, Oe, Pe),
                                    ]),
                                    g,
                                    "}",
                                  ]
                                : "",
                              qe ? "" : ";",
                            ];
                        }
                        return [
                          "@",
                          le(ie) || ie.name.endsWith(":")
                            ? ie.name
                            : d(ie.name),
                          ie.params
                            ? [
                                le(ie)
                                  ? ""
                                  : ue(ie)
                                  ? ie.raws.afterName === ""
                                    ? ""
                                    : ie.name.endsWith(":")
                                    ? " "
                                    : /^\s*\n\s*\n/.test(ie.raws.afterName)
                                    ? [m, m]
                                    : /^\s*\n/.test(ie.raws.afterName)
                                    ? m
                                    : " "
                                  : " ",
                                Pe("params"),
                              ]
                            : "",
                          ie.selector ? h([" ", Pe("selector")]) : "",
                          ie.value
                            ? p([
                                " ",
                                Pe("value"),
                                O(ie) ? (oe(ie) ? " " : C) : "",
                              ])
                            : ie.name === "else"
                            ? " "
                            : "",
                          ie.nodes
                            ? [
                                O(ie)
                                  ? ""
                                  : (ie.selector &&
                                      !ie.selector.nodes &&
                                      typeof ie.selector.value == "string" &&
                                      J(ie.selector.value)) ||
                                    (!ie.selector &&
                                      typeof ie.params == "string" &&
                                      J(ie.params))
                                  ? C
                                  : " ",
                                "{",
                                h([
                                  ie.nodes.length > 0 ? g : "",
                                  tt(Ae, Oe, Pe),
                                ]),
                                g,
                                "}",
                              ]
                            : qe
                            ? ""
                            : ";",
                        ];
                      }
                      case "media-query-list": {
                        let Me = [];
                        return (
                          Ae.each((qe) => {
                            let Je = qe.getValue();
                            (Je.type === "media-query" && Je.value === "") ||
                              Me.push(Pe());
                          }, "nodes"),
                          p(h(l(C, Me)))
                        );
                      }
                      case "media-query":
                        return [
                          l(" ", Ae.map(Pe, "nodes")),
                          _(Ae, ie) ? "" : ",",
                        ];
                      case "media-type":
                        return Ie(ze(ie.value, Oe));
                      case "media-feature-expression":
                        return ie.nodes
                          ? ["(", ...Ae.map(Pe, "nodes"), ")"]
                          : ie.value;
                      case "media-feature":
                        return d(ze(ie.value.replace(/ +/g, " "), Oe));
                      case "media-colon":
                        return [ie.value, " "];
                      case "media-value":
                        return Ie(ze(ie.value, Oe));
                      case "media-keyword":
                        return ze(ie.value, Oe);
                      case "media-url":
                        return ze(
                          ie.value
                            .replace(/^url\(\s+/gi, "url(")
                            .replace(/\s+\)$/g, ")"),
                          Oe
                        );
                      case "media-unknown":
                        return ie.value;
                      case "selector-root":
                        return p([
                          x(Ae, "custom-selector")
                            ? [E(Ae, "css-atrule").customSelector, C]
                            : "",
                          l(
                            [
                              ",",
                              x(Ae, ["extend", "custom-selector", "nest"])
                                ? C
                                : m,
                            ],
                            Ae.map(Pe, "nodes")
                          ),
                        ]);
                      case "selector-selector":
                        return p(h(Ae.map(Pe, "nodes")));
                      case "selector-comment":
                        return ie.value;
                      case "selector-string":
                        return ze(ie.value, Oe);
                      case "selector-tag": {
                        let Me = Ae.getParentNode(),
                          qe = Me && Me.nodes.indexOf(ie),
                          Je = qe && Me.nodes[qe - 1];
                        return [
                          ie.namespace
                            ? [
                                ie.namespace === !0 ? "" : ie.namespace.trim(),
                                "|",
                              ]
                            : "",
                          Je.type === "selector-nesting"
                            ? ie.value
                            : Ie(
                                S(Ae, ie.value)
                                  ? ie.value.toLowerCase()
                                  : ie.value
                              ),
                        ];
                      }
                      case "selector-id":
                        return ["#", ie.value];
                      case "selector-class":
                        return [".", Ie(ze(ie.value, Oe))];
                      case "selector-attribute":
                        return [
                          "[",
                          ie.namespace
                            ? [
                                ie.namespace === !0 ? "" : ie.namespace.trim(),
                                "|",
                              ]
                            : "",
                          ie.attribute.trim(),
                          ie.operator ? ie.operator : "",
                          ie.value ? Be(ze(ie.value.trim(), Oe), Oe) : "",
                          ie.insensitive ? " i" : "",
                          "]",
                        ];
                      case "selector-combinator": {
                        if (
                          ie.value === "+" ||
                          ie.value === ">" ||
                          ie.value === "~" ||
                          ie.value === ">>>"
                        ) {
                          let Je = Ae.getParentNode();
                          return [
                            Je.type === "selector-selector" &&
                            Je.nodes[0] === ie
                              ? ""
                              : C,
                            ie.value,
                            _(Ae, ie) ? "" : " ",
                          ];
                        }
                        let Me = ie.value.trim().startsWith("(") ? C : "",
                          qe = Ie(ze(ie.value.trim(), Oe)) || C;
                        return [Me, qe];
                      }
                      case "selector-universal":
                        return [
                          ie.namespace
                            ? [
                                ie.namespace === !0 ? "" : ie.namespace.trim(),
                                "|",
                              ]
                            : "",
                          ie.value,
                        ];
                      case "selector-pseudo":
                        return [
                          d(ie.value),
                          c(ie.nodes)
                            ? ["(", l(", ", Ae.map(Pe, "nodes")), ")"]
                            : "",
                        ];
                      case "selector-nesting":
                        return ie.value;
                      case "selector-unknown": {
                        let Me = E(Ae, "css-rule");
                        if (Me && Me.isSCSSNesterProperty)
                          return Ie(ze(d(ie.value), Oe));
                        let qe = Ae.getParentNode();
                        if (qe.raws && qe.raws.selector) {
                          let rt = te(qe),
                            Ze = rt + qe.raws.selector.length;
                          return Oe.originalText.slice(rt, Ze).trim();
                        }
                        let Je = Ae.getParentNode(1);
                        if (
                          qe.type === "value-paren_group" &&
                          Je &&
                          Je.type === "value-func" &&
                          Je.value === "selector"
                        ) {
                          let rt = z(qe.open) + 1,
                            Ze = te(qe.close),
                            ct = Oe.originalText.slice(rt, Ze).trim();
                          return J(ct) ? [A, ct] : ct;
                        }
                        return ie.value;
                      }
                      case "value-value":
                      case "value-root":
                        return Pe("group");
                      case "value-comment":
                        return Oe.originalText.slice(te(ie), z(ie));
                      case "value-comma_group": {
                        let Me = Ae.getParentNode(),
                          qe = Ae.getParentNode(1),
                          Je = D(Ae),
                          rt =
                            Je &&
                            Me.type === "value-value" &&
                            (Je === "grid" || Je.startsWith("grid-template")),
                          Ze = E(Ae, "css-atrule"),
                          ct = Ze && O(Ze),
                          qt = ie.groups.some((ut) => ve(ut)),
                          L = Ae.map(Pe, "groups"),
                          De = [],
                          ke = y(Ae, "url"),
                          We = !1,
                          $e = !1;
                        for (let ut = 0; ut < ie.groups.length; ++ut) {
                          De.push(L[ut]);
                          let et = ie.groups[ut - 1],
                            Re = ie.groups[ut],
                            He = ie.groups[ut + 1],
                            Zt = ie.groups[ut + 2];
                          if (ke) {
                            ((He && re(He)) || re(Re)) && De.push(" ");
                            continue;
                          }
                          if (
                            (x(Ae, "forward") &&
                              Re.type === "value-word" &&
                              Re.value &&
                              et !== void 0 &&
                              et.type === "value-word" &&
                              et.value === "as" &&
                              He.type === "value-operator" &&
                              He.value === "*") ||
                            !He ||
                            (Re.type === "value-word" &&
                              Re.value.endsWith("-") &&
                              ye(He))
                          )
                            continue;
                          let ho =
                              Re.type === "value-string" &&
                              Re.value.startsWith("#{"),
                            Co =
                              We &&
                              He.type === "value-string" &&
                              He.value.endsWith("}");
                          if (ho || Co) {
                            We = !We;
                            continue;
                          }
                          if (
                            We ||
                            me(Re) ||
                            me(He) ||
                            (Re.type === "value-atword" && Re.value === "") ||
                            Re.value === "~" ||
                            (Re.value &&
                              Re.value.includes("\\") &&
                              He &&
                              He.type !== "value-comment") ||
                            (et &&
                              et.value &&
                              et.value.indexOf("\\") === et.value.length - 1 &&
                              Re.type === "value-operator" &&
                              Re.value === "/") ||
                            Re.value === "\\" ||
                            de(Re, He) ||
                            xe(Re) ||
                            we(Re) ||
                            fe(He) ||
                            (we(He) && K(He)) ||
                            (fe(Re) && K(He)) ||
                            (Re.value === "--" && xe(He))
                          )
                            continue;
                          let Qn = W(Re),
                            Zn = W(He);
                          if (
                            (((Qn && xe(He)) || (Zn && fe(Re))) && K(He)) ||
                            (!et && G(Re)) ||
                            (y(Ae, "calc") &&
                              (re(Re) || re(He) || $(Re) || $(He)) &&
                              K(He))
                          )
                            continue;
                          let Eo =
                              (re(Re) || $(Re)) &&
                              ut === 0 &&
                              (He.type === "value-number" || He.isHex) &&
                              qe &&
                              he(qe) &&
                              !K(He),
                            eu =
                              (Zt && Zt.type === "value-func") ||
                              (Zt && pe(Zt)) ||
                              Re.type === "value-func" ||
                              pe(Re),
                            tu =
                              He.type === "value-func" ||
                              pe(He) ||
                              (et && et.type === "value-func") ||
                              (et && pe(et));
                          if (
                            !(
                              !(P(He) || P(Re)) &&
                              !y(Ae, "calc") &&
                              !Eo &&
                              ((G(He) && !eu) ||
                                (G(Re) && !tu) ||
                                (re(He) && !eu) ||
                                (re(Re) && !tu) ||
                                $(He) ||
                                $(Re)) &&
                              (K(He) || (Qn && (!et || (et && W(et)))))
                            )
                          ) {
                            if (ve(Re)) {
                              if (Me.type === "value-paren_group") {
                                De.push(N(m));
                                continue;
                              }
                              De.push(m);
                              continue;
                            }
                            if (
                              ct &&
                              (H(He) || M(He) || se(He) || ee(Re) || U(Re))
                            ) {
                              De.push(" ");
                              continue;
                            }
                            if (Ze && Ze.name.toLowerCase() === "namespace") {
                              De.push(" ");
                              continue;
                            }
                            if (rt) {
                              Re.source &&
                              He.source &&
                              Re.source.start.line !== He.source.start.line
                                ? (De.push(m), ($e = !0))
                                : De.push(" ");
                              continue;
                            }
                            if (Zn) {
                              De.push(" ");
                              continue;
                            }
                            if (
                              !(He && He.value === "...") &&
                              !(ye(Re) && ye(He) && z(Re) === te(He))
                            ) {
                              if (ye(Re) && Y(He) && z(Re) === te(He.open)) {
                                De.push(g);
                                continue;
                              }
                              if (Re.value === "with" && Y(He)) {
                                De.push(" ");
                                continue;
                              }
                              De.push(C);
                            }
                          }
                        }
                        return (
                          qt && De.push(A),
                          $e && De.unshift(m),
                          ct ? p(h(De)) : F(Ae) ? p(f(De)) : p(h(f(De)))
                        );
                      }
                      case "value-paren_group": {
                        let Me = Ae.getParentNode();
                        if (
                          Me &&
                          ne(Me) &&
                          (ie.groups.length === 1 ||
                            (ie.groups.length > 0 &&
                              ie.groups[0].type === "value-comma_group" &&
                              ie.groups[0].groups.length > 0 &&
                              ie.groups[0].groups[0].type === "value-word" &&
                              ie.groups[0].groups[0].value.startsWith("data:")))
                        )
                          return [
                            ie.open ? Pe("open") : "",
                            l(",", Ae.map(Pe, "groups")),
                            ie.close ? Pe("close") : "",
                          ];
                        if (!ie.open) {
                          let ke = Ae.map(Pe, "groups"),
                            We = [];
                          for (let $e = 0; $e < ke.length; $e++)
                            $e !== 0 && We.push([",", C]), We.push(ke[$e]);
                          return p(h(f(We)));
                        }
                        let qe = ge(Ae),
                          Je = t(ie.groups),
                          rt = Je && Je.type === "value-comment",
                          Ze = q(ie, Me),
                          ct = X(ie, Me),
                          qt = ct || (qe && !Ze),
                          L = ct || Ze,
                          De = p(
                            [
                              ie.open ? Pe("open") : "",
                              h([
                                g,
                                l(
                                  [C],
                                  Ae.map((ke, We) => {
                                    let $e = ke.getValue(),
                                      ut = We === ie.groups.length - 1,
                                      et = [Pe(), ut ? "" : ","];
                                    if (
                                      Ee($e) &&
                                      $e.type === "value-comma_group" &&
                                      $e.groups &&
                                      $e.groups[0].type !==
                                        "value-paren_group" &&
                                      $e.groups[2] &&
                                      $e.groups[2].type === "value-paren_group"
                                    ) {
                                      let Re = v(et[0].contents.contents);
                                      return (Re[1] = p(Re[1])), p(N(et));
                                    }
                                    if (
                                      !ut &&
                                      $e.type === "value-comma_group" &&
                                      c($e.groups)
                                    ) {
                                      let Re = t($e.groups);
                                      Re.source &&
                                        a(Oe.originalText, Re, z) &&
                                        et.push(m);
                                    }
                                    return et;
                                  }, "groups")
                                ),
                              ]),
                              T(
                                !rt &&
                                  Ce(Oe.parser, Oe.originalText) &&
                                  qe &&
                                  je(Oe)
                                  ? ","
                                  : ""
                              ),
                              g,
                              ie.close ? Pe("close") : "",
                            ],
                            { shouldBreak: qt }
                          );
                        return L ? N(De) : De;
                      }
                      case "value-func":
                        return [
                          ie.value,
                          x(Ae, "supports") && ce(ie) ? " " : "",
                          Pe("group"),
                        ];
                      case "value-paren":
                        return ie.value;
                      case "value-number":
                        return [Ve(ie.value), Ne(ie.unit)];
                      case "value-operator":
                        return ie.value;
                      case "value-word":
                        return (ie.isColor && ie.isHex) || k(ie.value)
                          ? ie.value.toLowerCase()
                          : ie.value;
                      case "value-colon": {
                        let Me = Ae.getParentNode(),
                          qe = Me && Me.groups.indexOf(ie),
                          Je = qe && Me.groups[qe - 1];
                        return [
                          ie.value,
                          (Je &&
                            typeof Je.value == "string" &&
                            t(Je.value) === "\\") ||
                          y(Ae, "url")
                            ? ""
                            : C,
                        ];
                      }
                      case "value-comma":
                        return [ie.value, " "];
                      case "value-string":
                        return i(ie.raws.quote + ie.value + ie.raws.quote, Oe);
                      case "value-atword":
                        return ["@", ie.value];
                      case "value-unicode-range":
                        return ie.value;
                      case "value-unknown":
                        return ie.value;
                      default:
                        throw new Error(
                          "Unknown postcss type ".concat(
                            JSON.stringify(ie.type)
                          )
                        );
                    }
                  }
                  function tt(Ae, Oe, Pe) {
                    let ie = [];
                    return (
                      Ae.each((Me, qe, Je) => {
                        let rt = Je[qe - 1];
                        if (
                          rt &&
                          rt.type === "css-comment" &&
                          rt.text.trim() === "prettier-ignore"
                        ) {
                          let Ze = Me.getValue();
                          ie.push(Oe.originalText.slice(te(Ze), z(Ze)));
                        } else ie.push(Pe());
                        qe !== Je.length - 1 &&
                          ((Je[qe + 1].type === "css-comment" &&
                            !r(Oe.originalText, te(Je[qe + 1]), {
                              backwards: !0,
                            }) &&
                            !u(Je[qe])) ||
                          (Je[qe + 1].type === "css-atrule" &&
                            Je[qe + 1].name === "else" &&
                            Je[qe].type !== "css-comment")
                            ? ie.push(" ")
                            : (ie.push(Oe.__isHTMLStyleAttribute ? C : m),
                              a(Oe.originalText, Me.getValue(), z) &&
                                !u(Je[qe]) &&
                                ie.push(m)));
                      }, "nodes"),
                      ie
                    );
                  }
                  var Te = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs,
                    _e = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g,
                    Fe = /[A-Za-z]+/g,
                    Ke = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g,
                    Se = new RegExp(
                      Te.source +
                        "|("
                          .concat(Ke.source, ")?(")
                          .concat(_e.source, ")(")
                          .concat(Fe.source, ")?"),
                      "g"
                    );
                  function ze(Ae, Oe) {
                    return Ae.replace(Te, (Pe) => i(Pe, Oe));
                  }
                  function Be(Ae, Oe) {
                    let Pe = Oe.singleQuote ? "'" : '"';
                    return Ae.includes('"') || Ae.includes("'")
                      ? Ae
                      : Pe + Ae + Pe;
                  }
                  function Ie(Ae) {
                    return Ae.replace(Se, (Oe, Pe, ie, Me, qe) =>
                      !ie && Me ? Ve(Me) + d(qe || "") : Oe
                    );
                  }
                  function Ve(Ae) {
                    return s(Ae).replace(/\.0(?=$|e)/, "");
                  }
                  n.exports = {
                    print: Ue,
                    embed: w,
                    insertPragma: I,
                    massageAstNode: B,
                  };
                },
              }),
              td = Z({
                "src/language-css/options.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Lt();
                  n.exports = { singleQuote: t.singleQuote };
                },
              }),
              rd = Z({
                "src/language-css/parsers.js"() {
                  ae();
                },
              }),
              nd = Z({
                "node_modules/linguist-languages/data/CSS.json"(e, n) {
                  n.exports = {
                    name: "CSS",
                    type: "markup",
                    tmScope: "source.css",
                    aceMode: "css",
                    codemirrorMode: "css",
                    codemirrorMimeType: "text/css",
                    color: "#563d7c",
                    extensions: [".css"],
                    languageId: 50,
                  };
                },
              }),
              ud = Z({
                "node_modules/linguist-languages/data/PostCSS.json"(e, n) {
                  n.exports = {
                    name: "PostCSS",
                    type: "markup",
                    tmScope: "source.postcss",
                    group: "CSS",
                    extensions: [".pcss", ".postcss"],
                    aceMode: "text",
                    languageId: 262764437,
                  };
                },
              }),
              sd = Z({
                "node_modules/linguist-languages/data/Less.json"(e, n) {
                  n.exports = {
                    name: "Less",
                    type: "markup",
                    color: "#1d365d",
                    extensions: [".less"],
                    tmScope: "source.css.less",
                    aceMode: "less",
                    codemirrorMode: "css",
                    codemirrorMimeType: "text/css",
                    languageId: 198,
                  };
                },
              }),
              ad = Z({
                "node_modules/linguist-languages/data/SCSS.json"(e, n) {
                  n.exports = {
                    name: "SCSS",
                    type: "markup",
                    color: "#c6538c",
                    tmScope: "source.css.scss",
                    aceMode: "scss",
                    codemirrorMode: "css",
                    codemirrorMimeType: "text/x-scss",
                    extensions: [".scss"],
                    languageId: 329,
                  };
                },
              }),
              id = Z({
                "src/language-css/index.js"(e, n) {
                  "use strict";
                  ae();
                  var t = bt(),
                    s = ed(),
                    i = td(),
                    r = rd(),
                    u = [
                      t(nd(), (c) => ({
                        since: "1.4.0",
                        parsers: ["css"],
                        vscodeLanguageIds: ["css"],
                        extensions: [...c.extensions, ".wxss"],
                      })),
                      t(ud(), () => ({
                        since: "1.4.0",
                        parsers: ["css"],
                        vscodeLanguageIds: ["postcss"],
                      })),
                      t(sd(), () => ({
                        since: "1.4.0",
                        parsers: ["less"],
                        vscodeLanguageIds: ["less"],
                      })),
                      t(ad(), () => ({
                        since: "1.4.0",
                        parsers: ["scss"],
                        vscodeLanguageIds: ["scss"],
                      })),
                    ],
                    a = { postcss: s };
                  n.exports = {
                    languages: u,
                    options: i,
                    printers: a,
                    parsers: r,
                  };
                },
              }),
              od = Z({
                "src/language-handlebars/loc.js"(e, n) {
                  "use strict";
                  ae();
                  function t(i) {
                    return i.loc.start.offset;
                  }
                  function s(i) {
                    return i.loc.end.offset;
                  }
                  n.exports = { locStart: t, locEnd: s };
                },
              }),
              cd = Z({
                "src/language-handlebars/clean.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s, i) {
                    if (s.type === "TextNode") {
                      let r = s.chars.trim();
                      if (!r) return null;
                      i.chars = r.replace(/[\t\n\f\r ]+/g, " ");
                    }
                    s.type === "AttrNode" &&
                      s.name.toLowerCase() === "class" &&
                      delete i.value;
                  }
                  (t.ignoredProperties = new Set(["loc", "selfClosing"])),
                    (n.exports = t);
                },
              }),
              ld = Z({
                "vendors/html-void-elements.json"(e, n) {
                  n.exports = {
                    htmlVoidElements: [
                      "area",
                      "base",
                      "basefont",
                      "bgsound",
                      "br",
                      "col",
                      "command",
                      "embed",
                      "frame",
                      "hr",
                      "image",
                      "img",
                      "input",
                      "isindex",
                      "keygen",
                      "link",
                      "menuitem",
                      "meta",
                      "nextid",
                      "param",
                      "source",
                      "track",
                      "wbr",
                    ],
                  };
                },
              }),
              pd = Z({
                "src/language-handlebars/utils.js"(e, n) {
                  "use strict";
                  ae();
                  var { htmlVoidElements: t } = ld(),
                    s = st();
                  function i(b) {
                    let v = b.getValue(),
                      B = b.getParentNode(0);
                    return !!(
                      (m(b, ["ElementNode"]) && s(B.children) === v) ||
                      (m(b, ["Block"]) && s(B.body) === v)
                    );
                  }
                  function r(b) {
                    return b.toUpperCase() === b;
                  }
                  function u(b) {
                    return (
                      C(b, ["ElementNode"]) &&
                      typeof b.tag == "string" &&
                      b.tag[0] !== ":" &&
                      (r(b.tag[0]) || b.tag.includes("."))
                    );
                  }
                  var a = new Set(t);
                  function c(b) {
                    return (
                      (u(b) && b.children.every((v) => l(v))) || a.has(b.tag)
                    );
                  }
                  function l(b) {
                    return C(b, ["TextNode"]) && !/\S/.test(b.chars);
                  }
                  function C(b, v) {
                    return b && v.includes(b.type);
                  }
                  function m(b, v) {
                    let B = b.getParentNode(0);
                    return C(B, v);
                  }
                  function g(b, v) {
                    let B = h(b);
                    return C(B, v);
                  }
                  function p(b, v) {
                    let B = N(b);
                    return C(B, v);
                  }
                  function f(b, v) {
                    let B = b.getValue(),
                      w = b.getParentNode(0) || {},
                      I = w.children || w.body || w.parts || [],
                      E = I.indexOf(B);
                    return E !== -1 && I[E + v];
                  }
                  function h(b) {
                    let v =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : 1;
                    return f(b, -v);
                  }
                  function N(b) {
                    return f(b, 1);
                  }
                  function T(b) {
                    return (
                      C(b, ["MustacheCommentStatement"]) &&
                      typeof b.value == "string" &&
                      b.value.trim() === "prettier-ignore"
                    );
                  }
                  function A(b) {
                    let v = b.getValue(),
                      B = h(b, 2);
                    return T(v) || T(B);
                  }
                  n.exports = {
                    getNextNode: N,
                    getPreviousNode: h,
                    hasPrettierIgnore: A,
                    isLastNodeOfSiblings: i,
                    isNextNodeOfSomeType: p,
                    isNodeOfSomeType: C,
                    isParentOfSomeType: m,
                    isPreviousNodeOfSomeType: g,
                    isVoid: c,
                    isWhitespaceNode: l,
                  };
                },
              }),
              fd = Z({
                "src/language-handlebars/printer-glimmer.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: {
                        dedent: t,
                        fill: s,
                        group: i,
                        hardline: r,
                        ifBreak: u,
                        indent: a,
                        join: c,
                        line: l,
                        softline: C,
                      },
                      utils: { getDocParts: m, replaceTextEndOfLine: g },
                    } = Le(),
                    { getPreferredQuote: p, isNonEmptyArray: f } = Ge(),
                    { locStart: h, locEnd: N } = od(),
                    T = cd(),
                    {
                      getNextNode: A,
                      getPreviousNode: b,
                      hasPrettierIgnore: v,
                      isLastNodeOfSiblings: B,
                      isNextNodeOfSomeType: w,
                      isNodeOfSomeType: I,
                      isParentOfSomeType: E,
                      isPreviousNodeOfSomeType: D,
                      isVoid: d,
                      isWhitespaceNode: y,
                    } = pd(),
                    o = 2;
                  function x(J, ye, X) {
                    let Y = J.getValue();
                    if (!Y) return "";
                    if (v(J)) return ye.originalText.slice(h(Y), N(Y));
                    let te = ye.singleQuote ? "'" : '"';
                    switch (Y.type) {
                      case "Block":
                      case "Program":
                      case "Template":
                        return i(J.map(X, "body"));
                      case "ElementNode": {
                        let z = i(S(J, X)),
                          j =
                            ye.htmlWhitespaceSensitivity === "ignore" &&
                            w(J, ["ElementNode"])
                              ? C
                              : "";
                        if (d(Y)) return [z, j];
                        let Ce = ["</", Y.tag, ">"];
                        return Y.children.length === 0
                          ? [z, a(Ce), j]
                          : ye.htmlWhitespaceSensitivity === "ignore"
                          ? [z, a(k(J, ye, X)), r, a(Ce), j]
                          : [z, a(i(k(J, ye, X))), a(Ce), j];
                      }
                      case "BlockStatement": {
                        let z = J.getParentNode(1);
                        return z &&
                          z.inverse &&
                          z.inverse.body.length === 1 &&
                          z.inverse.body[0] === Y &&
                          z.inverse.body[0].path.parts[0] === "if"
                          ? [U(J, X), K(J, X, ye), Ee(J, X, ye)]
                          : [
                              W(J, X),
                              i([K(J, X, ye), Ee(J, X, ye), ne(J, X, ye)]),
                            ];
                      }
                      case "ElementModifierStatement":
                        return i(["{{", pe(J, X), "}}"]);
                      case "MustacheStatement":
                        return i([O(Y), pe(J, X), R(Y)]);
                      case "SubExpression":
                        return i(["(", fe(J, X), C, ")"]);
                      case "AttrNode": {
                        let z = Y.value.type === "TextNode";
                        if (
                          z &&
                          Y.value.chars === "" &&
                          h(Y.value) === N(Y.value)
                        )
                          return Y.name;
                        let Ce = z
                            ? p(Y.value.chars, te).quote
                            : Y.value.type === "ConcatStatement"
                            ? p(
                                Y.value.parts
                                  .filter((je) => je.type === "TextNode")
                                  .map((je) => je.chars)
                                  .join(""),
                                te
                              ).quote
                            : "",
                          Ne = X("value");
                        return [
                          Y.name,
                          "=",
                          Ce,
                          Y.name === "class" && Ce ? i(a(Ne)) : Ne,
                          Ce,
                        ];
                      }
                      case "ConcatStatement":
                        return J.map(X, "parts");
                      case "Hash":
                        return c(l, J.map(X, "pairs"));
                      case "HashPair":
                        return [Y.key, "=", X("value")];
                      case "TextNode": {
                        let z = Y.chars.replace(/{{/g, "\\{{"),
                          j = ue(J);
                        if (j) {
                          if (j === "class") {
                            let Se = z.trim().split(/\s+/).join(" "),
                              ze = !1,
                              Be = !1;
                            return (
                              E(J, ["ConcatStatement"]) &&
                                (D(J, ["MustacheStatement"]) &&
                                  /^\s/.test(z) &&
                                  (ze = !0),
                                w(J, ["MustacheStatement"]) &&
                                  /\s$/.test(z) &&
                                  Se !== "" &&
                                  (Be = !0)),
                              [ze ? l : "", Se, Be ? l : ""]
                            );
                          }
                          return g(z);
                        }
                        let Ne = /^[\t\n\f\r ]*$/.test(z),
                          je = !b(J),
                          Ue = !A(J);
                        if (ye.htmlWhitespaceSensitivity !== "ignore") {
                          let Se = /^[\t\n\f\r ]*/,
                            ze = /[\t\n\f\r ]*$/,
                            Be = Ue && E(J, ["Template"]),
                            Ie = je && E(J, ["Template"]);
                          if (Ne) {
                            if (Ie || Be) return "";
                            let ie = [l],
                              Me = Q(z);
                            return (
                              Me && (ie = ve(Me)),
                              B(J) && (ie = ie.map((qe) => t(qe))),
                              ie
                            );
                          }
                          let [Ve] = z.match(Se),
                            [Ae] = z.match(ze),
                            Oe = [];
                          if (Ve) {
                            Oe = [l];
                            let ie = Q(Ve);
                            ie && (Oe = ve(ie)), (z = z.replace(Se, ""));
                          }
                          let Pe = [];
                          if (Ae) {
                            if (!Be) {
                              Pe = [l];
                              let ie = Q(Ae);
                              ie && (Pe = ve(ie)),
                                B(J) && (Pe = Pe.map((Me) => t(Me)));
                            }
                            z = z.replace(ze, "");
                          }
                          return [...Oe, s(q(z)), ...Pe];
                        }
                        let tt = Q(z),
                          Te = de(z),
                          _e = ge(z);
                        if (
                          (je || Ue) &&
                          Ne &&
                          E(J, ["Block", "ElementNode", "Template"])
                        )
                          return "";
                        Ne && tt
                          ? ((Te = Math.min(tt, o)), (_e = 0))
                          : (w(J, ["BlockStatement", "ElementNode"]) &&
                              (_e = Math.max(_e, 1)),
                            D(J, ["BlockStatement", "ElementNode"]) &&
                              (Te = Math.max(Te, 1)));
                        let Fe = "",
                          Ke = "";
                        return (
                          _e === 0 && w(J, ["MustacheStatement"]) && (Ke = " "),
                          Te === 0 && D(J, ["MustacheStatement"]) && (Fe = " "),
                          je && ((Te = 0), (Fe = "")),
                          Ue && ((_e = 0), (Ke = "")),
                          (z = z
                            .replace(/^[\t\n\f\r ]+/g, Fe)
                            .replace(/[\t\n\f\r ]+$/, Ke)),
                          [...ve(Te), s(q(z)), ...ve(_e)]
                        );
                      }
                      case "MustacheCommentStatement": {
                        let z = h(Y),
                          j = N(Y),
                          Ce = ye.originalText.charAt(z + 2) === "~",
                          Ne = ye.originalText.charAt(j - 3) === "~",
                          je = Y.value.includes("}}") ? "--" : "";
                        return [
                          "{{",
                          Ce ? "~" : "",
                          "!",
                          je,
                          Y.value,
                          je,
                          Ne ? "~" : "",
                          "}}",
                        ];
                      }
                      case "PathExpression":
                        return Y.original;
                      case "BooleanLiteral":
                        return String(Y.value);
                      case "CommentStatement":
                        return ["<!--", Y.value, "-->"];
                      case "StringLiteral": {
                        if (we(J)) {
                          let z = ye.singleQuote ? '"' : "'";
                          return xe(Y.value, z);
                        }
                        return xe(Y.value, te);
                      }
                      case "NumberLiteral":
                        return String(Y.value);
                      case "UndefinedLiteral":
                        return "undefined";
                      case "NullLiteral":
                        return "null";
                      default:
                        throw new Error(
                          "unknown glimmer type: " + JSON.stringify(Y.type)
                        );
                    }
                  }
                  function F(J, ye) {
                    return h(J) - h(ye);
                  }
                  function S(J, ye) {
                    let X = J.getValue(),
                      Y = ["attributes", "modifiers", "comments"].filter((z) =>
                        f(X[z])
                      ),
                      te = Y.flatMap((z) => X[z]).sort(F);
                    for (let z of Y)
                      J.each((j) => {
                        let Ce = te.indexOf(j.getValue());
                        te.splice(Ce, 1, [l, ye()]);
                      }, z);
                    return (
                      f(X.blockParams) && te.push(l, he(X)),
                      ["<", X.tag, a(te), _(X)]
                    );
                  }
                  function k(J, ye, X) {
                    let te = J.getValue().children.every((z) => y(z));
                    return ye.htmlWhitespaceSensitivity === "ignore" && te
                      ? ""
                      : J.map((z, j) => {
                          let Ce = X();
                          return j === 0 &&
                            ye.htmlWhitespaceSensitivity === "ignore"
                            ? [C, Ce]
                            : Ce;
                        }, "children");
                  }
                  function _(J) {
                    return d(J) ? u([C, "/>"], [" />", C]) : u([C, ">"], ">");
                  }
                  function O(J) {
                    let ye = J.escaped === !1 ? "{{{" : "{{",
                      X = J.strip && J.strip.open ? "~" : "";
                    return [ye, X];
                  }
                  function R(J) {
                    let ye = J.escaped === !1 ? "}}}" : "}}";
                    return [J.strip && J.strip.close ? "~" : "", ye];
                  }
                  function M(J) {
                    let ye = O(J),
                      X = J.openStrip.open ? "~" : "";
                    return [ye, X, "#"];
                  }
                  function H(J) {
                    let ye = R(J);
                    return [J.openStrip.close ? "~" : "", ye];
                  }
                  function P(J) {
                    let ye = O(J),
                      X = J.closeStrip.open ? "~" : "";
                    return [ye, X, "/"];
                  }
                  function G(J) {
                    let ye = R(J);
                    return [J.closeStrip.close ? "~" : "", ye];
                  }
                  function re(J) {
                    let ye = O(J),
                      X = J.inverseStrip.open ? "~" : "";
                    return [ye, X];
                  }
                  function $(J) {
                    let ye = R(J);
                    return [J.inverseStrip.close ? "~" : "", ye];
                  }
                  function W(J, ye) {
                    let X = J.getValue(),
                      Y = M(X),
                      te = H(X),
                      z = [me(J, ye)],
                      j = ce(J, ye);
                    if ((j && z.push(l, j), f(X.program.blockParams))) {
                      let Ce = he(X.program);
                      z.push(l, Ce);
                    }
                    return i([Y, a(z), C, te]);
                  }
                  function ee(J, ye) {
                    return [
                      ye.htmlWhitespaceSensitivity === "ignore" ? r : "",
                      re(J),
                      "else",
                      $(J),
                    ];
                  }
                  function U(J, ye) {
                    let X = J.getParentNode(1);
                    return [re(X), "else if ", ce(J, ye), $(X)];
                  }
                  function ne(J, ye, X) {
                    let Y = J.getValue();
                    return X.htmlWhitespaceSensitivity === "ignore"
                      ? [se(Y) ? C : r, P(Y), ye("path"), G(Y)]
                      : [P(Y), ye("path"), G(Y)];
                  }
                  function se(J) {
                    return (
                      I(J, ["BlockStatement"]) &&
                      J.program.body.every((ye) => y(ye))
                    );
                  }
                  function V(J) {
                    return (
                      oe(J) &&
                      J.inverse.body.length === 1 &&
                      I(J.inverse.body[0], ["BlockStatement"]) &&
                      J.inverse.body[0].path.parts[0] === "if"
                    );
                  }
                  function oe(J) {
                    return I(J, ["BlockStatement"]) && J.inverse;
                  }
                  function K(J, ye, X) {
                    let Y = J.getValue();
                    if (se(Y)) return "";
                    let te = ye("program");
                    return X.htmlWhitespaceSensitivity === "ignore"
                      ? a([r, te])
                      : a(te);
                  }
                  function Ee(J, ye, X) {
                    let Y = J.getValue(),
                      te = ye("inverse"),
                      z =
                        X.htmlWhitespaceSensitivity === "ignore" ? [r, te] : te;
                    return V(Y) ? z : oe(Y) ? [ee(Y, X), a(z)] : "";
                  }
                  function q(J) {
                    return m(c(l, le(J)));
                  }
                  function le(J) {
                    return J.split(/[\t\n\f\r ]+/);
                  }
                  function ue(J) {
                    for (let ye = 0; ye < 2; ye++) {
                      let X = J.getParentNode(ye);
                      if (X && X.type === "AttrNode")
                        return X.name.toLowerCase();
                    }
                  }
                  function Q(J) {
                    return (
                      (J = typeof J == "string" ? J : ""),
                      J.split(`
`).length - 1
                    );
                  }
                  function de(J) {
                    J = typeof J == "string" ? J : "";
                    let ye = (J.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
                    return Q(ye);
                  }
                  function ge(J) {
                    J = typeof J == "string" ? J : "";
                    let ye = (J.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
                    return Q(ye);
                  }
                  function ve() {
                    let J =
                      arguments.length > 0 && arguments[0] !== void 0
                        ? arguments[0]
                        : 0;
                    return Array.from({ length: Math.min(J, o) }).fill(r);
                  }
                  function xe(J, ye) {
                    let { quote: X, regex: Y } = p(J, ye);
                    return [X, J.replace(Y, "\\".concat(X)), X];
                  }
                  function we(J) {
                    let ye = 0,
                      X = J.getParentNode(ye);
                    for (; X && I(X, ["SubExpression"]); )
                      ye++, (X = J.getParentNode(ye));
                    return !!(
                      X &&
                      I(J.getParentNode(ye + 1), ["ConcatStatement"]) &&
                      I(J.getParentNode(ye + 2), ["AttrNode"])
                    );
                  }
                  function fe(J, ye) {
                    let X = me(J, ye),
                      Y = ce(J, ye);
                    return Y ? a([X, l, i(Y)]) : X;
                  }
                  function pe(J, ye) {
                    let X = me(J, ye),
                      Y = ce(J, ye);
                    return Y ? [a([X, l, Y]), C] : X;
                  }
                  function me(J, ye) {
                    return ye("path");
                  }
                  function ce(J, ye) {
                    let X = J.getValue(),
                      Y = [];
                    if (X.params.length > 0) {
                      let te = J.map(ye, "params");
                      Y.push(...te);
                    }
                    if (X.hash && X.hash.pairs.length > 0) {
                      let te = ye("hash");
                      Y.push(te);
                    }
                    return Y.length === 0 ? "" : c(l, Y);
                  }
                  function he(J) {
                    return ["as |", J.blockParams.join(" "), "|"];
                  }
                  n.exports = { print: x, massageAstNode: T };
                },
              }),
              Dd = Z({
                "src/language-handlebars/parsers.js"() {
                  ae();
                },
              }),
              md = Z({
                "node_modules/linguist-languages/data/Handlebars.json"(e, n) {
                  n.exports = {
                    name: "Handlebars",
                    type: "markup",
                    color: "#f7931e",
                    aliases: ["hbs", "htmlbars"],
                    extensions: [".handlebars", ".hbs"],
                    tmScope: "text.html.handlebars",
                    aceMode: "handlebars",
                    languageId: 155,
                  };
                },
              }),
              dd = Z({
                "src/language-handlebars/index.js"(e, n) {
                  "use strict";
                  ae();
                  var t = bt(),
                    s = fd(),
                    i = Dd(),
                    r = [
                      t(md(), () => ({
                        since: "2.3.0",
                        parsers: ["glimmer"],
                        vscodeLanguageIds: ["handlebars"],
                      })),
                    ],
                    u = { glimmer: s };
                  n.exports = { languages: r, printers: u, parsers: i };
                },
              }),
              gd = Z({
                "src/language-graphql/pragma.js"(e, n) {
                  "use strict";
                  ae();
                  function t(i) {
                    return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(
                      i
                    );
                  }
                  function s(i) {
                    return (
                      `# @format

` + i
                    );
                  }
                  n.exports = { hasPragma: t, insertPragma: s };
                },
              }),
              yd = Z({
                "src/language-graphql/loc.js"(e, n) {
                  "use strict";
                  ae();
                  function t(i) {
                    return typeof i.start == "number"
                      ? i.start
                      : i.loc && i.loc.start;
                  }
                  function s(i) {
                    return typeof i.end == "number"
                      ? i.end
                      : i.loc && i.loc.end;
                  }
                  n.exports = { locStart: t, locEnd: s };
                },
              }),
              hd = Z({
                "src/language-graphql/printer-graphql.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: {
                        join: t,
                        hardline: s,
                        line: i,
                        softline: r,
                        group: u,
                        indent: a,
                        ifBreak: c,
                      },
                    } = Le(),
                    { isNextLineEmpty: l, isNonEmptyArray: C } = Ge(),
                    { insertPragma: m } = gd(),
                    { locStart: g, locEnd: p } = yd();
                  function f(w, I, E) {
                    let D = w.getValue();
                    if (!D) return "";
                    if (typeof D == "string") return D;
                    switch (D.kind) {
                      case "Document": {
                        let d = [];
                        return (
                          w.each((y, o, x) => {
                            d.push(E()),
                              o !== x.length - 1 &&
                                (d.push(s),
                                l(I.originalText, y.getValue(), p) &&
                                  d.push(s));
                          }, "definitions"),
                          [...d, s]
                        );
                      }
                      case "OperationDefinition": {
                        let d = I.originalText[g(D)] !== "{",
                          y = Boolean(D.name);
                        return [
                          d ? D.operation : "",
                          d && y ? [" ", E("name")] : "",
                          d && !y && C(D.variableDefinitions) ? " " : "",
                          C(D.variableDefinitions)
                            ? u([
                                "(",
                                a([
                                  r,
                                  t(
                                    [c("", ", "), r],
                                    w.map(E, "variableDefinitions")
                                  ),
                                ]),
                                r,
                                ")",
                              ])
                            : "",
                          h(w, E, D),
                          D.selectionSet ? (!d && !y ? "" : " ") : "",
                          E("selectionSet"),
                        ];
                      }
                      case "FragmentDefinition":
                        return [
                          "fragment ",
                          E("name"),
                          C(D.variableDefinitions)
                            ? u([
                                "(",
                                a([
                                  r,
                                  t(
                                    [c("", ", "), r],
                                    w.map(E, "variableDefinitions")
                                  ),
                                ]),
                                r,
                                ")",
                              ])
                            : "",
                          " on ",
                          E("typeCondition"),
                          h(w, E, D),
                          " ",
                          E("selectionSet"),
                        ];
                      case "SelectionSet":
                        return [
                          "{",
                          a([s, t(s, N(w, I, E, "selections"))]),
                          s,
                          "}",
                        ];
                      case "Field":
                        return u([
                          D.alias ? [E("alias"), ": "] : "",
                          E("name"),
                          D.arguments.length > 0
                            ? u([
                                "(",
                                a([
                                  r,
                                  t([c("", ", "), r], N(w, I, E, "arguments")),
                                ]),
                                r,
                                ")",
                              ])
                            : "",
                          h(w, E, D),
                          D.selectionSet ? " " : "",
                          E("selectionSet"),
                        ]);
                      case "Name":
                        return D.value;
                      case "StringValue":
                        return D.block
                          ? [
                              '"""',
                              s,
                              t(
                                s,
                                D.value.replace(/"""/g, "\\$&").split(`
`)
                              ),
                              s,
                              '"""',
                            ]
                          : [
                              '"',
                              D.value
                                .replace(/["\\]/g, "\\$&")
                                .replace(/\n/g, "\\n"),
                              '"',
                            ];
                      case "IntValue":
                      case "FloatValue":
                      case "EnumValue":
                        return D.value;
                      case "BooleanValue":
                        return D.value ? "true" : "false";
                      case "NullValue":
                        return "null";
                      case "Variable":
                        return ["$", E("name")];
                      case "ListValue":
                        return u([
                          "[",
                          a([r, t([c("", ", "), r], w.map(E, "values"))]),
                          r,
                          "]",
                        ]);
                      case "ObjectValue":
                        return u([
                          "{",
                          I.bracketSpacing && D.fields.length > 0 ? " " : "",
                          a([r, t([c("", ", "), r], w.map(E, "fields"))]),
                          r,
                          c(
                            "",
                            I.bracketSpacing && D.fields.length > 0 ? " " : ""
                          ),
                          "}",
                        ]);
                      case "ObjectField":
                      case "Argument":
                        return [E("name"), ": ", E("value")];
                      case "Directive":
                        return [
                          "@",
                          E("name"),
                          D.arguments.length > 0
                            ? u([
                                "(",
                                a([
                                  r,
                                  t([c("", ", "), r], N(w, I, E, "arguments")),
                                ]),
                                r,
                                ")",
                              ])
                            : "",
                        ];
                      case "NamedType":
                        return E("name");
                      case "VariableDefinition":
                        return [
                          E("variable"),
                          ": ",
                          E("type"),
                          D.defaultValue ? [" = ", E("defaultValue")] : "",
                          h(w, E, D),
                        ];
                      case "ObjectTypeExtension":
                      case "ObjectTypeDefinition":
                        return [
                          E("description"),
                          D.description ? s : "",
                          D.kind === "ObjectTypeExtension" ? "extend " : "",
                          "type ",
                          E("name"),
                          D.interfaces.length > 0
                            ? [" implements ", ...b(w, I, E)]
                            : "",
                          h(w, E, D),
                          D.fields.length > 0
                            ? [" {", a([s, t(s, N(w, I, E, "fields"))]), s, "}"]
                            : "",
                        ];
                      case "FieldDefinition":
                        return [
                          E("description"),
                          D.description ? s : "",
                          E("name"),
                          D.arguments.length > 0
                            ? u([
                                "(",
                                a([
                                  r,
                                  t([c("", ", "), r], N(w, I, E, "arguments")),
                                ]),
                                r,
                                ")",
                              ])
                            : "",
                          ": ",
                          E("type"),
                          h(w, E, D),
                        ];
                      case "DirectiveDefinition":
                        return [
                          E("description"),
                          D.description ? s : "",
                          "directive ",
                          "@",
                          E("name"),
                          D.arguments.length > 0
                            ? u([
                                "(",
                                a([
                                  r,
                                  t([c("", ", "), r], N(w, I, E, "arguments")),
                                ]),
                                r,
                                ")",
                              ])
                            : "",
                          D.repeatable ? " repeatable" : "",
                          " on ",
                          t(" | ", w.map(E, "locations")),
                        ];
                      case "EnumTypeExtension":
                      case "EnumTypeDefinition":
                        return [
                          E("description"),
                          D.description ? s : "",
                          D.kind === "EnumTypeExtension" ? "extend " : "",
                          "enum ",
                          E("name"),
                          h(w, E, D),
                          D.values.length > 0
                            ? [" {", a([s, t(s, N(w, I, E, "values"))]), s, "}"]
                            : "",
                        ];
                      case "EnumValueDefinition":
                        return [
                          E("description"),
                          D.description ? s : "",
                          E("name"),
                          h(w, E, D),
                        ];
                      case "InputValueDefinition":
                        return [
                          E("description"),
                          D.description ? (D.description.block ? s : i) : "",
                          E("name"),
                          ": ",
                          E("type"),
                          D.defaultValue ? [" = ", E("defaultValue")] : "",
                          h(w, E, D),
                        ];
                      case "InputObjectTypeExtension":
                      case "InputObjectTypeDefinition":
                        return [
                          E("description"),
                          D.description ? s : "",
                          D.kind === "InputObjectTypeExtension"
                            ? "extend "
                            : "",
                          "input ",
                          E("name"),
                          h(w, E, D),
                          D.fields.length > 0
                            ? [" {", a([s, t(s, N(w, I, E, "fields"))]), s, "}"]
                            : "",
                        ];
                      case "SchemaDefinition":
                        return [
                          E("description"),
                          D.description ? s : "",
                          "schema",
                          h(w, E, D),
                          " {",
                          D.operationTypes.length > 0
                            ? a([s, t(s, N(w, I, E, "operationTypes"))])
                            : "",
                          s,
                          "}",
                        ];
                      case "OperationTypeDefinition":
                        return [E("operation"), ": ", E("type")];
                      case "InterfaceTypeExtension":
                      case "InterfaceTypeDefinition":
                        return [
                          E("description"),
                          D.description ? s : "",
                          D.kind === "InterfaceTypeExtension" ? "extend " : "",
                          "interface ",
                          E("name"),
                          D.interfaces.length > 0
                            ? [" implements ", ...b(w, I, E)]
                            : "",
                          h(w, E, D),
                          D.fields.length > 0
                            ? [" {", a([s, t(s, N(w, I, E, "fields"))]), s, "}"]
                            : "",
                        ];
                      case "FragmentSpread":
                        return ["...", E("name"), h(w, E, D)];
                      case "InlineFragment":
                        return [
                          "...",
                          D.typeCondition ? [" on ", E("typeCondition")] : "",
                          h(w, E, D),
                          " ",
                          E("selectionSet"),
                        ];
                      case "UnionTypeExtension":
                      case "UnionTypeDefinition":
                        return u([
                          E("description"),
                          D.description ? s : "",
                          u([
                            D.kind === "UnionTypeExtension" ? "extend " : "",
                            "union ",
                            E("name"),
                            h(w, E, D),
                            D.types.length > 0
                              ? [
                                  " =",
                                  c("", " "),
                                  a([
                                    c([i, "  "]),
                                    t([i, "| "], w.map(E, "types")),
                                  ]),
                                ]
                              : "",
                          ]),
                        ]);
                      case "ScalarTypeExtension":
                      case "ScalarTypeDefinition":
                        return [
                          E("description"),
                          D.description ? s : "",
                          D.kind === "ScalarTypeExtension" ? "extend " : "",
                          "scalar ",
                          E("name"),
                          h(w, E, D),
                        ];
                      case "NonNullType":
                        return [E("type"), "!"];
                      case "ListType":
                        return ["[", E("type"), "]"];
                      default:
                        throw new Error(
                          "unknown graphql type: " + JSON.stringify(D.kind)
                        );
                    }
                  }
                  function h(w, I, E) {
                    if (E.directives.length === 0) return "";
                    let D = t(i, w.map(I, "directives"));
                    return E.kind === "FragmentDefinition" ||
                      E.kind === "OperationDefinition"
                      ? u([i, D])
                      : [" ", u(a([r, D]))];
                  }
                  function N(w, I, E, D) {
                    return w.map((d, y, o) => {
                      let x = E();
                      return y < o.length - 1 &&
                        l(I.originalText, d.getValue(), p)
                        ? [x, s]
                        : x;
                    }, D);
                  }
                  function T(w) {
                    return w.kind && w.kind !== "Comment";
                  }
                  function A(w) {
                    let I = w.getValue();
                    if (I.kind === "Comment") return "#" + I.value.trimEnd();
                    throw new Error("Not a comment: " + JSON.stringify(I));
                  }
                  function b(w, I, E) {
                    let D = w.getNode(),
                      d = [],
                      { interfaces: y } = D,
                      o = w.map((x) => E(x), "interfaces");
                    for (let x = 0; x < y.length; x++) {
                      let F = y[x];
                      d.push(o[x]);
                      let S = y[x + 1];
                      if (S) {
                        let k = I.originalText.slice(F.loc.end, S.loc.start),
                          _ = k.includes("#"),
                          O = k.replace(/#.*/g, "").trim();
                        d.push(O === "," ? "," : " &", _ ? i : " ");
                      }
                    }
                    return d;
                  }
                  function v() {}
                  v.ignoredProperties = new Set(["loc", "comments"]);
                  function B(w) {
                    let I = w.getValue();
                    return (
                      I &&
                      Array.isArray(I.comments) &&
                      I.comments.some(
                        (E) => E.value.trim() === "prettier-ignore"
                      )
                    );
                  }
                  n.exports = {
                    print: f,
                    massageAstNode: v,
                    hasPrettierIgnore: B,
                    insertPragma: m,
                    printComment: A,
                    canAttachComment: T,
                  };
                },
              }),
              Cd = Z({
                "src/language-graphql/options.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Lt();
                  n.exports = { bracketSpacing: t.bracketSpacing };
                },
              }),
              Ed = Z({
                "src/language-graphql/parsers.js"() {
                  ae();
                },
              }),
              vd = Z({
                "node_modules/linguist-languages/data/GraphQL.json"(e, n) {
                  n.exports = {
                    name: "GraphQL",
                    type: "data",
                    color: "#e10098",
                    extensions: [".graphql", ".gql", ".graphqls"],
                    tmScope: "source.graphql",
                    aceMode: "text",
                    languageId: 139,
                  };
                },
              }),
              Fd = Z({
                "src/language-graphql/index.js"(e, n) {
                  "use strict";
                  ae();
                  var t = bt(),
                    s = hd(),
                    i = Cd(),
                    r = Ed(),
                    u = [
                      t(vd(), () => ({
                        since: "1.5.0",
                        parsers: ["graphql"],
                        vscodeLanguageIds: ["graphql"],
                      })),
                    ],
                    a = { graphql: s };
                  n.exports = {
                    languages: u,
                    options: i,
                    printers: a,
                    parsers: r,
                  };
                },
              }),
              fo = Z({
                "src/language-markdown/loc.js"(e, n) {
                  "use strict";
                  ae();
                  function t(i) {
                    return i.position.start.offset;
                  }
                  function s(i) {
                    return i.position.end.offset;
                  }
                  n.exports = { locStart: t, locEnd: s };
                },
              }),
              Ad = Z({
                "src/language-markdown/constants.evaluate.js"(e, n) {
                  n.exports = {
                    cjkPattern:
                      "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?",
                    kPattern:
                      "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",
                    punctuationPattern:
                      "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]",
                  };
                },
              }),
              Kn = Z({
                "src/language-markdown/utils.js"(e, n) {
                  "use strict";
                  ae();
                  var { getLast: t } = Ge(),
                    { locStart: s, locEnd: i } = fo(),
                    {
                      cjkPattern: r,
                      kPattern: u,
                      punctuationPattern: a,
                    } = Ad(),
                    c = [
                      "liquidNode",
                      "inlineCode",
                      "emphasis",
                      "esComment",
                      "strong",
                      "delete",
                      "wikiLink",
                      "link",
                      "linkReference",
                      "image",
                      "imageReference",
                      "footnote",
                      "footnoteReference",
                      "sentence",
                      "whitespace",
                      "word",
                      "break",
                      "inlineMath",
                    ],
                    l = [...c, "tableCell", "paragraph", "heading"],
                    C = new RegExp(u),
                    m = new RegExp(a);
                  function g(A, b) {
                    let v = "non-cjk",
                      B = "cj-letter",
                      w = "k-letter",
                      I = "cjk-punctuation",
                      E = [],
                      D = (
                        b.proseWrap === "preserve"
                          ? A
                          : A.replace(
                              new RegExp(
                                "("
                                  .concat(
                                    r,
                                    `)
(`
                                  )
                                  .concat(r, ")"),
                                "g"
                              ),
                              "$1$2"
                            )
                      ).split(/([\t\n ]+)/);
                    for (let [y, o] of D.entries()) {
                      if (y % 2 === 1) {
                        E.push({
                          type: "whitespace",
                          value: /\n/.test(o)
                            ? `
`
                            : " ",
                        });
                        continue;
                      }
                      if ((y === 0 || y === D.length - 1) && o === "") continue;
                      let x = o.split(new RegExp("(".concat(r, ")")));
                      for (let [F, S] of x.entries())
                        if (!((F === 0 || F === x.length - 1) && S === "")) {
                          if (F % 2 === 0) {
                            S !== "" &&
                              d({
                                type: "word",
                                value: S,
                                kind: v,
                                hasLeadingPunctuation: m.test(S[0]),
                                hasTrailingPunctuation: m.test(t(S)),
                              });
                            continue;
                          }
                          d(
                            m.test(S)
                              ? {
                                  type: "word",
                                  value: S,
                                  kind: I,
                                  hasLeadingPunctuation: !0,
                                  hasTrailingPunctuation: !0,
                                }
                              : {
                                  type: "word",
                                  value: S,
                                  kind: C.test(S) ? w : B,
                                  hasLeadingPunctuation: !1,
                                  hasTrailingPunctuation: !1,
                                }
                          );
                        }
                    }
                    return E;
                    function d(y) {
                      let o = t(E);
                      o &&
                        o.type === "word" &&
                        ((o.kind === v &&
                          y.kind === B &&
                          !o.hasTrailingPunctuation) ||
                        (o.kind === B &&
                          y.kind === v &&
                          !y.hasLeadingPunctuation)
                          ? E.push({ type: "whitespace", value: " " })
                          : !x(v, I) &&
                            ![o.value, y.value].some((F) => /\u3000/.test(F)) &&
                            E.push({ type: "whitespace", value: "" })),
                        E.push(y);
                      function x(F, S) {
                        return (
                          (o.kind === F && y.kind === S) ||
                          (o.kind === S && y.kind === F)
                        );
                      }
                    }
                  }
                  function p(A, b) {
                    let [, v, B, w] = b
                      .slice(A.position.start.offset, A.position.end.offset)
                      .match(/^\s*(\d+)(\.|\))(\s*)/);
                    return { numberText: v, marker: B, leadingSpaces: w };
                  }
                  function f(A, b) {
                    if (!A.ordered || A.children.length < 2) return !1;
                    let v = Number(p(A.children[0], b.originalText).numberText),
                      B = Number(p(A.children[1], b.originalText).numberText);
                    if (v === 0 && A.children.length > 2) {
                      let w = Number(
                        p(A.children[2], b.originalText).numberText
                      );
                      return B === 1 && w === 1;
                    }
                    return B === 1;
                  }
                  function h(A, b) {
                    let { value: v } = A;
                    return A.position.end.offset === b.length &&
                      v.endsWith(`
`) &&
                      b.endsWith(`
`)
                      ? v.slice(0, -1)
                      : v;
                  }
                  function N(A, b) {
                    return (function v(B, w, I) {
                      let E = Object.assign({}, b(B, w, I));
                      return (
                        E.children &&
                          (E.children = E.children.map((D, d) =>
                            v(D, d, [E, ...I])
                          )),
                        E
                      );
                    })(A, null, []);
                  }
                  function T(A) {
                    if (!A || A.type !== "link" || A.children.length !== 1)
                      return !1;
                    let b = A.children[0];
                    return b && s(A) === s(b) && i(A) === i(b);
                  }
                  n.exports = {
                    mapAst: N,
                    splitText: g,
                    punctuationPattern: a,
                    getFencedCodeBlockValue: h,
                    getOrderedListItemInfo: p,
                    hasGitDiffFriendlyOrderedList: f,
                    INLINE_NODE_TYPES: c,
                    INLINE_NODE_WRAPPER_TYPES: l,
                    isAutolink: T,
                  };
                },
              }),
              Sd = Z({
                "src/language-markdown/embed.js"(e, n) {
                  "use strict";
                  ae();
                  var { inferParserByLanguage: t, getMaxContinuousCount: s } =
                      Ge(),
                    {
                      builders: { hardline: i, markAsRoot: r },
                      utils: { replaceEndOfLine: u },
                    } = Le(),
                    a = Xn(),
                    { getFencedCodeBlockValue: c } = Kn();
                  function l(C, m, g, p) {
                    let f = C.getValue();
                    if (f.type === "code" && f.lang !== null) {
                      let h = t(f.lang, p);
                      if (h) {
                        let N = p.__inJsTemplate ? "~" : "`",
                          T = N.repeat(Math.max(3, s(f.value, N) + 1)),
                          A = { parser: h };
                        f.lang === "tsx" && (A.filepath = "dummy.tsx");
                        let b = g(c(f, p.originalText), A, {
                          stripTrailingHardline: !0,
                        });
                        return r([
                          T,
                          f.lang,
                          f.meta ? " " + f.meta : "",
                          i,
                          u(b),
                          i,
                          T,
                        ]);
                      }
                    }
                    switch (f.type) {
                      case "front-matter":
                        return a(f, g);
                      case "importExport":
                        return [
                          g(
                            f.value,
                            { parser: "babel" },
                            { stripTrailingHardline: !0 }
                          ),
                          i,
                        ];
                      case "jsx":
                        return g(
                          "<$>".concat(f.value, "</$>"),
                          { parser: "__js_expression", rootMarker: "mdx" },
                          { stripTrailingHardline: !0 }
                        );
                    }
                    return null;
                  }
                  n.exports = l;
                },
              }),
              Do = Z({
                "src/language-markdown/pragma.js"(e, n) {
                  "use strict";
                  ae();
                  var t = po(),
                    s = ["format", "prettier"];
                  function i(r) {
                    let u = "@(".concat(s.join("|"), ")"),
                      a = new RegExp(
                        [
                          "<!--\\s*".concat(u, "\\s*-->"),
                          "{\\s*\\/\\*\\s*".concat(u, "\\s*\\*\\/\\s*}"),
                          `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*`.concat(
                            u,
                            `[^\\S
]*($|
)[\\s\\S]*
.*-->`
                          ),
                        ].join("|"),
                        "m"
                      ),
                      c = r.match(a);
                    return c && c.index === 0;
                  }
                  n.exports = {
                    startWithPragma: i,
                    hasPragma: (r) => i(t(r).content.trimStart()),
                    insertPragma: (r) => {
                      let u = t(r),
                        a = "<!-- @".concat(s[0], " -->");
                      return u.frontMatter
                        ? ""
                            .concat(
                              u.frontMatter.raw,
                              `

`
                            )
                            .concat(
                              a,
                              `

`
                            )
                            .concat(u.content)
                        : ""
                            .concat(
                              a,
                              `

`
                            )
                            .concat(u.content);
                    },
                  };
                },
              }),
              xd = Z({
                "src/language-markdown/print-preprocess.js"(e, n) {
                  "use strict";
                  ae();
                  var t = st(),
                    {
                      getOrderedListItemInfo: s,
                      mapAst: i,
                      splitText: r,
                    } = Kn(),
                    u = /^.$/su;
                  function a(T, A) {
                    return (
                      (T = C(T, A)),
                      (T = p(T)),
                      (T = l(T)),
                      (T = h(T, A)),
                      (T = N(T, A)),
                      (T = f(T, A)),
                      (T = c(T)),
                      (T = m(T)),
                      T
                    );
                  }
                  function c(T) {
                    return i(T, (A) =>
                      A.type !== "import" && A.type !== "export"
                        ? A
                        : Object.assign(
                            Object.assign({}, A),
                            {},
                            { type: "importExport" }
                          )
                    );
                  }
                  function l(T) {
                    return i(T, (A) =>
                      A.type !== "inlineCode"
                        ? A
                        : Object.assign(
                            Object.assign({}, A),
                            {},
                            { value: A.value.replace(/\s+/g, " ") }
                          )
                    );
                  }
                  function C(T, A) {
                    return i(T, (b) =>
                      b.type !== "text" ||
                      b.value === "*" ||
                      b.value === "_" ||
                      !u.test(b.value) ||
                      b.position.end.offset - b.position.start.offset ===
                        b.value.length
                        ? b
                        : Object.assign(
                            Object.assign({}, b),
                            {},
                            {
                              value: A.originalText.slice(
                                b.position.start.offset,
                                b.position.end.offset
                              ),
                            }
                          )
                    );
                  }
                  function m(T) {
                    return g(
                      T,
                      (A, b) =>
                        A.type === "importExport" && b.type === "importExport",
                      (A, b) => ({
                        type: "importExport",
                        value:
                          A.value +
                          `

` +
                          b.value,
                        position: {
                          start: A.position.start,
                          end: b.position.end,
                        },
                      })
                    );
                  }
                  function g(T, A, b) {
                    return i(T, (v) => {
                      if (!v.children) return v;
                      let B = v.children.reduce((w, I) => {
                        let E = t(w);
                        return (
                          E && A(E, I) ? w.splice(-1, 1, b(E, I)) : w.push(I), w
                        );
                      }, []);
                      return Object.assign(
                        Object.assign({}, v),
                        {},
                        { children: B }
                      );
                    });
                  }
                  function p(T) {
                    return g(
                      T,
                      (A, b) => A.type === "text" && b.type === "text",
                      (A, b) => ({
                        type: "text",
                        value: A.value + b.value,
                        position: {
                          start: A.position.start,
                          end: b.position.end,
                        },
                      })
                    );
                  }
                  function f(T, A) {
                    return i(T, (b, v, B) => {
                      let [w] = B;
                      if (b.type !== "text") return b;
                      let { value: I } = b;
                      return (
                        w.type === "paragraph" &&
                          (v === 0 && (I = I.trimStart()),
                          v === w.children.length - 1 && (I = I.trimEnd())),
                        {
                          type: "sentence",
                          position: b.position,
                          children: r(I, A),
                        }
                      );
                    });
                  }
                  function h(T, A) {
                    return i(T, (b, v, B) => {
                      if (b.type === "code") {
                        let w = /^\n?(?: {4,}|\t)/.test(
                          A.originalText.slice(
                            b.position.start.offset,
                            b.position.end.offset
                          )
                        );
                        if (((b.isIndented = w), w))
                          for (let I = 0; I < B.length; I++) {
                            let E = B[I];
                            if (E.hasIndentedCodeblock) break;
                            E.type === "list" && (E.hasIndentedCodeblock = !0);
                          }
                      }
                      return b;
                    });
                  }
                  function N(T, A) {
                    return i(T, (B, w, I) => {
                      if (B.type === "list" && B.children.length > 0) {
                        for (let E = 0; E < I.length; E++) {
                          let D = I[E];
                          if (D.type === "list" && !D.isAligned)
                            return (B.isAligned = !1), B;
                        }
                        B.isAligned = v(B);
                      }
                      return B;
                    });
                    function b(B) {
                      return B.children.length === 0
                        ? -1
                        : B.children[0].position.start.column - 1;
                    }
                    function v(B) {
                      if (!B.ordered) return !0;
                      let [w, I] = B.children;
                      if (s(w, A.originalText).leadingSpaces.length > 1)
                        return !0;
                      let D = b(w);
                      if (D === -1) return !1;
                      if (B.children.length === 1) return D % A.tabWidth === 0;
                      let d = b(I);
                      return D !== d
                        ? !1
                        : D % A.tabWidth === 0
                        ? !0
                        : s(I, A.originalText).leadingSpaces.length > 1;
                    }
                  }
                  n.exports = a;
                },
              }),
              bd = Z({
                "src/language-markdown/clean.js"(e, n) {
                  "use strict";
                  ae();
                  var { isFrontMatterNode: t } = Ge(),
                    { startWithPragma: s } = Do(),
                    i = new Set(["position", "raw"]);
                  function r(u, a, c) {
                    if (
                      ((u.type === "front-matter" ||
                        u.type === "code" ||
                        u.type === "yaml" ||
                        u.type === "import" ||
                        u.type === "export" ||
                        u.type === "jsx") &&
                        delete a.value,
                      u.type === "list" && delete a.isAligned,
                      (u.type === "list" || u.type === "listItem") &&
                        (delete a.spread, delete a.loose),
                      u.type === "text" ||
                        (u.type === "inlineCode" &&
                          (a.value = u.value.replace(/[\t\n ]+/g, " ")),
                        u.type === "wikiLink" &&
                          (a.value = u.value.trim().replace(/[\t\n]+/g, " ")),
                        (u.type === "definition" ||
                          u.type === "linkReference") &&
                          (a.label = u.label
                            .trim()
                            .replace(/[\t\n ]+/g, " ")
                            .toLowerCase()),
                        (u.type === "definition" ||
                          u.type === "link" ||
                          u.type === "image") &&
                          u.title &&
                          (a.title = u.title.replace(/\\(["')])/g, "$1")),
                        c &&
                          c.type === "root" &&
                          c.children.length > 0 &&
                          (c.children[0] === u ||
                            (t(c.children[0]) && c.children[1] === u)) &&
                          u.type === "html" &&
                          s(u.value)))
                    )
                      return null;
                  }
                  (r.ignoredProperties = i), (n.exports = r);
                },
              }),
              Td = Z({
                "src/language-markdown/printer-markdown.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      getLast: t,
                      getMinNotPresentContinuousCount: s,
                      getMaxContinuousCount: i,
                      getStringWidth: r,
                      isNonEmptyArray: u,
                    } = Ge(),
                    {
                      builders: {
                        breakParent: a,
                        join: c,
                        line: l,
                        literalline: C,
                        markAsRoot: m,
                        hardline: g,
                        softline: p,
                        ifBreak: f,
                        fill: h,
                        align: N,
                        indent: T,
                        group: A,
                        hardlineWithoutBreakParent: b,
                      },
                      utils: { normalizeDoc: v, replaceTextEndOfLine: B },
                      printer: { printDocToString: w },
                    } = Le(),
                    I = Sd(),
                    { insertPragma: E } = Do(),
                    { locStart: D, locEnd: d } = fo(),
                    y = xd(),
                    o = bd(),
                    {
                      getFencedCodeBlockValue: x,
                      hasGitDiffFriendlyOrderedList: F,
                      splitText: S,
                      punctuationPattern: k,
                      INLINE_NODE_TYPES: _,
                      INLINE_NODE_WRAPPER_TYPES: O,
                      isAutolink: R,
                    } = Kn(),
                    M = new Set(["importExport"]),
                    H = ["heading", "tableCell", "link", "wikiLink"],
                    P = new Set([
                      "listItem",
                      "definition",
                      "footnoteDefinition",
                    ]);
                  function G(fe, pe, me) {
                    let ce = fe.getValue();
                    if (de(fe))
                      return S(
                        pe.originalText.slice(
                          ce.position.start.offset,
                          ce.position.end.offset
                        ),
                        pe
                      ).map((he) =>
                        he.type === "word"
                          ? he.value
                          : he.value === ""
                          ? ""
                          : se(fe, he.value, pe)
                      );
                    switch (ce.type) {
                      case "front-matter":
                        return pe.originalText.slice(
                          ce.position.start.offset,
                          ce.position.end.offset
                        );
                      case "root":
                        return ce.children.length === 0
                          ? ""
                          : [v(oe(fe, pe, me)), M.has(Ee(ce).type) ? "" : g];
                      case "paragraph":
                        return K(fe, pe, me, { postprocessor: h });
                      case "sentence":
                        return K(fe, pe, me);
                      case "word": {
                        let he = ce.value
                            .replace(/\*/g, "\\$&")
                            .replace(
                              new RegExp(
                                [
                                  "(^|".concat(k, ")(_+)"),
                                  "(_+)(".concat(k, "|$)"),
                                ].join("|"),
                                "g"
                              ),
                              (X, Y, te, z, j) =>
                                (te
                                  ? "".concat(Y).concat(te)
                                  : "".concat(z).concat(j)
                                ).replace(/_/g, "\\_")
                            ),
                          J = (X, Y, te) => X.type === "sentence" && te === 0,
                          ye = (X, Y, te) => R(X.children[te - 1]);
                        return (
                          he !== ce.value &&
                            (fe.match(void 0, J, ye) ||
                              fe.match(
                                void 0,
                                J,
                                (X, Y, te) => X.type === "emphasis" && te === 0,
                                ye
                              )) &&
                            (he = he.replace(/^(\\?[*_])+/, (X) =>
                              X.replace(/\\/g, "")
                            )),
                          he
                        );
                      }
                      case "whitespace": {
                        let he = fe.getParentNode(),
                          J = he.children.indexOf(ce),
                          ye = he.children[J + 1],
                          X =
                            ye && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(ye.value)
                              ? "never"
                              : pe.proseWrap;
                        return se(fe, ce.value, { proseWrap: X });
                      }
                      case "emphasis": {
                        let he;
                        if (R(ce.children[0]))
                          he = pe.originalText[ce.position.start.offset];
                        else {
                          let J = fe.getParentNode(),
                            ye = J.children.indexOf(ce),
                            X = J.children[ye - 1],
                            Y = J.children[ye + 1];
                          he =
                            (X &&
                              X.type === "sentence" &&
                              X.children.length > 0 &&
                              t(X.children).type === "word" &&
                              !t(X.children).hasTrailingPunctuation) ||
                            (Y &&
                              Y.type === "sentence" &&
                              Y.children.length > 0 &&
                              Y.children[0].type === "word" &&
                              !Y.children[0].hasLeadingPunctuation) ||
                            ne(fe, "emphasis")
                              ? "*"
                              : "_";
                        }
                        return [he, K(fe, pe, me), he];
                      }
                      case "strong":
                        return ["**", K(fe, pe, me), "**"];
                      case "delete":
                        return ["~~", K(fe, pe, me), "~~"];
                      case "inlineCode": {
                        let he = s(ce.value, "`"),
                          J = "`".repeat(he || 1),
                          ye = he && !/^\s/.test(ce.value) ? " " : "";
                        return [J, ye, ce.value, ye, J];
                      }
                      case "wikiLink": {
                        let he = "";
                        return (
                          pe.proseWrap === "preserve"
                            ? (he = ce.value)
                            : (he = ce.value.replace(/[\t\n]+/g, " ")),
                          ["[[", he, "]]"]
                        );
                      }
                      case "link":
                        switch (pe.originalText[ce.position.start.offset]) {
                          case "<": {
                            let he = "mailto:",
                              J =
                                ce.url.startsWith(he) &&
                                pe.originalText.slice(
                                  ce.position.start.offset + 1,
                                  ce.position.start.offset + 1 + he.length
                                ) !== he
                                  ? ce.url.slice(he.length)
                                  : ce.url;
                            return ["<", J, ">"];
                          }
                          case "[":
                            return [
                              "[",
                              K(fe, pe, me),
                              "](",
                              ge(ce.url, ")"),
                              ve(ce.title, pe),
                              ")",
                            ];
                          default:
                            return pe.originalText.slice(
                              ce.position.start.offset,
                              ce.position.end.offset
                            );
                        }
                      case "image":
                        return [
                          "![",
                          ce.alt || "",
                          "](",
                          ge(ce.url, ")"),
                          ve(ce.title, pe),
                          ")",
                        ];
                      case "blockquote":
                        return ["> ", N("> ", K(fe, pe, me))];
                      case "heading":
                        return ["#".repeat(ce.depth) + " ", K(fe, pe, me)];
                      case "code": {
                        if (ce.isIndented) {
                          let ye = " ".repeat(4);
                          return N(ye, [ye, ...B(ce.value, g)]);
                        }
                        let he = pe.__inJsTemplate ? "~" : "`",
                          J = he.repeat(Math.max(3, i(ce.value, he) + 1));
                        return [
                          J,
                          ce.lang || "",
                          ce.meta ? " " + ce.meta : "",
                          g,
                          ...B(x(ce, pe.originalText), g),
                          g,
                          J,
                        ];
                      }
                      case "html": {
                        let he = fe.getParentNode(),
                          J =
                            he.type === "root" && t(he.children) === ce
                              ? ce.value.trimEnd()
                              : ce.value,
                          ye = /^<!--.*-->$/s.test(J);
                        return B(J, ye ? g : m(C));
                      }
                      case "list": {
                        let he = W(ce, fe.getParentNode()),
                          J = F(ce, pe);
                        return K(fe, pe, me, {
                          processor: (ye, X) => {
                            let Y = z(),
                              te = ye.getValue();
                            if (
                              te.children.length === 2 &&
                              te.children[1].type === "html" &&
                              te.children[0].position.start.column !==
                                te.children[1].position.start.column
                            )
                              return [Y, re(ye, pe, me, Y)];
                            return [
                              Y,
                              N(" ".repeat(Y.length), re(ye, pe, me, Y)),
                            ];
                            function z() {
                              let j = ce.ordered
                                ? (X === 0 ? ce.start : J ? 1 : ce.start + X) +
                                  (he % 2 === 0 ? ". " : ") ")
                                : he % 2 === 0
                                ? "- "
                                : "* ";
                              return ce.isAligned || ce.hasIndentedCodeblock
                                ? $(j, pe)
                                : j;
                            }
                          },
                        });
                      }
                      case "thematicBreak": {
                        let he = U(fe, "list");
                        return he === -1
                          ? "---"
                          : W(fe.getParentNode(he), fe.getParentNode(he + 1)) %
                              2 ===
                            0
                          ? "***"
                          : "---";
                      }
                      case "linkReference":
                        return [
                          "[",
                          K(fe, pe, me),
                          "]",
                          ce.referenceType === "full"
                            ? ["[", ce.identifier, "]"]
                            : ce.referenceType === "collapsed"
                            ? "[]"
                            : "",
                        ];
                      case "imageReference":
                        switch (ce.referenceType) {
                          case "full":
                            return [
                              "![",
                              ce.alt || "",
                              "][",
                              ce.identifier,
                              "]",
                            ];
                          default:
                            return [
                              "![",
                              ce.alt,
                              "]",
                              ce.referenceType === "collapsed" ? "[]" : "",
                            ];
                        }
                      case "definition": {
                        let he = pe.proseWrap === "always" ? l : " ";
                        return A([
                          "[",
                          ce.identifier,
                          "]:",
                          T([
                            he,
                            ge(ce.url),
                            ce.title === null ? "" : [he, ve(ce.title, pe, !1)],
                          ]),
                        ]);
                      }
                      case "footnote":
                        return ["[^", K(fe, pe, me), "]"];
                      case "footnoteReference":
                        return ["[^", ce.identifier, "]"];
                      case "footnoteDefinition": {
                        let he = fe.getParentNode().children[fe.getName() + 1],
                          J =
                            ce.children.length === 1 &&
                            ce.children[0].type === "paragraph" &&
                            (pe.proseWrap === "never" ||
                              (pe.proseWrap === "preserve" &&
                                ce.children[0].position.start.line ===
                                  ce.children[0].position.end.line));
                        return [
                          "[^",
                          ce.identifier,
                          "]: ",
                          J
                            ? K(fe, pe, me)
                            : A([
                                N(
                                  " ".repeat(4),
                                  K(fe, pe, me, {
                                    processor: (ye, X) =>
                                      X === 0 ? A([p, me()]) : me(),
                                  })
                                ),
                                he && he.type === "footnoteDefinition" ? p : "",
                              ]),
                        ];
                      }
                      case "table":
                        return V(fe, pe, me);
                      case "tableCell":
                        return K(fe, pe, me);
                      case "break":
                        return /\s/.test(
                          pe.originalText[ce.position.start.offset]
                        )
                          ? ["  ", m(C)]
                          : ["\\", g];
                      case "liquidNode":
                        return B(ce.value, g);
                      case "importExport":
                        return [ce.value, g];
                      case "esComment":
                        return ["{/* ", ce.value, " */}"];
                      case "jsx":
                        return ce.value;
                      case "math":
                        return [
                          "$$",
                          g,
                          ce.value ? [...B(ce.value, g), g] : "",
                          "$$",
                        ];
                      case "inlineMath":
                        return pe.originalText.slice(D(ce), d(ce));
                      case "tableRow":
                      case "listItem":
                      default:
                        throw new Error(
                          "Unknown markdown type ".concat(
                            JSON.stringify(ce.type)
                          )
                        );
                    }
                  }
                  function re(fe, pe, me, ce) {
                    let he = fe.getValue(),
                      J =
                        he.checked === null ? "" : he.checked ? "[x] " : "[ ] ";
                    return [
                      J,
                      K(fe, pe, me, {
                        processor: (ye, X) => {
                          if (X === 0 && ye.getValue().type !== "list")
                            return N(" ".repeat(J.length), me());
                          let Y = " ".repeat(xe(pe.tabWidth - ce.length, 0, 3));
                          return [Y, N(Y, me())];
                        },
                      }),
                    ];
                  }
                  function $(fe, pe) {
                    let me = ce();
                    return fe + " ".repeat(me >= 4 ? 0 : me);
                    function ce() {
                      let he = fe.length % pe.tabWidth;
                      return he === 0 ? 0 : pe.tabWidth - he;
                    }
                  }
                  function W(fe, pe) {
                    return ee(fe, pe, (me) => me.ordered === fe.ordered);
                  }
                  function ee(fe, pe, me) {
                    let ce = -1;
                    for (let he of pe.children)
                      if (
                        (he.type === fe.type && me(he) ? ce++ : (ce = -1),
                        he === fe)
                      )
                        return ce;
                  }
                  function U(fe, pe) {
                    let me = Array.isArray(pe) ? pe : [pe],
                      ce = -1,
                      he;
                    for (; (he = fe.getParentNode(++ce)); )
                      if (me.includes(he.type)) return ce;
                    return -1;
                  }
                  function ne(fe, pe) {
                    let me = U(fe, pe);
                    return me === -1 ? null : fe.getParentNode(me);
                  }
                  function se(fe, pe, me) {
                    if (
                      me.proseWrap === "preserve" &&
                      pe ===
                        `
`
                    )
                      return g;
                    let ce = me.proseWrap === "always" && !ne(fe, H);
                    return pe !== "" ? (ce ? l : " ") : ce ? p : "";
                  }
                  function V(fe, pe, me) {
                    let ce = fe.getValue(),
                      he = [],
                      J = fe.map(
                        (j) =>
                          j.map((Ce, Ne) => {
                            let je = w(me(), pe).formatted,
                              Ue = r(je);
                            return (
                              (he[Ne] = Math.max(he[Ne] || 3, Ue)),
                              { text: je, width: Ue }
                            );
                          }, "children"),
                        "children"
                      ),
                      ye = Y(!1);
                    if (pe.proseWrap !== "never") return [a, ye];
                    let X = Y(!0);
                    return [a, A(f(X, ye))];
                    function Y(j) {
                      let Ce = [z(J[0], j), te(j)];
                      return (
                        J.length > 1 &&
                          Ce.push(
                            c(
                              b,
                              J.slice(1).map((Ne) => z(Ne, j))
                            )
                          ),
                        c(b, Ce)
                      );
                    }
                    function te(j) {
                      let Ce = he.map((Ne, je) => {
                        let Ue = ce.align[je],
                          tt = Ue === "center" || Ue === "left" ? ":" : "-",
                          Te = Ue === "center" || Ue === "right" ? ":" : "-",
                          _e = j ? "-" : "-".repeat(Ne - 2);
                        return "".concat(tt).concat(_e).concat(Te);
                      });
                      return "| ".concat(Ce.join(" | "), " |");
                    }
                    function z(j, Ce) {
                      let Ne = j.map((je, Ue) => {
                        let { text: tt, width: Te } = je;
                        if (Ce) return tt;
                        let _e = he[Ue] - Te,
                          Fe = ce.align[Ue],
                          Ke = 0;
                        Fe === "right"
                          ? (Ke = _e)
                          : Fe === "center" && (Ke = Math.floor(_e / 2));
                        let Se = _e - Ke;
                        return ""
                          .concat(" ".repeat(Ke))
                          .concat(tt)
                          .concat(" ".repeat(Se));
                      });
                      return "| ".concat(Ne.join(" | "), " |");
                    }
                  }
                  function oe(fe, pe, me) {
                    let ce = [],
                      he = null,
                      { children: J } = fe.getValue();
                    for (let [ye, X] of J.entries())
                      switch (q(X)) {
                        case "start":
                          he === null &&
                            (he = { index: ye, offset: X.position.end.offset });
                          break;
                        case "end":
                          he !== null &&
                            (ce.push({
                              start: he,
                              end: {
                                index: ye,
                                offset: X.position.start.offset,
                              },
                            }),
                            (he = null));
                          break;
                        default:
                          break;
                      }
                    return K(fe, pe, me, {
                      processor: (ye, X) => {
                        if (ce.length > 0) {
                          let Y = ce[0];
                          if (X === Y.start.index)
                            return [
                              J[Y.start.index].value,
                              pe.originalText.slice(
                                Y.start.offset,
                                Y.end.offset
                              ),
                              J[Y.end.index].value,
                            ];
                          if (Y.start.index < X && X < Y.end.index) return !1;
                          if (X === Y.end.index) return ce.shift(), !1;
                        }
                        return me();
                      },
                    });
                  }
                  function K(fe, pe, me) {
                    let ce =
                        arguments.length > 3 && arguments[3] !== void 0
                          ? arguments[3]
                          : {},
                      { postprocessor: he } = ce,
                      J = ce.processor || (() => me()),
                      ye = fe.getValue(),
                      X = [],
                      Y;
                    return (
                      fe.each((te, z) => {
                        let j = te.getValue(),
                          Ce = J(te, z);
                        if (Ce !== !1) {
                          let Ne = {
                            parts: X,
                            prevNode: Y,
                            parentNode: ye,
                            options: pe,
                          };
                          le(j, Ne) &&
                            (X.push(g),
                            (Y && M.has(Y.type)) ||
                              ((ue(j, Ne) || Q(j, Ne)) && X.push(g)),
                            Q(j, Ne) && X.push(g)),
                            X.push(Ce),
                            (Y = j);
                        }
                      }, "children"),
                      he ? he(X) : X
                    );
                  }
                  function Ee(fe) {
                    let pe = fe;
                    for (; u(pe.children); ) pe = t(pe.children);
                    return pe;
                  }
                  function q(fe) {
                    let pe;
                    if (fe.type === "html")
                      pe = fe.value.match(
                        /^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/
                      );
                    else {
                      let me;
                      fe.type === "esComment"
                        ? (me = fe)
                        : fe.type === "paragraph" &&
                          fe.children.length === 1 &&
                          fe.children[0].type === "esComment" &&
                          (me = fe.children[0]),
                        me &&
                          (pe = me.value.match(
                            /^prettier-ignore(?:-(start|end))?$/
                          ));
                    }
                    return pe ? (pe[1] ? pe[1] : "next") : !1;
                  }
                  function le(fe, pe) {
                    let me = pe.parts.length === 0,
                      ce = _.includes(fe.type),
                      he = fe.type === "html" && O.includes(pe.parentNode.type);
                    return !me && !ce && !he;
                  }
                  function ue(fe, pe) {
                    let ce =
                        (pe.prevNode && pe.prevNode.type) === fe.type &&
                        P.has(fe.type),
                      he =
                        pe.parentNode.type === "listItem" &&
                        !pe.parentNode.loose,
                      J =
                        pe.prevNode &&
                        pe.prevNode.type === "listItem" &&
                        pe.prevNode.loose,
                      ye = q(pe.prevNode) === "next",
                      X =
                        fe.type === "html" &&
                        pe.prevNode &&
                        pe.prevNode.type === "html" &&
                        pe.prevNode.position.end.line + 1 ===
                          fe.position.start.line,
                      Y =
                        fe.type === "html" &&
                        pe.parentNode.type === "listItem" &&
                        pe.prevNode &&
                        pe.prevNode.type === "paragraph" &&
                        pe.prevNode.position.end.line + 1 ===
                          fe.position.start.line;
                    return J || !(ce || he || ye || X || Y);
                  }
                  function Q(fe, pe) {
                    let me = pe.prevNode && pe.prevNode.type === "list",
                      ce = fe.type === "code" && fe.isIndented;
                    return me && ce;
                  }
                  function de(fe) {
                    let pe = ne(fe, ["linkReference", "imageReference"]);
                    return (
                      pe &&
                      (pe.type !== "linkReference" ||
                        pe.referenceType !== "full")
                    );
                  }
                  function ge(fe) {
                    let pe =
                        arguments.length > 1 && arguments[1] !== void 0
                          ? arguments[1]
                          : [],
                      me = [" ", ...(Array.isArray(pe) ? pe : [pe])];
                    return new RegExp(
                      me.map((ce) => "\\".concat(ce)).join("|")
                    ).test(fe)
                      ? "<".concat(fe, ">")
                      : fe;
                  }
                  function ve(fe, pe) {
                    let me =
                      arguments.length > 2 && arguments[2] !== void 0
                        ? arguments[2]
                        : !0;
                    if (!fe) return "";
                    if (me) return " " + ve(fe, pe, !1);
                    if (
                      ((fe = fe.replace(/\\(["')])/g, "$1")),
                      fe.includes('"') && fe.includes("'") && !fe.includes(")"))
                    )
                      return "(".concat(fe, ")");
                    let ce = fe.split("'").length - 1,
                      he = fe.split('"').length - 1,
                      J = ce > he ? '"' : he > ce || pe.singleQuote ? "'" : '"';
                    return (
                      (fe = fe.replace(/\\/, "\\\\")),
                      (fe = fe.replace(
                        new RegExp("(".concat(J, ")"), "g"),
                        "\\$1"
                      )),
                      "".concat(J).concat(fe).concat(J)
                    );
                  }
                  function xe(fe, pe, me) {
                    return fe < pe ? pe : fe > me ? me : fe;
                  }
                  function we(fe) {
                    let pe = Number(fe.getName());
                    if (pe === 0) return !1;
                    let me = fe.getParentNode().children[pe - 1];
                    return q(me) === "next";
                  }
                  n.exports = {
                    preprocess: y,
                    print: G,
                    embed: I,
                    massageAstNode: o,
                    hasPrettierIgnore: we,
                    insertPragma: E,
                  };
                },
              }),
              Bd = Z({
                "src/language-markdown/options.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Lt();
                  n.exports = {
                    proseWrap: t.proseWrap,
                    singleQuote: t.singleQuote,
                  };
                },
              }),
              Nd = Z({
                "src/language-markdown/parsers.js"() {
                  ae();
                },
              }),
              di = Z({
                "node_modules/linguist-languages/data/Markdown.json"(e, n) {
                  n.exports = {
                    name: "Markdown",
                    type: "prose",
                    color: "#083fa1",
                    aliases: ["pandoc"],
                    aceMode: "markdown",
                    codemirrorMode: "gfm",
                    codemirrorMimeType: "text/x-gfm",
                    wrap: !0,
                    extensions: [
                      ".md",
                      ".markdown",
                      ".mdown",
                      ".mdwn",
                      ".mdx",
                      ".mkd",
                      ".mkdn",
                      ".mkdown",
                      ".ronn",
                      ".scd",
                      ".workbook",
                    ],
                    filenames: ["contents.lr"],
                    tmScope: "source.gfm",
                    languageId: 222,
                  };
                },
              }),
              wd = Z({
                "src/language-markdown/index.js"(e, n) {
                  "use strict";
                  ae();
                  var t = bt(),
                    s = Td(),
                    i = Bd(),
                    r = Nd(),
                    u = [
                      t(di(), (c) => ({
                        since: "1.8.0",
                        parsers: ["markdown"],
                        vscodeLanguageIds: ["markdown"],
                        filenames: [...c.filenames, "README"],
                        extensions: c.extensions.filter((l) => l !== ".mdx"),
                      })),
                      t(di(), () => ({
                        name: "MDX",
                        since: "1.15.0",
                        parsers: ["mdx"],
                        vscodeLanguageIds: ["mdx"],
                        filenames: [],
                        extensions: [".mdx"],
                      })),
                    ],
                    a = { mdast: s };
                  n.exports = {
                    languages: u,
                    options: i,
                    printers: a,
                    parsers: r,
                  };
                },
              }),
              _d = Z({
                "src/language-html/clean.js"(e, n) {
                  "use strict";
                  ae();
                  var { isFrontMatterNode: t } = Ge(),
                    s = new Set([
                      "sourceSpan",
                      "startSourceSpan",
                      "endSourceSpan",
                      "nameSpan",
                      "valueSpan",
                      "parent",
                    ]);
                  function i(r, u) {
                    if (
                      r.type === "text" ||
                      r.type === "comment" ||
                      t(r) ||
                      r.type === "yaml" ||
                      r.type === "toml"
                    )
                      return null;
                    r.type === "attribute" && delete u.value,
                      r.type === "docType" && delete u.value;
                  }
                  (i.ignoredProperties = s), (n.exports = i);
                },
              }),
              Pd = Z({
                "src/language-html/constants.evaluate.js"(e, n) {
                  n.exports = {
                    CSS_DISPLAY_TAGS: {
                      area: "none",
                      base: "none",
                      basefont: "none",
                      datalist: "none",
                      head: "none",
                      link: "none",
                      meta: "none",
                      noembed: "none",
                      noframes: "none",
                      param: "block",
                      rp: "none",
                      script: "block",
                      source: "block",
                      style: "none",
                      template: "inline",
                      track: "block",
                      title: "none",
                      html: "block",
                      body: "block",
                      address: "block",
                      blockquote: "block",
                      center: "block",
                      div: "block",
                      figure: "block",
                      figcaption: "block",
                      footer: "block",
                      form: "block",
                      header: "block",
                      hr: "block",
                      legend: "block",
                      listing: "block",
                      main: "block",
                      p: "block",
                      plaintext: "block",
                      pre: "block",
                      xmp: "block",
                      slot: "contents",
                      ruby: "ruby",
                      rt: "ruby-text",
                      article: "block",
                      aside: "block",
                      h1: "block",
                      h2: "block",
                      h3: "block",
                      h4: "block",
                      h5: "block",
                      h6: "block",
                      hgroup: "block",
                      nav: "block",
                      section: "block",
                      dir: "block",
                      dd: "block",
                      dl: "block",
                      dt: "block",
                      ol: "block",
                      ul: "block",
                      li: "list-item",
                      table: "table",
                      caption: "table-caption",
                      colgroup: "table-column-group",
                      col: "table-column",
                      thead: "table-header-group",
                      tbody: "table-row-group",
                      tfoot: "table-footer-group",
                      tr: "table-row",
                      td: "table-cell",
                      th: "table-cell",
                      fieldset: "block",
                      button: "inline-block",
                      details: "block",
                      summary: "block",
                      dialog: "block",
                      meter: "inline-block",
                      progress: "inline-block",
                      object: "inline-block",
                      video: "inline-block",
                      audio: "inline-block",
                      select: "inline-block",
                      option: "block",
                      optgroup: "block",
                    },
                    CSS_DISPLAY_DEFAULT: "inline",
                    CSS_WHITE_SPACE_TAGS: {
                      listing: "pre",
                      plaintext: "pre",
                      pre: "pre",
                      xmp: "pre",
                      nobr: "nowrap",
                      table: "initial",
                      textarea: "pre-wrap",
                    },
                    CSS_WHITE_SPACE_DEFAULT: "normal",
                  };
                },
              }),
              Id = Z({
                "src/language-html/utils/is-unknown-namespace.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s) {
                    return (
                      s.type === "element" &&
                      !s.hasExplicitNamespace &&
                      !["html", "svg"].includes(s.namespace)
                    );
                  }
                  n.exports = t;
                },
              }),
              Ot = Z({
                "src/language-html/utils/index.js"(e, n) {
                  "use strict";
                  ae();
                  var { inferParserByLanguage: t, isFrontMatterNode: s } = Ge(),
                    {
                      builders: { line: i, hardline: r, join: u },
                      utils: { getDocParts: a, replaceTextEndOfLine: c },
                    } = Le(),
                    {
                      CSS_DISPLAY_TAGS: l,
                      CSS_DISPLAY_DEFAULT: C,
                      CSS_WHITE_SPACE_TAGS: m,
                      CSS_WHITE_SPACE_DEFAULT: g,
                    } = Pd(),
                    p = Id(),
                    f = new Set([
                      "	",
                      `
`,
                      "\f",
                      "\r",
                      " ",
                    ]),
                    h = (j) => j.replace(/^[\t\n\f\r ]+/, ""),
                    N = (j) => j.replace(/[\t\n\f\r ]+$/, ""),
                    T = (j) => h(N(j)),
                    A = (j) => j.replace(/^[\t\f\r ]*\n/g, ""),
                    b = (j) => A(N(j)),
                    v = (j) => j.split(/[\t\n\f\r ]+/),
                    B = (j) => j.match(/^[\t\n\f\r ]*/)[0],
                    w = (j) => {
                      let [, Ce, Ne, je] = j.match(
                        /^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s
                      );
                      return {
                        leadingWhitespace: Ce,
                        trailingWhitespace: je,
                        text: Ne,
                      };
                    },
                    I = (j) => /[\t\n\f\r ]/.test(j);
                  function E(j, Ce) {
                    return !!(
                      (j.type === "ieConditionalComment" &&
                        j.lastChild &&
                        !j.lastChild.isSelfClosing &&
                        !j.lastChild.endSourceSpan) ||
                      (j.type === "ieConditionalComment" && !j.complete) ||
                      (de(j) &&
                        j.children.some(
                          (Ne) =>
                            Ne.type !== "text" && Ne.type !== "interpolation"
                        )) ||
                      (X(j, Ce) && !o(j) && j.type !== "interpolation")
                    );
                  }
                  function D(j) {
                    return j.type === "attribute" || !j.parent || !j.prev
                      ? !1
                      : d(j.prev);
                  }
                  function d(j) {
                    return (
                      j.type === "comment" &&
                      j.value.trim() === "prettier-ignore"
                    );
                  }
                  function y(j) {
                    return j.type === "text" || j.type === "comment";
                  }
                  function o(j) {
                    return (
                      j.type === "element" &&
                      (j.fullName === "script" ||
                        j.fullName === "style" ||
                        j.fullName === "svg:style" ||
                        (p(j) && (j.name === "script" || j.name === "style")))
                    );
                  }
                  function x(j) {
                    return j.children && !o(j);
                  }
                  function F(j) {
                    return o(j) || j.type === "interpolation" || S(j);
                  }
                  function S(j) {
                    return we(j).startsWith("pre");
                  }
                  function k(j, Ce) {
                    let Ne = je();
                    if (
                      Ne &&
                      !j.prev &&
                      j.parent &&
                      j.parent.tagDefinition &&
                      j.parent.tagDefinition.ignoreFirstLf
                    )
                      return j.type === "interpolation";
                    return Ne;
                    function je() {
                      return s(j)
                        ? !1
                        : (j.type === "text" || j.type === "interpolation") &&
                          j.prev &&
                          (j.prev.type === "text" ||
                            j.prev.type === "interpolation")
                        ? !0
                        : !j.parent || j.parent.cssDisplay === "none"
                        ? !1
                        : de(j.parent)
                        ? !0
                        : !(
                            (!j.prev &&
                              (j.parent.type === "root" ||
                                (de(j) && j.parent) ||
                                o(j.parent) ||
                                J(j.parent, Ce) ||
                                !Ee(j.parent.cssDisplay))) ||
                            (j.prev && !ue(j.prev.cssDisplay))
                          );
                    }
                  }
                  function _(j, Ce) {
                    return s(j)
                      ? !1
                      : (j.type === "text" || j.type === "interpolation") &&
                        j.next &&
                        (j.next.type === "text" ||
                          j.next.type === "interpolation")
                      ? !0
                      : !j.parent || j.parent.cssDisplay === "none"
                      ? !1
                      : de(j.parent)
                      ? !0
                      : !(
                          (!j.next &&
                            (j.parent.type === "root" ||
                              (de(j) && j.parent) ||
                              o(j.parent) ||
                              J(j.parent, Ce) ||
                              !q(j.parent.cssDisplay))) ||
                          (j.next && !le(j.next.cssDisplay))
                        );
                  }
                  function O(j) {
                    return Q(j.cssDisplay) && !o(j);
                  }
                  function R(j) {
                    return (
                      s(j) ||
                      (j.next &&
                        j.sourceSpan.end &&
                        j.sourceSpan.end.line + 1 <
                          j.next.sourceSpan.start.line)
                    );
                  }
                  function M(j) {
                    return (
                      H(j) ||
                      (j.type === "element" &&
                        j.children.length > 0 &&
                        (["body", "script", "style"].includes(j.name) ||
                          j.children.some((Ce) => ne(Ce)))) ||
                      (j.firstChild &&
                        j.firstChild === j.lastChild &&
                        j.firstChild.type !== "text" &&
                        $(j.firstChild) &&
                        (!j.lastChild.isTrailingSpaceSensitive ||
                          W(j.lastChild)))
                    );
                  }
                  function H(j) {
                    return (
                      j.type === "element" &&
                      j.children.length > 0 &&
                      (["html", "head", "ul", "ol", "select"].includes(
                        j.name
                      ) ||
                        (j.cssDisplay.startsWith("table") &&
                          j.cssDisplay !== "table-cell"))
                    );
                  }
                  function P(j) {
                    return ee(j) || (j.prev && G(j.prev)) || re(j);
                  }
                  function G(j) {
                    return (
                      ee(j) ||
                      (j.type === "element" && j.fullName === "br") ||
                      re(j)
                    );
                  }
                  function re(j) {
                    return $(j) && W(j);
                  }
                  function $(j) {
                    return (
                      j.hasLeadingSpaces &&
                      (j.prev
                        ? j.prev.sourceSpan.end.line < j.sourceSpan.start.line
                        : j.parent.type === "root" ||
                          j.parent.startSourceSpan.end.line <
                            j.sourceSpan.start.line)
                    );
                  }
                  function W(j) {
                    return (
                      j.hasTrailingSpaces &&
                      (j.next
                        ? j.next.sourceSpan.start.line > j.sourceSpan.end.line
                        : j.parent.type === "root" ||
                          (j.parent.endSourceSpan &&
                            j.parent.endSourceSpan.start.line >
                              j.sourceSpan.end.line))
                    );
                  }
                  function ee(j) {
                    switch (j.type) {
                      case "ieConditionalComment":
                      case "comment":
                      case "directive":
                        return !0;
                      case "element":
                        return ["script", "select"].includes(j.name);
                    }
                    return !1;
                  }
                  function U(j) {
                    return j.lastChild ? U(j.lastChild) : j;
                  }
                  function ne(j) {
                    return (
                      j.children && j.children.some((Ce) => Ce.type !== "text")
                    );
                  }
                  function se(j) {
                    let { type: Ce, lang: Ne } = j.attrMap;
                    if (
                      Ce === "module" ||
                      Ce === "text/javascript" ||
                      Ce === "text/babel" ||
                      Ce === "application/javascript" ||
                      Ne === "jsx"
                    )
                      return "babel";
                    if (
                      Ce === "application/x-typescript" ||
                      Ne === "ts" ||
                      Ne === "tsx"
                    )
                      return "typescript";
                    if (Ce === "text/markdown") return "markdown";
                    if (Ce === "text/html") return "html";
                    if (Ce && (Ce.endsWith("json") || Ce.endsWith("importmap")))
                      return "json";
                    if (Ce === "text/x-handlebars-template") return "glimmer";
                  }
                  function V(j) {
                    let { lang: Ce } = j.attrMap;
                    if (!Ce || Ce === "postcss" || Ce === "css") return "css";
                    if (Ce === "scss") return "scss";
                    if (Ce === "less") return "less";
                  }
                  function oe(j, Ce) {
                    if (j.name === "script" && !j.attrMap.src)
                      return !j.attrMap.lang && !j.attrMap.type
                        ? "babel"
                        : se(j);
                    if (j.name === "style") return V(j);
                    if (Ce && X(j, Ce))
                      return (
                        se(j) ||
                        (!("src" in j.attrMap) && t(j.attrMap.lang, Ce))
                      );
                  }
                  function K(j) {
                    return (
                      j === "block" ||
                      j === "list-item" ||
                      j.startsWith("table")
                    );
                  }
                  function Ee(j) {
                    return !K(j) && j !== "inline-block";
                  }
                  function q(j) {
                    return !K(j) && j !== "inline-block";
                  }
                  function le(j) {
                    return !K(j);
                  }
                  function ue(j) {
                    return !K(j);
                  }
                  function Q(j) {
                    return !K(j) && j !== "inline-block";
                  }
                  function de(j) {
                    return we(j).startsWith("pre");
                  }
                  function ge(j, Ce) {
                    let Ne = 0;
                    for (let je = j.stack.length - 1; je >= 0; je--) {
                      let Ue = j.stack[je];
                      Ue &&
                        typeof Ue == "object" &&
                        !Array.isArray(Ue) &&
                        Ce(Ue) &&
                        Ne++;
                    }
                    return Ne;
                  }
                  function ve(j, Ce) {
                    let Ne = j;
                    for (; Ne; ) {
                      if (Ce(Ne)) return !0;
                      Ne = Ne.parent;
                    }
                    return !1;
                  }
                  function xe(j, Ce) {
                    if (j.prev && j.prev.type === "comment") {
                      let je = j.prev.value.match(
                        /^\s*display:\s*([a-z]+)\s*$/
                      );
                      if (je) return je[1];
                    }
                    let Ne = !1;
                    if (j.type === "element" && j.namespace === "svg")
                      if (ve(j, (je) => je.fullName === "svg:foreignObject"))
                        Ne = !0;
                      else return j.name === "svg" ? "inline-block" : "block";
                    switch (Ce.htmlWhitespaceSensitivity) {
                      case "strict":
                        return "inline";
                      case "ignore":
                        return "block";
                      default:
                        return Ce.parser === "vue" &&
                          j.parent &&
                          j.parent.type === "root"
                          ? "block"
                          : (j.type === "element" &&
                              (!j.namespace || Ne || p(j)) &&
                              l[j.name]) ||
                              C;
                    }
                  }
                  function we(j) {
                    return (
                      (j.type === "element" &&
                        (!j.namespace || p(j)) &&
                        m[j.name]) ||
                      g
                    );
                  }
                  function fe(j) {
                    let Ce = Number.POSITIVE_INFINITY;
                    for (let Ne of j.split(`
`)) {
                      if (Ne.length === 0) continue;
                      if (!f.has(Ne[0])) return 0;
                      let je = B(Ne).length;
                      Ne.length !== je && je < Ce && (Ce = je);
                    }
                    return Ce === Number.POSITIVE_INFINITY ? 0 : Ce;
                  }
                  function pe(j) {
                    let Ce =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : fe(j);
                    return Ce === 0
                      ? j
                      : j
                          .split(
                            `
`
                          )
                          .map((Ne) => Ne.slice(Ce)).join(`
`);
                  }
                  function me(j, Ce) {
                    let Ne = 0;
                    for (let je = 0; je < j.length; je++) j[je] === Ce && Ne++;
                    return Ne;
                  }
                  function ce(j) {
                    return j.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                  }
                  var he = new Set(["template", "style", "script"]);
                  function J(j, Ce) {
                    return ye(j, Ce) && !he.has(j.fullName);
                  }
                  function ye(j, Ce) {
                    return (
                      Ce.parser === "vue" &&
                      j.type === "element" &&
                      j.parent.type === "root" &&
                      j.fullName.toLowerCase() !== "html"
                    );
                  }
                  function X(j, Ce) {
                    return (
                      ye(j, Ce) &&
                      (J(j, Ce) ||
                        (j.attrMap.lang && j.attrMap.lang !== "html"))
                    );
                  }
                  function Y(j) {
                    let Ce = j.fullName;
                    return (
                      Ce.charAt(0) === "#" ||
                      Ce === "slot-scope" ||
                      Ce === "v-slot" ||
                      Ce.startsWith("v-slot:")
                    );
                  }
                  function te(j, Ce) {
                    let Ne = j.parent;
                    if (!ye(Ne, Ce)) return !1;
                    let je = Ne.fullName,
                      Ue = j.fullName;
                    return (
                      (je === "script" && Ue === "setup") ||
                      (je === "style" && Ue === "vars")
                    );
                  }
                  function z(j) {
                    let Ce =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : j.value;
                    return j.parent.isWhitespaceSensitive
                      ? j.parent.isIndentationSensitive
                        ? c(Ce)
                        : c(pe(b(Ce)), r)
                      : a(u(i, v(Ce)));
                  }
                  n.exports = {
                    htmlTrim: T,
                    htmlTrimPreserveIndentation: b,
                    hasHtmlWhitespace: I,
                    getLeadingAndTrailingHtmlWhitespace: w,
                    canHaveInterpolation: x,
                    countChars: me,
                    countParents: ge,
                    dedentString: pe,
                    forceBreakChildren: H,
                    forceBreakContent: M,
                    forceNextEmptyLine: R,
                    getLastDescendant: U,
                    getNodeCssStyleDisplay: xe,
                    getNodeCssStyleWhiteSpace: we,
                    hasPrettierIgnore: D,
                    inferScriptParser: oe,
                    isVueCustomBlock: J,
                    isVueNonHtmlBlock: X,
                    isVueSlotAttribute: Y,
                    isVueSfcBindingsAttribute: te,
                    isDanglingSpaceSensitiveNode: O,
                    isIndentationSensitiveNode: S,
                    isLeadingSpaceSensitiveNode: k,
                    isPreLikeNode: de,
                    isScriptLikeTag: o,
                    isTextLikeNode: y,
                    isTrailingSpaceSensitiveNode: _,
                    isWhitespaceSensitiveNode: F,
                    isUnknownNamespace: p,
                    preferHardlineAsLeadingSpaces: P,
                    preferHardlineAsTrailingSpaces: G,
                    shouldPreserveContent: E,
                    unescapeQuoteEntities: ce,
                    getTextValueParts: z,
                  };
                },
              }),
              kd = Z({
                "node_modules/angular-html-parser/lib/compiler/src/chars.js"(
                  e
                ) {
                  "use strict";
                  ae(),
                    Object.defineProperty(e, "__esModule", { value: !0 }),
                    (e.$EOF = 0),
                    (e.$BSPACE = 8),
                    (e.$TAB = 9),
                    (e.$LF = 10),
                    (e.$VTAB = 11),
                    (e.$FF = 12),
                    (e.$CR = 13),
                    (e.$SPACE = 32),
                    (e.$BANG = 33),
                    (e.$DQ = 34),
                    (e.$HASH = 35),
                    (e.$$ = 36),
                    (e.$PERCENT = 37),
                    (e.$AMPERSAND = 38),
                    (e.$SQ = 39),
                    (e.$LPAREN = 40),
                    (e.$RPAREN = 41),
                    (e.$STAR = 42),
                    (e.$PLUS = 43),
                    (e.$COMMA = 44),
                    (e.$MINUS = 45),
                    (e.$PERIOD = 46),
                    (e.$SLASH = 47),
                    (e.$COLON = 58),
                    (e.$SEMICOLON = 59),
                    (e.$LT = 60),
                    (e.$EQ = 61),
                    (e.$GT = 62),
                    (e.$QUESTION = 63),
                    (e.$0 = 48),
                    (e.$7 = 55),
                    (e.$9 = 57),
                    (e.$A = 65),
                    (e.$E = 69),
                    (e.$F = 70),
                    (e.$X = 88),
                    (e.$Z = 90),
                    (e.$LBRACKET = 91),
                    (e.$BACKSLASH = 92),
                    (e.$RBRACKET = 93),
                    (e.$CARET = 94),
                    (e.$_ = 95),
                    (e.$a = 97),
                    (e.$b = 98),
                    (e.$e = 101),
                    (e.$f = 102),
                    (e.$n = 110),
                    (e.$r = 114),
                    (e.$t = 116),
                    (e.$u = 117),
                    (e.$v = 118),
                    (e.$x = 120),
                    (e.$z = 122),
                    (e.$LBRACE = 123),
                    (e.$BAR = 124),
                    (e.$RBRACE = 125),
                    (e.$NBSP = 160),
                    (e.$PIPE = 124),
                    (e.$TILDA = 126),
                    (e.$AT = 64),
                    (e.$BT = 96);
                  function n(a) {
                    return (a >= e.$TAB && a <= e.$SPACE) || a == e.$NBSP;
                  }
                  e.isWhitespace = n;
                  function t(a) {
                    return e.$0 <= a && a <= e.$9;
                  }
                  e.isDigit = t;
                  function s(a) {
                    return (a >= e.$a && a <= e.$z) || (a >= e.$A && a <= e.$Z);
                  }
                  e.isAsciiLetter = s;
                  function i(a) {
                    return (
                      (a >= e.$a && a <= e.$f) ||
                      (a >= e.$A && a <= e.$F) ||
                      t(a)
                    );
                  }
                  e.isAsciiHexDigit = i;
                  function r(a) {
                    return a === e.$LF || a === e.$CR;
                  }
                  e.isNewLine = r;
                  function u(a) {
                    return e.$0 <= a && a <= e.$7;
                  }
                  e.isOctalDigit = u;
                },
              }),
              Ld = Z({
                "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(
                  e
                ) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = class {
                    constructor(s, i, r) {
                      (this.filePath = s), (this.name = i), (this.members = r);
                    }
                    assertNoMembers() {
                      if (this.members.length)
                        throw new Error(
                          "Illegal state: symbol without members expected, but got ".concat(
                            JSON.stringify(this),
                            "."
                          )
                        );
                    }
                  };
                  e.StaticSymbol = n;
                  var t = class {
                    constructor() {
                      this.cache = new Map();
                    }
                    get(s, i, r) {
                      r = r || [];
                      let u = r.length ? ".".concat(r.join(".")) : "",
                        a = '"'.concat(s, '".').concat(i).concat(u),
                        c = this.cache.get(a);
                      return (
                        c || ((c = new n(s, i, r)), this.cache.set(a, c)), c
                      );
                    }
                  };
                  e.StaticSymbolCache = t;
                },
              }),
              Od = Z({
                "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = /-+([a-z0-9])/g;
                  function t(o) {
                    return o.replace(n, function () {
                      for (
                        var x = arguments.length, F = new Array(x), S = 0;
                        S < x;
                        S++
                      )
                        F[S] = arguments[S];
                      return F[1].toUpperCase();
                    });
                  }
                  e.dashCaseToCamelCase = t;
                  function s(o, x) {
                    return r(o, ":", x);
                  }
                  e.splitAtColon = s;
                  function i(o, x) {
                    return r(o, ".", x);
                  }
                  e.splitAtPeriod = i;
                  function r(o, x, F) {
                    let S = o.indexOf(x);
                    return S == -1
                      ? F
                      : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
                  }
                  function u(o, x, F) {
                    return Array.isArray(o)
                      ? x.visitArray(o, F)
                      : A(o)
                      ? x.visitStringMap(o, F)
                      : o == null ||
                        typeof o == "string" ||
                        typeof o == "number" ||
                        typeof o == "boolean"
                      ? x.visitPrimitive(o, F)
                      : x.visitOther(o, F);
                  }
                  e.visitValue = u;
                  function a(o) {
                    return o != null;
                  }
                  e.isDefined = a;
                  function c(o) {
                    return o === void 0 ? null : o;
                  }
                  e.noUndefined = c;
                  var l = class {
                    visitArray(o, x) {
                      return o.map((F) => u(F, this, x));
                    }
                    visitStringMap(o, x) {
                      let F = {};
                      return (
                        Object.keys(o).forEach((S) => {
                          F[S] = u(o[S], this, x);
                        }),
                        F
                      );
                    }
                    visitPrimitive(o, x) {
                      return o;
                    }
                    visitOther(o, x) {
                      return o;
                    }
                  };
                  (e.ValueTransformer = l),
                    (e.SyncAsync = {
                      assertSync: (o) => {
                        if (w(o))
                          throw new Error(
                            "Illegal state: value cannot be a promise"
                          );
                        return o;
                      },
                      then: (o, x) => (w(o) ? o.then(x) : x(o)),
                      all: (o) => (o.some(w) ? Promise.all(o) : o),
                    });
                  function C(o) {
                    throw new Error("Internal Error: ".concat(o));
                  }
                  e.error = C;
                  function m(o, x) {
                    let F = Error(o);
                    return (F[g] = !0), x && (F[p] = x), F;
                  }
                  e.syntaxError = m;
                  var g = "ngSyntaxError",
                    p = "ngParseErrors";
                  function f(o) {
                    return o[g];
                  }
                  e.isSyntaxError = f;
                  function h(o) {
                    return o[p] || [];
                  }
                  e.getParseErrors = h;
                  function N(o) {
                    return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
                  }
                  e.escapeRegExp = N;
                  var T = Object.getPrototypeOf({});
                  function A(o) {
                    return (
                      typeof o == "object" &&
                      o !== null &&
                      Object.getPrototypeOf(o) === T
                    );
                  }
                  function b(o) {
                    let x = "";
                    for (let F = 0; F < o.length; F++) {
                      let S = o.charCodeAt(F);
                      if (S >= 55296 && S <= 56319 && o.length > F + 1) {
                        let k = o.charCodeAt(F + 1);
                        k >= 56320 &&
                          k <= 57343 &&
                          (F++, (S = ((S - 55296) << 10) + k - 56320 + 65536));
                      }
                      S <= 127
                        ? (x += String.fromCharCode(S))
                        : S <= 2047
                        ? (x += String.fromCharCode(
                            ((S >> 6) & 31) | 192,
                            (S & 63) | 128
                          ))
                        : S <= 65535
                        ? (x += String.fromCharCode(
                            (S >> 12) | 224,
                            ((S >> 6) & 63) | 128,
                            (S & 63) | 128
                          ))
                        : S <= 2097151 &&
                          (x += String.fromCharCode(
                            ((S >> 18) & 7) | 240,
                            ((S >> 12) & 63) | 128,
                            ((S >> 6) & 63) | 128,
                            (S & 63) | 128
                          ));
                    }
                    return x;
                  }
                  e.utf8Encode = b;
                  function v(o) {
                    if (typeof o == "string") return o;
                    if (o instanceof Array)
                      return "[" + o.map(v).join(", ") + "]";
                    if (o == null) return "" + o;
                    if (o.overriddenName) return "".concat(o.overriddenName);
                    if (o.name) return "".concat(o.name);
                    if (!o.toString) return "object";
                    let x = o.toString();
                    if (x == null) return "" + x;
                    let F = x.indexOf(`
`);
                    return F === -1 ? x : x.substring(0, F);
                  }
                  e.stringify = v;
                  function B(o) {
                    return typeof o == "function" &&
                      o.hasOwnProperty("__forward_ref__")
                      ? o()
                      : o;
                  }
                  e.resolveForwardRef = B;
                  function w(o) {
                    return !!o && typeof o.then == "function";
                  }
                  e.isPromise = w;
                  var I = class {
                    constructor(o) {
                      this.full = o;
                      let x = o.split(".");
                      (this.major = x[0]),
                        (this.minor = x[1]),
                        (this.patch = x.slice(2).join("."));
                    }
                  };
                  e.Version = I;
                  var E = typeof window < "u" && window,
                    D =
                      typeof self < "u" &&
                      typeof WorkerGlobalScope < "u" &&
                      self instanceof WorkerGlobalScope &&
                      self,
                    d = typeof globalThis < "u" && globalThis,
                    y = d || E || D;
                  e.global = y;
                },
              }),
              jd = Z({
                "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(
                  e
                ) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = Ld(),
                    t = Od(),
                    s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
                  function i(F) {
                    return F.replace(/\W/g, "_");
                  }
                  e.sanitizeIdentifier = i;
                  var r = 0;
                  function u(F) {
                    if (!F || !F.reference) return null;
                    let S = F.reference;
                    if (S instanceof n.StaticSymbol) return S.name;
                    if (S.__anonymousType) return S.__anonymousType;
                    let k = t.stringify(S);
                    return (
                      k.indexOf("(") >= 0
                        ? ((k = "anonymous_".concat(r++)),
                          (S.__anonymousType = k))
                        : (k = i(k)),
                      k
                    );
                  }
                  e.identifierName = u;
                  function a(F) {
                    let S = F.reference;
                    return S instanceof n.StaticSymbol
                      ? S.filePath
                      : "./".concat(t.stringify(S));
                  }
                  e.identifierModuleUrl = a;
                  function c(F, S) {
                    return "View_".concat(u({ reference: F }), "_").concat(S);
                  }
                  e.viewClassName = c;
                  function l(F) {
                    return "RenderType_".concat(u({ reference: F }));
                  }
                  e.rendererTypeName = l;
                  function C(F) {
                    return "HostView_".concat(u({ reference: F }));
                  }
                  e.hostViewClassName = C;
                  function m(F) {
                    return "".concat(u({ reference: F }), "NgFactory");
                  }
                  e.componentFactoryName = m;
                  var g;
                  (function (F) {
                    (F[(F.Pipe = 0)] = "Pipe"),
                      (F[(F.Directive = 1)] = "Directive"),
                      (F[(F.NgModule = 2)] = "NgModule"),
                      (F[(F.Injectable = 3)] = "Injectable");
                  })((g = e.CompileSummaryKind || (e.CompileSummaryKind = {})));
                  function p(F) {
                    return F.value != null ? i(F.value) : u(F.identifier);
                  }
                  e.tokenName = p;
                  function f(F) {
                    return F.identifier != null
                      ? F.identifier.reference
                      : F.value;
                  }
                  e.tokenReference = f;
                  var h = class {
                    constructor() {
                      let {
                        moduleUrl: F,
                        styles: S,
                        styleUrls: k,
                      } = arguments.length > 0 && arguments[0] !== void 0
                        ? arguments[0]
                        : {};
                      (this.moduleUrl = F || null),
                        (this.styles = w(S)),
                        (this.styleUrls = w(k));
                    }
                  };
                  e.CompileStylesheetMetadata = h;
                  var N = class {
                    constructor(F) {
                      let {
                        encapsulation: S,
                        template: k,
                        templateUrl: _,
                        htmlAst: O,
                        styles: R,
                        styleUrls: M,
                        externalStylesheets: H,
                        animations: P,
                        ngContentSelectors: G,
                        interpolation: re,
                        isInline: $,
                        preserveWhitespaces: W,
                      } = F;
                      if (
                        ((this.encapsulation = S),
                        (this.template = k),
                        (this.templateUrl = _),
                        (this.htmlAst = O),
                        (this.styles = w(R)),
                        (this.styleUrls = w(M)),
                        (this.externalStylesheets = w(H)),
                        (this.animations = P ? E(P) : []),
                        (this.ngContentSelectors = G || []),
                        re && re.length != 2)
                      )
                        throw new Error(
                          "'interpolation' should have a start and an end symbol."
                        );
                      (this.interpolation = re),
                        (this.isInline = $),
                        (this.preserveWhitespaces = W);
                    }
                    toSummary() {
                      return {
                        ngContentSelectors: this.ngContentSelectors,
                        encapsulation: this.encapsulation,
                        styles: this.styles,
                        animations: this.animations,
                      };
                    }
                  };
                  e.CompileTemplateMetadata = N;
                  var T = class {
                    static create(F) {
                      let {
                          isHost: S,
                          type: k,
                          isComponent: _,
                          selector: O,
                          exportAs: R,
                          changeDetection: M,
                          inputs: H,
                          outputs: P,
                          host: G,
                          providers: re,
                          viewProviders: $,
                          queries: W,
                          guards: ee,
                          viewQueries: U,
                          entryComponents: ne,
                          template: se,
                          componentViewType: V,
                          rendererType: oe,
                          componentFactory: K,
                        } = F,
                        Ee = {},
                        q = {},
                        le = {};
                      G != null &&
                        Object.keys(G).forEach((de) => {
                          let ge = G[de],
                            ve = de.match(s);
                          ve === null
                            ? (le[de] = ge)
                            : ve[1] != null
                            ? (q[ve[1]] = ge)
                            : ve[2] != null && (Ee[ve[2]] = ge);
                        });
                      let ue = {};
                      H != null &&
                        H.forEach((de) => {
                          let ge = t.splitAtColon(de, [de, de]);
                          ue[ge[0]] = ge[1];
                        });
                      let Q = {};
                      return (
                        P != null &&
                          P.forEach((de) => {
                            let ge = t.splitAtColon(de, [de, de]);
                            Q[ge[0]] = ge[1];
                          }),
                        new T({
                          isHost: S,
                          type: k,
                          isComponent: !!_,
                          selector: O,
                          exportAs: R,
                          changeDetection: M,
                          inputs: ue,
                          outputs: Q,
                          hostListeners: Ee,
                          hostProperties: q,
                          hostAttributes: le,
                          providers: re,
                          viewProviders: $,
                          queries: W,
                          guards: ee,
                          viewQueries: U,
                          entryComponents: ne,
                          template: se,
                          componentViewType: V,
                          rendererType: oe,
                          componentFactory: K,
                        })
                      );
                    }
                    constructor(F) {
                      let {
                        isHost: S,
                        type: k,
                        isComponent: _,
                        selector: O,
                        exportAs: R,
                        changeDetection: M,
                        inputs: H,
                        outputs: P,
                        hostListeners: G,
                        hostProperties: re,
                        hostAttributes: $,
                        providers: W,
                        viewProviders: ee,
                        queries: U,
                        guards: ne,
                        viewQueries: se,
                        entryComponents: V,
                        template: oe,
                        componentViewType: K,
                        rendererType: Ee,
                        componentFactory: q,
                      } = F;
                      (this.isHost = !!S),
                        (this.type = k),
                        (this.isComponent = _),
                        (this.selector = O),
                        (this.exportAs = R),
                        (this.changeDetection = M),
                        (this.inputs = H),
                        (this.outputs = P),
                        (this.hostListeners = G),
                        (this.hostProperties = re),
                        (this.hostAttributes = $),
                        (this.providers = w(W)),
                        (this.viewProviders = w(ee)),
                        (this.queries = w(U)),
                        (this.guards = ne),
                        (this.viewQueries = w(se)),
                        (this.entryComponents = w(V)),
                        (this.template = oe),
                        (this.componentViewType = K),
                        (this.rendererType = Ee),
                        (this.componentFactory = q);
                    }
                    toSummary() {
                      return {
                        summaryKind: g.Directive,
                        type: this.type,
                        isComponent: this.isComponent,
                        selector: this.selector,
                        exportAs: this.exportAs,
                        inputs: this.inputs,
                        outputs: this.outputs,
                        hostListeners: this.hostListeners,
                        hostProperties: this.hostProperties,
                        hostAttributes: this.hostAttributes,
                        providers: this.providers,
                        viewProviders: this.viewProviders,
                        queries: this.queries,
                        guards: this.guards,
                        viewQueries: this.viewQueries,
                        entryComponents: this.entryComponents,
                        changeDetection: this.changeDetection,
                        template: this.template && this.template.toSummary(),
                        componentViewType: this.componentViewType,
                        rendererType: this.rendererType,
                        componentFactory: this.componentFactory,
                      };
                    }
                  };
                  e.CompileDirectiveMetadata = T;
                  var A = class {
                    constructor(F) {
                      let { type: S, name: k, pure: _ } = F;
                      (this.type = S), (this.name = k), (this.pure = !!_);
                    }
                    toSummary() {
                      return {
                        summaryKind: g.Pipe,
                        type: this.type,
                        name: this.name,
                        pure: this.pure,
                      };
                    }
                  };
                  e.CompilePipeMetadata = A;
                  var b = class {};
                  e.CompileShallowModuleMetadata = b;
                  var v = class {
                    constructor(F) {
                      let {
                        type: S,
                        providers: k,
                        declaredDirectives: _,
                        exportedDirectives: O,
                        declaredPipes: R,
                        exportedPipes: M,
                        entryComponents: H,
                        bootstrapComponents: P,
                        importedModules: G,
                        exportedModules: re,
                        schemas: $,
                        transitiveModule: W,
                        id: ee,
                      } = F;
                      (this.type = S || null),
                        (this.declaredDirectives = w(_)),
                        (this.exportedDirectives = w(O)),
                        (this.declaredPipes = w(R)),
                        (this.exportedPipes = w(M)),
                        (this.providers = w(k)),
                        (this.entryComponents = w(H)),
                        (this.bootstrapComponents = w(P)),
                        (this.importedModules = w(G)),
                        (this.exportedModules = w(re)),
                        (this.schemas = w($)),
                        (this.id = ee || null),
                        (this.transitiveModule = W || null);
                    }
                    toSummary() {
                      let F = this.transitiveModule;
                      return {
                        summaryKind: g.NgModule,
                        type: this.type,
                        entryComponents: F.entryComponents,
                        providers: F.providers,
                        modules: F.modules,
                        exportedDirectives: F.exportedDirectives,
                        exportedPipes: F.exportedPipes,
                      };
                    }
                  };
                  e.CompileNgModuleMetadata = v;
                  var B = class {
                    constructor() {
                      (this.directivesSet = new Set()),
                        (this.directives = []),
                        (this.exportedDirectivesSet = new Set()),
                        (this.exportedDirectives = []),
                        (this.pipesSet = new Set()),
                        (this.pipes = []),
                        (this.exportedPipesSet = new Set()),
                        (this.exportedPipes = []),
                        (this.modulesSet = new Set()),
                        (this.modules = []),
                        (this.entryComponentsSet = new Set()),
                        (this.entryComponents = []),
                        (this.providers = []);
                    }
                    addProvider(F, S) {
                      this.providers.push({ provider: F, module: S });
                    }
                    addDirective(F) {
                      this.directivesSet.has(F.reference) ||
                        (this.directivesSet.add(F.reference),
                        this.directives.push(F));
                    }
                    addExportedDirective(F) {
                      this.exportedDirectivesSet.has(F.reference) ||
                        (this.exportedDirectivesSet.add(F.reference),
                        this.exportedDirectives.push(F));
                    }
                    addPipe(F) {
                      this.pipesSet.has(F.reference) ||
                        (this.pipesSet.add(F.reference), this.pipes.push(F));
                    }
                    addExportedPipe(F) {
                      this.exportedPipesSet.has(F.reference) ||
                        (this.exportedPipesSet.add(F.reference),
                        this.exportedPipes.push(F));
                    }
                    addModule(F) {
                      this.modulesSet.has(F.reference) ||
                        (this.modulesSet.add(F.reference),
                        this.modules.push(F));
                    }
                    addEntryComponent(F) {
                      this.entryComponentsSet.has(F.componentType) ||
                        (this.entryComponentsSet.add(F.componentType),
                        this.entryComponents.push(F));
                    }
                  };
                  e.TransitiveCompileNgModuleMetadata = B;
                  function w(F) {
                    return F || [];
                  }
                  var I = class {
                    constructor(F, S) {
                      let {
                        useClass: k,
                        useValue: _,
                        useExisting: O,
                        useFactory: R,
                        deps: M,
                        multi: H,
                      } = S;
                      (this.token = F),
                        (this.useClass = k || null),
                        (this.useValue = _),
                        (this.useExisting = O),
                        (this.useFactory = R || null),
                        (this.dependencies = M || null),
                        (this.multi = !!H);
                    }
                  };
                  e.ProviderMeta = I;
                  function E(F) {
                    return F.reduce((S, k) => {
                      let _ = Array.isArray(k) ? E(k) : k;
                      return S.concat(_);
                    }, []);
                  }
                  e.flatten = E;
                  function D(F) {
                    return F.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
                  }
                  function d(F, S, k) {
                    let _;
                    return (
                      k.isInline
                        ? S.type.reference instanceof n.StaticSymbol
                          ? (_ = ""
                              .concat(S.type.reference.filePath, ".")
                              .concat(S.type.reference.name, ".html"))
                          : (_ = ""
                              .concat(u(F), "/")
                              .concat(u(S.type), ".html"))
                        : (_ = k.templateUrl),
                      S.type.reference instanceof n.StaticSymbol ? _ : D(_)
                    );
                  }
                  e.templateSourceUrl = d;
                  function y(F, S) {
                    let k = F.moduleUrl.split(/\/\\/g),
                      _ = k[k.length - 1];
                    return D("css/".concat(S).concat(_, ".ngstyle.js"));
                  }
                  e.sharedStylesheetJitUrl = y;
                  function o(F) {
                    return D("".concat(u(F.type), "/module.ngfactory.js"));
                  }
                  e.ngModuleJitUrl = o;
                  function x(F, S) {
                    return D(
                      "".concat(u(F), "/").concat(u(S.type), ".ngfactory.js")
                    );
                  }
                  e.templateJitUrl = x;
                },
              }),
              qd = Z({
                "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(
                  e
                ) {
                  "use strict";
                  ae(), Object.defineProperty(e, "__esModule", { value: !0 });
                  var n = kd(),
                    t = jd(),
                    s = class {
                      constructor(C, m, g, p) {
                        (this.file = C),
                          (this.offset = m),
                          (this.line = g),
                          (this.col = p);
                      }
                      toString() {
                        return this.offset != null
                          ? ""
                              .concat(this.file.url, "@")
                              .concat(this.line, ":")
                              .concat(this.col)
                          : this.file.url;
                      }
                      moveBy(C) {
                        let m = this.file.content,
                          g = m.length,
                          p = this.offset,
                          f = this.line,
                          h = this.col;
                        for (; p > 0 && C < 0; )
                          if ((p--, C++, m.charCodeAt(p) == n.$LF)) {
                            f--;
                            let T = m
                              .substr(0, p - 1)
                              .lastIndexOf(String.fromCharCode(n.$LF));
                            h = T > 0 ? p - T : p;
                          } else h--;
                        for (; p < g && C > 0; ) {
                          let N = m.charCodeAt(p);
                          p++, C--, N == n.$LF ? (f++, (h = 0)) : h++;
                        }
                        return new s(this.file, p, f, h);
                      }
                      getContext(C, m) {
                        let g = this.file.content,
                          p = this.offset;
                        if (p != null) {
                          p > g.length - 1 && (p = g.length - 1);
                          let f = p,
                            h = 0,
                            N = 0;
                          for (
                            ;
                            h < C &&
                            p > 0 &&
                            (p--,
                            h++,
                            !(
                              g[p] ==
                                `
` && ++N == m
                            ));

                          );
                          for (
                            h = 0, N = 0;
                            h < C &&
                            f < g.length - 1 &&
                            (f++,
                            h++,
                            !(
                              g[f] ==
                                `
` && ++N == m
                            ));

                          );
                          return {
                            before: g.substring(p, this.offset),
                            after: g.substring(this.offset, f + 1),
                          };
                        }
                        return null;
                      }
                    };
                  e.ParseLocation = s;
                  var i = class {
                    constructor(C, m) {
                      (this.content = C), (this.url = m);
                    }
                  };
                  e.ParseSourceFile = i;
                  var r = class {
                    constructor(C, m) {
                      let g =
                        arguments.length > 2 && arguments[2] !== void 0
                          ? arguments[2]
                          : null;
                      (this.start = C), (this.end = m), (this.details = g);
                    }
                    toString() {
                      return this.start.file.content.substring(
                        this.start.offset,
                        this.end.offset
                      );
                    }
                  };
                  (e.ParseSourceSpan = r),
                    (e.EMPTY_PARSE_LOCATION = new s(new i("", ""), 0, 0, 0)),
                    (e.EMPTY_SOURCE_SPAN = new r(
                      e.EMPTY_PARSE_LOCATION,
                      e.EMPTY_PARSE_LOCATION
                    ));
                  var u;
                  (function (C) {
                    (C[(C.WARNING = 0)] = "WARNING"),
                      (C[(C.ERROR = 1)] = "ERROR");
                  })((u = e.ParseErrorLevel || (e.ParseErrorLevel = {})));
                  var a = class {
                    constructor(C, m) {
                      let g =
                        arguments.length > 2 && arguments[2] !== void 0
                          ? arguments[2]
                          : u.ERROR;
                      (this.span = C), (this.msg = m), (this.level = g);
                    }
                    contextualMessage() {
                      let C = this.span.start.getContext(100, 3);
                      return C
                        ? ""
                            .concat(this.msg, ' ("')
                            .concat(C.before, "[")
                            .concat(u[this.level], " ->]")
                            .concat(C.after, '")')
                        : this.msg;
                    }
                    toString() {
                      let C = this.span.details
                        ? ", ".concat(this.span.details)
                        : "";
                      return ""
                        .concat(this.contextualMessage(), ": ")
                        .concat(this.span.start)
                        .concat(C);
                    }
                  };
                  e.ParseError = a;
                  function c(C, m) {
                    let g = t.identifierModuleUrl(m),
                      p =
                        g != null
                          ? "in "
                              .concat(C, " ")
                              .concat(t.identifierName(m), " in ")
                              .concat(g)
                          : "in ".concat(C, " ").concat(t.identifierName(m)),
                      f = new i("", p);
                    return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
                  }
                  e.typeSourceSpan = c;
                  function l(C, m, g) {
                    let p = "in ".concat(C, " ").concat(m, " in ").concat(g),
                      f = new i("", p);
                    return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
                  }
                  e.r3JitTypeSourceSpan = l;
                },
              }),
              Md = Z({
                "src/language-html/print-preprocess.js"(e, n) {
                  "use strict";
                  ae();
                  var { ParseSourceSpan: t } = qd(),
                    {
                      htmlTrim: s,
                      getLeadingAndTrailingHtmlWhitespace: i,
                      hasHtmlWhitespace: r,
                      canHaveInterpolation: u,
                      getNodeCssStyleDisplay: a,
                      isDanglingSpaceSensitiveNode: c,
                      isIndentationSensitiveNode: l,
                      isLeadingSpaceSensitiveNode: C,
                      isTrailingSpaceSensitiveNode: m,
                      isWhitespaceSensitiveNode: g,
                    } = Ot(),
                    p = [h, N, A, v, B, E, w, I, D, b];
                  function f(d, y) {
                    for (let o of p) o(d, y);
                    return d;
                  }
                  function h(d) {
                    d.walk((y) => {
                      if (
                        y.type === "element" &&
                        y.tagDefinition.ignoreFirstLf &&
                        y.children.length > 0 &&
                        y.children[0].type === "text" &&
                        y.children[0].value[0] ===
                          `
`
                      ) {
                        let o = y.children[0];
                        o.value.length === 1
                          ? y.removeChild(o)
                          : (o.value = o.value.slice(1));
                      }
                    });
                  }
                  function N(d) {
                    let y = (o) =>
                      o.type === "element" &&
                      o.prev &&
                      o.prev.type === "ieConditionalStartComment" &&
                      o.prev.sourceSpan.end.offset ===
                        o.startSourceSpan.start.offset &&
                      o.firstChild &&
                      o.firstChild.type === "ieConditionalEndComment" &&
                      o.firstChild.sourceSpan.start.offset ===
                        o.startSourceSpan.end.offset;
                    d.walk((o) => {
                      if (o.children)
                        for (let x = 0; x < o.children.length; x++) {
                          let F = o.children[x];
                          if (!y(F)) continue;
                          let S = F.prev,
                            k = F.firstChild;
                          o.removeChild(S), x--;
                          let _ = new t(S.sourceSpan.start, k.sourceSpan.end),
                            O = new t(_.start, F.sourceSpan.end);
                          (F.condition = S.condition),
                            (F.sourceSpan = O),
                            (F.startSourceSpan = _),
                            F.removeChild(k);
                        }
                    });
                  }
                  function T(d, y, o) {
                    d.walk((x) => {
                      if (x.children)
                        for (let F = 0; F < x.children.length; F++) {
                          let S = x.children[F];
                          if (S.type !== "text" && !y(S)) continue;
                          S.type !== "text" &&
                            ((S.type = "text"), (S.value = o(S)));
                          let k = S.prev;
                          !k ||
                            k.type !== "text" ||
                            ((k.value += S.value),
                            (k.sourceSpan = new t(
                              k.sourceSpan.start,
                              S.sourceSpan.end
                            )),
                            x.removeChild(S),
                            F--);
                        }
                    });
                  }
                  function A(d) {
                    return T(
                      d,
                      (y) => y.type === "cdata",
                      (y) => "<![CDATA[".concat(y.value, "]]>")
                    );
                  }
                  function b(d) {
                    let y = (o) =>
                      o.type === "element" &&
                      o.attrs.length === 0 &&
                      o.children.length === 1 &&
                      o.firstChild.type === "text" &&
                      !r(o.children[0].value) &&
                      !o.firstChild.hasLeadingSpaces &&
                      !o.firstChild.hasTrailingSpaces &&
                      o.isLeadingSpaceSensitive &&
                      !o.hasLeadingSpaces &&
                      o.isTrailingSpaceSensitive &&
                      !o.hasTrailingSpaces &&
                      o.prev &&
                      o.prev.type === "text" &&
                      o.next &&
                      o.next.type === "text";
                    d.walk((o) => {
                      if (o.children)
                        for (let x = 0; x < o.children.length; x++) {
                          let F = o.children[x];
                          if (!y(F)) continue;
                          let S = F.prev,
                            k = F.next;
                          (S.value +=
                            "<".concat(F.rawName, ">") +
                            F.firstChild.value +
                            "</".concat(F.rawName, ">") +
                            k.value),
                            (S.sourceSpan = new t(
                              S.sourceSpan.start,
                              k.sourceSpan.end
                            )),
                            (S.isTrailingSpaceSensitive =
                              k.isTrailingSpaceSensitive),
                            (S.hasTrailingSpaces = k.hasTrailingSpaces),
                            o.removeChild(F),
                            x--,
                            o.removeChild(k);
                        }
                    });
                  }
                  function v(d, y) {
                    if (y.parser === "html") return;
                    let o = /{{(.+?)}}/s;
                    d.walk((x) => {
                      if (!!u(x))
                        for (let F of x.children) {
                          if (F.type !== "text") continue;
                          let S = F.sourceSpan.start,
                            k = null,
                            _ = F.value.split(o);
                          for (let O = 0; O < _.length; O++, S = k) {
                            let R = _[O];
                            if (O % 2 === 0) {
                              (k = S.moveBy(R.length)),
                                R.length > 0 &&
                                  x.insertChildBefore(F, {
                                    type: "text",
                                    value: R,
                                    sourceSpan: new t(S, k),
                                  });
                              continue;
                            }
                            (k = S.moveBy(R.length + 4)),
                              x.insertChildBefore(F, {
                                type: "interpolation",
                                sourceSpan: new t(S, k),
                                children:
                                  R.length === 0
                                    ? []
                                    : [
                                        {
                                          type: "text",
                                          value: R,
                                          sourceSpan: new t(
                                            S.moveBy(2),
                                            k.moveBy(-2)
                                          ),
                                        },
                                      ],
                              });
                          }
                          x.removeChild(F);
                        }
                    });
                  }
                  function B(d) {
                    d.walk((y) => {
                      if (!y.children) return;
                      if (
                        y.children.length === 0 ||
                        (y.children.length === 1 &&
                          y.children[0].type === "text" &&
                          s(y.children[0].value).length === 0)
                      ) {
                        (y.hasDanglingSpaces = y.children.length > 0),
                          (y.children = []);
                        return;
                      }
                      let o = g(y),
                        x = l(y);
                      if (!o)
                        for (let F = 0; F < y.children.length; F++) {
                          let S = y.children[F];
                          if (S.type !== "text") continue;
                          let {
                              leadingWhitespace: k,
                              text: _,
                              trailingWhitespace: O,
                            } = i(S.value),
                            R = S.prev,
                            M = S.next;
                          _
                            ? ((S.value = _),
                              (S.sourceSpan = new t(
                                S.sourceSpan.start.moveBy(k.length),
                                S.sourceSpan.end.moveBy(-O.length)
                              )),
                              k &&
                                (R && (R.hasTrailingSpaces = !0),
                                (S.hasLeadingSpaces = !0)),
                              O &&
                                ((S.hasTrailingSpaces = !0),
                                M && (M.hasLeadingSpaces = !0)))
                            : (y.removeChild(S),
                              F--,
                              (k || O) &&
                                (R && (R.hasTrailingSpaces = !0),
                                M && (M.hasLeadingSpaces = !0)));
                        }
                      (y.isWhitespaceSensitive = o),
                        (y.isIndentationSensitive = x);
                    });
                  }
                  function w(d) {
                    d.walk((y) => {
                      y.isSelfClosing =
                        !y.children ||
                        (y.type === "element" &&
                          (y.tagDefinition.isVoid ||
                            y.startSourceSpan === y.endSourceSpan));
                    });
                  }
                  function I(d, y) {
                    d.walk((o) => {
                      o.type === "element" &&
                        (o.hasHtmComponentClosingTag =
                          o.endSourceSpan &&
                          /^<\s*\/\s*\/\s*>$/.test(
                            y.originalText.slice(
                              o.endSourceSpan.start.offset,
                              o.endSourceSpan.end.offset
                            )
                          ));
                    });
                  }
                  function E(d, y) {
                    d.walk((o) => {
                      o.cssDisplay = a(o, y);
                    });
                  }
                  function D(d, y) {
                    d.walk((o) => {
                      let { children: x } = o;
                      if (!!x) {
                        if (x.length === 0) {
                          o.isDanglingSpaceSensitive = c(o);
                          return;
                        }
                        for (let F of x)
                          (F.isLeadingSpaceSensitive = C(F, y)),
                            (F.isTrailingSpaceSensitive = m(F, y));
                        for (let F = 0; F < x.length; F++) {
                          let S = x[F];
                          (S.isLeadingSpaceSensitive =
                            (F === 0 || S.prev.isTrailingSpaceSensitive) &&
                            S.isLeadingSpaceSensitive),
                            (S.isTrailingSpaceSensitive =
                              (F === x.length - 1 ||
                                S.next.isLeadingSpaceSensitive) &&
                              S.isTrailingSpaceSensitive);
                        }
                      }
                    });
                  }
                  n.exports = f;
                },
              }),
              Rd = Z({
                "src/language-html/pragma.js"(e, n) {
                  "use strict";
                  ae();
                  function t(i) {
                    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(i);
                  }
                  function s(i) {
                    return (
                      `<!-- @format -->

` + i.replace(/^\s*\n/, "")
                    );
                  }
                  n.exports = { hasPragma: t, insertPragma: s };
                },
              }),
              Yn = Z({
                "src/language-html/loc.js"(e, n) {
                  "use strict";
                  ae();
                  function t(i) {
                    return i.sourceSpan.start.offset;
                  }
                  function s(i) {
                    return i.sourceSpan.end.offset;
                  }
                  n.exports = { locStart: t, locEnd: s };
                },
              }),
              Qt = Z({
                "src/language-html/print/tag.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Ut(),
                    { isNonEmptyArray: s } = Ge(),
                    {
                      builders: {
                        indent: i,
                        join: r,
                        line: u,
                        softline: a,
                        hardline: c,
                      },
                      utils: { replaceTextEndOfLine: l },
                    } = Le(),
                    { locStart: C, locEnd: m } = Yn(),
                    {
                      isTextLikeNode: g,
                      getLastDescendant: p,
                      isPreLikeNode: f,
                      hasPrettierIgnore: h,
                      shouldPreserveContent: N,
                    } = Ot();
                  function T(P, G) {
                    return [P.isSelfClosing ? "" : A(P, G), b(P, G)];
                  }
                  function A(P, G) {
                    return P.lastChild && y(P.lastChild)
                      ? ""
                      : [v(P, G), w(P, G)];
                  }
                  function b(P, G) {
                    return (P.next ? D(P.next) : d(P.parent))
                      ? ""
                      : [I(P, G), B(P, G)];
                  }
                  function v(P, G) {
                    return d(P) ? I(P.lastChild, G) : "";
                  }
                  function B(P, G) {
                    return y(P) ? w(P.parent, G) : o(P) ? M(P.next) : "";
                  }
                  function w(P, G) {
                    if ((t(!P.isSelfClosing), E(P, G))) return "";
                    switch (P.type) {
                      case "ieConditionalComment":
                        return "<!";
                      case "element":
                        if (P.hasHtmComponentClosingTag) return "<//";
                      default:
                        return "</".concat(P.rawName);
                    }
                  }
                  function I(P, G) {
                    if (E(P, G)) return "";
                    switch (P.type) {
                      case "ieConditionalComment":
                      case "ieConditionalEndComment":
                        return "[endif]-->";
                      case "ieConditionalStartComment":
                        return "]><!-->";
                      case "interpolation":
                        return "}}";
                      case "element":
                        if (P.isSelfClosing) return "/>";
                      default:
                        return ">";
                    }
                  }
                  function E(P, G) {
                    return (
                      !P.isSelfClosing &&
                      !P.endSourceSpan &&
                      (h(P) || N(P.parent, G))
                    );
                  }
                  function D(P) {
                    return (
                      P.prev &&
                      P.prev.type !== "docType" &&
                      !g(P.prev) &&
                      P.isLeadingSpaceSensitive &&
                      !P.hasLeadingSpaces
                    );
                  }
                  function d(P) {
                    return (
                      P.lastChild &&
                      P.lastChild.isTrailingSpaceSensitive &&
                      !P.lastChild.hasTrailingSpaces &&
                      !g(p(P.lastChild)) &&
                      !f(P)
                    );
                  }
                  function y(P) {
                    return (
                      !P.next &&
                      !P.hasTrailingSpaces &&
                      P.isTrailingSpaceSensitive &&
                      g(p(P))
                    );
                  }
                  function o(P) {
                    return (
                      P.next &&
                      !g(P.next) &&
                      g(P) &&
                      P.isTrailingSpaceSensitive &&
                      !P.hasTrailingSpaces
                    );
                  }
                  function x(P) {
                    let G = P.trim().match(
                      /^prettier-ignore-attribute(?:\s+(.+))?$/s
                    );
                    return G ? (G[1] ? G[1].split(/\s+/) : !0) : !1;
                  }
                  function F(P) {
                    return (
                      !P.prev &&
                      P.isLeadingSpaceSensitive &&
                      !P.hasLeadingSpaces
                    );
                  }
                  function S(P, G, re) {
                    let $ = P.getValue();
                    if (!s($.attrs)) return $.isSelfClosing ? " " : "";
                    let W =
                        $.prev && $.prev.type === "comment" && x($.prev.value),
                      ee =
                        typeof W == "boolean"
                          ? () => W
                          : Array.isArray(W)
                          ? (oe) => W.includes(oe.rawName)
                          : () => !1,
                      U = P.map((oe) => {
                        let K = oe.getValue();
                        return ee(K)
                          ? l(G.originalText.slice(C(K), m(K)))
                          : re();
                      }, "attrs"),
                      ne =
                        $.type === "element" &&
                        $.fullName === "script" &&
                        $.attrs.length === 1 &&
                        $.attrs[0].fullName === "src" &&
                        $.children.length === 0,
                      se =
                        G.singleAttributePerLine && $.attrs.length > 1 ? c : u,
                      V = [i([ne ? " " : u, r(se, U)])];
                    return (
                      ($.firstChild && F($.firstChild)) ||
                      ($.isSelfClosing && d($.parent)) ||
                      ne
                        ? V.push($.isSelfClosing ? " " : "")
                        : V.push(
                            G.bracketSameLine
                              ? $.isSelfClosing
                                ? " "
                                : ""
                              : $.isSelfClosing
                              ? u
                              : a
                          ),
                      V
                    );
                  }
                  function k(P) {
                    return P.firstChild && F(P.firstChild) ? "" : H(P);
                  }
                  function _(P, G, re) {
                    let $ = P.getValue();
                    return [O($, G), S(P, G, re), $.isSelfClosing ? "" : k($)];
                  }
                  function O(P, G) {
                    return P.prev && o(P.prev) ? "" : [R(P, G), M(P)];
                  }
                  function R(P, G) {
                    return F(P) ? H(P.parent) : D(P) ? I(P.prev, G) : "";
                  }
                  function M(P) {
                    switch (P.type) {
                      case "ieConditionalComment":
                      case "ieConditionalStartComment":
                        return "<!--[if ".concat(P.condition);
                      case "ieConditionalEndComment":
                        return "<!--<!";
                      case "interpolation":
                        return "{{";
                      case "docType":
                        return "<!DOCTYPE";
                      case "element":
                        if (P.condition)
                          return "<!--[if "
                            .concat(P.condition, "]><!--><")
                            .concat(P.rawName);
                      default:
                        return "<".concat(P.rawName);
                    }
                  }
                  function H(P) {
                    switch ((t(!P.isSelfClosing), P.type)) {
                      case "ieConditionalComment":
                        return "]>";
                      case "element":
                        if (P.condition) return "><!--<![endif]-->";
                      default:
                        return ">";
                    }
                  }
                  n.exports = {
                    printClosingTag: T,
                    printClosingTagStart: A,
                    printClosingTagStartMarker: w,
                    printClosingTagEndMarker: I,
                    printClosingTagSuffix: B,
                    printClosingTagEnd: b,
                    needsToBorrowLastChildClosingTagEndMarker: d,
                    needsToBorrowParentClosingTagStartMarker: y,
                    needsToBorrowPrevClosingTagEndMarker: D,
                    printOpeningTag: _,
                    printOpeningTagStart: O,
                    printOpeningTagPrefix: R,
                    printOpeningTagStartMarker: M,
                    printOpeningTagEndMarker: H,
                    needsToBorrowNextOpeningTagStartMarker: o,
                    needsToBorrowParentOpeningTagEndMarker: F,
                  };
                },
              }),
              Vd = Z({
                "node_modules/parse-srcset/src/parse-srcset.js"(e, n) {
                  ae(),
                    (function (t, s) {
                      true
                        ? !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
                          (__WEBPACK_AMD_DEFINE_FACTORY__ = s),
                          (__WEBPACK_AMD_DEFINE_RESULT__ =
                            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                                  exports,
                                  __WEBPACK_AMD_DEFINE_ARRAY__
                                )
                              : __WEBPACK_AMD_DEFINE_FACTORY__),
                          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
                        : 0;
                    })(e, function () {
                      return function (t, s) {
                        var i = (s && s.logger) || console;
                        function r(I) {
                          return (
                            I === " " ||
                            I === "	" ||
                            I ===
                              `
` ||
                            I === "\f" ||
                            I === "\r"
                          );
                        }
                        function u(I) {
                          var E,
                            D = I.exec(t.substring(b));
                          if (D) return (E = D[0]), (b += E.length), E;
                        }
                        for (
                          var a = t.length,
                            c = /^[ \t\n\r\u000c]+/,
                            l = /^[, \t\n\r\u000c]+/,
                            C = /^[^ \t\n\r\u000c]+/,
                            m = /[,]+$/,
                            g = /^\d+$/,
                            p =
                              /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,
                            f,
                            h,
                            N,
                            T,
                            A,
                            b = 0,
                            v = [];
                          ;

                        ) {
                          if ((u(l), b >= a)) return v;
                          (f = u(C)),
                            (h = []),
                            f.slice(-1) === ","
                              ? ((f = f.replace(m, "")), w())
                              : B();
                        }
                        function B() {
                          for (u(c), N = "", T = "in descriptor"; ; ) {
                            if (((A = t.charAt(b)), T === "in descriptor"))
                              if (r(A))
                                N &&
                                  (h.push(N),
                                  (N = ""),
                                  (T = "after descriptor"));
                              else if (A === ",") {
                                (b += 1), N && h.push(N), w();
                                return;
                              } else if (A === "(")
                                (N = N + A), (T = "in parens");
                              else if (A === "") {
                                N && h.push(N), w();
                                return;
                              } else N = N + A;
                            else if (T === "in parens")
                              if (A === ")") (N = N + A), (T = "in descriptor");
                              else if (A === "") {
                                h.push(N), w();
                                return;
                              } else N = N + A;
                            else if (T === "after descriptor" && !r(A))
                              if (A === "") {
                                w();
                                return;
                              } else (T = "in descriptor"), (b -= 1);
                            b += 1;
                          }
                        }
                        function w() {
                          var I = !1,
                            E,
                            D,
                            d,
                            y,
                            o = {},
                            x,
                            F,
                            S,
                            k,
                            _;
                          for (y = 0; y < h.length; y++)
                            (x = h[y]),
                              (F = x[x.length - 1]),
                              (S = x.substring(0, x.length - 1)),
                              (k = parseInt(S, 10)),
                              (_ = parseFloat(S)),
                              g.test(S) && F === "w"
                                ? ((E || D) && (I = !0),
                                  k === 0 ? (I = !0) : (E = k))
                                : p.test(S) && F === "x"
                                ? ((E || D || d) && (I = !0),
                                  _ < 0 ? (I = !0) : (D = _))
                                : g.test(S) && F === "h"
                                ? ((d || D) && (I = !0),
                                  k === 0 ? (I = !0) : (d = k))
                                : (I = !0);
                          I
                            ? i &&
                              i.error &&
                              i.error(
                                "Invalid srcset descriptor found in '" +
                                  t +
                                  "' at '" +
                                  x +
                                  "'."
                              )
                            : ((o.url = f),
                              E && (o.w = E),
                              D && (o.d = D),
                              d && (o.h = d),
                              v.push(o));
                        }
                      };
                    });
                },
              }),
              Wd = Z({
                "src/language-html/syntax-attribute.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Vd(),
                    {
                      builders: { ifBreak: s, join: i, line: r },
                    } = Le();
                  function u(c) {
                    let l = t(c, {
                        logger: {
                          error(B) {
                            throw new Error(B);
                          },
                        },
                      }),
                      C = l.some((B) => {
                        let { w } = B;
                        return w;
                      }),
                      m = l.some((B) => {
                        let { h: w } = B;
                        return w;
                      }),
                      g = l.some((B) => {
                        let { d: w } = B;
                        return w;
                      });
                    if (C + m + g > 1)
                      throw new Error(
                        "Mixed descriptor in srcset is not supported"
                      );
                    let p = C ? "w" : m ? "h" : "d",
                      f = C ? "w" : m ? "h" : "x",
                      h = (B) => Math.max(...B),
                      N = l.map((B) => B.url),
                      T = h(N.map((B) => B.length)),
                      A = l
                        .map((B) => B[p])
                        .map((B) => (B ? B.toString() : "")),
                      b = A.map((B) => {
                        let w = B.indexOf(".");
                        return w === -1 ? B.length : w;
                      }),
                      v = h(b);
                    return i(
                      [",", r],
                      N.map((B, w) => {
                        let I = [B],
                          E = A[w];
                        if (E) {
                          let D = T - B.length + 1,
                            d = v - b[w],
                            y = " ".repeat(D + d);
                          I.push(s(y, " "), E + f);
                        }
                        return I;
                      })
                    );
                  }
                  function a(c) {
                    return c.trim().split(/\s+/).join(" ");
                  }
                  n.exports = { printImgSrcset: u, printClassNames: a };
                },
              }),
              $d = Z({
                "src/language-html/syntax-vue.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                    builders: { group: t },
                  } = Le();
                  function s(a, c) {
                    let { left: l, operator: C, right: m } = i(a);
                    return [
                      t(
                        c("function _(".concat(l, ") {}"), {
                          parser: "babel",
                          __isVueForBindingLeft: !0,
                        })
                      ),
                      " ",
                      C,
                      " ",
                      c(
                        m,
                        { parser: "__js_expression" },
                        { stripTrailingHardline: !0 }
                      ),
                    ];
                  }
                  function i(a) {
                    let c = /(.*?)\s+(in|of)\s+(.*)/s,
                      l = /,([^,\]}]*)(?:,([^,\]}]*))?$/,
                      C = /^\(|\)$/g,
                      m = a.match(c);
                    if (!m) return;
                    let g = {};
                    if (((g.for = m[3].trim()), !g.for)) return;
                    let p = m[1].trim().replace(C, ""),
                      f = p.match(l);
                    f
                      ? ((g.alias = p.replace(l, "")),
                        (g.iterator1 = f[1].trim()),
                        f[2] && (g.iterator2 = f[2].trim()))
                      : (g.alias = p);
                    let h = [g.alias, g.iterator1, g.iterator2];
                    if (
                      !h.some(
                        (N, T) =>
                          !N && (T === 0 || h.slice(T + 1).some(Boolean))
                      )
                    )
                      return {
                        left: h.filter(Boolean).join(","),
                        operator: m[2],
                        right: g.for,
                      };
                  }
                  function r(a, c) {
                    return c("function _(".concat(a, ") {}"), {
                      parser: "babel",
                      __isVueBindings: !0,
                    });
                  }
                  function u(a) {
                    let c = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/,
                      l =
                        /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/,
                      C = a.trim();
                    return c.test(C) || l.test(C);
                  }
                  n.exports = {
                    isVueEventBindingExpression: u,
                    printVueFor: s,
                    printVueBindings: r,
                  };
                },
              }),
              mo = Z({
                "src/language-html/get-node-content.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                    needsToBorrowParentClosingTagStartMarker: t,
                    printClosingTagStartMarker: s,
                    needsToBorrowLastChildClosingTagEndMarker: i,
                    printClosingTagEndMarker: r,
                    needsToBorrowParentOpeningTagEndMarker: u,
                    printOpeningTagEndMarker: a,
                  } = Qt();
                  function c(l, C) {
                    let m = l.startSourceSpan.end.offset;
                    l.firstChild && u(l.firstChild) && (m -= a(l).length);
                    let g = l.endSourceSpan.start.offset;
                    return (
                      l.lastChild && t(l.lastChild)
                        ? (g += s(l, C).length)
                        : i(l) && (g -= r(l.lastChild, C).length),
                      C.originalText.slice(m, g)
                    );
                  }
                  n.exports = c;
                },
              }),
              Hd = Z({
                "src/language-html/embed.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: {
                        breakParent: t,
                        group: s,
                        hardline: i,
                        indent: r,
                        line: u,
                        fill: a,
                        softline: c,
                      },
                      utils: { mapDoc: l, replaceTextEndOfLine: C },
                    } = Le(),
                    m = Xn(),
                    {
                      printClosingTag: g,
                      printClosingTagSuffix: p,
                      needsToBorrowPrevClosingTagEndMarker: f,
                      printOpeningTagPrefix: h,
                      printOpeningTag: N,
                    } = Qt(),
                    { printImgSrcset: T, printClassNames: A } = Wd(),
                    {
                      printVueFor: b,
                      printVueBindings: v,
                      isVueEventBindingExpression: B,
                    } = $d(),
                    {
                      isScriptLikeTag: w,
                      isVueNonHtmlBlock: I,
                      inferScriptParser: E,
                      htmlTrimPreserveIndentation: D,
                      dedentString: d,
                      unescapeQuoteEntities: y,
                      isVueSlotAttribute: o,
                      isVueSfcBindingsAttribute: x,
                      getTextValueParts: F,
                    } = Ot(),
                    S = mo();
                  function k(O, R, M) {
                    let H = (ne) => new RegExp(ne.join("|")).test(O.fullName),
                      P = () => y(O.value),
                      G = !1,
                      re = (ne, se) => {
                        let V =
                          ne.type === "NGRoot"
                            ? ne.node.type === "NGMicrosyntax" &&
                              ne.node.body.length === 1 &&
                              ne.node.body[0].type === "NGMicrosyntaxExpression"
                              ? ne.node.body[0].expression
                              : ne.node
                            : ne.type === "JsExpressionRoot"
                            ? ne.node
                            : ne;
                        V &&
                          (V.type === "ObjectExpression" ||
                            V.type === "ArrayExpression" ||
                            (se.parser === "__vue_expression" &&
                              (V.type === "TemplateLiteral" ||
                                V.type === "StringLiteral"))) &&
                          (G = !0);
                      },
                      $ = (ne) => s(ne),
                      W = function (ne) {
                        let se =
                          arguments.length > 1 && arguments[1] !== void 0
                            ? arguments[1]
                            : !0;
                        return s([r([c, ne]), se ? c : ""]);
                      },
                      ee = (ne) => (G ? $(ne) : W(ne)),
                      U = (ne, se) =>
                        R(
                          ne,
                          Object.assign(
                            { __onHtmlBindingRoot: re, __embeddedInHtml: !0 },
                            se
                          )
                        );
                    if (
                      O.fullName === "srcset" &&
                      (O.parent.fullName === "img" ||
                        O.parent.fullName === "source")
                    )
                      return W(T(P()));
                    if (O.fullName === "class" && !M.parentParser) {
                      let ne = P();
                      if (!ne.includes("{{")) return A(ne);
                    }
                    if (O.fullName === "style" && !M.parentParser) {
                      let ne = P();
                      if (!ne.includes("{{"))
                        return W(
                          U(ne, { parser: "css", __isHTMLStyleAttribute: !0 })
                        );
                    }
                    if (M.parser === "vue") {
                      if (O.fullName === "v-for") return b(P(), U);
                      if (o(O) || x(O, M)) return v(P(), U);
                      let ne = ["^@", "^v-on:"],
                        se = ["^:", "^v-bind:"],
                        V = ["^v-"];
                      if (H(ne)) {
                        let oe = P();
                        return ee(
                          U(oe, {
                            parser: B(oe)
                              ? "__js_expression"
                              : "__vue_event_binding",
                          })
                        );
                      }
                      if (H(se))
                        return ee(U(P(), { parser: "__vue_expression" }));
                      if (H(V))
                        return ee(U(P(), { parser: "__js_expression" }));
                    }
                    if (M.parser === "angular") {
                      let ne = (le, ue) =>
                          U(
                            le,
                            Object.assign(
                              Object.assign({}, ue),
                              {},
                              { trailingComma: "none" }
                            )
                          ),
                        se = ["^\\*"],
                        V = ["^\\(.+\\)$", "^on-"],
                        oe = [
                          "^\\[.+\\]$",
                          "^bind(on)?-",
                          "^ng-(if|show|hide|class|style)$",
                        ],
                        K = ["^i18n(-.+)?$"];
                      if (H(V)) return ee(ne(P(), { parser: "__ng_action" }));
                      if (H(oe)) return ee(ne(P(), { parser: "__ng_binding" }));
                      if (H(K)) {
                        let le = P().trim();
                        return W(a(F(O, le)), !le.includes("@@"));
                      }
                      if (H(se))
                        return ee(ne(P(), { parser: "__ng_directive" }));
                      let Ee = /{{(.+?)}}/s,
                        q = P();
                      if (Ee.test(q)) {
                        let le = [];
                        for (let [ue, Q] of q.split(Ee).entries())
                          if (ue % 2 === 0) le.push(C(Q));
                          else
                            try {
                              le.push(
                                s([
                                  "{{",
                                  r([
                                    u,
                                    ne(Q, {
                                      parser: "__ng_interpolation",
                                      __isInHtmlInterpolation: !0,
                                    }),
                                  ]),
                                  u,
                                  "}}",
                                ])
                              );
                            } catch {
                              le.push("{{", C(Q), "}}");
                            }
                        return s(le);
                      }
                    }
                    return null;
                  }
                  function _(O, R, M, H) {
                    let P = O.getValue();
                    switch (P.type) {
                      case "element": {
                        if (w(P) || P.type === "interpolation") return;
                        if (!P.isSelfClosing && I(P, H)) {
                          let G = E(P, H);
                          if (!G) return;
                          let re = S(P, H),
                            $ = /^\s*$/.test(re),
                            W = "";
                          return (
                            $ ||
                              ((W = M(
                                D(re),
                                { parser: G, __embeddedInHtml: !0 },
                                { stripTrailingHardline: !0 }
                              )),
                              ($ = W === "")),
                            [
                              h(P, H),
                              s(N(O, H, R)),
                              $ ? "" : i,
                              W,
                              $ ? "" : i,
                              g(P, H),
                              p(P, H),
                            ]
                          );
                        }
                        break;
                      }
                      case "text": {
                        if (w(P.parent)) {
                          let G = E(P.parent);
                          if (G) {
                            let re =
                                G === "markdown"
                                  ? d(P.value.replace(/^[^\S\n]*\n/, ""))
                                  : P.value,
                              $ = { parser: G, __embeddedInHtml: !0 };
                            if (H.parser === "html" && G === "babel") {
                              let W = "script",
                                { attrMap: ee } = P.parent;
                              ee &&
                                (ee.type === "module" ||
                                  (ee.type === "text/babel" &&
                                    ee["data-type"] === "module")) &&
                                (W = "module"),
                                ($.__babelSourceType = W);
                            }
                            return [
                              t,
                              h(P, H),
                              M(re, $, { stripTrailingHardline: !0 }),
                              p(P, H),
                            ];
                          }
                        } else if (P.parent.type === "interpolation") {
                          let G = {
                            __isInHtmlInterpolation: !0,
                            __embeddedInHtml: !0,
                          };
                          return (
                            H.parser === "angular"
                              ? ((G.parser = "__ng_interpolation"),
                                (G.trailingComma = "none"))
                              : H.parser === "vue"
                              ? (G.parser = "__vue_expression")
                              : (G.parser = "__js_expression"),
                            [
                              r([
                                u,
                                M(P.value, G, { stripTrailingHardline: !0 }),
                              ]),
                              P.parent.next && f(P.parent.next) ? " " : u,
                            ]
                          );
                        }
                        break;
                      }
                      case "attribute": {
                        if (!P.value) break;
                        if (
                          /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(
                            H.originalText.slice(
                              P.valueSpan.start.offset,
                              P.valueSpan.end.offset
                            )
                          )
                        )
                          return [P.rawName, "=", P.value];
                        if (
                          H.parser === "lwc" &&
                          /^{.*}$/s.test(
                            H.originalText.slice(
                              P.valueSpan.start.offset,
                              P.valueSpan.end.offset
                            )
                          )
                        )
                          return [P.rawName, "=", P.value];
                        let G = k(
                          P,
                          (re, $) =>
                            M(
                              re,
                              Object.assign(
                                {
                                  __isInHtmlAttribute: !0,
                                  __embeddedInHtml: !0,
                                },
                                $
                              ),
                              { stripTrailingHardline: !0 }
                            ),
                          H
                        );
                        if (G)
                          return [
                            P.rawName,
                            '="',
                            s(
                              l(G, (re) =>
                                typeof re == "string"
                                  ? re.replace(/"/g, "&quot;")
                                  : re
                              )
                            ),
                            '"',
                          ];
                        break;
                      }
                      case "front-matter":
                        return m(P, M);
                    }
                  }
                  n.exports = _;
                },
              }),
              go = Z({
                "src/language-html/print/children.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: {
                        breakParent: t,
                        group: s,
                        ifBreak: i,
                        line: r,
                        softline: u,
                        hardline: a,
                      },
                      utils: { replaceTextEndOfLine: c },
                    } = Le(),
                    { locStart: l, locEnd: C } = Yn(),
                    {
                      forceBreakChildren: m,
                      forceNextEmptyLine: g,
                      isTextLikeNode: p,
                      hasPrettierIgnore: f,
                      preferHardlineAsLeadingSpaces: h,
                    } = Ot(),
                    {
                      printOpeningTagPrefix: N,
                      needsToBorrowNextOpeningTagStartMarker: T,
                      printOpeningTagStartMarker: A,
                      needsToBorrowPrevClosingTagEndMarker: b,
                      printClosingTagEndMarker: v,
                      printClosingTagSuffix: B,
                      needsToBorrowParentClosingTagStartMarker: w,
                    } = Qt();
                  function I(d, y, o) {
                    let x = d.getValue();
                    return f(x)
                      ? [
                          N(x, y),
                          ...c(
                            y.originalText.slice(
                              l(x) + (x.prev && T(x.prev) ? A(x).length : 0),
                              C(x) - (x.next && b(x.next) ? v(x, y).length : 0)
                            )
                          ),
                          B(x, y),
                        ]
                      : o();
                  }
                  function E(d, y) {
                    return p(d) && p(y)
                      ? d.isTrailingSpaceSensitive
                        ? d.hasTrailingSpaces
                          ? h(y)
                            ? a
                            : r
                          : ""
                        : h(y)
                        ? a
                        : u
                      : (T(d) &&
                          (f(y) ||
                            y.firstChild ||
                            y.isSelfClosing ||
                            (y.type === "element" && y.attrs.length > 0))) ||
                        (d.type === "element" && d.isSelfClosing && b(y))
                      ? ""
                      : !y.isLeadingSpaceSensitive ||
                        h(y) ||
                        (b(y) &&
                          d.lastChild &&
                          w(d.lastChild) &&
                          d.lastChild.lastChild &&
                          w(d.lastChild.lastChild))
                      ? a
                      : y.hasLeadingSpaces
                      ? r
                      : u;
                  }
                  function D(d, y, o) {
                    let x = d.getValue();
                    if (m(x))
                      return [
                        t,
                        ...d.map((S) => {
                          let k = S.getValue(),
                            _ = k.prev ? E(k.prev, k) : "";
                          return [_ ? [_, g(k.prev) ? a : ""] : "", I(S, y, o)];
                        }, "children"),
                      ];
                    let F = x.children.map(() => Symbol(""));
                    return d.map((S, k) => {
                      let _ = S.getValue();
                      if (p(_)) {
                        if (_.prev && p(_.prev)) {
                          let re = E(_.prev, _);
                          if (re)
                            return g(_.prev)
                              ? [a, a, I(S, y, o)]
                              : [re, I(S, y, o)];
                        }
                        return I(S, y, o);
                      }
                      let O = [],
                        R = [],
                        M = [],
                        H = [],
                        P = _.prev ? E(_.prev, _) : "",
                        G = _.next ? E(_, _.next) : "";
                      return (
                        P &&
                          (g(_.prev)
                            ? O.push(a, a)
                            : P === a
                            ? O.push(a)
                            : p(_.prev)
                            ? R.push(P)
                            : R.push(i("", u, { groupId: F[k - 1] }))),
                        G &&
                          (g(_)
                            ? p(_.next) && H.push(a, a)
                            : G === a
                            ? p(_.next) && H.push(a)
                            : M.push(G)),
                        [
                          ...O,
                          s([...R, s([I(S, y, o), ...M], { id: F[k] })]),
                          ...H,
                        ]
                      );
                    }, "children");
                  }
                  n.exports = { printChildren: D };
                },
              }),
              Gd = Z({
                "src/language-html/print/element.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: {
                        breakParent: t,
                        dedentToRoot: s,
                        group: i,
                        ifBreak: r,
                        indentIfBreak: u,
                        indent: a,
                        line: c,
                        softline: l,
                      },
                      utils: { replaceTextEndOfLine: C },
                    } = Le(),
                    m = mo(),
                    {
                      shouldPreserveContent: g,
                      isScriptLikeTag: p,
                      isVueCustomBlock: f,
                      countParents: h,
                      forceBreakContent: N,
                    } = Ot(),
                    {
                      printOpeningTagPrefix: T,
                      printOpeningTag: A,
                      printClosingTagSuffix: b,
                      printClosingTag: v,
                      needsToBorrowPrevClosingTagEndMarker: B,
                      needsToBorrowLastChildClosingTagEndMarker: w,
                    } = Qt(),
                    { printChildren: I } = go();
                  function E(D, d, y) {
                    let o = D.getValue();
                    if (g(o, d))
                      return [
                        T(o, d),
                        i(A(D, d, y)),
                        ...C(m(o, d)),
                        ...v(o, d),
                        b(o, d),
                      ];
                    let x =
                        o.children.length === 1 &&
                        o.firstChild.type === "interpolation" &&
                        o.firstChild.isLeadingSpaceSensitive &&
                        !o.firstChild.hasLeadingSpaces &&
                        o.lastChild.isTrailingSpaceSensitive &&
                        !o.lastChild.hasTrailingSpaces,
                      F = Symbol("element-attr-group-id"),
                      S = (R) => i([i(A(D, d, y), { id: F }), R, v(o, d)]),
                      k = (R) =>
                        x
                          ? u(R, { groupId: F })
                          : (p(o) || f(o, d)) &&
                            o.parent.type === "root" &&
                            d.parser === "vue" &&
                            !d.vueIndentScriptAndStyle
                          ? R
                          : a(R),
                      _ = () =>
                        x
                          ? r(l, "", { groupId: F })
                          : o.firstChild.hasLeadingSpaces &&
                            o.firstChild.isLeadingSpaceSensitive
                          ? c
                          : o.firstChild.type === "text" &&
                            o.isWhitespaceSensitive &&
                            o.isIndentationSensitive
                          ? s(l)
                          : l,
                      O = () =>
                        (o.next ? B(o.next) : w(o.parent))
                          ? o.lastChild.hasTrailingSpaces &&
                            o.lastChild.isTrailingSpaceSensitive
                            ? " "
                            : ""
                          : x
                          ? r(l, "", { groupId: F })
                          : o.lastChild.hasTrailingSpaces &&
                            o.lastChild.isTrailingSpaceSensitive
                          ? c
                          : (o.lastChild.type === "comment" ||
                              (o.lastChild.type === "text" &&
                                o.isWhitespaceSensitive &&
                                o.isIndentationSensitive)) &&
                            new RegExp(
                              "\\n[\\t ]{".concat(
                                d.tabWidth *
                                  h(
                                    D,
                                    (M) => M.parent && M.parent.type !== "root"
                                  ),
                                "}$"
                              )
                            ).test(o.lastChild.value)
                          ? ""
                          : l;
                    return o.children.length === 0
                      ? S(
                          o.hasDanglingSpaces && o.isDanglingSpaceSensitive
                            ? c
                            : ""
                        )
                      : S([N(o) ? t : "", k([_(), I(D, d, y)]), O()]);
                  }
                  n.exports = { printElement: E };
                },
              }),
              Jd = Z({
                "src/language-html/printer-html.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: {
                        fill: t,
                        group: s,
                        hardline: i,
                        literalline: r,
                      },
                      utils: {
                        cleanDoc: u,
                        getDocParts: a,
                        isConcat: c,
                        replaceTextEndOfLine: l,
                      },
                    } = Le(),
                    C = _d(),
                    {
                      countChars: m,
                      unescapeQuoteEntities: g,
                      getTextValueParts: p,
                    } = Ot(),
                    f = Md(),
                    { insertPragma: h } = Rd(),
                    { locStart: N, locEnd: T } = Yn(),
                    A = Hd(),
                    {
                      printClosingTagSuffix: b,
                      printClosingTagEnd: v,
                      printOpeningTagPrefix: B,
                      printOpeningTagStart: w,
                    } = Qt(),
                    { printElement: I } = Gd(),
                    { printChildren: E } = go();
                  function D(d, y, o) {
                    let x = d.getValue();
                    switch (x.type) {
                      case "front-matter":
                        return l(x.raw);
                      case "root":
                        return (
                          y.__onHtmlRoot && y.__onHtmlRoot(x),
                          [s(E(d, y, o)), i]
                        );
                      case "element":
                      case "ieConditionalComment":
                        return I(d, y, o);
                      case "ieConditionalStartComment":
                      case "ieConditionalEndComment":
                        return [w(x), v(x)];
                      case "interpolation":
                        return [w(x, y), ...d.map(o, "children"), v(x, y)];
                      case "text": {
                        if (x.parent.type === "interpolation") {
                          let S = /\n[^\S\n]*$/,
                            k = S.test(x.value),
                            _ = k ? x.value.replace(S, "") : x.value;
                          return [...l(_), k ? i : ""];
                        }
                        let F = u([B(x, y), ...p(x), b(x, y)]);
                        return c(F) || F.type === "fill" ? t(a(F)) : F;
                      }
                      case "docType":
                        return [
                          s([
                            w(x, y),
                            " ",
                            x.value
                              .replace(/^html\b/i, "html")
                              .replace(/\s+/g, " "),
                          ]),
                          v(x, y),
                        ];
                      case "comment":
                        return [
                          B(x, y),
                          ...l(y.originalText.slice(N(x), T(x)), r),
                          b(x, y),
                        ];
                      case "attribute": {
                        if (x.value === null) return x.rawName;
                        let F = g(x.value),
                          S = m(F, "'"),
                          k = m(F, '"'),
                          _ = S < k ? "'" : '"';
                        return [
                          x.rawName,
                          "=",
                          _,
                          ...l(
                            _ === '"'
                              ? F.replace(/"/g, "&quot;")
                              : F.replace(/'/g, "&apos;")
                          ),
                          _,
                        ];
                      }
                      default:
                        throw new Error("Unexpected node type ".concat(x.type));
                    }
                  }
                  n.exports = {
                    preprocess: f,
                    print: D,
                    insertPragma: h,
                    massageAstNode: C,
                    embed: A,
                  };
                },
              }),
              Ud = Z({
                "src/language-html/options.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Lt(),
                    s = "HTML";
                  n.exports = {
                    bracketSameLine: t.bracketSameLine,
                    htmlWhitespaceSensitivity: {
                      since: "1.15.0",
                      category: s,
                      type: "choice",
                      default: "css",
                      description: "How to handle whitespaces in HTML.",
                      choices: [
                        {
                          value: "css",
                          description:
                            "Respect the default value of CSS display property.",
                        },
                        {
                          value: "strict",
                          description: "Whitespaces are considered sensitive.",
                        },
                        {
                          value: "ignore",
                          description:
                            "Whitespaces are considered insensitive.",
                        },
                      ],
                    },
                    singleAttributePerLine: t.singleAttributePerLine,
                    vueIndentScriptAndStyle: {
                      since: "1.19.0",
                      category: s,
                      type: "boolean",
                      default: !1,
                      description: "Indent script and style tags in Vue files.",
                    },
                  };
                },
              }),
              zd = Z({
                "src/language-html/parsers.js"() {
                  ae();
                },
              }),
              An = Z({
                "node_modules/linguist-languages/data/HTML.json"(e, n) {
                  n.exports = {
                    name: "HTML",
                    type: "markup",
                    tmScope: "text.html.basic",
                    aceMode: "html",
                    codemirrorMode: "htmlmixed",
                    codemirrorMimeType: "text/html",
                    color: "#e34c26",
                    aliases: ["xhtml"],
                    extensions: [
                      ".html",
                      ".htm",
                      ".html.hl",
                      ".inc",
                      ".xht",
                      ".xhtml",
                    ],
                    languageId: 146,
                  };
                },
              }),
              Xd = Z({
                "node_modules/linguist-languages/data/Vue.json"(e, n) {
                  n.exports = {
                    name: "Vue",
                    type: "markup",
                    color: "#41b883",
                    extensions: [".vue"],
                    tmScope: "text.html.vue",
                    aceMode: "html",
                    languageId: 391,
                  };
                },
              }),
              Kd = Z({
                "src/language-html/index.js"(e, n) {
                  "use strict";
                  ae();
                  var t = bt(),
                    s = Jd(),
                    i = Ud(),
                    r = zd(),
                    u = [
                      t(An(), () => ({
                        name: "Angular",
                        since: "1.15.0",
                        parsers: ["angular"],
                        vscodeLanguageIds: ["html"],
                        extensions: [".component.html"],
                        filenames: [],
                      })),
                      t(An(), (c) => ({
                        since: "1.15.0",
                        parsers: ["html"],
                        vscodeLanguageIds: ["html"],
                        extensions: [...c.extensions, ".mjml"],
                      })),
                      t(An(), () => ({
                        name: "Lightning Web Components",
                        since: "1.17.0",
                        parsers: ["lwc"],
                        vscodeLanguageIds: ["html"],
                        extensions: [],
                        filenames: [],
                      })),
                      t(Xd(), () => ({
                        since: "1.10.0",
                        parsers: ["vue"],
                        vscodeLanguageIds: ["vue"],
                      })),
                    ],
                    a = { html: s };
                  n.exports = {
                    languages: u,
                    printers: a,
                    options: i,
                    parsers: r,
                  };
                },
              }),
              Yd = Z({
                "src/language-yaml/pragma.js"(e, n) {
                  "use strict";
                  ae();
                  function t(r) {
                    return /^\s*@(?:prettier|format)\s*$/.test(r);
                  }
                  function s(r) {
                    return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(
                      r
                    );
                  }
                  function i(r) {
                    return `# @format

`.concat(r);
                  }
                  n.exports = { isPragma: t, hasPragma: s, insertPragma: i };
                },
              }),
              Qd = Z({
                "src/language-yaml/loc.js"(e, n) {
                  "use strict";
                  ae();
                  function t(i) {
                    return i.position.start.offset;
                  }
                  function s(i) {
                    return i.position.end.offset;
                  }
                  n.exports = { locStart: t, locEnd: s };
                },
              }),
              Zd = Z({
                "src/language-yaml/embed.js"(e, n) {
                  "use strict";
                  ae();
                  function t(s, i, r, u) {
                    if (
                      s.getValue().type === "root" &&
                      u.filepath &&
                      /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(u.filepath)
                    )
                      return r(
                        u.originalText,
                        Object.assign(
                          Object.assign({}, u),
                          {},
                          { parser: "json" }
                        )
                      );
                  }
                  n.exports = t;
                },
              }),
              jt = Z({
                "src/language-yaml/utils.js"(e, n) {
                  "use strict";
                  ae();
                  var { getLast: t, isNonEmptyArray: s } = Ge();
                  function i(E, D) {
                    let d = 0,
                      y = E.stack.length - 1;
                    for (let o = 0; o < y; o++) {
                      let x = E.stack[o];
                      r(x) && D(x) && d++;
                    }
                    return d;
                  }
                  function r(E, D) {
                    return (
                      E &&
                      typeof E.type == "string" &&
                      (!D || D.includes(E.type))
                    );
                  }
                  function u(E, D, d) {
                    return D(
                      "children" in E
                        ? Object.assign(
                            Object.assign({}, E),
                            {},
                            { children: E.children.map((y) => u(y, D, E)) }
                          )
                        : E,
                      d
                    );
                  }
                  function a(E, D, d) {
                    Object.defineProperty(E, D, { get: d, enumerable: !1 });
                  }
                  function c(E, D) {
                    let d = 0,
                      y = D.length;
                    for (let o = E.position.end.offset - 1; o < y; o++) {
                      let x = D[o];
                      if (
                        (x ===
                          `
` && d++,
                        d === 1 && /\S/.test(x))
                      )
                        return !1;
                      if (d === 2) return !0;
                    }
                    return !1;
                  }
                  function l(E) {
                    switch (E.getValue().type) {
                      case "tag":
                      case "anchor":
                      case "comment":
                        return !1;
                    }
                    let d = E.stack.length;
                    for (let y = 1; y < d; y++) {
                      let o = E.stack[y],
                        x = E.stack[y - 1];
                      if (
                        Array.isArray(x) &&
                        typeof o == "number" &&
                        o !== x.length - 1
                      )
                        return !1;
                    }
                    return !0;
                  }
                  function C(E) {
                    return s(E.children) ? C(t(E.children)) : E;
                  }
                  function m(E) {
                    return E.value.trim() === "prettier-ignore";
                  }
                  function g(E) {
                    let D = E.getValue();
                    if (D.type === "documentBody") {
                      let d = E.getParentNode();
                      return b(d.head) && m(t(d.head.endComments));
                    }
                    return h(D) && m(t(D.leadingComments));
                  }
                  function p(E) {
                    return !s(E.children) && !f(E);
                  }
                  function f(E) {
                    return h(E) || N(E) || T(E) || A(E) || b(E);
                  }
                  function h(E) {
                    return E && s(E.leadingComments);
                  }
                  function N(E) {
                    return E && s(E.middleComments);
                  }
                  function T(E) {
                    return E && E.indicatorComment;
                  }
                  function A(E) {
                    return E && E.trailingComment;
                  }
                  function b(E) {
                    return E && s(E.endComments);
                  }
                  function v(E) {
                    let D = [],
                      d;
                    for (let y of E.split(/( +)/))
                      y !== " "
                        ? d === " "
                          ? D.push(y)
                          : D.push((D.pop() || "") + y)
                        : d === void 0 && D.unshift(""),
                        (d = y);
                    return (
                      d === " " && D.push((D.pop() || "") + " "),
                      D[0] === "" &&
                        (D.shift(), D.unshift(" " + (D.shift() || ""))),
                      D
                    );
                  }
                  function B(E, D, d) {
                    let y = D.split(
                      `
`
                    ).map((o, x, F) =>
                      x === 0 && x === F.length - 1
                        ? o
                        : x !== 0 && x !== F.length - 1
                        ? o.trim()
                        : x === 0
                        ? o.trimEnd()
                        : o.trimStart()
                    );
                    return d.proseWrap === "preserve"
                      ? y.map((o) => (o.length === 0 ? [] : [o]))
                      : y
                          .map((o) => (o.length === 0 ? [] : v(o)))
                          .reduce(
                            (o, x, F) =>
                              F !== 0 &&
                              y[F - 1].length > 0 &&
                              x.length > 0 &&
                              !(E === "quoteDouble" && t(t(o)).endsWith("\\"))
                                ? [...o.slice(0, -1), [...t(o), ...x]]
                                : [...o, x],
                            []
                          )
                          .map((o) =>
                            d.proseWrap === "never" ? [o.join(" ")] : o
                          );
                  }
                  function w(E, D) {
                    let {
                        parentIndent: d,
                        isLastDescendant: y,
                        options: o,
                      } = D,
                      x =
                        E.position.start.line === E.position.end.line
                          ? ""
                          : o.originalText
                              .slice(
                                E.position.start.offset,
                                E.position.end.offset
                              )
                              .match(/^[^\n]*\n(.*)$/s)[1],
                      F;
                    if (E.indent === null) {
                      let _ = x.match(/^(?<leadingSpace> *)[^\n\r ]/m);
                      F = _
                        ? _.groups.leadingSpace.length
                        : Number.POSITIVE_INFINITY;
                    } else F = E.indent - 1 + d;
                    let S = x
                      .split(
                        `
`
                      )
                      .map((_) => _.slice(F));
                    if (o.proseWrap === "preserve" || E.type === "blockLiteral")
                      return k(S.map((_) => (_.length === 0 ? [] : [_])));
                    return k(
                      S.map((_) => (_.length === 0 ? [] : v(_)))
                        .reduce(
                          (_, O, R) =>
                            R !== 0 &&
                            S[R - 1].length > 0 &&
                            O.length > 0 &&
                            !/^\s/.test(O[0]) &&
                            !/^\s|\s$/.test(t(_))
                              ? [..._.slice(0, -1), [...t(_), ...O]]
                              : [..._, O],
                          []
                        )
                        .map((_) =>
                          _.reduce(
                            (O, R) =>
                              O.length > 0 && /\s$/.test(t(O))
                                ? [...O.slice(0, -1), t(O) + " " + R]
                                : [...O, R],
                            []
                          )
                        )
                        .map((_) =>
                          o.proseWrap === "never" ? [_.join(" ")] : _
                        )
                    );
                    function k(_) {
                      if (E.chomping === "keep")
                        return t(_).length === 0 ? _.slice(0, -1) : _;
                      let O = 0;
                      for (
                        let R = _.length - 1;
                        R >= 0 && _[R].length === 0;
                        R--
                      )
                        O++;
                      return O === 0
                        ? _
                        : O >= 2 && !y
                        ? _.slice(0, -(O - 1))
                        : _.slice(0, -O);
                    }
                  }
                  function I(E) {
                    if (!E) return !0;
                    switch (E.type) {
                      case "plain":
                      case "quoteDouble":
                      case "quoteSingle":
                      case "alias":
                      case "flowMapping":
                      case "flowSequence":
                        return !0;
                      default:
                        return !1;
                    }
                  }
                  n.exports = {
                    getLast: t,
                    getAncestorCount: i,
                    isNode: r,
                    isEmptyNode: p,
                    isInlineNode: I,
                    mapNode: u,
                    defineShortcut: a,
                    isNextLineEmpty: c,
                    isLastDescendantNode: l,
                    getBlockValueLineContents: w,
                    getFlowScalarLineContents: B,
                    getLastDescendantNode: C,
                    hasPrettierIgnore: g,
                    hasLeadingComments: h,
                    hasMiddleComments: N,
                    hasIndicatorComment: T,
                    hasTrailingComment: A,
                    hasEndComments: b,
                  };
                },
              }),
              eg = Z({
                "src/language-yaml/print-preprocess.js"(e, n) {
                  "use strict";
                  ae();
                  var { defineShortcut: t, mapNode: s } = jt();
                  function i(u) {
                    return s(u, r);
                  }
                  function r(u) {
                    switch (u.type) {
                      case "document":
                        t(u, "head", () => u.children[0]),
                          t(u, "body", () => u.children[1]);
                        break;
                      case "documentBody":
                      case "sequenceItem":
                      case "flowSequenceItem":
                      case "mappingKey":
                      case "mappingValue":
                        t(u, "content", () => u.children[0]);
                        break;
                      case "mappingItem":
                      case "flowMappingItem":
                        t(u, "key", () => u.children[0]),
                          t(u, "value", () => u.children[1]);
                        break;
                    }
                    return u;
                  }
                  n.exports = i;
                },
              }),
              kr = Z({
                "src/language-yaml/print/misc.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: { softline: t, align: s },
                    } = Le(),
                    { hasEndComments: i, isNextLineEmpty: r, isNode: u } = jt(),
                    a = new WeakMap();
                  function c(m, g) {
                    let p = m.getValue(),
                      f = m.stack[0],
                      h;
                    return (
                      a.has(f)
                        ? (h = a.get(f))
                        : ((h = new Set()), a.set(f, h)),
                      !h.has(p.position.end.line) &&
                      (h.add(p.position.end.line),
                      r(p, g) && !l(m.getParentNode()))
                        ? t
                        : ""
                    );
                  }
                  function l(m) {
                    return (
                      i(m) &&
                      !u(m, [
                        "documentHead",
                        "documentBody",
                        "flowMapping",
                        "flowSequence",
                      ])
                    );
                  }
                  function C(m, g) {
                    return s(" ".repeat(m), g);
                  }
                  n.exports = {
                    alignWithSpaces: C,
                    shouldPrintEndComments: l,
                    printNextEmptyLine: c,
                  };
                },
              }),
              tg = Z({
                "src/language-yaml/print/flow-mapping-sequence.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: {
                        ifBreak: t,
                        line: s,
                        softline: i,
                        hardline: r,
                        join: u,
                      },
                    } = Le(),
                    { isEmptyNode: a, getLast: c, hasEndComments: l } = jt(),
                    { printNextEmptyLine: C, alignWithSpaces: m } = kr();
                  function g(f, h, N) {
                    let T = f.getValue(),
                      A = T.type === "flowMapping",
                      b = A ? "{" : "[",
                      v = A ? "}" : "]",
                      B = i;
                    A && T.children.length > 0 && N.bracketSpacing && (B = s);
                    let w = c(T.children),
                      I =
                        w &&
                        w.type === "flowMappingItem" &&
                        a(w.key) &&
                        a(w.value);
                    return [
                      b,
                      m(N.tabWidth, [
                        B,
                        p(f, h, N),
                        N.trailingComma === "none" ? "" : t(","),
                        l(T) ? [r, u(r, f.map(h, "endComments"))] : "",
                      ]),
                      I ? "" : B,
                      v,
                    ];
                  }
                  function p(f, h, N) {
                    let T = f.getValue();
                    return f.map(
                      (b, v) => [
                        h(),
                        v === T.children.length - 1
                          ? ""
                          : [
                              ",",
                              s,
                              T.children[v].position.start.line !==
                              T.children[v + 1].position.start.line
                                ? C(b, N.originalText)
                                : "",
                            ],
                      ],
                      "children"
                    );
                  }
                  n.exports = { printFlowMapping: g, printFlowSequence: g };
                },
              }),
              rg = Z({
                "src/language-yaml/print/mapping-item.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: {
                        conditionalGroup: t,
                        group: s,
                        hardline: i,
                        ifBreak: r,
                        join: u,
                        line: a,
                      },
                    } = Le(),
                    {
                      hasLeadingComments: c,
                      hasMiddleComments: l,
                      hasTrailingComment: C,
                      hasEndComments: m,
                      isNode: g,
                      isEmptyNode: p,
                      isInlineNode: f,
                    } = jt(),
                    { alignWithSpaces: h } = kr();
                  function N(v, B, w, I, E) {
                    let { key: D, value: d } = v,
                      y = p(D),
                      o = p(d);
                    if (y && o) return ": ";
                    let x = I("key"),
                      F = A(v) ? " " : "";
                    if (o)
                      return v.type === "flowMappingItem" &&
                        B.type === "flowMapping"
                        ? x
                        : v.type === "mappingItem" &&
                          T(D.content, E) &&
                          !C(D.content) &&
                          (!B.tag || B.tag.value !== "tag:yaml.org,2002:set")
                        ? [x, F, ":"]
                        : ["? ", h(2, x)];
                    let S = I("value");
                    if (y) return [": ", h(2, S)];
                    if (c(d) || !f(D.content))
                      return [
                        "? ",
                        h(2, x),
                        i,
                        u(
                          "",
                          w
                            .map(I, "value", "leadingComments")
                            .map((H) => [H, i])
                        ),
                        ": ",
                        h(2, S),
                      ];
                    if (
                      b(D.content) &&
                      !c(D.content) &&
                      !l(D.content) &&
                      !C(D.content) &&
                      !m(D) &&
                      !c(d.content) &&
                      !l(d.content) &&
                      !m(d) &&
                      T(d.content, E)
                    )
                      return [x, F, ": ", S];
                    let k = Symbol("mappingKey"),
                      _ = s([r("? "), s(h(2, x), { id: k })]),
                      O = [i, ": ", h(2, S)],
                      R = [F, ":"];
                    c(d.content) ||
                    (m(d) &&
                      d.content &&
                      !g(d.content, ["mapping", "sequence"])) ||
                    (B.type === "mapping" && C(D.content) && f(d.content)) ||
                    (g(d.content, ["mapping", "sequence"]) &&
                      d.content.tag === null &&
                      d.content.anchor === null)
                      ? R.push(i)
                      : d.content && R.push(a),
                      R.push(S);
                    let M = h(E.tabWidth, R);
                    return T(D.content, E) &&
                      !c(D.content) &&
                      !l(D.content) &&
                      !m(D)
                      ? t([[x, M]])
                      : t([[_, r(O, M, { groupId: k })]]);
                  }
                  function T(v, B) {
                    if (!v) return !0;
                    switch (v.type) {
                      case "plain":
                      case "quoteSingle":
                      case "quoteDouble":
                        break;
                      case "alias":
                        return !0;
                      default:
                        return !1;
                    }
                    if (B.proseWrap === "preserve")
                      return v.position.start.line === v.position.end.line;
                    if (
                      /\\$/m.test(
                        B.originalText.slice(
                          v.position.start.offset,
                          v.position.end.offset
                        )
                      )
                    )
                      return !1;
                    switch (B.proseWrap) {
                      case "never":
                        return !v.value.includes(`
`);
                      case "always":
                        return !/[\n ]/.test(v.value);
                      default:
                        return !1;
                    }
                  }
                  function A(v) {
                    return v.key.content && v.key.content.type === "alias";
                  }
                  function b(v) {
                    if (!v) return !0;
                    switch (v.type) {
                      case "plain":
                      case "quoteDouble":
                      case "quoteSingle":
                        return v.position.start.line === v.position.end.line;
                      case "alias":
                        return !0;
                      default:
                        return !1;
                    }
                  }
                  n.exports = N;
                },
              }),
              ng = Z({
                "src/language-yaml/print/block.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: {
                        dedent: t,
                        dedentToRoot: s,
                        fill: i,
                        hardline: r,
                        join: u,
                        line: a,
                        literalline: c,
                        markAsRoot: l,
                      },
                      utils: { getDocParts: C },
                    } = Le(),
                    {
                      getAncestorCount: m,
                      getBlockValueLineContents: g,
                      hasIndicatorComment: p,
                      isLastDescendantNode: f,
                      isNode: h,
                    } = jt(),
                    { alignWithSpaces: N } = kr();
                  function T(A, b, v) {
                    let B = A.getValue(),
                      w = m(A, (y) => h(y, ["sequence", "mapping"])),
                      I = f(A),
                      E = [B.type === "blockFolded" ? ">" : "|"];
                    B.indent !== null && E.push(B.indent.toString()),
                      B.chomping !== "clip" &&
                        E.push(B.chomping === "keep" ? "+" : "-"),
                      p(B) && E.push(" ", b("indicatorComment"));
                    let D = g(B, {
                        parentIndent: w,
                        isLastDescendant: I,
                        options: v,
                      }),
                      d = [];
                    for (let [y, o] of D.entries())
                      y === 0 && d.push(r),
                        d.push(i(C(u(a, o)))),
                        y !== D.length - 1
                          ? d.push(o.length === 0 ? r : l(c))
                          : B.chomping === "keep" &&
                            I &&
                            d.push(s(o.length === 0 ? r : c));
                    return (
                      B.indent === null
                        ? E.push(t(N(v.tabWidth, d)))
                        : E.push(s(N(B.indent - 1 + w, d))),
                      E
                    );
                  }
                  n.exports = T;
                },
              }),
              ug = Z({
                "src/language-yaml/printer-yaml.js"(e, n) {
                  "use strict";
                  ae();
                  var {
                      builders: {
                        breakParent: t,
                        fill: s,
                        group: i,
                        hardline: r,
                        join: u,
                        line: a,
                        lineSuffix: c,
                        literalline: l,
                      },
                      utils: { getDocParts: C, replaceTextEndOfLine: m },
                    } = Le(),
                    { isPreviousLineEmpty: g } = Ge(),
                    { insertPragma: p, isPragma: f } = Yd(),
                    { locStart: h } = Qd(),
                    N = Zd(),
                    {
                      getFlowScalarLineContents: T,
                      getLastDescendantNode: A,
                      hasLeadingComments: b,
                      hasMiddleComments: v,
                      hasTrailingComment: B,
                      hasEndComments: w,
                      hasPrettierIgnore: I,
                      isLastDescendantNode: E,
                      isNode: D,
                      isInlineNode: d,
                    } = jt(),
                    y = eg(),
                    {
                      alignWithSpaces: o,
                      printNextEmptyLine: x,
                      shouldPrintEndComments: F,
                    } = kr(),
                    { printFlowMapping: S, printFlowSequence: k } = tg(),
                    _ = rg(),
                    O = ng();
                  function R(W, ee, U) {
                    let ne = W.getValue(),
                      se = [];
                    ne.type !== "mappingValue" &&
                      b(ne) &&
                      se.push([u(r, W.map(U, "leadingComments")), r]);
                    let { tag: V, anchor: oe } = ne;
                    V && se.push(U("tag")),
                      V && oe && se.push(" "),
                      oe && se.push(U("anchor"));
                    let K = "";
                    D(ne, [
                      "mapping",
                      "sequence",
                      "comment",
                      "directive",
                      "mappingItem",
                      "sequenceItem",
                    ]) &&
                      !E(W) &&
                      (K = x(W, ee.originalText)),
                      (V || oe) &&
                        (D(ne, ["sequence", "mapping"]) && !v(ne)
                          ? se.push(r)
                          : se.push(" ")),
                      v(ne) &&
                        se.push([
                          ne.middleComments.length === 1 ? "" : r,
                          u(r, W.map(U, "middleComments")),
                          r,
                        ]);
                    let Ee = W.getParentNode();
                    return (
                      I(W)
                        ? se.push(
                            m(
                              ee.originalText
                                .slice(
                                  ne.position.start.offset,
                                  ne.position.end.offset
                                )
                                .trimEnd(),
                              l
                            )
                          )
                        : se.push(i(M(ne, Ee, W, ee, U))),
                      B(ne) &&
                        !D(ne, ["document", "documentHead"]) &&
                        se.push(
                          c([
                            ne.type === "mappingValue" && !ne.content
                              ? ""
                              : " ",
                            Ee.type === "mappingKey" &&
                            W.getParentNode(2).type === "mapping" &&
                            d(ne)
                              ? ""
                              : t,
                            U("trailingComment"),
                          ])
                        ),
                      F(ne) &&
                        se.push(
                          o(ne.type === "sequenceItem" ? 2 : 0, [
                            r,
                            u(
                              r,
                              W.map(
                                (q) => [
                                  g(ee.originalText, q.getValue(), h) ? r : "",
                                  U(),
                                ],
                                "endComments"
                              )
                            ),
                          ])
                        ),
                      se.push(K),
                      se
                    );
                  }
                  function M(W, ee, U, ne, se) {
                    switch (W.type) {
                      case "root": {
                        let { children: V } = W,
                          oe = [];
                        U.each((Ee, q) => {
                          let le = V[q],
                            ue = V[q + 1];
                          q !== 0 && oe.push(r),
                            oe.push(se()),
                            P(le, ue)
                              ? (oe.push(r, "..."),
                                B(le) && oe.push(" ", se("trailingComment")))
                              : ue && !B(ue.head) && oe.push(r, "---");
                        }, "children");
                        let K = A(W);
                        return (
                          (!D(K, ["blockLiteral", "blockFolded"]) ||
                            K.chomping !== "keep") &&
                            oe.push(r),
                          oe
                        );
                      }
                      case "document": {
                        let V = ee.children[U.getName() + 1],
                          oe = [];
                        return (
                          G(W, V, ee, ne) === "head" &&
                            ((W.head.children.length > 0 ||
                              W.head.endComments.length > 0) &&
                              oe.push(se("head")),
                            B(W.head)
                              ? oe.push([
                                  "---",
                                  " ",
                                  se(["head", "trailingComment"]),
                                ])
                              : oe.push("---")),
                          H(W) && oe.push(se("body")),
                          u(r, oe)
                        );
                      }
                      case "documentHead":
                        return u(r, [
                          ...U.map(se, "children"),
                          ...U.map(se, "endComments"),
                        ]);
                      case "documentBody": {
                        let { children: V, endComments: oe } = W,
                          K = "";
                        if (V.length > 0 && oe.length > 0) {
                          let Ee = A(W);
                          D(Ee, ["blockFolded", "blockLiteral"])
                            ? Ee.chomping !== "keep" && (K = [r, r])
                            : (K = r);
                        }
                        return [
                          u(r, U.map(se, "children")),
                          K,
                          u(r, U.map(se, "endComments")),
                        ];
                      }
                      case "directive":
                        return ["%", u(" ", [W.name, ...W.parameters])];
                      case "comment":
                        return ["#", W.value];
                      case "alias":
                        return ["*", W.value];
                      case "tag":
                        return ne.originalText.slice(
                          W.position.start.offset,
                          W.position.end.offset
                        );
                      case "anchor":
                        return ["&", W.value];
                      case "plain":
                        return re(
                          W.type,
                          ne.originalText.slice(
                            W.position.start.offset,
                            W.position.end.offset
                          ),
                          ne
                        );
                      case "quoteDouble":
                      case "quoteSingle": {
                        let V = "'",
                          oe = '"',
                          K = ne.originalText.slice(
                            W.position.start.offset + 1,
                            W.position.end.offset - 1
                          );
                        if (
                          (W.type === "quoteSingle" && K.includes("\\")) ||
                          (W.type === "quoteDouble" && /\\[^"]/.test(K))
                        ) {
                          let q = W.type === "quoteDouble" ? oe : V;
                          return [q, re(W.type, K, ne), q];
                        }
                        if (K.includes(oe))
                          return [
                            V,
                            re(
                              W.type,
                              W.type === "quoteDouble"
                                ? K.replace(/\\"/g, oe).replace(
                                    /'/g,
                                    V.repeat(2)
                                  )
                                : K,
                              ne
                            ),
                            V,
                          ];
                        if (K.includes(V))
                          return [
                            oe,
                            re(
                              W.type,
                              W.type === "quoteSingle"
                                ? K.replace(/''/g, V)
                                : K,
                              ne
                            ),
                            oe,
                          ];
                        let Ee = ne.singleQuote ? V : oe;
                        return [Ee, re(W.type, K, ne), Ee];
                      }
                      case "blockFolded":
                      case "blockLiteral":
                        return O(U, se, ne);
                      case "mapping":
                      case "sequence":
                        return u(r, U.map(se, "children"));
                      case "sequenceItem":
                        return ["- ", o(2, W.content ? se("content") : "")];
                      case "mappingKey":
                      case "mappingValue":
                        return W.content ? se("content") : "";
                      case "mappingItem":
                      case "flowMappingItem":
                        return _(W, ee, U, se, ne);
                      case "flowMapping":
                        return S(U, se, ne);
                      case "flowSequence":
                        return k(U, se, ne);
                      case "flowSequenceItem":
                        return se("content");
                      default:
                        throw new Error("Unexpected node type ".concat(W.type));
                    }
                  }
                  function H(W) {
                    return W.body.children.length > 0 || w(W.body);
                  }
                  function P(W, ee) {
                    return (
                      B(W) ||
                      (ee && (ee.head.children.length > 0 || w(ee.head)))
                    );
                  }
                  function G(W, ee, U, ne) {
                    return (U.children[0] === W &&
                      /---(?:\s|$)/.test(
                        ne.originalText.slice(h(W), h(W) + 4)
                      )) ||
                      W.head.children.length > 0 ||
                      w(W.head) ||
                      B(W.head)
                      ? "head"
                      : P(W, ee)
                      ? !1
                      : ee
                      ? "root"
                      : !1;
                  }
                  function re(W, ee, U) {
                    let ne = T(W, ee, U);
                    return u(
                      r,
                      ne.map((se) => s(C(u(a, se))))
                    );
                  }
                  function $(W, ee) {
                    if (D(ee))
                      switch ((delete ee.position, ee.type)) {
                        case "comment":
                          if (f(ee.value)) return null;
                          break;
                        case "quoteDouble":
                        case "quoteSingle":
                          ee.type = "quote";
                          break;
                      }
                  }
                  n.exports = {
                    preprocess: y,
                    embed: N,
                    print: R,
                    massageAstNode: $,
                    insertPragma: p,
                  };
                },
              }),
              sg = Z({
                "src/language-yaml/options.js"(e, n) {
                  "use strict";
                  ae();
                  var t = Lt();
                  n.exports = {
                    bracketSpacing: t.bracketSpacing,
                    singleQuote: t.singleQuote,
                    proseWrap: t.proseWrap,
                  };
                },
              }),
              ag = Z({
                "src/language-yaml/parsers.js"() {
                  ae();
                },
              }),
              ig = Z({
                "node_modules/linguist-languages/data/YAML.json"(e, n) {
                  n.exports = {
                    name: "YAML",
                    type: "data",
                    color: "#cb171e",
                    tmScope: "source.yaml",
                    aliases: ["yml"],
                    extensions: [
                      ".yml",
                      ".mir",
                      ".reek",
                      ".rviz",
                      ".sublime-syntax",
                      ".syntax",
                      ".yaml",
                      ".yaml-tmlanguage",
                      ".yaml.sed",
                      ".yml.mysql",
                    ],
                    filenames: [
                      ".clang-format",
                      ".clang-tidy",
                      ".gemrc",
                      "glide.lock",
                      "yarn.lock",
                    ],
                    aceMode: "yaml",
                    codemirrorMode: "yaml",
                    codemirrorMimeType: "text/x-yaml",
                    languageId: 407,
                  };
                },
              }),
              og = Z({
                "src/language-yaml/index.js"(e, n) {
                  "use strict";
                  ae();
                  var t = bt(),
                    s = ug(),
                    i = sg(),
                    r = ag(),
                    u = [
                      t(ig(), (a) => ({
                        since: "1.14.0",
                        parsers: ["yaml"],
                        vscodeLanguageIds: [
                          "yaml",
                          "ansible",
                          "home-assistant",
                        ],
                        filenames: [
                          ...a.filenames.filter((c) => c !== "yarn.lock"),
                          ".prettierrc",
                          ".stylelintrc",
                        ],
                      })),
                    ];
                  n.exports = {
                    languages: u,
                    printers: { yaml: s },
                    options: i,
                    parsers: r,
                  };
                },
              }),
              cg = Z({
                "src/languages.js"(e, n) {
                  "use strict";
                  ae(),
                    (n.exports = [$m(), id(), dd(), Fd(), wd(), Kd(), og()]);
                },
              });
            ae();
            var { version: lg } = gi(),
              _t = om(),
              { getSupportInfo: pg } = Mn(),
              fg = cm(),
              Dg = cg(),
              mg = Le();
            function St(e) {
              let n =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : 1;
              return function () {
                for (
                  var t = arguments.length, s = new Array(t), i = 0;
                  i < t;
                  i++
                )
                  s[i] = arguments[i];
                let r = s[n] || {},
                  u = r.plugins || [];
                return (
                  (s[n] = Object.assign(
                    Object.assign({}, r),
                    {},
                    {
                      plugins: [
                        ...Dg,
                        ...(Array.isArray(u) ? u : Object.values(u)),
                      ],
                    }
                  )),
                  e(...s)
                );
              };
            }
            var Sn = St(_t.formatWithCursor);
            yo.exports = {
              formatWithCursor: Sn,
              format(e, n) {
                return Sn(e, n).formatted;
              },
              check(e, n) {
                let { formatted: t } = Sn(e, n);
                return t === e;
              },
              doc: mg,
              getSupportInfo: St(pg, 0),
              version: lg,
              util: fg,
              __debug: {
                parse: St(_t.parse),
                formatAST: St(_t.formatAST),
                formatDoc: St(_t.formatDoc),
                printToDoc: St(_t.printToDoc),
                printDocToString: St(_t.printDocToString),
              },
            };
          });
          ("use strict");
          return dg();
        });

        /***/
      },

    /***/ "./src/loader.js":
      /*!***********************!*\
  !*** ./src/loader.js ***!
  \***********************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ UI: () => /* binding */ UI,
          /* harmony export */
        });
        /* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! prettier */ "./node_modules/prettier/standalone.js"
          );
        /* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            prettier__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _assets_search_svg__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./assets/search.svg */ "./src/assets/search.svg"
          );
        /* harmony import */ var _assets_cloudy_svg__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./assets/cloudy.svg */ "./src/assets/cloudy.svg"
          );

        let UI = (() => {
          function load() {
            loadSideBar();
            loadInfoBar();
          }

          function loadSideBar() {
            let aside = document.querySelector("aside");

            let searchButton = new Image();
            searchButton.className = "searchButton";
            searchButton.src = _assets_search_svg__WEBPACK_IMPORTED_MODULE_1__;
            searchButton.onclick = openSearchBar;
            aside.appendChild(searchButton);

            let cityName = document.createElement("div");
            cityName.className = "cityName";
            cityName.textContent = "Narnia";
            aside.appendChild(cityName);

            loadSearchBar(aside);
          }

          function loadSearchBar(aside) {
            let searchBar = document.createElement("div");
            searchBar.className = "searchBar";

            let searchText = document.createElement("INPUT");
            searchText.setAttribute("type", "text");
            searchBar.appendChild(searchText);

            aside.append(searchBar);
          }

          function loadInfoBar() {
            let main = document.querySelector("main");

            let otherInfo = document.createElement("div");
            otherInfo.className = "otherInfo";

            let timeInfo = document.createElement("div");
            timeInfo.textContent = "6:09 PM";
            timeInfo.className = "time";
            otherInfo.appendChild(timeInfo);

            let dateInfo = document.createElement("div");
            dateInfo.textContent = "31st February, 1911";
            dateInfo.className = "date";
            otherInfo.appendChild(dateInfo);

            main.appendChild(otherInfo);

            let description = document.createElement("div");
            description.className = "desc";
            description.textContent = "Sunny & Magical";

            let weatherInfo = document.createElement("div");
            weatherInfo.className = "weatherInfo";

            let temp = document.createElement("div");
            temp.className = "tempInfo";

            let tempIcon = new Image();
            tempIcon.className = "tempIcon";
            tempIcon.src = _assets_cloudy_svg__WEBPACK_IMPORTED_MODULE_2__;
            temp.appendChild(tempIcon);

            let tempText = document.createElement("div");
            tempText.className = "tempText";
            temp.textContent = "69° F";
            temp.appendChild(tempText);

            loadCFButton(main);
          }

          function loadCFButton(main) {
            let btn = document.createElement("label");
            btn.className = "switch";

            let btnInp = document.createElement("INPUT");
            btnInp.setAttribute("type", "checkbox");

            let slider = document.createElement("span");
            slider.className = "slider round";

            btn.appendChild(btnInp);
            btn.appendChild(slider);
            main.appendChild(btn);
          }

          let openSearchBar = () =>
            document.querySelector(".searchBar").classList.toggle("searchShow");

          return {
            load,
          };
        })();

        /***/
      },

    /***/ "./src/update.js":
      /*!***********************!*\
  !*** ./src/update.js ***!
  \***********************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ updater: () => /* binding */ updater,
          /* harmony export */
        });
        function updater() {}

        /***/
      },

    /***/ "./src/assets/cloudy.svg":
      /*!*******************************!*\
  !*** ./src/assets/cloudy.svg ***!
  \*******************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        "use strict";
        module.exports = __webpack_require__.p + "654c0bf34deca415e01b.svg";

        /***/
      },

    /***/ "./src/assets/search.svg":
      /*!*******************************!*\
  !*** ./src/assets/search.svg ***!
  \*******************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        "use strict";
        module.exports = __webpack_require__.p + "3afabfbf3f731a3bb722.svg";

        /***/
      },

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ // no module.id needed
      /******/ // no module.loaded needed
      /******/ exports: {},
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId](
      module,
      module.exports,
      __webpack_require__
    );
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/compat get default export */
  /******/ (() => {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = (module) => {
      /******/ var getter =
        module && module.__esModule
          ? /******/ () => module["default"]
          : /******/ () => module;
      /******/ __webpack_require__.d(getter, { a: getter });
      /******/ return getter;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (
          __webpack_require__.o(definition, key) &&
          !__webpack_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key],
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/global */
  /******/ (() => {
    /******/ __webpack_require__.g = (function () {
      /******/ if (typeof globalThis === "object") return globalThis;
      /******/ try {
        /******/ return this || new Function("return this")();
        /******/
      } catch (e) {
        /******/ if (typeof window === "object") return window;
        /******/
      }
      /******/
    })();
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __webpack_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = (exports) => {
      /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: "Module",
        });
        /******/
      }
      /******/ Object.defineProperty(exports, "__esModule", { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/publicPath */
  /******/ (() => {
    /******/ var scriptUrl;
    /******/ if (__webpack_require__.g.importScripts)
      scriptUrl = __webpack_require__.g.location + "";
    /******/ var document = __webpack_require__.g.document;
    /******/ if (!scriptUrl && document) {
      /******/ if (document.currentScript)
        /******/ scriptUrl = document.currentScript.src;
      /******/ if (!scriptUrl) {
        /******/ var scripts = document.getElementsByTagName("script");
        /******/ if (scripts.length)
          scriptUrl = scripts[scripts.length - 1].src;
        /******/
      }
      /******/
    }
    /******/ // When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
    /******/ // or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
    /******/ if (!scriptUrl)
      throw new Error("Automatic publicPath is not supported in this browser");
    /******/ scriptUrl = scriptUrl
      .replace(/#.*$/, "")
      .replace(/\?.*$/, "")
      .replace(/\/[^\/]+$/, "/");
    /******/ __webpack_require__.p = scriptUrl;
    /******/
  })();
  /******/
  /************************************************************************/
  var __webpack_exports__ = {};
  // This entry need to be wrapped in an IIFE because it need to be in strict mode.
  (() => {
    "use strict";
    /*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
    __webpack_require__.r(__webpack_exports__);
    /* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_0__ =
      __webpack_require__(/*! ./loader */ "./src/loader.js");
    /* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_1__ =
      __webpack_require__(/*! ./update */ "./src/update.js");

    _loader__WEBPACK_IMPORTED_MODULE_0__.UI.load();
  })();

  /******/
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0EsbUJBQW1CLCtDQUFNO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRWE7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0R2Q7O0FBRW1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVQ0ZuQjtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7Ozs7Ozs7Ozs7Ozs7QUNmOEI7QUFDSTs7QUFFbEMsNENBQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWF0aGVyLWFwcC8uL25vZGVfbW9kdWxlcy9wcmV0dGllci9zdGFuZGFsb25lLmpzIiwid2VicGFjazovL3dlYXRoZXItYXBwLy4vc3JjL2xvYWRlci5qcyIsIndlYnBhY2s6Ly93ZWF0aGVyLWFwcC8uL3NyYy91cGRhdGUuanMiLCJ3ZWJwYWNrOi8vd2VhdGhlci1hcHAvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vd2VhdGhlci1hcHAvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vd2VhdGhlci1hcHAvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3dlYXRoZXItYXBwL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vd2VhdGhlci1hcHAvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly93ZWF0aGVyLWFwcC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3dlYXRoZXItYXBwL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL3dlYXRoZXItYXBwLy4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihlKXtpZih0eXBlb2YgZXhwb3J0cz09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZT09XCJvYmplY3RcIiltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpZGVmaW5lKGUpO2Vsc2V7dmFyIGY9dHlwZW9mIGdsb2JhbFRoaXM8XCJ1XCI/Z2xvYmFsVGhpczp0eXBlb2YgZ2xvYmFsPFwidVwiP2dsb2JhbDp0eXBlb2Ygc2VsZjxcInVcIj9zZWxmOnRoaXN8fHt9O2YucHJldHRpZXI9ZSgpfX0pKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGJlPShlLG4pPT4oKT0+KG58fGUoKG49e2V4cG9ydHM6e319KS5leHBvcnRzLG4pLG4uZXhwb3J0cyk7dmFyIFllPWJlKCh5ZyxydSk9Pnt2YXIgZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuTWF0aD09TWF0aCYmZX07cnUuZXhwb3J0cz1lcih0eXBlb2YgZ2xvYmFsVGhpcz09XCJvYmplY3RcIiYmZ2xvYmFsVGhpcyl8fGVyKHR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCImJndpbmRvdyl8fGVyKHR5cGVvZiBzZWxmPT1cIm9iamVjdFwiJiZzZWxmKXx8ZXIodHlwZW9mIGdsb2JhbD09XCJvYmplY3RcIiYmZ2xvYmFsKXx8ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKXx8RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfSk7dmFyIGZ0PWJlKChoZyxudSk9PntudS5leHBvcnRzPWZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4hIWUoKX1jYXRjaHtyZXR1cm4hMH19fSk7dmFyIGh0PWJlKChDZyx1dSk9Pnt2YXIgdm89ZnQoKTt1dS5leHBvcnRzPSF2byhmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sMSx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSlbMV0hPTd9KX0pO3ZhciB0cj1iZSgoRWcsc3UpPT57dmFyIEZvPWZ0KCk7c3UuZXhwb3J0cz0hRm8oZnVuY3Rpb24oKXt2YXIgZT1mdW5jdGlvbigpe30uYmluZCgpO3JldHVybiB0eXBlb2YgZSE9XCJmdW5jdGlvblwifHxlLmhhc093blByb3BlcnR5KFwicHJvdG90eXBlXCIpfSl9KTt2YXIgQ3Q9YmUoKHZnLGF1KT0+e3ZhciBBbz10cigpLHJyPUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO2F1LmV4cG9ydHM9QW8/cnIuYmluZChycik6ZnVuY3Rpb24oKXtyZXR1cm4gcnIuYXBwbHkocnIsYXJndW1lbnRzKX19KTt2YXIgbHU9YmUoY3U9PntcInVzZSBzdHJpY3RcIjt2YXIgaXU9e30ucHJvcGVydHlJc0VudW1lcmFibGUsb3U9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixTbz1vdSYmIWl1LmNhbGwoezE6Mn0sMSk7Y3UuZj1Tbz9mdW5jdGlvbihuKXt2YXIgdD1vdSh0aGlzLG4pO3JldHVybiEhdCYmdC5lbnVtZXJhYmxlfTppdX0pO3ZhciBucj1iZSgoQWcscHUpPT57cHUuZXhwb3J0cz1mdW5jdGlvbihlLG4pe3JldHVybntlbnVtZXJhYmxlOiEoZSYxKSxjb25maWd1cmFibGU6IShlJjIpLHdyaXRhYmxlOiEoZSY0KSx2YWx1ZTpufX19KTt2YXIgYXQ9YmUoKFNnLG11KT0+e3ZhciBmdT10cigpLER1PUZ1bmN0aW9uLnByb3RvdHlwZSx4bz1EdS5iaW5kLExyPUR1LmNhbGwsYm89ZnUmJnhvLmJpbmQoTHIsTHIpO211LmV4cG9ydHM9ZnU/ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmJvKGUpfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmZnVuY3Rpb24oKXtyZXR1cm4gTHIuYXBwbHkoZSxhcmd1bWVudHMpfX19KTt2YXIgdXI9YmUoKHhnLGd1KT0+e3ZhciBkdT1hdCgpLFRvPWR1KHt9LnRvU3RyaW5nKSxCbz1kdShcIlwiLnNsaWNlKTtndS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBCbyhUbyhlKSw4LC0xKX19KTt2YXIgaHU9YmUoKGJnLHl1KT0+e3ZhciBObz1ZZSgpLHdvPWF0KCksX289ZnQoKSxQbz11cigpLE9yPU5vLk9iamVjdCxJbz13byhcIlwiLnNwbGl0KTt5dS5leHBvcnRzPV9vKGZ1bmN0aW9uKCl7cmV0dXJuIU9yKFwielwiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKX0pP2Z1bmN0aW9uKGUpe3JldHVybiBQbyhlKT09XCJTdHJpbmdcIj9JbyhlLFwiXCIpOk9yKGUpfTpPcn0pO3ZhciBqcj1iZSgoVGcsQ3UpPT57dmFyIGtvPVllKCksTG89a28uVHlwZUVycm9yO0N1LmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoZT09bnVsbCl0aHJvdyBMbyhcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiK2UpO3JldHVybiBlfX0pO3ZhciBzcj1iZSgoQmcsRXUpPT57dmFyIE9vPWh1KCksam89anIoKTtFdS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBPbyhqbyhlKSl9fSk7dmFyIGl0PWJlKChOZyx2dSk9Pnt2dS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZT09XCJmdW5jdGlvblwifX0pO3ZhciBFdD1iZSgod2csRnUpPT57dmFyIHFvPWl0KCk7RnUuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGU9PVwib2JqZWN0XCI/ZSE9PW51bGw6cW8oZSl9fSk7dmFyIE10PWJlKChfZyxBdSk9Pnt2YXIgcXI9WWUoKSxNbz1pdCgpLFJvPWZ1bmN0aW9uKGUpe3JldHVybiBNbyhlKT9lOnZvaWQgMH07QXUuZXhwb3J0cz1mdW5jdGlvbihlLG4pe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPDI/Um8ocXJbZV0pOnFyW2VdJiZxcltlXVtuXX19KTt2YXIgTXI9YmUoKFBnLFN1KT0+e3ZhciBWbz1hdCgpO1N1LmV4cG9ydHM9Vm8oe30uaXNQcm90b3R5cGVPZil9KTt2YXIgYnU9YmUoKElnLHh1KT0+e3ZhciBXbz1NdCgpO3h1LmV4cG9ydHM9V28oXCJuYXZpZ2F0b3JcIixcInVzZXJBZ2VudFwiKXx8XCJcIn0pO3ZhciBJdT1iZSgoa2csUHUpPT57dmFyIF91PVllKCksUnI9YnUoKSxUdT1fdS5wcm9jZXNzLEJ1PV91LkRlbm8sTnU9VHUmJlR1LnZlcnNpb25zfHxCdSYmQnUudmVyc2lvbix3dT1OdSYmTnUudjgsbHQsYXI7d3UmJihsdD13dS5zcGxpdChcIi5cIiksYXI9bHRbMF0+MCYmbHRbMF08ND8xOisobHRbMF0rbHRbMV0pKTshYXImJlJyJiYobHQ9UnIubWF0Y2goL0VkZ2VcXC8oXFxkKykvKSwoIWx0fHxsdFsxXT49NzQpJiYobHQ9UnIubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pLGx0JiYoYXI9K2x0WzFdKSkpO1B1LmV4cG9ydHM9YXJ9KTt2YXIgVnI9YmUoKExnLEx1KT0+e3ZhciBrdT1JdSgpLCRvPWZ0KCk7THUuZXhwb3J0cz0hIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJiEkbyhmdW5jdGlvbigpe3ZhciBlPVN5bWJvbCgpO3JldHVybiFTdHJpbmcoZSl8fCEoT2JqZWN0KGUpaW5zdGFuY2VvZiBTeW1ib2wpfHwhU3ltYm9sLnNoYW0mJmt1JiZrdTw0MX0pfSk7dmFyIFdyPWJlKChPZyxPdSk9Pnt2YXIgSG89VnIoKTtPdS5leHBvcnRzPUhvJiYhU3ltYm9sLnNoYW0mJnR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PVwic3ltYm9sXCJ9KTt2YXIgJHI9YmUoKGpnLGp1KT0+e3ZhciBHbz1ZZSgpLEpvPU10KCksVW89aXQoKSx6bz1NcigpLFhvPVdyKCksS289R28uT2JqZWN0O2p1LmV4cG9ydHM9WG8/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlPT1cInN5bWJvbFwifTpmdW5jdGlvbihlKXt2YXIgbj1KbyhcIlN5bWJvbFwiKTtyZXR1cm4gVW8obikmJnpvKG4ucHJvdG90eXBlLEtvKGUpKX19KTt2YXIgaXI9YmUoKHFnLHF1KT0+e3ZhciBZbz1ZZSgpLFFvPVlvLlN0cmluZztxdS5leHBvcnRzPWZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4gUW8oZSl9Y2F0Y2h7cmV0dXJuXCJPYmplY3RcIn19fSk7dmFyIFJ0PWJlKChNZyxNdSk9Pnt2YXIgWm89WWUoKSxlYz1pdCgpLHRjPWlyKCkscmM9Wm8uVHlwZUVycm9yO011LmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoZWMoZSkpcmV0dXJuIGU7dGhyb3cgcmModGMoZSkrXCIgaXMgbm90IGEgZnVuY3Rpb25cIil9fSk7dmFyIG9yPWJlKChSZyxSdSk9Pnt2YXIgbmM9UnQoKTtSdS5leHBvcnRzPWZ1bmN0aW9uKGUsbil7dmFyIHQ9ZVtuXTtyZXR1cm4gdD09bnVsbD92b2lkIDA6bmModCl9fSk7dmFyIFd1PWJlKChWZyxWdSk9Pnt2YXIgdWM9WWUoKSxIcj1DdCgpLEdyPWl0KCksSnI9RXQoKSxzYz11Yy5UeXBlRXJyb3I7VnUuZXhwb3J0cz1mdW5jdGlvbihlLG4pe3ZhciB0LHM7aWYobj09PVwic3RyaW5nXCImJkdyKHQ9ZS50b1N0cmluZykmJiFKcihzPUhyKHQsZSkpfHxHcih0PWUudmFsdWVPZikmJiFKcihzPUhyKHQsZSkpfHxuIT09XCJzdHJpbmdcIiYmR3IodD1lLnRvU3RyaW5nKSYmIUpyKHM9SHIodCxlKSkpcmV0dXJuIHM7dGhyb3cgc2MoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9fSk7dmFyIEh1PWJlKChXZywkdSk9PnskdS5leHBvcnRzPSExfSk7dmFyIGNyPWJlKCgkZyxKdSk9Pnt2YXIgR3U9WWUoKSxhYz1PYmplY3QuZGVmaW5lUHJvcGVydHk7SnUuZXhwb3J0cz1mdW5jdGlvbihlLG4pe3RyeXthYyhHdSxlLHt2YWx1ZTpuLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pfWNhdGNoe0d1W2VdPW59cmV0dXJuIG59fSk7dmFyIGxyPWJlKChIZyx6dSk9Pnt2YXIgaWM9WWUoKSxvYz1jcigpLFV1PVwiX19jb3JlLWpzX3NoYXJlZF9fXCIsY2M9aWNbVXVdfHxvYyhVdSx7fSk7enUuZXhwb3J0cz1jY30pO3ZhciBVcj1iZSgoR2csS3UpPT57dmFyIGxjPUh1KCksWHU9bHIoKTsoS3UuZXhwb3J0cz1mdW5jdGlvbihlLG4pe3JldHVybiBYdVtlXXx8KFh1W2VdPW4hPT12b2lkIDA/bjp7fSl9KShcInZlcnNpb25zXCIsW10pLnB1c2goe3ZlcnNpb246XCIzLjIxLjFcIixtb2RlOmxjP1wicHVyZVwiOlwiZ2xvYmFsXCIsY29weXJpZ2h0OlwiXFx4QTkgMjAxNC0yMDIyIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpXCIsbGljZW5zZTpcImh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuMjEuMS9MSUNFTlNFXCIsc291cmNlOlwiaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanNcIn0pfSk7dmFyIHByPWJlKChKZyxZdSk9Pnt2YXIgcGM9WWUoKSxmYz1qcigpLERjPXBjLk9iamVjdDtZdS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBEYyhmYyhlKSl9fSk7dmFyIG10PWJlKChVZyxRdSk9Pnt2YXIgbWM9YXQoKSxkYz1wcigpLGdjPW1jKHt9Lmhhc093blByb3BlcnR5KTtRdS5leHBvcnRzPU9iamVjdC5oYXNPd258fGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGdjKGRjKG4pLHQpfX0pO3ZhciB6cj1iZSgoemcsWnUpPT57dmFyIHljPWF0KCksaGM9MCxDYz1NYXRoLnJhbmRvbSgpLEVjPXljKDEgLnRvU3RyaW5nKTtadS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVyblwiU3ltYm9sKFwiKyhlPT09dm9pZCAwP1wiXCI6ZSkrXCIpX1wiK0VjKCsraGMrQ2MsMzYpfX0pO3ZhciBGdD1iZSgoWGcsdXMpPT57dmFyIHZjPVllKCksRmM9VXIoKSxlcz1tdCgpLEFjPXpyKCksdHM9VnIoKSxucz1XcigpLFR0PUZjKFwid2tzXCIpLHZ0PXZjLlN5bWJvbCxycz12dCYmdnQuZm9yLFNjPW5zP3Z0OnZ0JiZ2dC53aXRob3V0U2V0dGVyfHxBYzt1cy5leHBvcnRzPWZ1bmN0aW9uKGUpe2lmKCFlcyhUdCxlKXx8ISh0c3x8dHlwZW9mIFR0W2VdPT1cInN0cmluZ1wiKSl7dmFyIG49XCJTeW1ib2wuXCIrZTt0cyYmZXModnQsZSk/VHRbZV09dnRbZV06bnMmJnJzP1R0W2VdPXJzKG4pOlR0W2VdPVNjKG4pfXJldHVybiBUdFtlXX19KTt2YXIgb3M9YmUoKEtnLGlzKT0+e3ZhciB4Yz1ZZSgpLGJjPUN0KCksc3M9RXQoKSxhcz0kcigpLFRjPW9yKCksQmM9V3UoKSxOYz1GdCgpLHdjPXhjLlR5cGVFcnJvcixfYz1OYyhcInRvUHJpbWl0aXZlXCIpO2lzLmV4cG9ydHM9ZnVuY3Rpb24oZSxuKXtpZighc3MoZSl8fGFzKGUpKXJldHVybiBlO3ZhciB0PVRjKGUsX2MpLHM7aWYodCl7aWYobj09PXZvaWQgMCYmKG49XCJkZWZhdWx0XCIpLHM9YmModCxlLG4pLCFzcyhzKXx8YXMocykpcmV0dXJuIHM7dGhyb3cgd2MoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9cmV0dXJuIG49PT12b2lkIDAmJihuPVwibnVtYmVyXCIpLEJjKGUsbil9fSk7dmFyIGZyPWJlKChZZyxjcyk9Pnt2YXIgUGM9b3MoKSxJYz0kcigpO2NzLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIG49UGMoZSxcInN0cmluZ1wiKTtyZXR1cm4gSWMobik/bjpuK1wiXCJ9fSk7dmFyIGZzPWJlKChRZyxwcyk9Pnt2YXIga2M9WWUoKSxscz1FdCgpLFhyPWtjLmRvY3VtZW50LExjPWxzKFhyKSYmbHMoWHIuY3JlYXRlRWxlbWVudCk7cHMuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gTGM/WHIuY3JlYXRlRWxlbWVudChlKTp7fX19KTt2YXIgS3I9YmUoKFpnLERzKT0+e3ZhciBPYz1odCgpLGpjPWZ0KCkscWM9ZnMoKTtEcy5leHBvcnRzPSFPYyYmIWpjKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShxYyhcImRpdlwiKSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSk7dmFyIFlyPWJlKGRzPT57dmFyIE1jPWh0KCksUmM9Q3QoKSxWYz1sdSgpLFdjPW5yKCksJGM9c3IoKSxIYz1mcigpLEdjPW10KCksSmM9S3IoKSxtcz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2RzLmY9TWM/bXM6ZnVuY3Rpb24obix0KXtpZihuPSRjKG4pLHQ9SGModCksSmMpdHJ5e3JldHVybiBtcyhuLHQpfWNhdGNoe31pZihHYyhuLHQpKXJldHVybiBXYyghUmMoVmMuZixuLHQpLG5bdF0pfX0pO3ZhciB5cz1iZSgodDAsZ3MpPT57dmFyIFVjPWh0KCksemM9ZnQoKTtncy5leHBvcnRzPVVjJiZ6YyhmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24oKXt9LFwicHJvdG90eXBlXCIse3ZhbHVlOjQyLHdyaXRhYmxlOiExfSkucHJvdG90eXBlIT00Mn0pfSk7dmFyIEJ0PWJlKChyMCxDcyk9Pnt2YXIgaHM9WWUoKSxYYz1FdCgpLEtjPWhzLlN0cmluZyxZYz1ocy5UeXBlRXJyb3I7Q3MuZXhwb3J0cz1mdW5jdGlvbihlKXtpZihYYyhlKSlyZXR1cm4gZTt0aHJvdyBZYyhLYyhlKStcIiBpcyBub3QgYW4gb2JqZWN0XCIpfX0pO3ZhciBtcj1iZSh2cz0+e3ZhciBRYz1ZZSgpLFpjPWh0KCksZWw9S3IoKSx0bD15cygpLERyPUJ0KCksRXM9ZnIoKSxybD1RYy5UeXBlRXJyb3IsUXI9T2JqZWN0LmRlZmluZVByb3BlcnR5LG5sPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsWnI9XCJlbnVtZXJhYmxlXCIsZW49XCJjb25maWd1cmFibGVcIix0bj1cIndyaXRhYmxlXCI7dnMuZj1aYz90bD9mdW5jdGlvbihuLHQscyl7aWYoRHIobiksdD1Fcyh0KSxEcihzKSx0eXBlb2Ygbj09XCJmdW5jdGlvblwiJiZ0PT09XCJwcm90b3R5cGVcIiYmXCJ2YWx1ZVwiaW4gcyYmdG4gaW4gcyYmIXNbdG5dKXt2YXIgaT1ubChuLHQpO2kmJmlbdG5dJiYoblt0XT1zLnZhbHVlLHM9e2NvbmZpZ3VyYWJsZTplbiBpbiBzP3NbZW5dOmlbZW5dLGVudW1lcmFibGU6WnIgaW4gcz9zW1pyXTppW1pyXSx3cml0YWJsZTohMX0pfXJldHVybiBRcihuLHQscyl9OlFyOmZ1bmN0aW9uKG4sdCxzKXtpZihEcihuKSx0PUVzKHQpLERyKHMpLGVsKXRyeXtyZXR1cm4gUXIobix0LHMpfWNhdGNoe31pZihcImdldFwiaW4gc3x8XCJzZXRcImluIHMpdGhyb3cgcmwoXCJBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm5cInZhbHVlXCJpbiBzJiYoblt0XT1zLnZhbHVlKSxufX0pO3ZhciBkcj1iZSgodTAsRnMpPT57dmFyIHVsPWh0KCksc2w9bXIoKSxhbD1ucigpO0ZzLmV4cG9ydHM9dWw/ZnVuY3Rpb24oZSxuLHQpe3JldHVybiBzbC5mKGUsbixhbCgxLHQpKX06ZnVuY3Rpb24oZSxuLHQpe3JldHVybiBlW25dPXQsZX19KTt2YXIgZ3I9YmUoKHMwLEFzKT0+e3ZhciBpbD1hdCgpLG9sPWl0KCkscm49bHIoKSxjbD1pbChGdW5jdGlvbi50b1N0cmluZyk7b2wocm4uaW5zcGVjdFNvdXJjZSl8fChybi5pbnNwZWN0U291cmNlPWZ1bmN0aW9uKGUpe3JldHVybiBjbChlKX0pO0FzLmV4cG9ydHM9cm4uaW5zcGVjdFNvdXJjZX0pO3ZhciBicz1iZSgoYTAseHMpPT57dmFyIGxsPVllKCkscGw9aXQoKSxmbD1ncigpLFNzPWxsLldlYWtNYXA7eHMuZXhwb3J0cz1wbChTcykmJi9uYXRpdmUgY29kZS8udGVzdChmbChTcykpfSk7dmFyIE5zPWJlKChpMCxCcyk9Pnt2YXIgRGw9VXIoKSxtbD16cigpLFRzPURsKFwia2V5c1wiKTtCcy5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBUc1tlXXx8KFRzW2VdPW1sKGUpKX19KTt2YXIgbm49YmUoKG8wLHdzKT0+e3dzLmV4cG9ydHM9e319KTt2YXIgT3M9YmUoKGMwLExzKT0+e3ZhciBkbD1icygpLGtzPVllKCksdW49YXQoKSxnbD1FdCgpLHlsPWRyKCksc249bXQoKSxhbj1scigpLGhsPU5zKCksQ2w9bm4oKSxfcz1cIk9iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkXCIsY249a3MuVHlwZUVycm9yLEVsPWtzLldlYWtNYXAseXIsVnQsaHIsdmw9ZnVuY3Rpb24oZSl7cmV0dXJuIGhyKGUpP1Z0KGUpOnlyKGUse30pfSxGbD1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24obil7dmFyIHQ7aWYoIWdsKG4pfHwodD1WdChuKSkudHlwZSE9PWUpdGhyb3cgY24oXCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsIFwiK2UrXCIgcmVxdWlyZWRcIik7cmV0dXJuIHR9fTtkbHx8YW4uc3RhdGU/KGR0PWFuLnN0YXRlfHwoYW4uc3RhdGU9bmV3IEVsKSxQcz11bihkdC5nZXQpLG9uPXVuKGR0LmhhcyksSXM9dW4oZHQuc2V0KSx5cj1mdW5jdGlvbihlLG4pe2lmKG9uKGR0LGUpKXRocm93IG5ldyBjbihfcyk7cmV0dXJuIG4uZmFjYWRlPWUsSXMoZHQsZSxuKSxufSxWdD1mdW5jdGlvbihlKXtyZXR1cm4gUHMoZHQsZSl8fHt9fSxocj1mdW5jdGlvbihlKXtyZXR1cm4gb24oZHQsZSl9KTooQXQ9aGwoXCJzdGF0ZVwiKSxDbFtBdF09ITAseXI9ZnVuY3Rpb24oZSxuKXtpZihzbihlLEF0KSl0aHJvdyBuZXcgY24oX3MpO3JldHVybiBuLmZhY2FkZT1lLHlsKGUsQXQsbiksbn0sVnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHNuKGUsQXQpP2VbQXRdOnt9fSxocj1mdW5jdGlvbihlKXtyZXR1cm4gc24oZSxBdCl9KTt2YXIgZHQsUHMsb24sSXMsQXQ7THMuZXhwb3J0cz17c2V0OnlyLGdldDpWdCxoYXM6aHIsZW5mb3JjZTp2bCxnZXR0ZXJGb3I6Rmx9fSk7dmFyIE1zPWJlKChsMCxxcyk9Pnt2YXIgbG49aHQoKSxBbD1tdCgpLGpzPUZ1bmN0aW9uLnByb3RvdHlwZSxTbD1sbiYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixwbj1BbChqcyxcIm5hbWVcIikseGw9cG4mJmZ1bmN0aW9uKCl7fS5uYW1lPT09XCJzb21ldGhpbmdcIixibD1wbiYmKCFsbnx8bG4mJlNsKGpzLFwibmFtZVwiKS5jb25maWd1cmFibGUpO3FzLmV4cG9ydHM9e0VYSVNUUzpwbixQUk9QRVI6eGwsQ09ORklHVVJBQkxFOmJsfX0pO3ZhciBIcz1iZSgocDAsJHMpPT57dmFyIFRsPVllKCksUnM9aXQoKSxCbD1tdCgpLFZzPWRyKCksTmw9Y3IoKSx3bD1ncigpLFdzPU9zKCksX2w9TXMoKS5DT05GSUdVUkFCTEUsUGw9V3MuZ2V0LElsPVdzLmVuZm9yY2Usa2w9U3RyaW5nKFN0cmluZykuc3BsaXQoXCJTdHJpbmdcIik7KCRzLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHQscyl7dmFyIGk9cz8hIXMudW5zYWZlOiExLHI9cz8hIXMuZW51bWVyYWJsZTohMSx1PXM/ISFzLm5vVGFyZ2V0R2V0OiExLGE9cyYmcy5uYW1lIT09dm9pZCAwP3MubmFtZTpuLGM7aWYoUnModCkmJihTdHJpbmcoYSkuc2xpY2UoMCw3KT09PVwiU3ltYm9sKFwiJiYoYT1cIltcIitTdHJpbmcoYSkucmVwbGFjZSgvXlN5bWJvbFxcKChbXildKilcXCkvLFwiJDFcIikrXCJdXCIpLCghQmwodCxcIm5hbWVcIil8fF9sJiZ0Lm5hbWUhPT1hKSYmVnModCxcIm5hbWVcIixhKSxjPUlsKHQpLGMuc291cmNlfHwoYy5zb3VyY2U9a2wuam9pbih0eXBlb2YgYT09XCJzdHJpbmdcIj9hOlwiXCIpKSksZT09PVRsKXtyP2Vbbl09dDpObChuLHQpO3JldHVybn1lbHNlIGk/IXUmJmVbbl0mJihyPSEwKTpkZWxldGUgZVtuXTtyP2Vbbl09dDpWcyhlLG4sdCl9KShGdW5jdGlvbi5wcm90b3R5cGUsXCJ0b1N0cmluZ1wiLGZ1bmN0aW9uKCl7cmV0dXJuIFJzKHRoaXMpJiZQbCh0aGlzKS5zb3VyY2V8fHdsKHRoaXMpfSl9KTt2YXIgQ3I9YmUoKGYwLEdzKT0+e3ZhciBMbD1NYXRoLmNlaWwsT2w9TWF0aC5mbG9vcjtHcy5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciBuPStlO3JldHVybiBuIT09bnx8bj09PTA/MDoobj4wP09sOkxsKShuKX19KTt2YXIgVXM9YmUoKEQwLEpzKT0+e3ZhciBqbD1DcigpLHFsPU1hdGgubWF4LE1sPU1hdGgubWluO0pzLmV4cG9ydHM9ZnVuY3Rpb24oZSxuKXt2YXIgdD1qbChlKTtyZXR1cm4gdDwwP3FsKHQrbiwwKTpNbCh0LG4pfX0pO3ZhciBYcz1iZSgobTAsenMpPT57dmFyIFJsPUNyKCksVmw9TWF0aC5taW47enMuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gZT4wP1ZsKFJsKGUpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSk7dmFyIE50PWJlKChkMCxLcyk9Pnt2YXIgV2w9WHMoKTtLcy5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBXbChlLmxlbmd0aCl9fSk7dmFyIFpzPWJlKChnMCxRcyk9Pnt2YXIgJGw9c3IoKSxIbD1VcygpLEdsPU50KCksWXM9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKG4sdCxzKXt2YXIgaT0kbChuKSxyPUdsKGkpLHU9SGwocyxyKSxhO2lmKGUmJnQhPXQpe2Zvcig7cj51OylpZihhPWlbdSsrXSxhIT1hKXJldHVybiEwfWVsc2UgZm9yKDtyPnU7dSsrKWlmKChlfHx1IGluIGkpJiZpW3VdPT09dClyZXR1cm4gZXx8dXx8MDtyZXR1cm4hZSYmLTF9fTtRcy5leHBvcnRzPXtpbmNsdWRlczpZcyghMCksaW5kZXhPZjpZcyghMSl9fSk7dmFyIHJhPWJlKCh5MCx0YSk9Pnt2YXIgSmw9YXQoKSxmbj1tdCgpLFVsPXNyKCksemw9WnMoKS5pbmRleE9mLFhsPW5uKCksZWE9SmwoW10ucHVzaCk7dGEuZXhwb3J0cz1mdW5jdGlvbihlLG4pe3ZhciB0PVVsKGUpLHM9MCxpPVtdLHI7Zm9yKHIgaW4gdCkhZm4oWGwscikmJmZuKHQscikmJmVhKGkscik7Zm9yKDtuLmxlbmd0aD5zOylmbih0LHI9bltzKytdKSYmKH56bChpLHIpfHxlYShpLHIpKTtyZXR1cm4gaX19KTt2YXIgdWE9YmUoKGgwLG5hKT0+e25hLmV4cG9ydHM9W1wiY29uc3RydWN0b3JcIixcImhhc093blByb3BlcnR5XCIsXCJpc1Byb3RvdHlwZU9mXCIsXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLFwidG9Mb2NhbGVTdHJpbmdcIixcInRvU3RyaW5nXCIsXCJ2YWx1ZU9mXCJdfSk7dmFyIGFhPWJlKHNhPT57dmFyIEtsPXJhKCksWWw9dWEoKSxRbD1ZbC5jb25jYXQoXCJsZW5ndGhcIixcInByb3RvdHlwZVwiKTtzYS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbihuKXtyZXR1cm4gS2wobixRbCl9fSk7dmFyIG9hPWJlKGlhPT57aWEuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSk7dmFyIGxhPWJlKCh2MCxjYSk9Pnt2YXIgWmw9TXQoKSxlcD1hdCgpLHRwPWFhKCkscnA9b2EoKSxucD1CdCgpLHVwPWVwKFtdLmNvbmNhdCk7Y2EuZXhwb3J0cz1abChcIlJlZmxlY3RcIixcIm93bktleXNcIil8fGZ1bmN0aW9uKG4pe3ZhciB0PXRwLmYobnAobikpLHM9cnAuZjtyZXR1cm4gcz91cCh0LHMobikpOnR9fSk7dmFyIERhPWJlKChGMCxmYSk9Pnt2YXIgcGE9bXQoKSxzcD1sYSgpLGFwPVlyKCksaXA9bXIoKTtmYS5leHBvcnRzPWZ1bmN0aW9uKGUsbix0KXtmb3IodmFyIHM9c3AobiksaT1pcC5mLHI9YXAuZix1PTA7dTxzLmxlbmd0aDt1Kyspe3ZhciBhPXNbdV07IXBhKGUsYSkmJiEodCYmcGEodCxhKSkmJmkoZSxhLHIobixhKSl9fX0pO3ZhciBkYT1iZSgoQTAsbWEpPT57dmFyIG9wPWZ0KCksY3A9aXQoKSxscD0vI3xcXC5wcm90b3R5cGVcXC4vLFd0PWZ1bmN0aW9uKGUsbil7dmFyIHQ9ZnBbcHAoZSldO3JldHVybiB0PT1tcD8hMDp0PT1EcD8hMTpjcChuKT9vcChuKTohIW59LHBwPVd0Lm5vcm1hbGl6ZT1mdW5jdGlvbihlKXtyZXR1cm4gU3RyaW5nKGUpLnJlcGxhY2UobHAsXCIuXCIpLnRvTG93ZXJDYXNlKCl9LGZwPVd0LmRhdGE9e30sRHA9V3QuTkFUSVZFPVwiTlwiLG1wPVd0LlBPTFlGSUxMPVwiUFwiO21hLmV4cG9ydHM9V3R9KTt2YXIgJHQ9YmUoKFMwLGdhKT0+e3ZhciBEbj1ZZSgpLGRwPVlyKCkuZixncD1kcigpLHlwPUhzKCksaHA9Y3IoKSxDcD1EYSgpLEVwPWRhKCk7Z2EuZXhwb3J0cz1mdW5jdGlvbihlLG4pe3ZhciB0PWUudGFyZ2V0LHM9ZS5nbG9iYWwsaT1lLnN0YXQscix1LGEsYyxsLEM7aWYocz91PURuOmk/dT1Eblt0XXx8aHAodCx7fSk6dT0oRG5bdF18fHt9KS5wcm90b3R5cGUsdSlmb3IoYSBpbiBuKXtpZihsPW5bYV0sZS5ub1RhcmdldEdldD8oQz1kcCh1LGEpLGM9QyYmQy52YWx1ZSk6Yz11W2FdLHI9RXAocz9hOnQrKGk/XCIuXCI6XCIjXCIpK2EsZS5mb3JjZWQpLCFyJiZjIT09dm9pZCAwKXtpZih0eXBlb2YgbD09dHlwZW9mIGMpY29udGludWU7Q3AobCxjKX0oZS5zaGFtfHxjJiZjLnNoYW0pJiZncChsLFwic2hhbVwiLCEwKSx5cCh1LGEsbCxlKX19fSk7dmFyIG1uPWJlKCh4MCx5YSk9Pnt2YXIgdnA9dXIoKTt5YS5leHBvcnRzPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKG4pe3JldHVybiB2cChuKT09XCJBcnJheVwifX0pO3ZhciBkbj1iZSgoYjAsQ2EpPT57dmFyIGhhPWF0KCksRnA9UnQoKSxBcD10cigpLFNwPWhhKGhhLmJpbmQpO0NhLmV4cG9ydHM9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gRnAoZSksbj09PXZvaWQgMD9lOkFwP1NwKGUsbik6ZnVuY3Rpb24oKXtyZXR1cm4gZS5hcHBseShuLGFyZ3VtZW50cyl9fX0pO3ZhciBnbj1iZSgoVDAsdmEpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHhwPVllKCksYnA9bW4oKSxUcD1OdCgpLEJwPWRuKCksTnA9eHAuVHlwZUVycm9yLEVhPWZ1bmN0aW9uKGUsbix0LHMsaSxyLHUsYSl7Zm9yKHZhciBjPWksbD0wLEM9dT9CcCh1LGEpOiExLG0sZztsPHM7KXtpZihsIGluIHQpe2lmKG09Qz9DKHRbbF0sbCxuKTp0W2xdLHI+MCYmYnAobSkpZz1UcChtKSxjPUVhKGUsbixtLGcsYyxyLTEpLTE7ZWxzZXtpZihjPj05MDA3MTk5MjU0NzQwOTkxKXRocm93IE5wKFwiRXhjZWVkIHRoZSBhY2NlcHRhYmxlIGFycmF5IGxlbmd0aFwiKTtlW2NdPW19YysrfWwrK31yZXR1cm4gY307dmEuZXhwb3J0cz1FYX0pO3ZhciBTYT1iZSgoQjAsQWEpPT57dmFyIHdwPUZ0KCksX3A9d3AoXCJ0b1N0cmluZ1RhZ1wiKSxGYT17fTtGYVtfcF09XCJ6XCI7QWEuZXhwb3J0cz1TdHJpbmcoRmEpPT09XCJbb2JqZWN0IHpdXCJ9KTt2YXIgeW49YmUoKE4wLHhhKT0+e3ZhciBQcD1ZZSgpLElwPVNhKCksa3A9aXQoKSxFcj11cigpLExwPUZ0KCksT3A9THAoXCJ0b1N0cmluZ1RhZ1wiKSxqcD1QcC5PYmplY3QscXA9RXIoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT09XCJBcmd1bWVudHNcIixNcD1mdW5jdGlvbihlLG4pe3RyeXtyZXR1cm4gZVtuXX1jYXRjaHt9fTt4YS5leHBvcnRzPUlwP0VyOmZ1bmN0aW9uKGUpe3ZhciBuLHQscztyZXR1cm4gZT09PXZvaWQgMD9cIlVuZGVmaW5lZFwiOmU9PT1udWxsP1wiTnVsbFwiOnR5cGVvZih0PU1wKG49anAoZSksT3ApKT09XCJzdHJpbmdcIj90OnFwP0VyKG4pOihzPUVyKG4pKT09XCJPYmplY3RcIiYma3Aobi5jYWxsZWUpP1wiQXJndW1lbnRzXCI6c319KTt2YXIgX2E9YmUoKHcwLHdhKT0+e3ZhciBScD1hdCgpLFZwPWZ0KCksYmE9aXQoKSxXcD15bigpLCRwPU10KCksSHA9Z3IoKSxUYT1mdW5jdGlvbigpe30sR3A9W10sQmE9JHAoXCJSZWZsZWN0XCIsXCJjb25zdHJ1Y3RcIiksaG49L15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLyxKcD1ScChobi5leGVjKSxVcD0haG4uZXhlYyhUYSksSHQ9ZnVuY3Rpb24obil7aWYoIWJhKG4pKXJldHVybiExO3RyeXtyZXR1cm4gQmEoVGEsR3AsbiksITB9Y2F0Y2h7cmV0dXJuITF9fSxOYT1mdW5jdGlvbihuKXtpZighYmEobikpcmV0dXJuITE7c3dpdGNoKFdwKG4pKXtjYXNlXCJBc3luY0Z1bmN0aW9uXCI6Y2FzZVwiR2VuZXJhdG9yRnVuY3Rpb25cIjpjYXNlXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCI6cmV0dXJuITF9dHJ5e3JldHVybiBVcHx8ISFKcChobixIcChuKSl9Y2F0Y2h7cmV0dXJuITB9fTtOYS5zaGFtPSEwO3dhLmV4cG9ydHM9IUJhfHxWcChmdW5jdGlvbigpe3ZhciBlO3JldHVybiBIdChIdC5jYWxsKXx8IUh0KE9iamVjdCl8fCFIdChmdW5jdGlvbigpe2U9ITB9KXx8ZX0pP05hOkh0fSk7dmFyIExhPWJlKChfMCxrYSk9Pnt2YXIgenA9WWUoKSxQYT1tbigpLFhwPV9hKCksS3A9RXQoKSxZcD1GdCgpLFFwPVlwKFwic3BlY2llc1wiKSxJYT16cC5BcnJheTtrYS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciBuO3JldHVybiBQYShlKSYmKG49ZS5jb25zdHJ1Y3RvcixYcChuKSYmKG49PT1JYXx8UGEobi5wcm90b3R5cGUpKT9uPXZvaWQgMDpLcChuKSYmKG49bltRcF0sbj09PW51bGwmJihuPXZvaWQgMCkpKSxuPT09dm9pZCAwP0lhOm59fSk7dmFyIENuPWJlKChQMCxPYSk9Pnt2YXIgWnA9TGEoKTtPYS5leHBvcnRzPWZ1bmN0aW9uKGUsbil7cmV0dXJuIG5ldyhacChlKSkobj09PTA/MDpuKX19KTt2YXIgamE9YmUoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZWY9JHQoKSx0Zj1nbigpLHJmPVJ0KCksbmY9cHIoKSx1Zj1OdCgpLHNmPUNuKCk7ZWYoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITB9LHtmbGF0TWFwOmZ1bmN0aW9uKG4pe3ZhciB0PW5mKHRoaXMpLHM9dWYodCksaTtyZXR1cm4gcmYobiksaT1zZih0LDApLGkubGVuZ3RoPXRmKGksdCx0LHMsMCwxLG4sYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApLGl9fSl9KTt2YXIgRW49YmUoKEwwLHFhKT0+e3FhLmV4cG9ydHM9e319KTt2YXIgUmE9YmUoKE8wLE1hKT0+e3ZhciBhZj1GdCgpLG9mPUVuKCksY2Y9YWYoXCJpdGVyYXRvclwiKSxsZj1BcnJheS5wcm90b3R5cGU7TWEuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gZSE9PXZvaWQgMCYmKG9mLkFycmF5PT09ZXx8bGZbY2ZdPT09ZSl9fSk7dmFyIHZuPWJlKChqMCxXYSk9Pnt2YXIgcGY9eW4oKSxWYT1vcigpLGZmPUVuKCksRGY9RnQoKSxtZj1EZihcIml0ZXJhdG9yXCIpO1dhLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoZSE9bnVsbClyZXR1cm4gVmEoZSxtZil8fFZhKGUsXCJAQGl0ZXJhdG9yXCIpfHxmZltwZihlKV19fSk7dmFyIEhhPWJlKChxMCwkYSk9Pnt2YXIgZGY9WWUoKSxnZj1DdCgpLHlmPVJ0KCksaGY9QnQoKSxDZj1pcigpLEVmPXZuKCksdmY9ZGYuVHlwZUVycm9yOyRhLmV4cG9ydHM9ZnVuY3Rpb24oZSxuKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPDI/RWYoZSk6bjtpZih5Zih0KSlyZXR1cm4gaGYoZ2YodCxlKSk7dGhyb3cgdmYoQ2YoZSkrXCIgaXMgbm90IGl0ZXJhYmxlXCIpfX0pO3ZhciBVYT1iZSgoTTAsSmEpPT57dmFyIEZmPUN0KCksR2E9QnQoKSxBZj1vcigpO0phLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHQpe3ZhciBzLGk7R2EoZSk7dHJ5e2lmKHM9QWYoZSxcInJldHVyblwiKSwhcyl7aWYobj09PVwidGhyb3dcIil0aHJvdyB0O3JldHVybiB0fXM9RmYocyxlKX1jYXRjaChyKXtpPSEwLHM9cn1pZihuPT09XCJ0aHJvd1wiKXRocm93IHQ7aWYoaSl0aHJvdyBzO3JldHVybiBHYShzKSx0fX0pO3ZhciBRYT1iZSgoUjAsWWEpPT57dmFyIFNmPVllKCkseGY9ZG4oKSxiZj1DdCgpLFRmPUJ0KCksQmY9aXIoKSxOZj1SYSgpLHdmPU50KCksemE9TXIoKSxfZj1IYSgpLFBmPXZuKCksWGE9VWEoKSxJZj1TZi5UeXBlRXJyb3IsdnI9ZnVuY3Rpb24oZSxuKXt0aGlzLnN0b3BwZWQ9ZSx0aGlzLnJlc3VsdD1ufSxLYT12ci5wcm90b3R5cGU7WWEuZXhwb3J0cz1mdW5jdGlvbihlLG4sdCl7dmFyIHM9dCYmdC50aGF0LGk9ISEodCYmdC5BU19FTlRSSUVTKSxyPSEhKHQmJnQuSVNfSVRFUkFUT1IpLHU9ISEodCYmdC5JTlRFUlJVUFRFRCksYT14ZihuLHMpLGMsbCxDLG0sZyxwLGYsaD1mdW5jdGlvbihUKXtyZXR1cm4gYyYmWGEoYyxcIm5vcm1hbFwiLFQpLG5ldyB2cighMCxUKX0sTj1mdW5jdGlvbihUKXtyZXR1cm4gaT8oVGYoVCksdT9hKFRbMF0sVFsxXSxoKTphKFRbMF0sVFsxXSkpOnU/YShULGgpOmEoVCl9O2lmKHIpYz1lO2Vsc2V7aWYobD1QZihlKSwhbCl0aHJvdyBJZihCZihlKStcIiBpcyBub3QgaXRlcmFibGVcIik7aWYoTmYobCkpe2ZvcihDPTAsbT13ZihlKTttPkM7QysrKWlmKGc9TihlW0NdKSxnJiZ6YShLYSxnKSlyZXR1cm4gZztyZXR1cm4gbmV3IHZyKCExKX1jPV9mKGUsbCl9Zm9yKHA9Yy5uZXh0OyEoZj1iZihwLGMpKS5kb25lOyl7dHJ5e2c9TihmLnZhbHVlKX1jYXRjaChUKXtYYShjLFwidGhyb3dcIixUKX1pZih0eXBlb2YgZz09XCJvYmplY3RcIiYmZyYmemEoS2EsZykpcmV0dXJuIGd9cmV0dXJuIG5ldyB2cighMSl9fSk7dmFyIGVpPWJlKChWMCxaYSk9PntcInVzZSBzdHJpY3RcIjt2YXIga2Y9ZnIoKSxMZj1tcigpLE9mPW5yKCk7WmEuZXhwb3J0cz1mdW5jdGlvbihlLG4sdCl7dmFyIHM9a2Yobik7cyBpbiBlP0xmLmYoZSxzLE9mKDAsdCkpOmVbc109dH19KTt2YXIgdGk9YmUoKCk9Pnt2YXIgamY9JHQoKSxxZj1RYSgpLE1mPWVpKCk7amYoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITB9LHtmcm9tRW50cmllczpmdW5jdGlvbihuKXt2YXIgdD17fTtyZXR1cm4gcWYobixmdW5jdGlvbihzLGkpe01mKHQscyxpKX0se0FTX0VOVFJJRVM6ITB9KSx0fX0pfSk7dmFyIHJpPWJlKCgpPT57dmFyIFJmPSR0KCksVmY9WWUoKTtSZih7Z2xvYmFsOiEwfSx7Z2xvYmFsVGhpczpWZn0pfSk7dmFyIG5pPWJlKCgpPT57cmkoKX0pO3ZhciB1aT1iZSgoKT0+e1widXNlIHN0cmljdFwiO3ZhciBXZj0kdCgpLCRmPWduKCksSGY9cHIoKSxHZj1OdCgpLEpmPUNyKCksVWY9Q24oKTtXZih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMH0se2ZsYXQ6ZnVuY3Rpb24oKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1swXTp2b2lkIDAsdD1IZih0aGlzKSxzPUdmKHQpLGk9VWYodCwwKTtyZXR1cm4gaS5sZW5ndGg9JGYoaSx0LHQscywwLG49PT12b2lkIDA/MTpKZihuKSksaX19KX0pO3ZhciBkZz1iZSgoWTAseW8pPT57dmFyIHpmPVtcImNsaU5hbWVcIixcImNsaUNhdGVnb3J5XCIsXCJjbGlEZXNjcmlwdGlvblwiXSxYZj1bXCJfXCJdLEtmPVtcImxhbmd1YWdlSWRcIl0sc2ksYWksaWksb2ksY2ksbGk7ZnVuY3Rpb24gX24oZSxuKXtpZihlPT1udWxsKXJldHVybnt9O3ZhciB0PVlmKGUsbikscyxpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciByPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7Zm9yKGk9MDtpPHIubGVuZ3RoO2krKylzPXJbaV0sIShuLmluZGV4T2Yocyk+PTApJiYoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHMpfHwodFtzXT1lW3NdKSl9cmV0dXJuIHR9ZnVuY3Rpb24gWWYoZSxuKXtpZihlPT1udWxsKXJldHVybnt9O3ZhciB0PXt9LHM9T2JqZWN0LmtleXMoZSksaSxyO2ZvcihyPTA7cjxzLmxlbmd0aDtyKyspaT1zW3JdLCEobi5pbmRleE9mKGkpPj0wKSYmKHRbaV09ZVtpXSk7cmV0dXJuIHR9amEoKTt0aSgpO25pKCk7dWkoKTtmdW5jdGlvbiB3dChlLG4pe3JldHVybiBufHwobj1lLnNsaWNlKDApKSxPYmplY3QuZnJlZXplKE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUse3Jhdzp7dmFsdWU6T2JqZWN0LmZyZWV6ZShuKX19KSl9dmFyIFBuPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxRZj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLEluPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFpmPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksYnI9KGUsbik9PmZ1bmN0aW9uKCl7cmV0dXJuIGUmJihuPSgwLGVbSW4oZSlbMF1dKShlPTApKSxufSxaPShlLG4pPT5mdW5jdGlvbigpe3JldHVybiBufHwoMCxlW0luKGUpWzBdXSkoKG49e2V4cG9ydHM6e319KS5leHBvcnRzLG4pLG4uZXhwb3J0c30sa249KGUsbik9Pntmb3IodmFyIHQgaW4gbilQbihlLHQse2dldDpuW3RdLGVudW1lcmFibGU6ITB9KX0sZUQ9KGUsbix0LHMpPT57aWYobiYmdHlwZW9mIG49PVwib2JqZWN0XCJ8fHR5cGVvZiBuPT1cImZ1bmN0aW9uXCIpZm9yKGxldCBpIG9mIEluKG4pKSFaZi5jYWxsKGUsaSkmJmkhPT10JiZQbihlLGkse2dldDooKT0+bltpXSxlbnVtZXJhYmxlOiEocz1RZihuLGkpKXx8cy5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9LHB0PWU9PmVEKFBuKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpLHBpLGZpLHh0LGFlPWJyKHtcIjxkZWZpbmU6cHJvY2Vzcz5cIigpe3BpPXt9LGZpPVtdLHh0PXtlbnY6cGksYXJndjpmaX19fSksZ2k9Wih7XCJwYWNrYWdlLmpzb25cIihlLG4pe24uZXhwb3J0cz17dmVyc2lvbjpcIjIuNi4yXCJ9fX0pLHREPVooe1wibm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvYmFzZS5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PW47ZnVuY3Rpb24gbigpe31uLnByb3RvdHlwZT17ZGlmZjpmdW5jdGlvbihyLHUpe3ZhciBhPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTp7fSxjPWEuY2FsbGJhY2s7dHlwZW9mIGE9PVwiZnVuY3Rpb25cIiYmKGM9YSxhPXt9KSx0aGlzLm9wdGlvbnM9YTt2YXIgbD10aGlzO2Z1bmN0aW9uIEMoYil7cmV0dXJuIGM/KHNldFRpbWVvdXQoZnVuY3Rpb24oKXtjKHZvaWQgMCxiKX0sMCksITApOmJ9cj10aGlzLmNhc3RJbnB1dChyKSx1PXRoaXMuY2FzdElucHV0KHUpLHI9dGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKHIpKSx1PXRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZSh1KSk7dmFyIG09dS5sZW5ndGgsZz1yLmxlbmd0aCxwPTEsZj1tK2csaD1be25ld1BvczotMSxjb21wb25lbnRzOltdfV0sTj10aGlzLmV4dHJhY3RDb21tb24oaFswXSx1LHIsMCk7aWYoaFswXS5uZXdQb3MrMT49bSYmTisxPj1nKXJldHVybiBDKFt7dmFsdWU6dGhpcy5qb2luKHUpLGNvdW50OnUubGVuZ3RofV0pO2Z1bmN0aW9uIFQoKXtmb3IodmFyIGI9LTEqcDtiPD1wO2IrPTIpe3ZhciB2PXZvaWQgMCxCPWhbYi0xXSx3PWhbYisxXSxJPSh3P3cubmV3UG9zOjApLWI7QiYmKGhbYi0xXT12b2lkIDApO3ZhciBFPUImJkIubmV3UG9zKzE8bSxEPXcmJjA8PUkmJkk8ZztpZighRSYmIUQpe2hbYl09dm9pZCAwO2NvbnRpbnVlfWlmKCFFfHxEJiZCLm5ld1Bvczx3Lm5ld1Bvcz8odj1zKHcpLGwucHVzaENvbXBvbmVudCh2LmNvbXBvbmVudHMsdm9pZCAwLCEwKSk6KHY9Qix2Lm5ld1BvcysrLGwucHVzaENvbXBvbmVudCh2LmNvbXBvbmVudHMsITAsdm9pZCAwKSksST1sLmV4dHJhY3RDb21tb24odix1LHIsYiksdi5uZXdQb3MrMT49bSYmSSsxPj1nKXJldHVybiBDKHQobCx2LmNvbXBvbmVudHMsdSxyLGwudXNlTG9uZ2VzdFRva2VuKSk7aFtiXT12fXArK31pZihjKShmdW5jdGlvbiBiKCl7c2V0VGltZW91dChmdW5jdGlvbigpe2lmKHA+ZilyZXR1cm4gYygpO1QoKXx8YigpfSwwKX0pKCk7ZWxzZSBmb3IoO3A8PWY7KXt2YXIgQT1UKCk7aWYoQSlyZXR1cm4gQX19LHB1c2hDb21wb25lbnQ6ZnVuY3Rpb24ocix1LGEpe3ZhciBjPXJbci5sZW5ndGgtMV07YyYmYy5hZGRlZD09PXUmJmMucmVtb3ZlZD09PWE/cltyLmxlbmd0aC0xXT17Y291bnQ6Yy5jb3VudCsxLGFkZGVkOnUscmVtb3ZlZDphfTpyLnB1c2goe2NvdW50OjEsYWRkZWQ6dSxyZW1vdmVkOmF9KX0sZXh0cmFjdENvbW1vbjpmdW5jdGlvbihyLHUsYSxjKXtmb3IodmFyIGw9dS5sZW5ndGgsQz1hLmxlbmd0aCxtPXIubmV3UG9zLGc9bS1jLHA9MDttKzE8bCYmZysxPEMmJnRoaXMuZXF1YWxzKHVbbSsxXSxhW2crMV0pOyltKyssZysrLHArKztyZXR1cm4gcCYmci5jb21wb25lbnRzLnB1c2goe2NvdW50OnB9KSxyLm5ld1Bvcz1tLGd9LGVxdWFsczpmdW5jdGlvbihyLHUpe3JldHVybiB0aGlzLm9wdGlvbnMuY29tcGFyYXRvcj90aGlzLm9wdGlvbnMuY29tcGFyYXRvcihyLHUpOnI9PT11fHx0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSYmci50b0xvd2VyQ2FzZSgpPT09dS50b0xvd2VyQ2FzZSgpfSxyZW1vdmVFbXB0eTpmdW5jdGlvbihyKXtmb3IodmFyIHU9W10sYT0wO2E8ci5sZW5ndGg7YSsrKXJbYV0mJnUucHVzaChyW2FdKTtyZXR1cm4gdX0sY2FzdElucHV0OmZ1bmN0aW9uKHIpe3JldHVybiByfSx0b2tlbml6ZTpmdW5jdGlvbihyKXtyZXR1cm4gci5zcGxpdChcIlwiKX0sam9pbjpmdW5jdGlvbihyKXtyZXR1cm4gci5qb2luKFwiXCIpfX07ZnVuY3Rpb24gdChpLHIsdSxhLGMpe2Zvcih2YXIgbD0wLEM9ci5sZW5ndGgsbT0wLGc9MDtsPEM7bCsrKXt2YXIgcD1yW2xdO2lmKHAucmVtb3ZlZCl7aWYocC52YWx1ZT1pLmpvaW4oYS5zbGljZShnLGcrcC5jb3VudCkpLGcrPXAuY291bnQsbCYmcltsLTFdLmFkZGVkKXt2YXIgaD1yW2wtMV07cltsLTFdPXJbbF0scltsXT1ofX1lbHNle2lmKCFwLmFkZGVkJiZjKXt2YXIgZj11LnNsaWNlKG0sbStwLmNvdW50KTtmPWYubWFwKGZ1bmN0aW9uKFQsQSl7dmFyIGI9YVtnK0FdO3JldHVybiBiLmxlbmd0aD5ULmxlbmd0aD9iOlR9KSxwLnZhbHVlPWkuam9pbihmKX1lbHNlIHAudmFsdWU9aS5qb2luKHUuc2xpY2UobSxtK3AuY291bnQpKTttKz1wLmNvdW50LHAuYWRkZWR8fChnKz1wLmNvdW50KX19dmFyIE49cltDLTFdO3JldHVybiBDPjEmJnR5cGVvZiBOLnZhbHVlPT1cInN0cmluZ1wiJiYoTi5hZGRlZHx8Ti5yZW1vdmVkKSYmaS5lcXVhbHMoXCJcIixOLnZhbHVlKSYmKHJbQy0yXS52YWx1ZSs9Ti52YWx1ZSxyLnBvcCgpKSxyfWZ1bmN0aW9uIHMoaSl7cmV0dXJue25ld1BvczppLm5ld1Bvcyxjb21wb25lbnRzOmkuY29tcG9uZW50cy5zbGljZSgwKX19fX0pLHJEPVooe1wibm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvYXJyYXkuanNcIihlKXtcInVzZSBzdHJpY3RcIjthZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGlmZkFycmF5cz1pLGUuYXJyYXlEaWZmPXZvaWQgMDt2YXIgbj10KHREKCkpO2Z1bmN0aW9uIHQocil7cmV0dXJuIHImJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fXZhciBzPW5ldyBuLmRlZmF1bHQ7ZS5hcnJheURpZmY9cyxzLnRva2VuaXplPWZ1bmN0aW9uKHIpe3JldHVybiByLnNsaWNlKCl9LHMuam9pbj1zLnJlbW92ZUVtcHR5PWZ1bmN0aW9uKHIpe3JldHVybiByfTtmdW5jdGlvbiBpKHIsdSxhKXtyZXR1cm4gcy5kaWZmKHIsdSxhKX19fSksTG49Wih7XCJzcmMvZG9jdW1lbnQvZG9jLWJ1aWxkZXJzLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO2Z1bmN0aW9uIHQoeSl7cmV0dXJue3R5cGU6XCJjb25jYXRcIixwYXJ0czp5fX1mdW5jdGlvbiBzKHkpe3JldHVybnt0eXBlOlwiaW5kZW50XCIsY29udGVudHM6eX19ZnVuY3Rpb24gaSh5LG8pe3JldHVybnt0eXBlOlwiYWxpZ25cIixjb250ZW50czpvLG46eX19ZnVuY3Rpb24gcih5KXtsZXQgbz1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e307cmV0dXJue3R5cGU6XCJncm91cFwiLGlkOm8uaWQsY29udGVudHM6eSxicmVhazpCb29sZWFuKG8uc2hvdWxkQnJlYWspLGV4cGFuZGVkU3RhdGVzOm8uZXhwYW5kZWRTdGF0ZXN9fWZ1bmN0aW9uIHUoeSl7cmV0dXJuIGkoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLHkpfWZ1bmN0aW9uIGEoeSl7cmV0dXJuIGkoe3R5cGU6XCJyb290XCJ9LHkpfWZ1bmN0aW9uIGMoeSl7cmV0dXJuIGkoLTEseSl9ZnVuY3Rpb24gbCh5LG8pe3JldHVybiByKHlbMF0sT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHt9LHtleHBhbmRlZFN0YXRlczp5fSkpfWZ1bmN0aW9uIEMoeSl7cmV0dXJue3R5cGU6XCJmaWxsXCIscGFydHM6eX19ZnVuY3Rpb24gbSh5LG8pe2xldCB4PWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTp7fTtyZXR1cm57dHlwZTpcImlmLWJyZWFrXCIsYnJlYWtDb250ZW50czp5LGZsYXRDb250ZW50czpvLGdyb3VwSWQ6eC5ncm91cElkfX1mdW5jdGlvbiBnKHksbyl7cmV0dXJue3R5cGU6XCJpbmRlbnQtaWYtYnJlYWtcIixjb250ZW50czp5LGdyb3VwSWQ6by5ncm91cElkLG5lZ2F0ZTpvLm5lZ2F0ZX19ZnVuY3Rpb24gcCh5KXtyZXR1cm57dHlwZTpcImxpbmUtc3VmZml4XCIsY29udGVudHM6eX19dmFyIGY9e3R5cGU6XCJsaW5lLXN1ZmZpeC1ib3VuZGFyeVwifSxoPXt0eXBlOlwiYnJlYWstcGFyZW50XCJ9LE49e3R5cGU6XCJ0cmltXCJ9LFQ9e3R5cGU6XCJsaW5lXCIsaGFyZDohMH0sQT17dHlwZTpcImxpbmVcIixoYXJkOiEwLGxpdGVyYWw6ITB9LGI9e3R5cGU6XCJsaW5lXCJ9LHY9e3R5cGU6XCJsaW5lXCIsc29mdDohMH0sQj10KFtULGhdKSx3PXQoW0EsaF0pLEk9e3R5cGU6XCJjdXJzb3JcIixwbGFjZWhvbGRlcjpTeW1ib2woXCJjdXJzb3JcIil9O2Z1bmN0aW9uIEUoeSxvKXtsZXQgeD1bXTtmb3IobGV0IEY9MDtGPG8ubGVuZ3RoO0YrKylGIT09MCYmeC5wdXNoKHkpLHgucHVzaChvW0ZdKTtyZXR1cm4gdCh4KX1mdW5jdGlvbiBEKHksbyx4KXtsZXQgRj15O2lmKG8+MCl7Zm9yKGxldCBTPTA7UzxNYXRoLmZsb29yKG8veCk7KytTKUY9cyhGKTtGPWkobyV4LEYpLEY9aShOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksRil9cmV0dXJuIEZ9ZnVuY3Rpb24gZCh5LG8pe3JldHVybnt0eXBlOlwibGFiZWxcIixsYWJlbDp5LGNvbnRlbnRzOm99fW4uZXhwb3J0cz17Y29uY2F0OnQsam9pbjpFLGxpbmU6Yixzb2Z0bGluZTp2LGhhcmRsaW5lOkIsbGl0ZXJhbGxpbmU6dyxncm91cDpyLGNvbmRpdGlvbmFsR3JvdXA6bCxmaWxsOkMsbGluZVN1ZmZpeDpwLGxpbmVTdWZmaXhCb3VuZGFyeTpmLGN1cnNvcjpJLGJyZWFrUGFyZW50OmgsaWZCcmVhazptLHRyaW06TixpbmRlbnQ6cyxpbmRlbnRJZkJyZWFrOmcsYWxpZ246aSxhZGRBbGlnbm1lbnRUb0RvYzpELG1hcmtBc1Jvb3Q6YSxkZWRlbnRUb1Jvb3Q6dSxkZWRlbnQ6YyxoYXJkbGluZVdpdGhvdXRCcmVha1BhcmVudDpULGxpdGVyYWxsaW5lV2l0aG91dEJyZWFrUGFyZW50OkEsbGFiZWw6ZH19fSksT249Wih7XCJzcmMvY29tbW9uL2VuZC1vZi1saW5lLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO2Z1bmN0aW9uIHQodSl7bGV0IGE9dS5pbmRleE9mKFwiXFxyXCIpO3JldHVybiBhPj0wP3UuY2hhckF0KGErMSk9PT1gXG5gP1wiY3JsZlwiOlwiY3JcIjpcImxmXCJ9ZnVuY3Rpb24gcyh1KXtzd2l0Y2godSl7Y2FzZVwiY3JcIjpyZXR1cm5cIlxcclwiO2Nhc2VcImNybGZcIjpyZXR1cm5gXFxyXG5gO2RlZmF1bHQ6cmV0dXJuYFxuYH19ZnVuY3Rpb24gaSh1LGEpe2xldCBjO3N3aXRjaChhKXtjYXNlYFxuYDpjPS9cXG4vZzticmVhaztjYXNlXCJcXHJcIjpjPS9cXHIvZzticmVhaztjYXNlYFxcclxuYDpjPS9cXHJcXG4vZzticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBcImVvbFwiICcuY29uY2F0KEpTT04uc3RyaW5naWZ5KGEpLFwiLlwiKSl9bGV0IGw9dS5tYXRjaChjKTtyZXR1cm4gbD9sLmxlbmd0aDowfWZ1bmN0aW9uIHIodSl7cmV0dXJuIHUucmVwbGFjZSgvXFxyXFxuPy9nLGBcbmApfW4uZXhwb3J0cz17Z3Vlc3NFbmRPZkxpbmU6dCxjb252ZXJ0RW5kT2ZMaW5lVG9DaGFyczpzLGNvdW50RW5kT2ZMaW5lQ2hhcnM6aSxub3JtYWxpemVFbmRPZkxpbmU6cn19fSksc3Q9Wih7XCJzcmMvdXRpbHMvZ2V0LWxhc3QuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9cz0+c1tzLmxlbmd0aC0xXTtuLmV4cG9ydHM9dH19KSxuRD1aKHtcInZlbmRvcnMvc3RyaW5nLXdpZHRoLmpzXCIoZSxuKXthZSgpO3ZhciB0PU9iamVjdC5jcmVhdGUscz1PYmplY3QuZGVmaW5lUHJvcGVydHksaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLHI9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsdT1PYmplY3QuZ2V0UHJvdG90eXBlT2YsYT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LGM9KHYsQik9PmZ1bmN0aW9uKCl7cmV0dXJuIEJ8fCgwLHZbcih2KVswXV0pKChCPXtleHBvcnRzOnt9fSkuZXhwb3J0cyxCKSxCLmV4cG9ydHN9LGw9KHYsQik9Pntmb3IodmFyIHcgaW4gQilzKHYsdyx7Z2V0OkJbd10sZW51bWVyYWJsZTohMH0pfSxDPSh2LEIsdyxJKT0+e2lmKEImJnR5cGVvZiBCPT1cIm9iamVjdFwifHx0eXBlb2YgQj09XCJmdW5jdGlvblwiKWZvcihsZXQgRSBvZiByKEIpKSFhLmNhbGwodixFKSYmRSE9PXcmJnModixFLHtnZXQ6KCk9PkJbRV0sZW51bWVyYWJsZTohKEk9aShCLEUpKXx8SS5lbnVtZXJhYmxlfSk7cmV0dXJuIHZ9LG09KHYsQix3KT0+KHc9diE9bnVsbD90KHUodikpOnt9LEMoQnx8IXZ8fCF2Ll9fZXNNb2R1bGU/cyh3LFwiZGVmYXVsdFwiLHt2YWx1ZTp2LGVudW1lcmFibGU6ITB9KTp3LHYpKSxnPXY9PkMocyh7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx2KSxwPWMoe1wibm9kZV9tb2R1bGVzL2Vtb2ppLXJlZ2V4L2luZGV4LmpzXCIodixCKXtcInVzZSBzdHJpY3RcIjtCLmV4cG9ydHM9ZnVuY3Rpb24oKXtyZXR1cm4vXFx1RDgzQ1xcdURGRjRcXHVEQjQwXFx1REM2N1xcdURCNDBcXHVEQzYyKD86XFx1REI0MFxcdURDNzdcXHVEQjQwXFx1REM2Q1xcdURCNDBcXHVEQzczfFxcdURCNDBcXHVEQzczXFx1REI0MFxcdURDNjNcXHVEQjQwXFx1REM3NHxcXHVEQjQwXFx1REM2NVxcdURCNDBcXHVEQzZFXFx1REI0MFxcdURDNjcpXFx1REI0MFxcdURDN0Z8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGRlxcdTIwMERcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkZcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXSl8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGRVxcdTIwMERcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkVcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXFx1REZGRl0pfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkRcXHUyMDBEXFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMXxcXHVEODNEXFx1REM2OVxcdUQ4M0NcXHVERkZEXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKSkoPzpcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZDXFx1MjAwRFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGQ1xcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpKD86XFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSl8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGQlxcdTIwMERcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkJcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKSg/OlxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSl8XFx1RDgzRFxcdURDNjgoPzpcXHVEODNDXFx1REZGQig/OlxcdTIwMEQoPzpcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKXxcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSl8W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSkpP3woPzpcXHVEODNDW1xcdURGRkMtXFx1REZGRl0pXFx1MjAwRFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpfFxcdTIwMEQoPzpcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY4fCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQoPzpcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSkpfFxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZGXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZFXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRFxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkNcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfCg/OlxcdUQ4M0NcXHVERkZGXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZFXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZEXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZDXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XSlcXHVGRTBGfFxcdTIwMEQoPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNDXFx1REZGRnxcXHVEODNDXFx1REZGRXxcXHVEODNDXFx1REZGRHxcXHVEODNDXFx1REZGQyk/fCg/OlxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1xcdURGRkJcXHUyMDBEXFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXwoPzpcXHVEODNDW1xcdURGRkMtXFx1REZGRl0pXFx1MjAwRFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpfFxcdUQ4M0VcXHVEREQxKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKSl8XFx1RDgzRFxcdURDNjkoPzpcXHUyMDBEKD86XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZGXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkVcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRFxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZDXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkJcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKSl8XFx1RDgzRVxcdURERDEoPzpcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDF8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkZcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkVcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkRcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkNcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkJcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSkpfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8KD86XFx1RDgzRFxcdURDNDFcXHVGRTBGXFx1MjAwRFxcdUQ4M0RcXHVEREU4fFxcdUQ4M0VcXHVEREQxKD86XFx1RDgzQ1xcdURGRkZcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkVcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkRcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkNcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkJcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdKXxcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NcXHVERkZGXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZFXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZEXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZDXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZCXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XSl8XFx1RDgzRFxcdURFMzZcXHUyMDBEXFx1RDgzQ1xcdURGMkJ8XFx1RDgzQ1xcdURGRjNcXHVGRTBGXFx1MjAwRFxcdTI2QTd8XFx1RDgzRFxcdURDM0JcXHUyMDBEXFx1Mjc0NHwoPzooPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MFxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM1XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdUREQ0QtXFx1RERDRlxcdURERDRcXHVEREQ2LVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzRFxcdURDNkZ8XFx1RDgzRVtcXHVERDNDXFx1RERERVxcdUREREZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18XFx1RDgzQ1xcdURGRjRcXHUyMDBEXFx1MjYyMHwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MFxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM1XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdUREQ0QtXFx1RERDRlxcdURERDRcXHVEREQ2LVxcdURERERdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfFtcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMyOFxcdTIzQ0ZcXHUyM0VELVxcdTIzRUZcXHUyM0YxXFx1MjNGMlxcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQlxcdTI1RkNcXHUyNjAwLVxcdTI2MDRcXHUyNjBFXFx1MjYxMVxcdTI2MThcXHUyNjIwXFx1MjYyMlxcdTI2MjNcXHUyNjI2XFx1MjYyQVxcdTI2MkVcXHUyNjJGXFx1MjYzOC1cXHUyNjNBXFx1MjY0MFxcdTI2NDJcXHUyNjVGXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NjhcXHUyNjdCXFx1MjY3RVxcdTI2OTJcXHUyNjk0LVxcdTI2OTdcXHUyNjk5XFx1MjY5QlxcdTI2OUNcXHUyNkEwXFx1MjZBN1xcdTI2QjBcXHUyNkIxXFx1MjZDOFxcdTI2Q0ZcXHUyNkQxXFx1MjZEM1xcdTI2RTlcXHUyNkYwXFx1MjZGMVxcdTI2RjRcXHUyNkY3XFx1MjZGOFxcdTI3MDJcXHUyNzA4XFx1MjcwOVxcdTI3MEZcXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzYzXFx1MjdBMVxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVERDcwXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REUwMlxcdURFMzdcXHVERjIxXFx1REYyNC1cXHVERjJDXFx1REYzNlxcdURGN0RcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUVcXHVERjlGXFx1REZDRFxcdURGQ0VcXHVERkQ0LVxcdURGREZcXHVERkY1XFx1REZGN118XFx1RDgzRFtcXHVEQzNGXFx1RENGRFxcdURENDlcXHVERDRBXFx1REQ2RlxcdURENzBcXHVERDczXFx1REQ3Ni1cXHVERDc5XFx1REQ4N1xcdUREOEEtXFx1REQ4RFxcdUREQTVcXHVEREE4XFx1RERCMVxcdUREQjJcXHVEREJDXFx1RERDMi1cXHVEREM0XFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERFXFx1RERFMVxcdURERTNcXHVEREU4XFx1RERFRlxcdURERjNcXHVEREZBXFx1REVDQlxcdURFQ0QtXFx1REVDRlxcdURFRTAtXFx1REVFNVxcdURFRTlcXHVERUYwXFx1REVGM10pXFx1RkUwRnxcXHVEODNDXFx1REZGM1xcdUZFMEZcXHUyMDBEXFx1RDgzQ1xcdURGMDh8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjd8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURFMzVcXHUyMDBEXFx1RDgzRFxcdURDQUJ8XFx1RDgzRFxcdURFMkVcXHUyMDBEXFx1RDgzRFxcdURDQTh8XFx1RDgzRFxcdURDMTVcXHUyMDBEXFx1RDgzRVxcdUREQkF8XFx1RDgzRVxcdURERDEoPzpcXHVEODNDXFx1REZGRnxcXHVEODNDXFx1REZGRXxcXHVEODNDXFx1REZGRHxcXHVEODNDXFx1REZGQ3xcXHVEODNDXFx1REZGQik/fFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1xcdURGRkZ8XFx1RDgzQ1xcdURGRkV8XFx1RDgzQ1xcdURGRkR8XFx1RDgzQ1xcdURGRkN8XFx1RDgzQ1xcdURGRkIpP3xcXHVEODNDXFx1RERGRFxcdUQ4M0NcXHVEREYwfFxcdUQ4M0NcXHVEREY2XFx1RDgzQ1xcdURERTZ8XFx1RDgzQ1xcdURERjRcXHVEODNDXFx1RERGMnxcXHVEODNEXFx1REMwOFxcdTIwMERcXHUyQjFCfFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVERDI1fFxcdUQ4M0VcXHVERTc5KXxcXHVEODNEXFx1REM0MVxcdUZFMEZ8XFx1RDgzQ1xcdURGRjNcXHVGRTBGfFxcdUQ4M0NcXHVEREZGKD86XFx1RDgzQ1tcXHVEREU2XFx1RERGMlxcdURERkNdKXxcXHVEODNDXFx1RERGRSg/OlxcdUQ4M0NbXFx1RERFQVxcdURERjldKXxcXHVEODNDXFx1RERGQyg/OlxcdUQ4M0NbXFx1RERFQlxcdURERjhdKXxcXHVEODNDXFx1RERGQig/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERUVcXHVEREYzXFx1RERGQV0pfFxcdUQ4M0NcXHVEREZBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQ1xcdURERjJcXHVEREYzXFx1RERGOFxcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERjkoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRFxcdURERUYtXFx1RERGNFxcdURERjdcXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZGXSl8XFx1RDgzQ1xcdURERjgoPzpcXHVEODNDW1xcdURERTYtXFx1RERFQVxcdURERUMtXFx1RERGNFxcdURERjctXFx1RERGOVxcdURERkJcXHVEREZELVxcdURERkZdKXxcXHVEODNDXFx1RERGNyg/OlxcdUQ4M0NbXFx1RERFQVxcdURERjRcXHVEREY4XFx1RERGQVxcdURERkNdKXxcXHVEODNDXFx1RERGNSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERUEtXFx1RERFRFxcdURERjAtXFx1RERGM1xcdURERjctXFx1RERGOVxcdURERkNcXHVEREZFXSl8XFx1RDgzQ1xcdURERjMoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQS1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREY0XFx1RERGNVxcdURERjdcXHVEREZBXFx1RERGRl0pfFxcdUQ4M0NcXHVEREYyKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOC1cXHVEREVEXFx1RERGMC1cXHVEREZGXSl8XFx1RDgzQ1xcdURERjEoPzpcXHVEODNDW1xcdURERTYtXFx1RERFOFxcdURERUVcXHVEREYwXFx1RERGNy1cXHVEREZCXFx1RERGRV0pfFxcdUQ4M0NcXHVEREYwKD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQy1cXHVEREVFXFx1RERGMlxcdURERjNcXHVEREY1XFx1RERGN1xcdURERkNcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREVGKD86XFx1RDgzQ1tcXHVEREVBXFx1RERGMlxcdURERjRcXHVEREY1XSl8XFx1RDgzQ1xcdURERUUoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQVxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOV0pfFxcdUQ4M0NcXHVEREVEKD86XFx1RDgzQ1tcXHVEREYwXFx1RERGMlxcdURERjNcXHVEREY3XFx1RERGOVxcdURERkFdKXxcXHVEODNDXFx1RERFQyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUVcXHVEREYxLVxcdURERjNcXHVEREY1LVxcdURERkFcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREVCKD86XFx1RDgzQ1tcXHVEREVFLVxcdURERjBcXHVEREYyXFx1RERGNFxcdURERjddKXxcXHVEODNDXFx1RERFQSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERURcXHVEREY3LVxcdURERkFdKXxcXHVEODNDXFx1RERFOSg/OlxcdUQ4M0NbXFx1RERFQVxcdURERUNcXHVEREVGXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGRl0pfFxcdUQ4M0NcXHVEREU4KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERUVcXHVEREYwLVxcdURERjVcXHVEREY3XFx1RERGQS1cXHVEREZGXSl8XFx1RDgzQ1xcdURERTcoPzpcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVGXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREU2KD86XFx1RDgzQ1tcXHVEREU4LVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjJcXHVEREY0XFx1RERGNi1cXHVEREZBXFx1RERGQ1xcdURERkRcXHVEREZGXSl8WyNcXCowLTldXFx1RkUwRlxcdTIwRTN8XFx1Mjc2NFxcdUZFMEZ8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzBcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNVxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCOFxcdUREQjlcXHVERENELVxcdUREQ0ZcXHVEREQ0XFx1RERENi1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0NcXHVERkY0fCg/OltcXHUyNzBBXFx1MjcwQl18XFx1RDgzQ1tcXHVERjg1XFx1REZDMlxcdURGQzddfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2XFx1REM2N1xcdURDNkItXFx1REM2RFxcdURDNzJcXHVEQzc0LVxcdURDNzZcXHVEQzc4XFx1REM3Q1xcdURDODNcXHVEQzg1XFx1REM4RlxcdURDOTFcXHVEQ0FBXFx1REQ3QVxcdUREOTVcXHVERDk2XFx1REU0Q1xcdURFNEZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDBDXFx1REQwRlxcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQzMC1cXHVERDM0XFx1REQzNlxcdURENzdcXHVEREI1XFx1RERCNlxcdUREQkJcXHVEREQyXFx1REREM1xcdURERDVdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86W1xcdTI2MURcXHUyNzBDXFx1MjcwRF18XFx1RDgzRFtcXHVERDc0XFx1REQ5MF0pKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFtcXHUyNzBBXFx1MjcwQl18XFx1RDgzQ1tcXHVERjg1XFx1REZDMlxcdURGQzddfFxcdUQ4M0RbXFx1REMwOFxcdURDMTVcXHVEQzNCXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2XFx1REM2N1xcdURDNkItXFx1REM2RFxcdURDNzJcXHVEQzc0LVxcdURDNzZcXHVEQzc4XFx1REM3Q1xcdURDODNcXHVEQzg1XFx1REM4RlxcdURDOTFcXHVEQ0FBXFx1REQ3QVxcdUREOTVcXHVERDk2XFx1REUyRVxcdURFMzVcXHVERTM2XFx1REU0Q1xcdURFNEZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDBDXFx1REQwRlxcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQzMC1cXHVERDM0XFx1REQzNlxcdURENzdcXHVEREI1XFx1RERCNlxcdUREQkJcXHVEREQyXFx1REREM1xcdURERDVdfFxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcwXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzVcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdUREQjhcXHVEREI5XFx1RERDRC1cXHVERENGXFx1RERENFxcdURERDYtXFx1RERERF18XFx1RDgzRFxcdURDNkZ8XFx1RDgzRVtcXHVERDNDXFx1RERERVxcdUREREZdfFtcXHUyMzFBXFx1MjMxQlxcdTIzRTktXFx1MjNFQ1xcdTIzRjBcXHUyM0YzXFx1MjVGRFxcdTI1RkVcXHUyNjE0XFx1MjYxNVxcdTI2NDgtXFx1MjY1M1xcdTI2N0ZcXHUyNjkzXFx1MjZBMVxcdTI2QUFcXHUyNkFCXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2Q0VcXHUyNkQ0XFx1MjZFQVxcdTI2RjJcXHUyNkYzXFx1MjZGNVxcdTI2RkFcXHUyNkZEXFx1MjcwNVxcdTI3MjhcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzk1LVxcdTI3OTdcXHUyN0IwXFx1MjdCRlxcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVdfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1REUwMVxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTM2XFx1REUzOC1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjBcXHVERjJELVxcdURGMzVcXHVERjM3LVxcdURGN0NcXHVERjdFLVxcdURGODRcXHVERjg2LVxcdURGOTNcXHVERkEwLVxcdURGQzFcXHVERkM1XFx1REZDNlxcdURGQzhcXHVERkM5XFx1REZDRi1cXHVERkQzXFx1REZFMC1cXHVERkYwXFx1REZGOC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REMwN1xcdURDMDktXFx1REMxNFxcdURDMTYtXFx1REMzQVxcdURDM0MtXFx1REMzRVxcdURDNDBcXHVEQzQ0XFx1REM0NVxcdURDNTEtXFx1REM2NVxcdURDNkFcXHVEQzc5LVxcdURDN0JcXHVEQzdELVxcdURDODBcXHVEQzg0XFx1REM4OC1cXHVEQzhFXFx1REM5MFxcdURDOTItXFx1RENBOVxcdURDQUItXFx1RENGQ1xcdURDRkYtXFx1REQzRFxcdURENEItXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdUREQTRcXHVEREZCLVxcdURFMkRcXHVERTJGLVxcdURFMzRcXHVERTM3LVxcdURFNDRcXHVERTQ4LVxcdURFNEFcXHVERTgwLVxcdURFQTJcXHVERUE0LVxcdURFQjNcXHVERUI3LVxcdURFQkZcXHVERUMxLVxcdURFQzVcXHVERUQwLVxcdURFRDJcXHVERUQ1LVxcdURFRDdcXHVERUVCXFx1REVFQ1xcdURFRjQtXFx1REVGQ1xcdURGRTAtXFx1REZFQl18XFx1RDgzRVtcXHVERDBEXFx1REQwRVxcdUREMTAtXFx1REQxN1xcdUREMURcXHVERDIwLVxcdUREMjVcXHVERDI3LVxcdUREMkZcXHVERDNBXFx1REQzRi1cXHVERDQ1XFx1REQ0Ny1cXHVERDc2XFx1REQ3OFxcdUREN0EtXFx1RERCNFxcdUREQjdcXHVEREJBXFx1RERCQy1cXHVERENCXFx1REREMFxcdURERTAtXFx1RERGRlxcdURFNzAtXFx1REU3NFxcdURFNzgtXFx1REU3QVxcdURFODAtXFx1REU4NlxcdURFOTAtXFx1REVBOFxcdURFQjAtXFx1REVCNlxcdURFQzAtXFx1REVDMlxcdURFRDAtXFx1REVENl18KD86W1xcdTIzMUFcXHUyMzFCXFx1MjNFOS1cXHUyM0VDXFx1MjNGMFxcdTIzRjNcXHUyNUZEXFx1MjVGRVxcdTI2MTRcXHUyNjE1XFx1MjY0OC1cXHUyNjUzXFx1MjY3RlxcdTI2OTNcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDRVxcdTI2RDRcXHUyNkVBXFx1MjZGMlxcdTI2RjNcXHUyNkY1XFx1MjZGQVxcdTI2RkRcXHUyNzA1XFx1MjcwQVxcdTI3MEJcXHUyNzI4XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc5NS1cXHUyNzk3XFx1MjdCMFxcdTI3QkZcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzNlxcdURFMzgtXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIwXFx1REYyRC1cXHVERjM1XFx1REYzNy1cXHVERjdDXFx1REY3RS1cXHVERjkzXFx1REZBMC1cXHVERkNBXFx1REZDRi1cXHVERkQzXFx1REZFMC1cXHVERkYwXFx1REZGNFxcdURGRjgtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDM0VcXHVEQzQwXFx1REM0Mi1cXHVEQ0ZDXFx1RENGRi1cXHVERDNEXFx1REQ0Qi1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ3QVxcdUREOTVcXHVERDk2XFx1RERBNFxcdURERkItXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0NcXHVERUQwLVxcdURFRDJcXHVERUQ1LVxcdURFRDdcXHVERUVCXFx1REVFQ1xcdURFRjQtXFx1REVGQ1xcdURGRTAtXFx1REZFQl18XFx1RDgzRVtcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURENzhcXHVERDdBLVxcdUREQ0JcXHVERENELVxcdURERkZcXHVERTcwLVxcdURFNzRcXHVERTc4LVxcdURFN0FcXHVERTgwLVxcdURFODZcXHVERTkwLVxcdURFQThcXHVERUIwLVxcdURFQjZcXHVERUMwLVxcdURFQzJcXHVERUQwLVxcdURFRDZdKXwoPzpbI1xcKjAtOVxceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDRcXHUyNjBFXFx1MjYxMVxcdTI2MTRcXHUyNjE1XFx1MjYxOFxcdTI2MURcXHUyNjIwXFx1MjYyMlxcdTI2MjNcXHUyNjI2XFx1MjYyQVxcdTI2MkVcXHUyNjJGXFx1MjYzOC1cXHUyNjNBXFx1MjY0MFxcdTI2NDJcXHUyNjQ4LVxcdTI2NTNcXHUyNjVGXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NjhcXHUyNjdCXFx1MjY3RVxcdTI2N0ZcXHUyNjkyLVxcdTI2OTdcXHUyNjk5XFx1MjY5QlxcdTI2OUNcXHUyNkEwXFx1MjZBMVxcdTI2QTdcXHUyNkFBXFx1MjZBQlxcdTI2QjBcXHUyNkIxXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2QzhcXHUyNkNFXFx1MjZDRlxcdTI2RDFcXHUyNkQzXFx1MjZENFxcdTI2RTlcXHUyNkVBXFx1MjZGMC1cXHUyNkY1XFx1MjZGNy1cXHUyNkZBXFx1MjZGRFxcdTI3MDJcXHUyNzA1XFx1MjcwOC1cXHUyNzBEXFx1MjcwRlxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzXFx1Mjc2NFxcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDcwXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTAyXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMVxcdURGMjQtXFx1REY5M1xcdURGOTZcXHVERjk3XFx1REY5OS1cXHVERjlCXFx1REY5RS1cXHVERkYwXFx1REZGMy1cXHVERkY1XFx1REZGNy1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1RENGRFxcdURDRkYtXFx1REQzRFxcdURENDktXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdURENkZcXHVERDcwXFx1REQ3My1cXHVERDdBXFx1REQ4N1xcdUREOEEtXFx1REQ4RFxcdUREOTBcXHVERDk1XFx1REQ5NlxcdUREQTRcXHVEREE1XFx1RERBOFxcdUREQjFcXHVEREIyXFx1RERCQ1xcdUREQzItXFx1RERDNFxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERVxcdURERTFcXHVEREUzXFx1RERFOFxcdURERUZcXHVEREYzXFx1RERGQS1cXHVERTRGXFx1REU4MC1cXHVERUM1XFx1REVDQi1cXHVERUQyXFx1REVENS1cXHVERUQ3XFx1REVFMC1cXHVERUU1XFx1REVFOVxcdURFRUJcXHVERUVDXFx1REVGMFxcdURFRjMtXFx1REVGQ1xcdURGRTAtXFx1REZFQl18XFx1RDgzRVtcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURENzhcXHVERDdBLVxcdUREQ0JcXHVERENELVxcdURERkZcXHVERTcwLVxcdURFNzRcXHVERTc4LVxcdURFN0FcXHVERTgwLVxcdURFODZcXHVERTkwLVxcdURFQThcXHVERUIwLVxcdURFQjZcXHVERUMwLVxcdURFQzJcXHVERUQwLVxcdURFRDZdKVxcdUZFMEZ8KD86W1xcdTI2MURcXHUyNkY5XFx1MjcwQS1cXHUyNzBEXXxcXHVEODNDW1xcdURGODVcXHVERkMyLVxcdURGQzRcXHVERkM3XFx1REZDQS1cXHVERkNDXXxcXHVEODNEW1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2Ni1cXHVEQzc4XFx1REM3Q1xcdURDODEtXFx1REM4M1xcdURDODUtXFx1REM4N1xcdURDOEZcXHVEQzkxXFx1RENBQVxcdURENzRcXHVERDc1XFx1REQ3QVxcdUREOTBcXHVERDk1XFx1REQ5NlxcdURFNDUtXFx1REU0N1xcdURFNEItXFx1REU0RlxcdURFQTNcXHVERUI0LVxcdURFQjZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDBDXFx1REQwRlxcdUREMTgtXFx1REQxRlxcdUREMjZcXHVERDMwLVxcdUREMzlcXHVERDNDLVxcdUREM0VcXHVERDc3XFx1RERCNVxcdUREQjZcXHVEREI4XFx1RERCOVxcdUREQkJcXHVERENELVxcdUREQ0ZcXHVEREQxLVxcdURERERdKS9nfX19KSxmPXt9O2woZix7ZGVmYXVsdDooKT0+Yn0pLG4uZXhwb3J0cz1nKGYpO2Z1bmN0aW9uIGgoKXtsZXR7b25seUZpcnN0OnY9ITF9PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTp7fSxCPVtcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10rKSp8W2EtekEtWlxcXFxkXSsoPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNylcIixcIig/Oig/OlxcXFxkezEsNH0oPzo7XFxcXGR7MCw0fSkqKT9bXFxcXGRBLVBSLVRaY2YtbnRxcnk9Pjx+XSkpXCJdLmpvaW4oXCJ8XCIpO3JldHVybiBuZXcgUmVnRXhwKEIsdj92b2lkIDA6XCJnXCIpfWZ1bmN0aW9uIE4odil7aWYodHlwZW9mIHYhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgYHN0cmluZ2AsIGdvdCBgXCIuY29uY2F0KHR5cGVvZiB2LFwiYFwiKSk7cmV0dXJuIHYucmVwbGFjZShoKCksXCJcIil9ZnVuY3Rpb24gVCh2KXtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2KT92Pj00MzUyJiYodjw9NDQ0N3x8dj09PTkwMDF8fHY9PT05MDAyfHwxMTkwNDw9diYmdjw9MTI4NzEmJnYhPT0xMjM1MXx8MTI4ODA8PXYmJnY8PTE5OTAzfHwxOTk2ODw9diYmdjw9NDIxODJ8fDQzMzYwPD12JiZ2PD00MzM4OHx8NDQwMzI8PXYmJnY8PTU1MjAzfHw2Mzc0NDw9diYmdjw9NjQyNTV8fDY1MDQwPD12JiZ2PD02NTA0OXx8NjUwNzI8PXYmJnY8PTY1MTMxfHw2NTI4MTw9diYmdjw9NjUzNzZ8fDY1NTA0PD12JiZ2PD02NTUxMHx8MTEwNTkyPD12JiZ2PD0xMTA1OTN8fDEyNzQ4ODw9diYmdjw9MTI3NTY5fHwxMzEwNzI8PXYmJnY8PTI2MjE0MSk6ITF9dmFyIEE9bShwKCksMSk7ZnVuY3Rpb24gYih2KXtpZih0eXBlb2YgdiE9XCJzdHJpbmdcInx8di5sZW5ndGg9PT0wfHwodj1OKHYpLHYubGVuZ3RoPT09MCkpcmV0dXJuIDA7dj12LnJlcGxhY2UoKDAsQS5kZWZhdWx0KSgpLFwiICBcIik7bGV0IEI9MDtmb3IobGV0IHc9MDt3PHYubGVuZ3RoO3crKyl7bGV0IEk9di5jb2RlUG9pbnRBdCh3KTtJPD0zMXx8ST49MTI3JiZJPD0xNTl8fEk+PTc2OCYmSTw9ODc5fHwoST42NTUzNSYmdysrLEIrPVQoSSk/MjoxKX1yZXR1cm4gQn19fSkseWk9Wih7XCJzcmMvdXRpbHMvZ2V0LXN0cmluZy13aWR0aC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD1uRCgpLmRlZmF1bHQscz0vW15cXHgyMC1cXHg3Rl0vO2Z1bmN0aW9uIGkocil7cmV0dXJuIHI/cy50ZXN0KHIpP3Qocik6ci5sZW5ndGg6MH1uLmV4cG9ydHM9aX19KSxqbj1aKHtcInNyYy9kb2N1bWVudC9kb2MtdXRpbHMuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9c3QoKSx7bGl0ZXJhbGxpbmU6cyxqb2luOml9PUxuKCkscj1vPT5BcnJheS5pc0FycmF5KG8pfHxvJiZvLnR5cGU9PT1cImNvbmNhdFwiLHU9bz0+e2lmKEFycmF5LmlzQXJyYXkobykpcmV0dXJuIG87aWYoby50eXBlIT09XCJjb25jYXRcIiYmby50eXBlIT09XCJmaWxsXCIpdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0IGRvYyB0eXBlIHRvIGJlIGBjb25jYXRgIG9yIGBmaWxsYC5cIik7cmV0dXJuIG8ucGFydHN9LGE9e307ZnVuY3Rpb24gYyhvLHgsRixTKXtsZXQgaz1bb107Zm9yKDtrLmxlbmd0aD4wOyl7bGV0IF89ay5wb3AoKTtpZihfPT09YSl7RihrLnBvcCgpKTtjb250aW51ZX1pZihGJiZrLnB1c2goXyxhKSwheHx8eChfKSE9PSExKWlmKHIoXyl8fF8udHlwZT09PVwiZmlsbFwiKXtsZXQgTz11KF8pO2ZvcihsZXQgUj1PLmxlbmd0aCxNPVItMTtNPj0wOy0tTSlrLnB1c2goT1tNXSl9ZWxzZSBpZihfLnR5cGU9PT1cImlmLWJyZWFrXCIpXy5mbGF0Q29udGVudHMmJmsucHVzaChfLmZsYXRDb250ZW50cyksXy5icmVha0NvbnRlbnRzJiZrLnB1c2goXy5icmVha0NvbnRlbnRzKTtlbHNlIGlmKF8udHlwZT09PVwiZ3JvdXBcIiYmXy5leHBhbmRlZFN0YXRlcylpZihTKWZvcihsZXQgTz1fLmV4cGFuZGVkU3RhdGVzLmxlbmd0aCxSPU8tMTtSPj0wOy0tUilrLnB1c2goXy5leHBhbmRlZFN0YXRlc1tSXSk7ZWxzZSBrLnB1c2goXy5jb250ZW50cyk7ZWxzZSBfLmNvbnRlbnRzJiZrLnB1c2goXy5jb250ZW50cyl9fWZ1bmN0aW9uIGwobyx4KXtsZXQgRj1uZXcgTWFwO3JldHVybiBTKG8pO2Z1bmN0aW9uIFMoXyl7aWYoRi5oYXMoXykpcmV0dXJuIEYuZ2V0KF8pO2xldCBPPWsoXyk7cmV0dXJuIEYuc2V0KF8sTyksT31mdW5jdGlvbiBrKF8pe2lmKEFycmF5LmlzQXJyYXkoXykpcmV0dXJuIHgoXy5tYXAoUykpO2lmKF8udHlwZT09PVwiY29uY2F0XCJ8fF8udHlwZT09PVwiZmlsbFwiKXtsZXQgTz1fLnBhcnRzLm1hcChTKTtyZXR1cm4geChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sXykse30se3BhcnRzOk99KSl9aWYoXy50eXBlPT09XCJpZi1icmVha1wiKXtsZXQgTz1fLmJyZWFrQ29udGVudHMmJlMoXy5icmVha0NvbnRlbnRzKSxSPV8uZmxhdENvbnRlbnRzJiZTKF8uZmxhdENvbnRlbnRzKTtyZXR1cm4geChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sXykse30se2JyZWFrQ29udGVudHM6TyxmbGF0Q29udGVudHM6Un0pKX1pZihfLnR5cGU9PT1cImdyb3VwXCImJl8uZXhwYW5kZWRTdGF0ZXMpe2xldCBPPV8uZXhwYW5kZWRTdGF0ZXMubWFwKFMpLFI9T1swXTtyZXR1cm4geChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sXykse30se2NvbnRlbnRzOlIsZXhwYW5kZWRTdGF0ZXM6T30pKX1pZihfLmNvbnRlbnRzKXtsZXQgTz1TKF8uY29udGVudHMpO3JldHVybiB4KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxfKSx7fSx7Y29udGVudHM6T30pKX1yZXR1cm4geChfKX19ZnVuY3Rpb24gQyhvLHgsRil7bGV0IFM9RixrPSExO2Z1bmN0aW9uIF8oTyl7bGV0IFI9eChPKTtpZihSIT09dm9pZCAwJiYoaz0hMCxTPVIpLGspcmV0dXJuITF9cmV0dXJuIGMobyxfKSxTfWZ1bmN0aW9uIG0obyl7aWYoby50eXBlPT09XCJncm91cFwiJiZvLmJyZWFrfHxvLnR5cGU9PT1cImxpbmVcIiYmby5oYXJkfHxvLnR5cGU9PT1cImJyZWFrLXBhcmVudFwiKXJldHVybiEwfWZ1bmN0aW9uIGcobyl7cmV0dXJuIEMobyxtLCExKX1mdW5jdGlvbiBwKG8pe2lmKG8ubGVuZ3RoPjApe2xldCB4PXQobyk7IXguZXhwYW5kZWRTdGF0ZXMmJiF4LmJyZWFrJiYoeC5icmVhaz1cInByb3BhZ2F0ZWRcIil9cmV0dXJuIG51bGx9ZnVuY3Rpb24gZihvKXtsZXQgeD1uZXcgU2V0LEY9W107ZnVuY3Rpb24gUyhfKXtpZihfLnR5cGU9PT1cImJyZWFrLXBhcmVudFwiJiZwKEYpLF8udHlwZT09PVwiZ3JvdXBcIil7aWYoRi5wdXNoKF8pLHguaGFzKF8pKXJldHVybiExO3guYWRkKF8pfX1mdW5jdGlvbiBrKF8pe18udHlwZT09PVwiZ3JvdXBcIiYmRi5wb3AoKS5icmVhayYmcChGKX1jKG8sUyxrLCEwKX1mdW5jdGlvbiBoKG8pe3JldHVybiBvLnR5cGU9PT1cImxpbmVcIiYmIW8uaGFyZD9vLnNvZnQ/XCJcIjpcIiBcIjpvLnR5cGU9PT1cImlmLWJyZWFrXCI/by5mbGF0Q29udGVudHN8fFwiXCI6b31mdW5jdGlvbiBOKG8pe3JldHVybiBsKG8saCl9dmFyIFQ9KG8seCk9Pm8mJm8udHlwZT09PVwibGluZVwiJiZvLmhhcmQmJngmJngudHlwZT09PVwiYnJlYWstcGFyZW50XCI7ZnVuY3Rpb24gQShvKXtpZighbylyZXR1cm4gbztpZihyKG8pfHxvLnR5cGU9PT1cImZpbGxcIil7bGV0IHg9dShvKTtmb3IoO3gubGVuZ3RoPjEmJlQoLi4ueC5zbGljZSgtMikpOyl4Lmxlbmd0aC09MjtpZih4Lmxlbmd0aD4wKXtsZXQgRj1BKHQoeCkpO3hbeC5sZW5ndGgtMV09Rn1yZXR1cm4gQXJyYXkuaXNBcnJheShvKT94Ok9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxvKSx7fSx7cGFydHM6eH0pfXN3aXRjaChvLnR5cGUpe2Nhc2VcImFsaWduXCI6Y2FzZVwiaW5kZW50XCI6Y2FzZVwiaW5kZW50LWlmLWJyZWFrXCI6Y2FzZVwiZ3JvdXBcIjpjYXNlXCJsaW5lLXN1ZmZpeFwiOmNhc2VcImxhYmVsXCI6e2xldCB4PUEoby5jb250ZW50cyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxvKSx7fSx7Y29udGVudHM6eH0pfWNhc2VcImlmLWJyZWFrXCI6e2xldCB4PUEoby5icmVha0NvbnRlbnRzKSxGPUEoby5mbGF0Q29udGVudHMpO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbykse30se2JyZWFrQ29udGVudHM6eCxmbGF0Q29udGVudHM6Rn0pfX1yZXR1cm4gb31mdW5jdGlvbiBiKG8pe3JldHVybiBBKEIobykpfWZ1bmN0aW9uIHYobyl7c3dpdGNoKG8udHlwZSl7Y2FzZVwiZmlsbFwiOmlmKG8ucGFydHMuZXZlcnkoRj0+Rj09PVwiXCIpKXJldHVyblwiXCI7YnJlYWs7Y2FzZVwiZ3JvdXBcIjppZighby5jb250ZW50cyYmIW8uaWQmJiFvLmJyZWFrJiYhby5leHBhbmRlZFN0YXRlcylyZXR1cm5cIlwiO2lmKG8uY29udGVudHMudHlwZT09PVwiZ3JvdXBcIiYmby5jb250ZW50cy5pZD09PW8uaWQmJm8uY29udGVudHMuYnJlYWs9PT1vLmJyZWFrJiZvLmNvbnRlbnRzLmV4cGFuZGVkU3RhdGVzPT09by5leHBhbmRlZFN0YXRlcylyZXR1cm4gby5jb250ZW50czticmVhaztjYXNlXCJhbGlnblwiOmNhc2VcImluZGVudFwiOmNhc2VcImluZGVudC1pZi1icmVha1wiOmNhc2VcImxpbmUtc3VmZml4XCI6aWYoIW8uY29udGVudHMpcmV0dXJuXCJcIjticmVhaztjYXNlXCJpZi1icmVha1wiOmlmKCFvLmZsYXRDb250ZW50cyYmIW8uYnJlYWtDb250ZW50cylyZXR1cm5cIlwiO2JyZWFrfWlmKCFyKG8pKXJldHVybiBvO2xldCB4PVtdO2ZvcihsZXQgRiBvZiB1KG8pKXtpZighRiljb250aW51ZTtsZXRbUywuLi5rXT1yKEYpP3UoRik6W0ZdO3R5cGVvZiBTPT1cInN0cmluZ1wiJiZ0eXBlb2YgdCh4KT09XCJzdHJpbmdcIj94W3gubGVuZ3RoLTFdKz1TOngucHVzaChTKSx4LnB1c2goLi4uayl9cmV0dXJuIHgubGVuZ3RoPT09MD9cIlwiOngubGVuZ3RoPT09MT94WzBdOkFycmF5LmlzQXJyYXkobyk/eDpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbykse30se3BhcnRzOnh9KX1mdW5jdGlvbiBCKG8pe3JldHVybiBsKG8seD0+dih4KSl9ZnVuY3Rpb24gdyhvKXtsZXQgeD1bXSxGPW8uZmlsdGVyKEJvb2xlYW4pO2Zvcig7Ri5sZW5ndGg+MDspe2xldCBTPUYuc2hpZnQoKTtpZighIVMpe2lmKHIoUykpe0YudW5zaGlmdCguLi51KFMpKTtjb250aW51ZX1pZih4Lmxlbmd0aD4wJiZ0eXBlb2YgdCh4KT09XCJzdHJpbmdcIiYmdHlwZW9mIFM9PVwic3RyaW5nXCIpe3hbeC5sZW5ndGgtMV0rPVM7Y29udGludWV9eC5wdXNoKFMpfX1yZXR1cm4geH1mdW5jdGlvbiBJKG8pe3JldHVybiBsKG8seD0+QXJyYXkuaXNBcnJheSh4KT93KHgpOngucGFydHM/T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHgpLHt9LHtwYXJ0czp3KHgucGFydHMpfSk6eCl9ZnVuY3Rpb24gRShvKXtyZXR1cm4gbChvLHg9PnR5cGVvZiB4PT1cInN0cmluZ1wiJiZ4LmluY2x1ZGVzKGBcbmApP0QoeCk6eCl9ZnVuY3Rpb24gRChvKXtsZXQgeD1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06cztyZXR1cm4gaSh4LG8uc3BsaXQoYFxuYCkpLnBhcnRzfWZ1bmN0aW9uIGQobyl7aWYoby50eXBlPT09XCJsaW5lXCIpcmV0dXJuITB9ZnVuY3Rpb24geShvKXtyZXR1cm4gQyhvLGQsITEpfW4uZXhwb3J0cz17aXNDb25jYXQ6cixnZXREb2NQYXJ0czp1LHdpbGxCcmVhazpnLHRyYXZlcnNlRG9jOmMsZmluZEluRG9jOkMsbWFwRG9jOmwscHJvcGFnYXRlQnJlYWtzOmYscmVtb3ZlTGluZXM6TixzdHJpcFRyYWlsaW5nSGFyZGxpbmU6Yixub3JtYWxpemVQYXJ0czp3LG5vcm1hbGl6ZURvYzpJLGNsZWFuRG9jOkIscmVwbGFjZVRleHRFbmRPZkxpbmU6RCxyZXBsYWNlRW5kT2ZMaW5lOkUsY2FuQnJlYWs6eX19fSksdUQ9Wih7XCJzcmMvZG9jdW1lbnQvZG9jLXByaW50ZXIuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2NvbnZlcnRFbmRPZkxpbmVUb0NoYXJzOnR9PU9uKCkscz1zdCgpLGk9eWkoKSx7ZmlsbDpyLGN1cnNvcjp1LGluZGVudDphfT1MbigpLHtpc0NvbmNhdDpjLGdldERvY1BhcnRzOmx9PWpuKCksQyxtPTEsZz0yO2Z1bmN0aW9uIHAoKXtyZXR1cm57dmFsdWU6XCJcIixsZW5ndGg6MCxxdWV1ZTpbXX19ZnVuY3Rpb24gZih2LEIpe3JldHVybiBOKHYse3R5cGU6XCJpbmRlbnRcIn0sQil9ZnVuY3Rpb24gaCh2LEIsdyl7cmV0dXJuIEI9PT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk/di5yb290fHxwKCk6QjwwP04odix7dHlwZTpcImRlZGVudFwifSx3KTpCP0IudHlwZT09PVwicm9vdFwiP09iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx2KSx7fSx7cm9vdDp2fSk6Tih2LHt0eXBlOnR5cGVvZiBCPT1cInN0cmluZ1wiP1wic3RyaW5nQWxpZ25cIjpcIm51bWJlckFsaWduXCIsbjpCfSx3KTp2fWZ1bmN0aW9uIE4odixCLHcpe2xldCBJPUIudHlwZT09PVwiZGVkZW50XCI/di5xdWV1ZS5zbGljZSgwLC0xKTpbLi4udi5xdWV1ZSxCXSxFPVwiXCIsRD0wLGQ9MCx5PTA7Zm9yKGxldCBPIG9mIEkpc3dpdGNoKE8udHlwZSl7Y2FzZVwiaW5kZW50XCI6RigpLHcudXNlVGFicz9vKDEpOngody50YWJXaWR0aCk7YnJlYWs7Y2FzZVwic3RyaW5nQWxpZ25cIjpGKCksRSs9Ty5uLEQrPU8ubi5sZW5ndGg7YnJlYWs7Y2FzZVwibnVtYmVyQWxpZ25cIjpkKz0xLHkrPU8ubjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdHlwZSAnXCIuY29uY2F0KE8udHlwZSxcIidcIikpfXJldHVybiBrKCksT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHYpLHt9LHt2YWx1ZTpFLGxlbmd0aDpELHF1ZXVlOkl9KTtmdW5jdGlvbiBvKE8pe0UrPVwiXHRcIi5yZXBlYXQoTyksRCs9dy50YWJXaWR0aCpPfWZ1bmN0aW9uIHgoTyl7RSs9XCIgXCIucmVwZWF0KE8pLEQrPU99ZnVuY3Rpb24gRigpe3cudXNlVGFicz9TKCk6aygpfWZ1bmN0aW9uIFMoKXtkPjAmJm8oZCksXygpfWZ1bmN0aW9uIGsoKXt5PjAmJngoeSksXygpfWZ1bmN0aW9uIF8oKXtkPTAseT0wfX1mdW5jdGlvbiBUKHYpe2lmKHYubGVuZ3RoPT09MClyZXR1cm4gMDtsZXQgQj0wO2Zvcig7di5sZW5ndGg+MCYmdHlwZW9mIHModik9PVwic3RyaW5nXCImJi9eW1xcdCBdKiQvLnRlc3Qocyh2KSk7KUIrPXYucG9wKCkubGVuZ3RoO2lmKHYubGVuZ3RoPjAmJnR5cGVvZiBzKHYpPT1cInN0cmluZ1wiKXtsZXQgdz1zKHYpLnJlcGxhY2UoL1tcXHQgXSokLyxcIlwiKTtCKz1zKHYpLmxlbmd0aC13Lmxlbmd0aCx2W3YubGVuZ3RoLTFdPXd9cmV0dXJuIEJ9ZnVuY3Rpb24gQSh2LEIsdyxJLEUsRCl7bGV0IGQ9Qi5sZW5ndGgseT1bdl0sbz1bXTtmb3IoO3c+PTA7KXtpZih5Lmxlbmd0aD09PTApe2lmKGQ9PT0wKXJldHVybiEwO3kucHVzaChCW2QtMV0pLGQtLTtjb250aW51ZX1sZXRbeCxGLFNdPXkucG9wKCk7aWYodHlwZW9mIFM9PVwic3RyaW5nXCIpby5wdXNoKFMpLHctPWkoUyk7ZWxzZSBpZihjKFMpKXtsZXQgaz1sKFMpO2ZvcihsZXQgXz1rLmxlbmd0aC0xO18+PTA7Xy0tKXkucHVzaChbeCxGLGtbX11dKX1lbHNlIHN3aXRjaChTLnR5cGUpe2Nhc2VcImluZGVudFwiOnkucHVzaChbZih4LEkpLEYsUy5jb250ZW50c10pO2JyZWFrO2Nhc2VcImFsaWduXCI6eS5wdXNoKFtoKHgsUy5uLEkpLEYsUy5jb250ZW50c10pO2JyZWFrO2Nhc2VcInRyaW1cIjp3Kz1UKG8pO2JyZWFrO2Nhc2VcImdyb3VwXCI6e2lmKEQmJlMuYnJlYWspcmV0dXJuITE7bGV0IGs9Uy5icmVhaz9tOkY7eS5wdXNoKFt4LGssUy5leHBhbmRlZFN0YXRlcyYmaz09PW0/cyhTLmV4cGFuZGVkU3RhdGVzKTpTLmNvbnRlbnRzXSksUy5pZCYmKENbUy5pZF09ayk7YnJlYWt9Y2FzZVwiZmlsbFwiOmZvcihsZXQgaz1TLnBhcnRzLmxlbmd0aC0xO2s+PTA7ay0tKXkucHVzaChbeCxGLFMucGFydHNba11dKTticmVhaztjYXNlXCJpZi1icmVha1wiOmNhc2VcImluZGVudC1pZi1icmVha1wiOntsZXQgaz1TLmdyb3VwSWQ/Q1tTLmdyb3VwSWRdOkY7aWYoaz09PW0pe2xldCBfPVMudHlwZT09PVwiaWYtYnJlYWtcIj9TLmJyZWFrQ29udGVudHM6Uy5uZWdhdGU/Uy5jb250ZW50czphKFMuY29udGVudHMpO18mJnkucHVzaChbeCxGLF9dKX1pZihrPT09Zyl7bGV0IF89Uy50eXBlPT09XCJpZi1icmVha1wiP1MuZmxhdENvbnRlbnRzOlMubmVnYXRlP2EoUy5jb250ZW50cyk6Uy5jb250ZW50cztfJiZ5LnB1c2goW3gsRixfXSl9YnJlYWt9Y2FzZVwibGluZVwiOnN3aXRjaChGKXtjYXNlIGc6aWYoIVMuaGFyZCl7Uy5zb2Z0fHwoby5wdXNoKFwiIFwiKSx3LT0xKTticmVha31yZXR1cm4hMDtjYXNlIG06cmV0dXJuITB9YnJlYWs7Y2FzZVwibGluZS1zdWZmaXhcIjpFPSEwO2JyZWFrO2Nhc2VcImxpbmUtc3VmZml4LWJvdW5kYXJ5XCI6aWYoRSlyZXR1cm4hMTticmVhaztjYXNlXCJsYWJlbFwiOnkucHVzaChbeCxGLFMuY29udGVudHNdKTticmVha319cmV0dXJuITF9ZnVuY3Rpb24gYih2LEIpe0M9e307bGV0IHc9Qi5wcmludFdpZHRoLEk9dChCLmVuZE9mTGluZSksRT0wLEQ9W1twKCksbSx2XV0sZD1bXSx5PSExLG89W107Zm9yKDtELmxlbmd0aD4wOyl7bGV0W0YsUyxrXT1ELnBvcCgpO2lmKHR5cGVvZiBrPT1cInN0cmluZ1wiKXtsZXQgXz1JIT09YFxuYD9rLnJlcGxhY2UoL1xcbi9nLEkpOms7ZC5wdXNoKF8pLEUrPWkoXyl9ZWxzZSBpZihjKGspKXtsZXQgXz1sKGspO2ZvcihsZXQgTz1fLmxlbmd0aC0xO08+PTA7Ty0tKUQucHVzaChbRixTLF9bT11dKX1lbHNlIHN3aXRjaChrLnR5cGUpe2Nhc2VcImN1cnNvclwiOmQucHVzaCh1LnBsYWNlaG9sZGVyKTticmVhaztjYXNlXCJpbmRlbnRcIjpELnB1c2goW2YoRixCKSxTLGsuY29udGVudHNdKTticmVhaztjYXNlXCJhbGlnblwiOkQucHVzaChbaChGLGsubixCKSxTLGsuY29udGVudHNdKTticmVhaztjYXNlXCJ0cmltXCI6RS09VChkKTticmVhaztjYXNlXCJncm91cFwiOnN3aXRjaChTKXtjYXNlIGc6aWYoIXkpe0QucHVzaChbRixrLmJyZWFrP206ZyxrLmNvbnRlbnRzXSk7YnJlYWt9Y2FzZSBtOnt5PSExO2xldCBfPVtGLGcsay5jb250ZW50c10sTz13LUUsUj1vLmxlbmd0aD4wO2lmKCFrLmJyZWFrJiZBKF8sRCxPLEIsUikpRC5wdXNoKF8pO2Vsc2UgaWYoay5leHBhbmRlZFN0YXRlcyl7bGV0IE09cyhrLmV4cGFuZGVkU3RhdGVzKTtpZihrLmJyZWFrKXtELnB1c2goW0YsbSxNXSk7YnJlYWt9ZWxzZSBmb3IobGV0IEg9MTtIPGsuZXhwYW5kZWRTdGF0ZXMubGVuZ3RoKzE7SCsrKWlmKEg+PWsuZXhwYW5kZWRTdGF0ZXMubGVuZ3RoKXtELnB1c2goW0YsbSxNXSk7YnJlYWt9ZWxzZXtsZXQgUD1rLmV4cGFuZGVkU3RhdGVzW0hdLEc9W0YsZyxQXTtpZihBKEcsRCxPLEIsUikpe0QucHVzaChHKTticmVha319fWVsc2UgRC5wdXNoKFtGLG0say5jb250ZW50c10pO2JyZWFrfX1rLmlkJiYoQ1trLmlkXT1zKEQpWzFdKTticmVhaztjYXNlXCJmaWxsXCI6e2xldCBfPXctRSx7cGFydHM6T309aztpZihPLmxlbmd0aD09PTApYnJlYWs7bGV0W1IsTV09TyxIPVtGLGcsUl0sUD1bRixtLFJdLEc9QShILFtdLF8sQixvLmxlbmd0aD4wLCEwKTtpZihPLmxlbmd0aD09PTEpe0c/RC5wdXNoKEgpOkQucHVzaChQKTticmVha31sZXQgcmU9W0YsZyxNXSwkPVtGLG0sTV07aWYoTy5sZW5ndGg9PT0yKXtHP0QucHVzaChyZSxIKTpELnB1c2goJCxQKTticmVha31PLnNwbGljZSgwLDIpO2xldCBXPVtGLFMscihPKV0sZWU9T1swXTtBKFtGLGcsW1IsTSxlZV1dLFtdLF8sQixvLmxlbmd0aD4wLCEwKT9ELnB1c2goVyxyZSxIKTpHP0QucHVzaChXLCQsSCk6RC5wdXNoKFcsJCxQKTticmVha31jYXNlXCJpZi1icmVha1wiOmNhc2VcImluZGVudC1pZi1icmVha1wiOntsZXQgXz1rLmdyb3VwSWQ/Q1trLmdyb3VwSWRdOlM7aWYoXz09PW0pe2xldCBPPWsudHlwZT09PVwiaWYtYnJlYWtcIj9rLmJyZWFrQ29udGVudHM6ay5uZWdhdGU/ay5jb250ZW50czphKGsuY29udGVudHMpO08mJkQucHVzaChbRixTLE9dKX1pZihfPT09Zyl7bGV0IE89ay50eXBlPT09XCJpZi1icmVha1wiP2suZmxhdENvbnRlbnRzOmsubmVnYXRlP2Eoay5jb250ZW50cyk6ay5jb250ZW50cztPJiZELnB1c2goW0YsUyxPXSl9YnJlYWt9Y2FzZVwibGluZS1zdWZmaXhcIjpvLnB1c2goW0YsUyxrLmNvbnRlbnRzXSk7YnJlYWs7Y2FzZVwibGluZS1zdWZmaXgtYm91bmRhcnlcIjpvLmxlbmd0aD4wJiZELnB1c2goW0YsUyx7dHlwZTpcImxpbmVcIixoYXJkOiEwfV0pO2JyZWFrO2Nhc2VcImxpbmVcIjpzd2l0Y2goUyl7Y2FzZSBnOmlmKGsuaGFyZCl5PSEwO2Vsc2V7ay5zb2Z0fHwoZC5wdXNoKFwiIFwiKSxFKz0xKTticmVha31jYXNlIG06aWYoby5sZW5ndGg+MCl7RC5wdXNoKFtGLFMsa10sLi4uby5yZXZlcnNlKCkpLG89W107YnJlYWt9ay5saXRlcmFsP0Yucm9vdD8oZC5wdXNoKEksRi5yb290LnZhbHVlKSxFPUYucm9vdC5sZW5ndGgpOihkLnB1c2goSSksRT0wKTooRS09VChkKSxkLnB1c2goSStGLnZhbHVlKSxFPUYubGVuZ3RoKTticmVha31icmVhaztjYXNlXCJsYWJlbFwiOkQucHVzaChbRixTLGsuY29udGVudHNdKTticmVhaztkZWZhdWx0On1ELmxlbmd0aD09PTAmJm8ubGVuZ3RoPjAmJihELnB1c2goLi4uby5yZXZlcnNlKCkpLG89W10pfWxldCB4PWQuaW5kZXhPZih1LnBsYWNlaG9sZGVyKTtpZih4IT09LTEpe2xldCBGPWQuaW5kZXhPZih1LnBsYWNlaG9sZGVyLHgrMSksUz1kLnNsaWNlKDAseCkuam9pbihcIlwiKSxrPWQuc2xpY2UoeCsxLEYpLmpvaW4oXCJcIiksXz1kLnNsaWNlKEYrMSkuam9pbihcIlwiKTtyZXR1cm57Zm9ybWF0dGVkOlMraytfLGN1cnNvck5vZGVTdGFydDpTLmxlbmd0aCxjdXJzb3JOb2RlVGV4dDprfX1yZXR1cm57Zm9ybWF0dGVkOmQuam9pbihcIlwiKX19bi5leHBvcnRzPXtwcmludERvY1RvU3RyaW5nOmJ9fX0pLHNEPVooe1wic3JjL2RvY3VtZW50L2RvYy1kZWJ1Zy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7aXNDb25jYXQ6dCxnZXREb2NQYXJ0czpzfT1qbigpO2Z1bmN0aW9uIGkodSl7aWYoIXUpcmV0dXJuXCJcIjtpZih0KHUpKXtsZXQgYT1bXTtmb3IobGV0IGMgb2Ygcyh1KSlpZih0KGMpKWEucHVzaCguLi5pKGMpLnBhcnRzKTtlbHNle2xldCBsPWkoYyk7bCE9PVwiXCImJmEucHVzaChsKX1yZXR1cm57dHlwZTpcImNvbmNhdFwiLHBhcnRzOmF9fXJldHVybiB1LnR5cGU9PT1cImlmLWJyZWFrXCI/T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHt9LHticmVha0NvbnRlbnRzOmkodS5icmVha0NvbnRlbnRzKSxmbGF0Q29udGVudHM6aSh1LmZsYXRDb250ZW50cyl9KTp1LnR5cGU9PT1cImdyb3VwXCI/T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHt9LHtjb250ZW50czppKHUuY29udGVudHMpLGV4cGFuZGVkU3RhdGVzOnUuZXhwYW5kZWRTdGF0ZXMmJnUuZXhwYW5kZWRTdGF0ZXMubWFwKGkpfSk6dS50eXBlPT09XCJmaWxsXCI/e3R5cGU6XCJmaWxsXCIscGFydHM6dS5wYXJ0cy5tYXAoaSl9OnUuY29udGVudHM/T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHt9LHtjb250ZW50czppKHUuY29udGVudHMpfSk6dX1mdW5jdGlvbiByKHUpe2xldCBhPU9iamVjdC5jcmVhdGUobnVsbCksYz1uZXcgU2V0O3JldHVybiBsKGkodSkpO2Z1bmN0aW9uIGwobSxnLHApe2lmKHR5cGVvZiBtPT1cInN0cmluZ1wiKXJldHVybiBKU09OLnN0cmluZ2lmeShtKTtpZih0KG0pKXtsZXQgZj1zKG0pLm1hcChsKS5maWx0ZXIoQm9vbGVhbik7cmV0dXJuIGYubGVuZ3RoPT09MT9mWzBdOlwiW1wiLmNvbmNhdChmLmpvaW4oXCIsIFwiKSxcIl1cIil9aWYobS50eXBlPT09XCJsaW5lXCIpe2xldCBmPUFycmF5LmlzQXJyYXkocCkmJnBbZysxXSYmcFtnKzFdLnR5cGU9PT1cImJyZWFrLXBhcmVudFwiO3JldHVybiBtLmxpdGVyYWw/Zj9cImxpdGVyYWxsaW5lXCI6XCJsaXRlcmFsbGluZVdpdGhvdXRCcmVha1BhcmVudFwiOm0uaGFyZD9mP1wiaGFyZGxpbmVcIjpcImhhcmRsaW5lV2l0aG91dEJyZWFrUGFyZW50XCI6bS5zb2Z0P1wic29mdGxpbmVcIjpcImxpbmVcIn1pZihtLnR5cGU9PT1cImJyZWFrLXBhcmVudFwiKXJldHVybiBBcnJheS5pc0FycmF5KHApJiZwW2ctMV0mJnBbZy0xXS50eXBlPT09XCJsaW5lXCImJnBbZy0xXS5oYXJkP3ZvaWQgMDpcImJyZWFrUGFyZW50XCI7aWYobS50eXBlPT09XCJ0cmltXCIpcmV0dXJuXCJ0cmltXCI7aWYobS50eXBlPT09XCJpbmRlbnRcIilyZXR1cm5cImluZGVudChcIitsKG0uY29udGVudHMpK1wiKVwiO2lmKG0udHlwZT09PVwiYWxpZ25cIilyZXR1cm4gbS5uPT09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZP1wiZGVkZW50VG9Sb290KFwiK2wobS5jb250ZW50cykrXCIpXCI6bS5uPDA/XCJkZWRlbnQoXCIrbChtLmNvbnRlbnRzKStcIilcIjptLm4udHlwZT09PVwicm9vdFwiP1wibWFya0FzUm9vdChcIitsKG0uY29udGVudHMpK1wiKVwiOlwiYWxpZ24oXCIrSlNPTi5zdHJpbmdpZnkobS5uKStcIiwgXCIrbChtLmNvbnRlbnRzKStcIilcIjtpZihtLnR5cGU9PT1cImlmLWJyZWFrXCIpcmV0dXJuXCJpZkJyZWFrKFwiK2wobS5icmVha0NvbnRlbnRzKSsobS5mbGF0Q29udGVudHM/XCIsIFwiK2wobS5mbGF0Q29udGVudHMpOlwiXCIpKyhtLmdyb3VwSWQ/KG0uZmxhdENvbnRlbnRzP1wiXCI6JywgXCJcIicpK1wiLCB7IGdyb3VwSWQ6IFwiLmNvbmNhdChDKG0uZ3JvdXBJZCksXCIgfVwiKTpcIlwiKStcIilcIjtpZihtLnR5cGU9PT1cImluZGVudC1pZi1icmVha1wiKXtsZXQgZj1bXTttLm5lZ2F0ZSYmZi5wdXNoKFwibmVnYXRlOiB0cnVlXCIpLG0uZ3JvdXBJZCYmZi5wdXNoKFwiZ3JvdXBJZDogXCIuY29uY2F0KEMobS5ncm91cElkKSkpO2xldCBoPWYubGVuZ3RoPjA/XCIsIHsgXCIuY29uY2F0KGYuam9pbihcIiwgXCIpLFwiIH1cIik6XCJcIjtyZXR1cm5cImluZGVudElmQnJlYWsoXCIuY29uY2F0KGwobS5jb250ZW50cykpLmNvbmNhdChoLFwiKVwiKX1pZihtLnR5cGU9PT1cImdyb3VwXCIpe2xldCBmPVtdO20uYnJlYWsmJm0uYnJlYWshPT1cInByb3BhZ2F0ZWRcIiYmZi5wdXNoKFwic2hvdWxkQnJlYWs6IHRydWVcIiksbS5pZCYmZi5wdXNoKFwiaWQ6IFwiLmNvbmNhdChDKG0uaWQpKSk7bGV0IGg9Zi5sZW5ndGg+MD9cIiwgeyBcIi5jb25jYXQoZi5qb2luKFwiLCBcIiksXCIgfVwiKTpcIlwiO3JldHVybiBtLmV4cGFuZGVkU3RhdGVzP1wiY29uZGl0aW9uYWxHcm91cChbXCIuY29uY2F0KG0uZXhwYW5kZWRTdGF0ZXMubWFwKE49PmwoTikpLmpvaW4oXCIsXCIpLFwiXVwiKS5jb25jYXQoaCxcIilcIik6XCJncm91cChcIi5jb25jYXQobChtLmNvbnRlbnRzKSkuY29uY2F0KGgsXCIpXCIpfWlmKG0udHlwZT09PVwiZmlsbFwiKXJldHVyblwiZmlsbChbXCIuY29uY2F0KG0ucGFydHMubWFwKGY9PmwoZikpLmpvaW4oXCIsIFwiKSxcIl0pXCIpO2lmKG0udHlwZT09PVwibGluZS1zdWZmaXhcIilyZXR1cm5cImxpbmVTdWZmaXgoXCIrbChtLmNvbnRlbnRzKStcIilcIjtpZihtLnR5cGU9PT1cImxpbmUtc3VmZml4LWJvdW5kYXJ5XCIpcmV0dXJuXCJsaW5lU3VmZml4Qm91bmRhcnlcIjtpZihtLnR5cGU9PT1cImxhYmVsXCIpcmV0dXJuXCJsYWJlbChcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkobS5sYWJlbCksXCIsIFwiKS5jb25jYXQobChtLmNvbnRlbnRzKSxcIilcIik7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkb2MgdHlwZSBcIittLnR5cGUpfWZ1bmN0aW9uIEMobSl7aWYodHlwZW9mIG0hPVwic3ltYm9sXCIpcmV0dXJuIEpTT04uc3RyaW5naWZ5KFN0cmluZyhtKSk7aWYobSBpbiBhKXJldHVybiBhW21dO2xldCBnPVN0cmluZyhtKS5zbGljZSg3LC0xKXx8XCJzeW1ib2xcIjtmb3IobGV0IHA9MDs7cCsrKXtsZXQgZj1nKyhwPjA/XCIgI1wiLmNvbmNhdChwKTpcIlwiKTtpZighYy5oYXMoZikpcmV0dXJuIGMuYWRkKGYpLGFbbV09XCJTeW1ib2wuZm9yKFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShmKSxcIilcIil9fX1uLmV4cG9ydHM9e3ByaW50RG9jVG9EZWJ1ZzpyfX19KSxMZT1aKHtcInNyYy9kb2N1bWVudC9pbmRleC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKSxuLmV4cG9ydHM9e2J1aWxkZXJzOkxuKCkscHJpbnRlcjp1RCgpLHV0aWxzOmpuKCksZGVidWc6c0QoKX19fSksYUQ9Wih7XCJ2ZW5kb3JzL2VzY2FwZS1zdHJpbmctcmVnZXhwLmpzXCIoZSxuKXthZSgpO3ZhciB0PU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsaT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxyPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksdT0obSxnKT0+e2Zvcih2YXIgcCBpbiBnKXQobSxwLHtnZXQ6Z1twXSxlbnVtZXJhYmxlOiEwfSl9LGE9KG0sZyxwLGYpPT57aWYoZyYmdHlwZW9mIGc9PVwib2JqZWN0XCJ8fHR5cGVvZiBnPT1cImZ1bmN0aW9uXCIpZm9yKGxldCBoIG9mIGkoZykpIXIuY2FsbChtLGgpJiZoIT09cCYmdChtLGgse2dldDooKT0+Z1toXSxlbnVtZXJhYmxlOiEoZj1zKGcsaCkpfHxmLmVudW1lcmFibGV9KTtyZXR1cm4gbX0sYz1tPT5hKHQoe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbSksbD17fTt1KGwse2RlZmF1bHQ6KCk9PkN9KSxuLmV4cG9ydHM9YyhsKTtmdW5jdGlvbiBDKG0pe2lmKHR5cGVvZiBtIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtyZXR1cm4gbS5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZyxcIlxcXFwkJlwiKS5yZXBsYWNlKC8tL2csXCJcXFxceDJkXCIpfX19KSxoaT1aKHtcIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanNcIihlLG4pe2FlKCk7dmFyIHQ9dHlwZW9mIHh0PT1cIm9iamVjdFwiJiZ4dC5lbnYmJnh0LmVudi5OT0RFX0RFQlVHJiYvXFxic2VtdmVyXFxiL2kudGVzdCh4dC5lbnYuTk9ERV9ERUJVRyk/ZnVuY3Rpb24oKXtmb3IodmFyIHM9YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShzKSxyPTA7cjxzO3IrKylpW3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gY29uc29sZS5lcnJvcihcIlNFTVZFUlwiLC4uLmkpfTooKT0+e307bi5leHBvcnRzPXR9fSksQ2k9Wih7XCJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qc1wiKGUsbil7YWUoKTt2YXIgdD1cIjIuMC4wXCIscz0yNTYsaT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUnx8OTAwNzE5OTI1NDc0MDk5MSxyPTE2O24uZXhwb3J0cz17U0VNVkVSX1NQRUNfVkVSU0lPTjp0LE1BWF9MRU5HVEg6cyxNQVhfU0FGRV9JTlRFR0VSOmksTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSDpyfX19KSxpRD1aKHtcIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcmUuanNcIihlLG4pe2FlKCk7dmFye01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEg6dH09Q2koKSxzPWhpKCk7ZT1uLmV4cG9ydHM9e307dmFyIGk9ZS5yZT1bXSxyPWUuc3JjPVtdLHU9ZS50PXt9LGE9MCxjPShsLEMsbSk9PntsZXQgZz1hKys7cyhnLEMpLHVbbF09ZyxyW2ddPUMsaVtnXT1uZXcgUmVnRXhwKEMsbT9cImdcIjp2b2lkIDApfTtjKFwiTlVNRVJJQ0lERU5USUZJRVJcIixcIjB8WzEtOV1cXFxcZCpcIiksYyhcIk5VTUVSSUNJREVOVElGSUVSTE9PU0VcIixcIlswLTldK1wiKSxjKFwiTk9OTlVNRVJJQ0lERU5USUZJRVJcIixcIlxcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSpcIiksYyhcIk1BSU5WRVJTSU9OXCIsXCIoXCIuY29uY2F0KHJbdS5OVU1FUklDSURFTlRJRklFUl0sXCIpXFxcXC4oXCIpLmNvbmNhdChyW3UuTlVNRVJJQ0lERU5USUZJRVJdLFwiKVxcXFwuKFwiKS5jb25jYXQoclt1Lk5VTUVSSUNJREVOVElGSUVSXSxcIilcIikpLGMoXCJNQUlOVkVSU0lPTkxPT1NFXCIsXCIoXCIuY29uY2F0KHJbdS5OVU1FUklDSURFTlRJRklFUkxPT1NFXSxcIilcXFxcLihcIikuY29uY2F0KHJbdS5OVU1FUklDSURFTlRJRklFUkxPT1NFXSxcIilcXFxcLihcIikuY29uY2F0KHJbdS5OVU1FUklDSURFTlRJRklFUkxPT1NFXSxcIilcIikpLGMoXCJQUkVSRUxFQVNFSURFTlRJRklFUlwiLFwiKD86XCIuY29uY2F0KHJbdS5OVU1FUklDSURFTlRJRklFUl0sXCJ8XCIpLmNvbmNhdChyW3UuTk9OTlVNRVJJQ0lERU5USUZJRVJdLFwiKVwiKSksYyhcIlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VcIixcIig/OlwiLmNvbmNhdChyW3UuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0sXCJ8XCIpLmNvbmNhdChyW3UuTk9OTlVNRVJJQ0lERU5USUZJRVJdLFwiKVwiKSksYyhcIlBSRVJFTEVBU0VcIixcIig/Oi0oXCIuY29uY2F0KHJbdS5QUkVSRUxFQVNFSURFTlRJRklFUl0sXCIoPzpcXFxcLlwiKS5jb25jYXQoclt1LlBSRVJFTEVBU0VJREVOVElGSUVSXSxcIikqKSlcIikpLGMoXCJQUkVSRUxFQVNFTE9PU0VcIixcIig/Oi0/KFwiLmNvbmNhdChyW3UuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0sXCIoPzpcXFxcLlwiKS5jb25jYXQoclt1LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdLFwiKSopKVwiKSksYyhcIkJVSUxESURFTlRJRklFUlwiLFwiWzAtOUEtWmEtei1dK1wiKSxjKFwiQlVJTERcIixcIig/OlxcXFwrKFwiLmNvbmNhdChyW3UuQlVJTERJREVOVElGSUVSXSxcIig/OlxcXFwuXCIpLmNvbmNhdChyW3UuQlVJTERJREVOVElGSUVSXSxcIikqKSlcIikpLGMoXCJGVUxMUExBSU5cIixcInY/XCIuY29uY2F0KHJbdS5NQUlOVkVSU0lPTl0pLmNvbmNhdChyW3UuUFJFUkVMRUFTRV0sXCI/XCIpLmNvbmNhdChyW3UuQlVJTERdLFwiP1wiKSksYyhcIkZVTExcIixcIl5cIi5jb25jYXQoclt1LkZVTExQTEFJTl0sXCIkXCIpKSxjKFwiTE9PU0VQTEFJTlwiLFwiW3Y9XFxcXHNdKlwiLmNvbmNhdChyW3UuTUFJTlZFUlNJT05MT09TRV0pLmNvbmNhdChyW3UuUFJFUkVMRUFTRUxPT1NFXSxcIj9cIikuY29uY2F0KHJbdS5CVUlMRF0sXCI/XCIpKSxjKFwiTE9PU0VcIixcIl5cIi5jb25jYXQoclt1LkxPT1NFUExBSU5dLFwiJFwiKSksYyhcIkdUTFRcIixcIigoPzo8fD4pPz0/KVwiKSxjKFwiWFJBTkdFSURFTlRJRklFUkxPT1NFXCIsXCJcIi5jb25jYXQoclt1Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdLFwifHh8WHxcXFxcKlwiKSksYyhcIlhSQU5HRUlERU5USUZJRVJcIixcIlwiLmNvbmNhdChyW3UuTlVNRVJJQ0lERU5USUZJRVJdLFwifHh8WHxcXFxcKlwiKSksYyhcIlhSQU5HRVBMQUlOXCIsXCJbdj1cXFxcc10qKFwiLmNvbmNhdChyW3UuWFJBTkdFSURFTlRJRklFUl0sXCIpKD86XFxcXC4oXCIpLmNvbmNhdChyW3UuWFJBTkdFSURFTlRJRklFUl0sXCIpKD86XFxcXC4oXCIpLmNvbmNhdChyW3UuWFJBTkdFSURFTlRJRklFUl0sXCIpKD86XCIpLmNvbmNhdChyW3UuUFJFUkVMRUFTRV0sXCIpP1wiKS5jb25jYXQoclt1LkJVSUxEXSxcIj8pPyk/XCIpKSxjKFwiWFJBTkdFUExBSU5MT09TRVwiLFwiW3Y9XFxcXHNdKihcIi5jb25jYXQoclt1LlhSQU5HRUlERU5USUZJRVJMT09TRV0sXCIpKD86XFxcXC4oXCIpLmNvbmNhdChyW3UuWFJBTkdFSURFTlRJRklFUkxPT1NFXSxcIikoPzpcXFxcLihcIikuY29uY2F0KHJbdS5YUkFOR0VJREVOVElGSUVSTE9PU0VdLFwiKSg/OlwiKS5jb25jYXQoclt1LlBSRVJFTEVBU0VMT09TRV0sXCIpP1wiKS5jb25jYXQoclt1LkJVSUxEXSxcIj8pPyk/XCIpKSxjKFwiWFJBTkdFXCIsXCJeXCIuY29uY2F0KHJbdS5HVExUXSxcIlxcXFxzKlwiKS5jb25jYXQoclt1LlhSQU5HRVBMQUlOXSxcIiRcIikpLGMoXCJYUkFOR0VMT09TRVwiLFwiXlwiLmNvbmNhdChyW3UuR1RMVF0sXCJcXFxccypcIikuY29uY2F0KHJbdS5YUkFOR0VQTEFJTkxPT1NFXSxcIiRcIikpLGMoXCJDT0VSQ0VcIixcIihefFteXFxcXGRdKShcXFxcZHsxLFwiLmNvbmNhdCh0LFwifSkoPzpcXFxcLihcXFxcZHsxLFwiKS5jb25jYXQodCxcIn0pKT8oPzpcXFxcLihcXFxcZHsxLFwiKS5jb25jYXQodCxcIn0pKT8oPzokfFteXFxcXGRdKVwiKSksYyhcIkNPRVJDRVJUTFwiLHJbdS5DT0VSQ0VdLCEwKSxjKFwiTE9ORVRJTERFXCIsXCIoPzp+Pj8pXCIpLGMoXCJUSUxERVRSSU1cIixcIihcXFxccyopXCIuY29uY2F0KHJbdS5MT05FVElMREVdLFwiXFxcXHMrXCIpLCEwKSxlLnRpbGRlVHJpbVJlcGxhY2U9XCIkMX5cIixjKFwiVElMREVcIixcIl5cIi5jb25jYXQoclt1LkxPTkVUSUxERV0pLmNvbmNhdChyW3UuWFJBTkdFUExBSU5dLFwiJFwiKSksYyhcIlRJTERFTE9PU0VcIixcIl5cIi5jb25jYXQoclt1LkxPTkVUSUxERV0pLmNvbmNhdChyW3UuWFJBTkdFUExBSU5MT09TRV0sXCIkXCIpKSxjKFwiTE9ORUNBUkVUXCIsXCIoPzpcXFxcXilcIiksYyhcIkNBUkVUVFJJTVwiLFwiKFxcXFxzKilcIi5jb25jYXQoclt1LkxPTkVDQVJFVF0sXCJcXFxccytcIiksITApLGUuY2FyZXRUcmltUmVwbGFjZT1cIiQxXlwiLGMoXCJDQVJFVFwiLFwiXlwiLmNvbmNhdChyW3UuTE9ORUNBUkVUXSkuY29uY2F0KHJbdS5YUkFOR0VQTEFJTl0sXCIkXCIpKSxjKFwiQ0FSRVRMT09TRVwiLFwiXlwiLmNvbmNhdChyW3UuTE9ORUNBUkVUXSkuY29uY2F0KHJbdS5YUkFOR0VQTEFJTkxPT1NFXSxcIiRcIikpLGMoXCJDT01QQVJBVE9STE9PU0VcIixcIl5cIi5jb25jYXQoclt1LkdUTFRdLFwiXFxcXHMqKFwiKS5jb25jYXQoclt1LkxPT1NFUExBSU5dLFwiKSR8XiRcIikpLGMoXCJDT01QQVJBVE9SXCIsXCJeXCIuY29uY2F0KHJbdS5HVExUXSxcIlxcXFxzKihcIikuY29uY2F0KHJbdS5GVUxMUExBSU5dLFwiKSR8XiRcIikpLGMoXCJDT01QQVJBVE9SVFJJTVwiLFwiKFxcXFxzKilcIi5jb25jYXQoclt1LkdUTFRdLFwiXFxcXHMqKFwiKS5jb25jYXQoclt1LkxPT1NFUExBSU5dLFwifFwiKS5jb25jYXQoclt1LlhSQU5HRVBMQUlOXSxcIilcIiksITApLGUuY29tcGFyYXRvclRyaW1SZXBsYWNlPVwiJDEkMiQzXCIsYyhcIkhZUEhFTlJBTkdFXCIsXCJeXFxcXHMqKFwiLmNvbmNhdChyW3UuWFJBTkdFUExBSU5dLFwiKVxcXFxzKy1cXFxccysoXCIpLmNvbmNhdChyW3UuWFJBTkdFUExBSU5dLFwiKVxcXFxzKiRcIikpLGMoXCJIWVBIRU5SQU5HRUxPT1NFXCIsXCJeXFxcXHMqKFwiLmNvbmNhdChyW3UuWFJBTkdFUExBSU5MT09TRV0sXCIpXFxcXHMrLVxcXFxzKyhcIikuY29uY2F0KHJbdS5YUkFOR0VQTEFJTkxPT1NFXSxcIilcXFxccyokXCIpKSxjKFwiU1RBUlwiLFwiKDx8Pik/PT9cXFxccypcXFxcKlwiKSxjKFwiR1RFMFwiLFwiXlxcXFxzKj49XFxcXHMqMC4wLjBcXFxccyokXCIpLGMoXCJHVEUwUFJFXCIsXCJeXFxcXHMqPj1cXFxccyowLjAuMC0wXFxcXHMqJFwiKX19KSxvRD1aKHtcIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcGFyc2Utb3B0aW9ucy5qc1wiKGUsbil7YWUoKTt2YXIgdD1bXCJpbmNsdWRlUHJlcmVsZWFzZVwiLFwibG9vc2VcIixcInJ0bFwiXSxzPWk9Pmk/dHlwZW9mIGkhPVwib2JqZWN0XCI/e2xvb3NlOiEwfTp0LmZpbHRlcihyPT5pW3JdKS5yZWR1Y2UoKHIsdSk9PihyW3VdPSEwLHIpLHt9KTp7fTtuLmV4cG9ydHM9c319KSxjRD1aKHtcIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvaWRlbnRpZmllcnMuanNcIihlLG4pe2FlKCk7dmFyIHQ9L15bMC05XSskLyxzPShyLHUpPT57bGV0IGE9dC50ZXN0KHIpLGM9dC50ZXN0KHUpO3JldHVybiBhJiZjJiYocj0rcix1PSt1KSxyPT09dT8wOmEmJiFjPy0xOmMmJiFhPzE6cjx1Py0xOjF9LGk9KHIsdSk9PnModSxyKTtuLmV4cG9ydHM9e2NvbXBhcmVJZGVudGlmaWVyczpzLHJjb21wYXJlSWRlbnRpZmllcnM6aX19fSksbEQ9Wih7XCJub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvc2VtdmVyLmpzXCIoZSxuKXthZSgpO3ZhciB0PWhpKCkse01BWF9MRU5HVEg6cyxNQVhfU0FGRV9JTlRFR0VSOml9PUNpKCkse3JlOnIsdDp1fT1pRCgpLGE9b0QoKSx7Y29tcGFyZUlkZW50aWZpZXJzOmN9PWNEKCksbD1jbGFzc3tjb25zdHJ1Y3RvcihDLG0pe2lmKG09YShtKSxDIGluc3RhbmNlb2YgbCl7aWYoQy5sb29zZT09PSEhbS5sb29zZSYmQy5pbmNsdWRlUHJlcmVsZWFzZT09PSEhbS5pbmNsdWRlUHJlcmVsZWFzZSlyZXR1cm4gQztDPUMudmVyc2lvbn1lbHNlIGlmKHR5cGVvZiBDIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFZlcnNpb246IFwiLmNvbmNhdChDKSk7aWYoQy5sZW5ndGg+cyl0aHJvdyBuZXcgVHlwZUVycm9yKFwidmVyc2lvbiBpcyBsb25nZXIgdGhhbiBcIi5jb25jYXQocyxcIiBjaGFyYWN0ZXJzXCIpKTt0KFwiU2VtVmVyXCIsQyxtKSx0aGlzLm9wdGlvbnM9bSx0aGlzLmxvb3NlPSEhbS5sb29zZSx0aGlzLmluY2x1ZGVQcmVyZWxlYXNlPSEhbS5pbmNsdWRlUHJlcmVsZWFzZTtsZXQgZz1DLnRyaW0oKS5tYXRjaChtLmxvb3NlP3JbdS5MT09TRV06clt1LkZVTExdKTtpZighZyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBWZXJzaW9uOiBcIi5jb25jYXQoQykpO2lmKHRoaXMucmF3PUMsdGhpcy5tYWpvcj0rZ1sxXSx0aGlzLm1pbm9yPStnWzJdLHRoaXMucGF0Y2g9K2dbM10sdGhpcy5tYWpvcj5pfHx0aGlzLm1ham9yPDApdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgbWFqb3IgdmVyc2lvblwiKTtpZih0aGlzLm1pbm9yPml8fHRoaXMubWlub3I8MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBtaW5vciB2ZXJzaW9uXCIpO2lmKHRoaXMucGF0Y2g+aXx8dGhpcy5wYXRjaDwwKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHBhdGNoIHZlcnNpb25cIik7Z1s0XT90aGlzLnByZXJlbGVhc2U9Z1s0XS5zcGxpdChcIi5cIikubWFwKHA9PntpZigvXlswLTldKyQvLnRlc3QocCkpe2xldCBmPStwO2lmKGY+PTAmJmY8aSlyZXR1cm4gZn1yZXR1cm4gcH0pOnRoaXMucHJlcmVsZWFzZT1bXSx0aGlzLmJ1aWxkPWdbNV0/Z1s1XS5zcGxpdChcIi5cIik6W10sdGhpcy5mb3JtYXQoKX1mb3JtYXQoKXtyZXR1cm4gdGhpcy52ZXJzaW9uPVwiXCIuY29uY2F0KHRoaXMubWFqb3IsXCIuXCIpLmNvbmNhdCh0aGlzLm1pbm9yLFwiLlwiKS5jb25jYXQodGhpcy5wYXRjaCksdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCYmKHRoaXMudmVyc2lvbis9XCItXCIuY29uY2F0KHRoaXMucHJlcmVsZWFzZS5qb2luKFwiLlwiKSkpLHRoaXMudmVyc2lvbn10b1N0cmluZygpe3JldHVybiB0aGlzLnZlcnNpb259Y29tcGFyZShDKXtpZih0KFwiU2VtVmVyLmNvbXBhcmVcIix0aGlzLnZlcnNpb24sdGhpcy5vcHRpb25zLEMpLCEoQyBpbnN0YW5jZW9mIGwpKXtpZih0eXBlb2YgQz09XCJzdHJpbmdcIiYmQz09PXRoaXMudmVyc2lvbilyZXR1cm4gMDtDPW5ldyBsKEMsdGhpcy5vcHRpb25zKX1yZXR1cm4gQy52ZXJzaW9uPT09dGhpcy52ZXJzaW9uPzA6dGhpcy5jb21wYXJlTWFpbihDKXx8dGhpcy5jb21wYXJlUHJlKEMpfWNvbXBhcmVNYWluKEMpe3JldHVybiBDIGluc3RhbmNlb2YgbHx8KEM9bmV3IGwoQyx0aGlzLm9wdGlvbnMpKSxjKHRoaXMubWFqb3IsQy5tYWpvcil8fGModGhpcy5taW5vcixDLm1pbm9yKXx8Yyh0aGlzLnBhdGNoLEMucGF0Y2gpfWNvbXBhcmVQcmUoQyl7aWYoQyBpbnN0YW5jZW9mIGx8fChDPW5ldyBsKEMsdGhpcy5vcHRpb25zKSksdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCYmIUMucHJlcmVsZWFzZS5sZW5ndGgpcmV0dXJuLTE7aWYoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGgmJkMucHJlcmVsZWFzZS5sZW5ndGgpcmV0dXJuIDE7aWYoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGgmJiFDLnByZXJlbGVhc2UubGVuZ3RoKXJldHVybiAwO2xldCBtPTA7ZG97bGV0IGc9dGhpcy5wcmVyZWxlYXNlW21dLHA9Qy5wcmVyZWxlYXNlW21dO2lmKHQoXCJwcmVyZWxlYXNlIGNvbXBhcmVcIixtLGcscCksZz09PXZvaWQgMCYmcD09PXZvaWQgMClyZXR1cm4gMDtpZihwPT09dm9pZCAwKXJldHVybiAxO2lmKGc9PT12b2lkIDApcmV0dXJuLTE7aWYoZz09PXApY29udGludWU7cmV0dXJuIGMoZyxwKX13aGlsZSgrK20pfWNvbXBhcmVCdWlsZChDKXtDIGluc3RhbmNlb2YgbHx8KEM9bmV3IGwoQyx0aGlzLm9wdGlvbnMpKTtsZXQgbT0wO2Rve2xldCBnPXRoaXMuYnVpbGRbbV0scD1DLmJ1aWxkW21dO2lmKHQoXCJwcmVyZWxlYXNlIGNvbXBhcmVcIixtLGcscCksZz09PXZvaWQgMCYmcD09PXZvaWQgMClyZXR1cm4gMDtpZihwPT09dm9pZCAwKXJldHVybiAxO2lmKGc9PT12b2lkIDApcmV0dXJuLTE7aWYoZz09PXApY29udGludWU7cmV0dXJuIGMoZyxwKX13aGlsZSgrK20pfWluYyhDLG0pe3N3aXRjaChDKXtjYXNlXCJwcmVtYWpvclwiOnRoaXMucHJlcmVsZWFzZS5sZW5ndGg9MCx0aGlzLnBhdGNoPTAsdGhpcy5taW5vcj0wLHRoaXMubWFqb3IrKyx0aGlzLmluYyhcInByZVwiLG0pO2JyZWFrO2Nhc2VcInByZW1pbm9yXCI6dGhpcy5wcmVyZWxlYXNlLmxlbmd0aD0wLHRoaXMucGF0Y2g9MCx0aGlzLm1pbm9yKyssdGhpcy5pbmMoXCJwcmVcIixtKTticmVhaztjYXNlXCJwcmVwYXRjaFwiOnRoaXMucHJlcmVsZWFzZS5sZW5ndGg9MCx0aGlzLmluYyhcInBhdGNoXCIsbSksdGhpcy5pbmMoXCJwcmVcIixtKTticmVhaztjYXNlXCJwcmVyZWxlYXNlXCI6dGhpcy5wcmVyZWxlYXNlLmxlbmd0aD09PTAmJnRoaXMuaW5jKFwicGF0Y2hcIixtKSx0aGlzLmluYyhcInByZVwiLG0pO2JyZWFrO2Nhc2VcIm1ham9yXCI6KHRoaXMubWlub3IhPT0wfHx0aGlzLnBhdGNoIT09MHx8dGhpcy5wcmVyZWxlYXNlLmxlbmd0aD09PTApJiZ0aGlzLm1ham9yKyssdGhpcy5taW5vcj0wLHRoaXMucGF0Y2g9MCx0aGlzLnByZXJlbGVhc2U9W107YnJlYWs7Y2FzZVwibWlub3JcIjoodGhpcy5wYXRjaCE9PTB8fHRoaXMucHJlcmVsZWFzZS5sZW5ndGg9PT0wKSYmdGhpcy5taW5vcisrLHRoaXMucGF0Y2g9MCx0aGlzLnByZXJlbGVhc2U9W107YnJlYWs7Y2FzZVwicGF0Y2hcIjp0aGlzLnByZXJlbGVhc2UubGVuZ3RoPT09MCYmdGhpcy5wYXRjaCsrLHRoaXMucHJlcmVsZWFzZT1bXTticmVhaztjYXNlXCJwcmVcIjppZih0aGlzLnByZXJlbGVhc2UubGVuZ3RoPT09MCl0aGlzLnByZXJlbGVhc2U9WzBdO2Vsc2V7bGV0IGc9dGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtmb3IoOy0tZz49MDspdHlwZW9mIHRoaXMucHJlcmVsZWFzZVtnXT09XCJudW1iZXJcIiYmKHRoaXMucHJlcmVsZWFzZVtnXSsrLGc9LTIpO2c9PT0tMSYmdGhpcy5wcmVyZWxlYXNlLnB1c2goMCl9bSYmKHRoaXMucHJlcmVsZWFzZVswXT09PW0/aXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSYmKHRoaXMucHJlcmVsZWFzZT1bbSwwXSk6dGhpcy5wcmVyZWxlYXNlPVttLDBdKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiBcIi5jb25jYXQoQykpfXJldHVybiB0aGlzLmZvcm1hdCgpLHRoaXMucmF3PXRoaXMudmVyc2lvbix0aGlzfX07bi5leHBvcnRzPWx9fSkscW49Wih7XCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzXCIoZSxuKXthZSgpO3ZhciB0PWxEKCkscz0oaSxyLHUpPT5uZXcgdChpLHUpLmNvbXBhcmUobmV3IHQocix1KSk7bi5leHBvcnRzPXN9fSkscEQ9Wih7XCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdC5qc1wiKGUsbil7YWUoKTt2YXIgdD1xbigpLHM9KGkscix1KT0+dChpLHIsdSk8MDtuLmV4cG9ydHM9c319KSxmRD1aKHtcIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qc1wiKGUsbil7YWUoKTt2YXIgdD1xbigpLHM9KGkscix1KT0+dChpLHIsdSk+PTA7bi5leHBvcnRzPXN9fSksREQ9Wih7XCJzcmMvdXRpbHMvYXJyYXlpZnkuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCksbi5leHBvcnRzPSh0LHMpPT5PYmplY3QuZW50cmllcyh0KS5tYXAoaT0+e2xldFtyLHVdPWk7cmV0dXJuIE9iamVjdC5hc3NpZ24oe1tzXTpyfSx1KX0pfX0pLG1EPVooe1wibm9kZV9tb2R1bGVzL291dGRlbnQvbGliL2luZGV4LmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUub3V0ZGVudD12b2lkIDA7ZnVuY3Rpb24gdCgpe2Zvcih2YXIgQT1bXSxiPTA7Yjxhcmd1bWVudHMubGVuZ3RoO2IrKylBW2JdPWFyZ3VtZW50c1tiXX1mdW5jdGlvbiBzKCl7cmV0dXJuIHR5cGVvZiBXZWFrTWFwPFwidVwiP25ldyBXZWFrTWFwOmkoKX1mdW5jdGlvbiBpKCl7cmV0dXJue2FkZDp0LGRlbGV0ZTp0LGdldDp0LHNldDp0LGhhczpmdW5jdGlvbihBKXtyZXR1cm4hMX19fXZhciByPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksdT1mdW5jdGlvbihBLGIpe3JldHVybiByLmNhbGwoQSxiKX07ZnVuY3Rpb24gYShBLGIpe2Zvcih2YXIgdiBpbiBiKXUoYix2KSYmKEFbdl09Ylt2XSk7cmV0dXJuIEF9dmFyIGM9L15bIFxcdF0qKD86XFxyXFxufFxccnxcXG4pLyxsPS8oPzpcXHJcXG58XFxyfFxcbilbIFxcdF0qJC8sQz0vXig/OltcXHJcXG5dfCQpLyxtPS8oPzpcXHJcXG58XFxyfFxcbikoWyBcXHRdKikoPzpbXiBcXHRcXHJcXG5dfCQpLyxnPS9eWyBcXHRdKltcXHJcXG5dWyBcXHRcXHJcXG5dKiQvO2Z1bmN0aW9uIHAoQSxiLHYpe3ZhciBCPTAsdz1BWzBdLm1hdGNoKG0pO3cmJihCPXdbMV0ubGVuZ3RoKTt2YXIgST1cIihcXFxcclxcXFxufFxcXFxyfFxcXFxuKS57MCxcIitCK1wifVwiLEU9bmV3IFJlZ0V4cChJLFwiZ1wiKTtiJiYoQT1BLnNsaWNlKDEpKTt2YXIgRD12Lm5ld2xpbmUsZD12LnRyaW1MZWFkaW5nTmV3bGluZSx5PXYudHJpbVRyYWlsaW5nTmV3bGluZSxvPXR5cGVvZiBEPT1cInN0cmluZ1wiLHg9QS5sZW5ndGgsRj1BLm1hcChmdW5jdGlvbihTLGspe3JldHVybiBTPVMucmVwbGFjZShFLFwiJDFcIiksaz09PTAmJmQmJihTPVMucmVwbGFjZShjLFwiXCIpKSxrPT09eC0xJiZ5JiYoUz1TLnJlcGxhY2UobCxcIlwiKSksbyYmKFM9Uy5yZXBsYWNlKC9cXHJcXG58XFxufFxcci9nLGZ1bmN0aW9uKF8pe3JldHVybiBEfSkpLFN9KTtyZXR1cm4gRn1mdW5jdGlvbiBmKEEsYil7Zm9yKHZhciB2PVwiXCIsQj0wLHc9QS5sZW5ndGg7Qjx3O0IrKyl2Kz1BW0JdLEI8dy0xJiYodis9YltCXSk7cmV0dXJuIHZ9ZnVuY3Rpb24gaChBKXtyZXR1cm4gdShBLFwicmF3XCIpJiZ1KEEsXCJsZW5ndGhcIil9ZnVuY3Rpb24gTihBKXt2YXIgYj1zKCksdj1zKCk7ZnVuY3Rpb24gQihJKXtmb3IodmFyIEU9W10sRD0xO0Q8YXJndW1lbnRzLmxlbmd0aDtEKyspRVtELTFdPWFyZ3VtZW50c1tEXTtpZihoKEkpKXt2YXIgZD1JLHk9KEVbMF09PT1CfHxFWzBdPT09VCkmJmcudGVzdChkWzBdKSYmQy50ZXN0KGRbMV0pLG89eT92OmIseD1vLmdldChkKTtpZih4fHwoeD1wKGQseSxBKSxvLnNldChkLHgpKSxFLmxlbmd0aD09PTApcmV0dXJuIHhbMF07dmFyIEY9Zih4LHk/RS5zbGljZSgxKTpFKTtyZXR1cm4gRn1lbHNlIHJldHVybiBOKGEoYSh7fSxBKSxJfHx7fSkpfXZhciB3PWEoQix7c3RyaW5nOmZ1bmN0aW9uKEkpe3JldHVybiBwKFtJXSwhMSxBKVswXX19KTtyZXR1cm4gd312YXIgVD1OKHt0cmltTGVhZGluZ05ld2xpbmU6ITAsdHJpbVRyYWlsaW5nTmV3bGluZTohMH0pO2lmKGUub3V0ZGVudD1ULGUuZGVmYXVsdD1ULHR5cGVvZiBuPFwidVwiKXRyeXtuLmV4cG9ydHM9VCxPYmplY3QuZGVmaW5lUHJvcGVydHkoVCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxULmRlZmF1bHQ9VCxULm91dGRlbnQ9VH1jYXRjaHt9fX0pLGREPVooe1wic3JjL21haW4vY29yZS1vcHRpb25zLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntvdXRkZW50OnR9PW1EKCkscz1cIkNvbmZpZ1wiLGk9XCJFZGl0b3JcIixyPVwiRm9ybWF0XCIsdT1cIk90aGVyXCIsYT1cIk91dHB1dFwiLGM9XCJHbG9iYWxcIixsPVwiU3BlY2lhbFwiLEM9e2N1cnNvck9mZnNldDp7c2luY2U6XCIxLjQuMFwiLGNhdGVnb3J5OmwsdHlwZTpcImludFwiLGRlZmF1bHQ6LTEscmFuZ2U6e3N0YXJ0Oi0xLGVuZDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksc3RlcDoxfSxkZXNjcmlwdGlvbjp0KHNpfHwoc2k9d3QoW2BcbiAgICAgIFByaW50ICh0byBzdGRlcnIpIHdoZXJlIGEgY3Vyc29yIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiB3b3VsZCBtb3ZlIHRvIGFmdGVyIGZvcm1hdHRpbmcuXG4gICAgICBUaGlzIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIC0tcmFuZ2Utc3RhcnQgYW5kIC0tcmFuZ2UtZW5kLlxuICAgIGBdKSkpLGNsaUNhdGVnb3J5Oml9LGVuZE9mTGluZTp7c2luY2U6XCIxLjE1LjBcIixjYXRlZ29yeTpjLHR5cGU6XCJjaG9pY2VcIixkZWZhdWx0Olt7c2luY2U6XCIxLjE1LjBcIix2YWx1ZTpcImF1dG9cIn0se3NpbmNlOlwiMi4wLjBcIix2YWx1ZTpcImxmXCJ9XSxkZXNjcmlwdGlvbjpcIldoaWNoIGVuZCBvZiBsaW5lIGNoYXJhY3RlcnMgdG8gYXBwbHkuXCIsY2hvaWNlczpbe3ZhbHVlOlwibGZcIixkZXNjcmlwdGlvbjpcIkxpbmUgRmVlZCBvbmx5IChcXFxcbiksIGNvbW1vbiBvbiBMaW51eCBhbmQgbWFjT1MgYXMgd2VsbCBhcyBpbnNpZGUgZ2l0IHJlcG9zXCJ9LHt2YWx1ZTpcImNybGZcIixkZXNjcmlwdGlvbjpcIkNhcnJpYWdlIFJldHVybiArIExpbmUgRmVlZCBjaGFyYWN0ZXJzIChcXFxcclxcXFxuKSwgY29tbW9uIG9uIFdpbmRvd3NcIn0se3ZhbHVlOlwiY3JcIixkZXNjcmlwdGlvbjpcIkNhcnJpYWdlIFJldHVybiBjaGFyYWN0ZXIgb25seSAoXFxcXHIpLCB1c2VkIHZlcnkgcmFyZWx5XCJ9LHt2YWx1ZTpcImF1dG9cIixkZXNjcmlwdGlvbjp0KGFpfHwoYWk9d3QoW2BcbiAgICAgICAgICBNYWludGFpbiBleGlzdGluZ1xuICAgICAgICAgIChtaXhlZCB2YWx1ZXMgd2l0aGluIG9uZSBmaWxlIGFyZSBub3JtYWxpc2VkIGJ5IGxvb2tpbmcgYXQgd2hhdCdzIHVzZWQgYWZ0ZXIgdGhlIGZpcnN0IGxpbmUpXG4gICAgICAgIGBdKSkpfV19LGZpbGVwYXRoOntzaW5jZTpcIjEuNC4wXCIsY2F0ZWdvcnk6bCx0eXBlOlwicGF0aFwiLGRlc2NyaXB0aW9uOlwiU3BlY2lmeSB0aGUgaW5wdXQgZmlsZXBhdGguIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGRvIHBhcnNlciBpbmZlcmVuY2UuXCIsY2xpTmFtZTpcInN0ZGluLWZpbGVwYXRoXCIsY2xpQ2F0ZWdvcnk6dSxjbGlEZXNjcmlwdGlvbjpcIlBhdGggdG8gdGhlIGZpbGUgdG8gcHJldGVuZCB0aGF0IHN0ZGluIGNvbWVzIGZyb20uXCJ9LGluc2VydFByYWdtYTp7c2luY2U6XCIxLjguMFwiLGNhdGVnb3J5OmwsdHlwZTpcImJvb2xlYW5cIixkZWZhdWx0OiExLGRlc2NyaXB0aW9uOlwiSW5zZXJ0IEBmb3JtYXQgcHJhZ21hIGludG8gZmlsZSdzIGZpcnN0IGRvY2Jsb2NrIGNvbW1lbnQuXCIsY2xpQ2F0ZWdvcnk6dX0scGFyc2VyOntzaW5jZTpcIjAuMC4xMFwiLGNhdGVnb3J5OmMsdHlwZTpcImNob2ljZVwiLGRlZmF1bHQ6W3tzaW5jZTpcIjAuMC4xMFwiLHZhbHVlOlwiYmFieWxvblwifSx7c2luY2U6XCIxLjEzLjBcIix2YWx1ZTp2b2lkIDB9XSxkZXNjcmlwdGlvbjpcIldoaWNoIHBhcnNlciB0byB1c2UuXCIsZXhjZXB0aW9uOm09PnR5cGVvZiBtPT1cInN0cmluZ1wifHx0eXBlb2YgbT09XCJmdW5jdGlvblwiLGNob2ljZXM6W3t2YWx1ZTpcImZsb3dcIixkZXNjcmlwdGlvbjpcIkZsb3dcIn0se3ZhbHVlOlwiYmFiZWxcIixzaW5jZTpcIjEuMTYuMFwiLGRlc2NyaXB0aW9uOlwiSmF2YVNjcmlwdFwifSx7dmFsdWU6XCJiYWJlbC1mbG93XCIsc2luY2U6XCIxLjE2LjBcIixkZXNjcmlwdGlvbjpcIkZsb3dcIn0se3ZhbHVlOlwiYmFiZWwtdHNcIixzaW5jZTpcIjIuMC4wXCIsZGVzY3JpcHRpb246XCJUeXBlU2NyaXB0XCJ9LHt2YWx1ZTpcInR5cGVzY3JpcHRcIixzaW5jZTpcIjEuNC4wXCIsZGVzY3JpcHRpb246XCJUeXBlU2NyaXB0XCJ9LHt2YWx1ZTpcImFjb3JuXCIsc2luY2U6XCIyLjYuMFwiLGRlc2NyaXB0aW9uOlwiSmF2YVNjcmlwdFwifSx7dmFsdWU6XCJlc3ByZWVcIixzaW5jZTpcIjIuMi4wXCIsZGVzY3JpcHRpb246XCJKYXZhU2NyaXB0XCJ9LHt2YWx1ZTpcIm1lcml5YWhcIixzaW5jZTpcIjIuMi4wXCIsZGVzY3JpcHRpb246XCJKYXZhU2NyaXB0XCJ9LHt2YWx1ZTpcImNzc1wiLHNpbmNlOlwiMS43LjFcIixkZXNjcmlwdGlvbjpcIkNTU1wifSx7dmFsdWU6XCJsZXNzXCIsc2luY2U6XCIxLjcuMVwiLGRlc2NyaXB0aW9uOlwiTGVzc1wifSx7dmFsdWU6XCJzY3NzXCIsc2luY2U6XCIxLjcuMVwiLGRlc2NyaXB0aW9uOlwiU0NTU1wifSx7dmFsdWU6XCJqc29uXCIsc2luY2U6XCIxLjUuMFwiLGRlc2NyaXB0aW9uOlwiSlNPTlwifSx7dmFsdWU6XCJqc29uNVwiLHNpbmNlOlwiMS4xMy4wXCIsZGVzY3JpcHRpb246XCJKU09ONVwifSx7dmFsdWU6XCJqc29uLXN0cmluZ2lmeVwiLHNpbmNlOlwiMS4xMy4wXCIsZGVzY3JpcHRpb246XCJKU09OLnN0cmluZ2lmeVwifSx7dmFsdWU6XCJncmFwaHFsXCIsc2luY2U6XCIxLjUuMFwiLGRlc2NyaXB0aW9uOlwiR3JhcGhRTFwifSx7dmFsdWU6XCJtYXJrZG93blwiLHNpbmNlOlwiMS44LjBcIixkZXNjcmlwdGlvbjpcIk1hcmtkb3duXCJ9LHt2YWx1ZTpcIm1keFwiLHNpbmNlOlwiMS4xNS4wXCIsZGVzY3JpcHRpb246XCJNRFhcIn0se3ZhbHVlOlwidnVlXCIsc2luY2U6XCIxLjEwLjBcIixkZXNjcmlwdGlvbjpcIlZ1ZVwifSx7dmFsdWU6XCJ5YW1sXCIsc2luY2U6XCIxLjE0LjBcIixkZXNjcmlwdGlvbjpcIllBTUxcIn0se3ZhbHVlOlwiZ2xpbW1lclwiLHNpbmNlOlwiMi4zLjBcIixkZXNjcmlwdGlvbjpcIkVtYmVyIC8gSGFuZGxlYmFyc1wifSx7dmFsdWU6XCJodG1sXCIsc2luY2U6XCIxLjE1LjBcIixkZXNjcmlwdGlvbjpcIkhUTUxcIn0se3ZhbHVlOlwiYW5ndWxhclwiLHNpbmNlOlwiMS4xNS4wXCIsZGVzY3JpcHRpb246XCJBbmd1bGFyXCJ9LHt2YWx1ZTpcImx3Y1wiLHNpbmNlOlwiMS4xNy4wXCIsZGVzY3JpcHRpb246XCJMaWdodG5pbmcgV2ViIENvbXBvbmVudHNcIn1dfSxwbHVnaW5zOntzaW5jZTpcIjEuMTAuMFwiLHR5cGU6XCJwYXRoXCIsYXJyYXk6ITAsZGVmYXVsdDpbe3ZhbHVlOltdfV0sY2F0ZWdvcnk6YyxkZXNjcmlwdGlvbjpcIkFkZCBhIHBsdWdpbi4gTXVsdGlwbGUgcGx1Z2lucyBjYW4gYmUgcGFzc2VkIGFzIHNlcGFyYXRlIGAtLXBsdWdpbmBzLlwiLGV4Y2VwdGlvbjptPT50eXBlb2YgbT09XCJzdHJpbmdcInx8dHlwZW9mIG09PVwib2JqZWN0XCIsY2xpTmFtZTpcInBsdWdpblwiLGNsaUNhdGVnb3J5OnN9LHBsdWdpblNlYXJjaERpcnM6e3NpbmNlOlwiMS4xMy4wXCIsdHlwZTpcInBhdGhcIixhcnJheTohMCxkZWZhdWx0Olt7dmFsdWU6W119XSxjYXRlZ29yeTpjLGRlc2NyaXB0aW9uOnQoaWl8fChpaT13dChbYFxuICAgICAgQ3VzdG9tIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIHByZXR0aWVyIHBsdWdpbnMgaW4gbm9kZV9tb2R1bGVzIHN1YmRpcmVjdG9yeS5cbiAgICAgIE92ZXJyaWRlcyBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gcGx1Z2lucyBhcmUgc2VhcmNoZWQgcmVsYXRpdmVseSB0byB0aGUgbG9jYXRpb24gb2YgUHJldHRpZXIuXG4gICAgICBNdWx0aXBsZSB2YWx1ZXMgYXJlIGFjY2VwdGVkLlxuICAgIGBdKSkpLGV4Y2VwdGlvbjptPT50eXBlb2YgbT09XCJzdHJpbmdcInx8dHlwZW9mIG09PVwib2JqZWN0XCIsY2xpTmFtZTpcInBsdWdpbi1zZWFyY2gtZGlyXCIsY2xpQ2F0ZWdvcnk6c30scHJpbnRXaWR0aDp7c2luY2U6XCIwLjAuMFwiLGNhdGVnb3J5OmMsdHlwZTpcImludFwiLGRlZmF1bHQ6ODAsZGVzY3JpcHRpb246XCJUaGUgbGluZSBsZW5ndGggd2hlcmUgUHJldHRpZXIgd2lsbCB0cnkgd3JhcC5cIixyYW5nZTp7c3RhcnQ6MCxlbmQ6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHN0ZXA6MX19LHJhbmdlRW5kOntzaW5jZTpcIjEuNC4wXCIsY2F0ZWdvcnk6bCx0eXBlOlwiaW50XCIsZGVmYXVsdDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkscmFuZ2U6e3N0YXJ0OjAsZW5kOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxzdGVwOjF9LGRlc2NyaXB0aW9uOnQob2l8fChvaT13dChbYFxuICAgICAgRm9ybWF0IGNvZGUgZW5kaW5nIGF0IGEgZ2l2ZW4gY2hhcmFjdGVyIG9mZnNldCAoZXhjbHVzaXZlKS5cbiAgICAgIFRoZSByYW5nZSB3aWxsIGV4dGVuZCBmb3J3YXJkcyB0byB0aGUgZW5kIG9mIHRoZSBzZWxlY3RlZCBzdGF0ZW1lbnQuXG4gICAgICBUaGlzIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIC0tY3Vyc29yLW9mZnNldC5cbiAgICBgXSkpKSxjbGlDYXRlZ29yeTppfSxyYW5nZVN0YXJ0OntzaW5jZTpcIjEuNC4wXCIsY2F0ZWdvcnk6bCx0eXBlOlwiaW50XCIsZGVmYXVsdDowLHJhbmdlOntzdGFydDowLGVuZDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksc3RlcDoxfSxkZXNjcmlwdGlvbjp0KGNpfHwoY2k9d3QoW2BcbiAgICAgIEZvcm1hdCBjb2RlIHN0YXJ0aW5nIGF0IGEgZ2l2ZW4gY2hhcmFjdGVyIG9mZnNldC5cbiAgICAgIFRoZSByYW5nZSB3aWxsIGV4dGVuZCBiYWNrd2FyZHMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBmaXJzdCBsaW5lIGNvbnRhaW5pbmcgdGhlIHNlbGVjdGVkIHN0YXRlbWVudC5cbiAgICAgIFRoaXMgb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggLS1jdXJzb3Itb2Zmc2V0LlxuICAgIGBdKSkpLGNsaUNhdGVnb3J5Oml9LHJlcXVpcmVQcmFnbWE6e3NpbmNlOlwiMS43LjBcIixjYXRlZ29yeTpsLHR5cGU6XCJib29sZWFuXCIsZGVmYXVsdDohMSxkZXNjcmlwdGlvbjp0KGxpfHwobGk9d3QoW2BcbiAgICAgIFJlcXVpcmUgZWl0aGVyICdAcHJldHRpZXInIG9yICdAZm9ybWF0JyB0byBiZSBwcmVzZW50IGluIHRoZSBmaWxlJ3MgZmlyc3QgZG9jYmxvY2sgY29tbWVudFxuICAgICAgaW4gb3JkZXIgZm9yIGl0IHRvIGJlIGZvcm1hdHRlZC5cbiAgICBgXSkpKSxjbGlDYXRlZ29yeTp1fSx0YWJXaWR0aDp7dHlwZTpcImludFwiLGNhdGVnb3J5OmMsZGVmYXVsdDoyLGRlc2NyaXB0aW9uOlwiTnVtYmVyIG9mIHNwYWNlcyBwZXIgaW5kZW50YXRpb24gbGV2ZWwuXCIscmFuZ2U6e3N0YXJ0OjAsZW5kOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxzdGVwOjF9fSx1c2VUYWJzOntzaW5jZTpcIjEuMC4wXCIsY2F0ZWdvcnk6Yyx0eXBlOlwiYm9vbGVhblwiLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJJbmRlbnQgd2l0aCB0YWJzIGluc3RlYWQgb2Ygc3BhY2VzLlwifSxlbWJlZGRlZExhbmd1YWdlRm9ybWF0dGluZzp7c2luY2U6XCIyLjEuMFwiLGNhdGVnb3J5OmMsdHlwZTpcImNob2ljZVwiLGRlZmF1bHQ6W3tzaW5jZTpcIjIuMS4wXCIsdmFsdWU6XCJhdXRvXCJ9XSxkZXNjcmlwdGlvbjpcIkNvbnRyb2wgaG93IFByZXR0aWVyIGZvcm1hdHMgcXVvdGVkIGNvZGUgZW1iZWRkZWQgaW4gdGhlIGZpbGUuXCIsY2hvaWNlczpbe3ZhbHVlOlwiYXV0b1wiLGRlc2NyaXB0aW9uOlwiRm9ybWF0IGVtYmVkZGVkIGNvZGUgaWYgUHJldHRpZXIgY2FuIGF1dG9tYXRpY2FsbHkgaWRlbnRpZnkgaXQuXCJ9LHt2YWx1ZTpcIm9mZlwiLGRlc2NyaXB0aW9uOlwiTmV2ZXIgYXV0b21hdGljYWxseSBmb3JtYXQgZW1iZWRkZWQgY29kZS5cIn1dfX07bi5leHBvcnRzPXtDQVRFR09SWV9DT05GSUc6cyxDQVRFR09SWV9FRElUT1I6aSxDQVRFR09SWV9GT1JNQVQ6cixDQVRFR09SWV9PVEhFUjp1LENBVEVHT1JZX09VVFBVVDphLENBVEVHT1JZX0dMT0JBTDpjLENBVEVHT1JZX1NQRUNJQUw6bCxvcHRpb25zOkN9fX0pLE1uPVooe1wic3JjL21haW4vc3VwcG9ydC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD17Y29tcGFyZTpxbigpLGx0OnBEKCksZ3RlOmZEKCl9LHM9REQoKSxpPWdpKCkudmVyc2lvbixyPWREKCkub3B0aW9ucztmdW5jdGlvbiB1KCl7bGV0e3BsdWdpbnM6Yz1bXSxzaG93VW5yZWxlYXNlZDpsPSExLHNob3dEZXByZWNhdGVkOkM9ITEsc2hvd0ludGVybmFsOm09ITF9PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTp7fSxnPWkuc3BsaXQoXCItXCIsMSlbMF0scD1jLmZsYXRNYXAoQT0+QS5sYW5ndWFnZXN8fFtdKS5maWx0ZXIoaCksZj1zKE9iamVjdC5hc3NpZ24oe30sLi4uYy5tYXAoQT0+e2xldHtvcHRpb25zOmJ9PUE7cmV0dXJuIGJ9KSxyKSxcIm5hbWVcIikuZmlsdGVyKEE9PmgoQSkmJk4oQSkpLnNvcnQoKEEsYik9PkEubmFtZT09PWIubmFtZT8wOkEubmFtZTxiLm5hbWU/LTE6MSkubWFwKFQpLm1hcChBPT57QT1PYmplY3QuYXNzaWduKHt9LEEpLEFycmF5LmlzQXJyYXkoQS5kZWZhdWx0KSYmKEEuZGVmYXVsdD1BLmRlZmF1bHQubGVuZ3RoPT09MT9BLmRlZmF1bHRbMF0udmFsdWU6QS5kZWZhdWx0LmZpbHRlcihoKS5zb3J0KCh2LEIpPT50LmNvbXBhcmUoQi5zaW5jZSx2LnNpbmNlKSlbMF0udmFsdWUpLEFycmF5LmlzQXJyYXkoQS5jaG9pY2VzKSYmKEEuY2hvaWNlcz1BLmNob2ljZXMuZmlsdGVyKHY9PmgodikmJk4odikpLEEubmFtZT09PVwicGFyc2VyXCImJmEoQSxwLGMpKTtsZXQgYj1PYmplY3QuZnJvbUVudHJpZXMoYy5maWx0ZXIodj0+di5kZWZhdWx0T3B0aW9ucyYmdi5kZWZhdWx0T3B0aW9uc1tBLm5hbWVdIT09dm9pZCAwKS5tYXAodj0+W3YubmFtZSx2LmRlZmF1bHRPcHRpb25zW0EubmFtZV1dKSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxBKSx7fSx7cGx1Z2luRGVmYXVsdHM6Yn0pfSk7cmV0dXJue2xhbmd1YWdlczpwLG9wdGlvbnM6Zn07ZnVuY3Rpb24gaChBKXtyZXR1cm4gbHx8IShcInNpbmNlXCJpbiBBKXx8QS5zaW5jZSYmdC5ndGUoZyxBLnNpbmNlKX1mdW5jdGlvbiBOKEEpe3JldHVybiBDfHwhKFwiZGVwcmVjYXRlZFwiaW4gQSl8fEEuZGVwcmVjYXRlZCYmdC5sdChnLEEuZGVwcmVjYXRlZCl9ZnVuY3Rpb24gVChBKXtpZihtKXJldHVybiBBO2xldHtjbGlOYW1lOmIsY2xpQ2F0ZWdvcnk6dixjbGlEZXNjcmlwdGlvbjpCfT1BO3JldHVybiBfbihBLHpmKX19ZnVuY3Rpb24gYShjLGwsQyl7bGV0IG09bmV3IFNldChjLmNob2ljZXMubWFwKGc9PmcudmFsdWUpKTtmb3IobGV0IGcgb2YgbClpZihnLnBhcnNlcnMpe2ZvcihsZXQgcCBvZiBnLnBhcnNlcnMpaWYoIW0uaGFzKHApKXttLmFkZChwKTtsZXQgZj1DLmZpbmQoTj0+Ti5wYXJzZXJzJiZOLnBhcnNlcnNbcF0pLGg9Zy5uYW1lO2YmJmYubmFtZSYmKGgrPVwiIChwbHVnaW46IFwiLmNvbmNhdChmLm5hbWUsXCIpXCIpKSxjLmNob2ljZXMucHVzaCh7dmFsdWU6cCxkZXNjcmlwdGlvbjpofSl9fX1uLmV4cG9ydHM9e2dldFN1cHBvcnRJbmZvOnV9fX0pLFJuPVooe1wic3JjL3V0aWxzL2lzLW5vbi1lbXB0eS1hcnJheS5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KHMpe3JldHVybiBBcnJheS5pc0FycmF5KHMpJiZzLmxlbmd0aD4wfW4uZXhwb3J0cz10fX0pLFRyPVooe1wic3JjL3V0aWxzL3RleHQvc2tpcC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KGEpe3JldHVybihjLGwsQyk9PntsZXQgbT1DJiZDLmJhY2t3YXJkcztpZihsPT09ITEpcmV0dXJuITE7bGV0e2xlbmd0aDpnfT1jLHA9bDtmb3IoO3A+PTAmJnA8Zzspe2xldCBmPWMuY2hhckF0KHApO2lmKGEgaW5zdGFuY2VvZiBSZWdFeHApe2lmKCFhLnRlc3QoZikpcmV0dXJuIHB9ZWxzZSBpZighYS5pbmNsdWRlcyhmKSlyZXR1cm4gcDttP3AtLTpwKyt9cmV0dXJuIHA9PT0tMXx8cD09PWc/cDohMX19dmFyIHM9dCgvXFxzLyksaT10KFwiIFx0XCIpLHI9dChcIiw7IFx0XCIpLHU9dCgvW15cXG5cXHJdLyk7bi5leHBvcnRzPXtza2lwV2hpdGVzcGFjZTpzLHNraXBTcGFjZXM6aSxza2lwVG9MaW5lRW5kOnIsc2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lOnV9fX0pLEVpPVooe1wic3JjL3V0aWxzL3RleHQvc2tpcC1pbmxpbmUtY29tbWVudC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KHMsaSl7aWYoaT09PSExKXJldHVybiExO2lmKHMuY2hhckF0KGkpPT09XCIvXCImJnMuY2hhckF0KGkrMSk9PT1cIipcIil7Zm9yKGxldCByPWkrMjtyPHMubGVuZ3RoOysrcilpZihzLmNoYXJBdChyKT09PVwiKlwiJiZzLmNoYXJBdChyKzEpPT09XCIvXCIpcmV0dXJuIHIrMn1yZXR1cm4gaX1uLmV4cG9ydHM9dH19KSx2aT1aKHtcInNyYy91dGlscy90ZXh0L3NraXAtdHJhaWxpbmctY29tbWVudC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7c2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lOnR9PVRyKCk7ZnVuY3Rpb24gcyhpLHIpe3JldHVybiByPT09ITE/ITE6aS5jaGFyQXQocik9PT1cIi9cIiYmaS5jaGFyQXQocisxKT09PVwiL1wiP3QoaSxyKTpyfW4uZXhwb3J0cz1zfX0pLEZpPVooe1wic3JjL3V0aWxzL3RleHQvc2tpcC1uZXdsaW5lLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO2Z1bmN0aW9uIHQocyxpLHIpe2xldCB1PXImJnIuYmFja3dhcmRzO2lmKGk9PT0hMSlyZXR1cm4hMTtsZXQgYT1zLmNoYXJBdChpKTtpZih1KXtpZihzLmNoYXJBdChpLTEpPT09XCJcXHJcIiYmYT09PWBcbmApcmV0dXJuIGktMjtpZihhPT09YFxuYHx8YT09PVwiXFxyXCJ8fGE9PT1cIlxcdTIwMjhcInx8YT09PVwiXFx1MjAyOVwiKXJldHVybiBpLTF9ZWxzZXtpZihhPT09XCJcXHJcIiYmcy5jaGFyQXQoaSsxKT09PWBcbmApcmV0dXJuIGkrMjtpZihhPT09YFxuYHx8YT09PVwiXFxyXCJ8fGE9PT1cIlxcdTIwMjhcInx8YT09PVwiXFx1MjAyOVwiKXJldHVybiBpKzF9cmV0dXJuIGl9bi5leHBvcnRzPXR9fSksZ0Q9Wih7XCJzcmMvdXRpbHMvdGV4dC9nZXQtbmV4dC1ub24tc3BhY2Utbm9uLWNvbW1lbnQtY2hhcmFjdGVyLWluZGV4LXdpdGgtc3RhcnQtaW5kZXguanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9RWkoKSxzPUZpKCksaT12aSgpLHtza2lwU3BhY2VzOnJ9PVRyKCk7ZnVuY3Rpb24gdShhLGMpe2xldCBsPW51bGwsQz1jO2Zvcig7QyE9PWw7KWw9QyxDPXIoYSxDKSxDPXQoYSxDKSxDPWkoYSxDKSxDPXMoYSxDKTtyZXR1cm4gQ31uLmV4cG9ydHM9dX19KSxHZT1aKHtcInNyYy9jb21tb24vdXRpbC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7ZGVmYXVsdDp0fT1hRCgpLHM9c3QoKSx7Z2V0U3VwcG9ydEluZm86aX09TW4oKSxyPVJuKCksdT15aSgpLHtza2lwV2hpdGVzcGFjZTphLHNraXBTcGFjZXM6Yyxza2lwVG9MaW5lRW5kOmwsc2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lOkN9PVRyKCksbT1FaSgpLGc9dmkoKSxwPUZpKCksZj1nRCgpLGg9JD0+JFskLmxlbmd0aC0yXTtmdW5jdGlvbiBOKCQpe3JldHVybihXLGVlLFUpPT57bGV0IG5lPVUmJlUuYmFja3dhcmRzO2lmKGVlPT09ITEpcmV0dXJuITE7bGV0e2xlbmd0aDpzZX09VyxWPWVlO2Zvcig7Vj49MCYmVjxzZTspe2xldCBvZT1XLmNoYXJBdChWKTtpZigkIGluc3RhbmNlb2YgUmVnRXhwKXtpZighJC50ZXN0KG9lKSlyZXR1cm4gVn1lbHNlIGlmKCEkLmluY2x1ZGVzKG9lKSlyZXR1cm4gVjtuZT9WLS06VisrfXJldHVybiBWPT09LTF8fFY9PT1zZT9WOiExfX1mdW5jdGlvbiBUKCQsVyl7bGV0IGVlPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTp7fSxVPWMoJCxlZS5iYWNrd2FyZHM/Vy0xOlcsZWUpLG5lPXAoJCxVLGVlKTtyZXR1cm4gVSE9PW5lfWZ1bmN0aW9uIEEoJCxXLGVlKXtmb3IobGV0IFU9VztVPGVlOysrVSlpZigkLmNoYXJBdChVKT09PWBcbmApcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gYigkLFcsZWUpe2xldCBVPWVlKFcpLTE7VT1jKCQsVSx7YmFja3dhcmRzOiEwfSksVT1wKCQsVSx7YmFja3dhcmRzOiEwfSksVT1jKCQsVSx7YmFja3dhcmRzOiEwfSk7bGV0IG5lPXAoJCxVLHtiYWNrd2FyZHM6ITB9KTtyZXR1cm4gVSE9PW5lfWZ1bmN0aW9uIHYoJCxXKXtsZXQgZWU9bnVsbCxVPVc7Zm9yKDtVIT09ZWU7KWVlPVUsVT1sKCQsVSksVT1tKCQsVSksVT1jKCQsVSk7cmV0dXJuIFU9ZygkLFUpLFU9cCgkLFUpLFUhPT0hMSYmVCgkLFUpfWZ1bmN0aW9uIEIoJCxXLGVlKXtyZXR1cm4gdigkLGVlKFcpKX1mdW5jdGlvbiB3KCQsVyxlZSl7cmV0dXJuIGYoJCxlZShXKSl9ZnVuY3Rpb24gSSgkLFcsZWUpe3JldHVybiAkLmNoYXJBdCh3KCQsVyxlZSkpfWZ1bmN0aW9uIEUoJCxXKXtsZXQgZWU9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOnt9O3JldHVybiBjKCQsZWUuYmFja3dhcmRzP1ctMTpXLGVlKSE9PVd9ZnVuY3Rpb24gRCgkLFcpe2xldCBlZT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06MCxVPTA7Zm9yKGxldCBuZT1lZTtuZTwkLmxlbmd0aDsrK25lKSRbbmVdPT09XCJcdFwiP1U9VStXLVUlVzpVKys7cmV0dXJuIFV9ZnVuY3Rpb24gZCgkLFcpe2xldCBlZT0kLmxhc3RJbmRleE9mKGBcbmApO3JldHVybiBlZT09PS0xPzA6RCgkLnNsaWNlKGVlKzEpLm1hdGNoKC9eW1xcdCBdKi8pWzBdLFcpfWZ1bmN0aW9uIHkoJCxXKXtsZXQgZWU9e3F1b3RlOidcIicscmVnZXg6L1wiL2csZXNjYXBlZDpcIiZxdW90O1wifSxVPXtxdW90ZTpcIidcIixyZWdleDovJy9nLGVzY2FwZWQ6XCImYXBvcztcIn0sbmU9Vz09PVwiJ1wiP1U6ZWUsc2U9bmU9PT1VP2VlOlUsVj1uZTtpZigkLmluY2x1ZGVzKG5lLnF1b3RlKXx8JC5pbmNsdWRlcyhzZS5xdW90ZSkpe2xldCBvZT0oJC5tYXRjaChuZS5yZWdleCl8fFtdKS5sZW5ndGgsSz0oJC5tYXRjaChzZS5yZWdleCl8fFtdKS5sZW5ndGg7Vj1vZT5LP3NlOm5lfXJldHVybiBWfWZ1bmN0aW9uIG8oJCxXKXtsZXQgZWU9JC5zbGljZSgxLC0xKSxVPVcucGFyc2VyPT09XCJqc29uXCJ8fFcucGFyc2VyPT09XCJqc29uNVwiJiZXLnF1b3RlUHJvcHM9PT1cInByZXNlcnZlXCImJiFXLnNpbmdsZVF1b3RlPydcIic6Vy5fX2lzSW5IdG1sQXR0cmlidXRlP1wiJ1wiOnkoZWUsVy5zaW5nbGVRdW90ZT9cIidcIjonXCInKS5xdW90ZTtyZXR1cm4geChlZSxVLCEoVy5wYXJzZXI9PT1cImNzc1wifHxXLnBhcnNlcj09PVwibGVzc1wifHxXLnBhcnNlcj09PVwic2Nzc1wifHxXLl9fZW1iZWRkZWRJbkh0bWwpKX1mdW5jdGlvbiB4KCQsVyxlZSl7bGV0IFU9Vz09PSdcIic/XCInXCI6J1wiJyxuZT0vXFxcXCguKXwoW1wiJ10pL2dzLHNlPSQucmVwbGFjZShuZSwoVixvZSxLKT0+b2U9PT1VP29lOks9PT1XP1wiXFxcXFwiK0s6S3x8KGVlJiYvXlteXFxuXFxyXCInMC03XFxcXGJmbnJ0LXZ4XFx1MjAyOFxcdTIwMjldJC8udGVzdChvZSk/b2U6XCJcXFxcXCIrb2UpKTtyZXR1cm4gVytzZStXfWZ1bmN0aW9uIEYoJCl7cmV0dXJuICQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eKFsrLV0/W1xcZC5dK2UpKD86XFwrfCgtKSk/MCooXFxkKS8sXCIkMSQyJDNcIikucmVwbGFjZSgvXihbKy1dP1tcXGQuXSspZVsrLV0/MCskLyxcIiQxXCIpLnJlcGxhY2UoL14oWystXSk/XFwuLyxcIiQxMC5cIikucmVwbGFjZSgvKFxcLlxcZCs/KTArKD89ZXwkKS8sXCIkMVwiKS5yZXBsYWNlKC9cXC4oPz1lfCQpLyxcIlwiKX1mdW5jdGlvbiBTKCQsVyl7bGV0IGVlPSQubWF0Y2gobmV3IFJlZ0V4cChcIihcIi5jb25jYXQodChXKSxcIikrXCIpLFwiZ1wiKSk7cmV0dXJuIGVlPT09bnVsbD8wOmVlLnJlZHVjZSgoVSxuZSk9Pk1hdGgubWF4KFUsbmUubGVuZ3RoL1cubGVuZ3RoKSwwKX1mdW5jdGlvbiBrKCQsVyl7bGV0IGVlPSQubWF0Y2gobmV3IFJlZ0V4cChcIihcIi5jb25jYXQodChXKSxcIikrXCIpLFwiZ1wiKSk7aWYoZWU9PT1udWxsKXJldHVybiAwO2xldCBVPW5ldyBNYXAsbmU9MDtmb3IobGV0IHNlIG9mIGVlKXtsZXQgVj1zZS5sZW5ndGgvVy5sZW5ndGg7VS5zZXQoViwhMCksVj5uZSYmKG5lPVYpfWZvcihsZXQgc2U9MTtzZTxuZTtzZSsrKWlmKCFVLmdldChzZSkpcmV0dXJuIHNlO3JldHVybiBuZSsxfWZ1bmN0aW9uIF8oJCxXKXsoJC5jb21tZW50c3x8KCQuY29tbWVudHM9W10pKS5wdXNoKFcpLFcucHJpbnRlZD0hMSxXLm5vZGVEZXNjcmlwdGlvbj1yZSgkKX1mdW5jdGlvbiBPKCQsVyl7Vy5sZWFkaW5nPSEwLFcudHJhaWxpbmc9ITEsXygkLFcpfWZ1bmN0aW9uIFIoJCxXLGVlKXtXLmxlYWRpbmc9ITEsVy50cmFpbGluZz0hMSxlZSYmKFcubWFya2VyPWVlKSxfKCQsVyl9ZnVuY3Rpb24gTSgkLFcpe1cubGVhZGluZz0hMSxXLnRyYWlsaW5nPSEwLF8oJCxXKX1mdW5jdGlvbiBIKCQsVyl7bGV0e2xhbmd1YWdlczplZX09aSh7cGx1Z2luczpXLnBsdWdpbnN9KSxVPWVlLmZpbmQobmU9PntsZXR7bmFtZTpzZX09bmU7cmV0dXJuIHNlLnRvTG93ZXJDYXNlKCk9PT0kfSl8fGVlLmZpbmQobmU9PntsZXR7YWxpYXNlczpzZX09bmU7cmV0dXJuIEFycmF5LmlzQXJyYXkoc2UpJiZzZS5pbmNsdWRlcygkKX0pfHxlZS5maW5kKG5lPT57bGV0e2V4dGVuc2lvbnM6c2V9PW5lO3JldHVybiBBcnJheS5pc0FycmF5KHNlKSYmc2UuaW5jbHVkZXMoXCIuXCIuY29uY2F0KCQpKX0pO3JldHVybiBVJiZVLnBhcnNlcnNbMF19ZnVuY3Rpb24gUCgkKXtyZXR1cm4gJCYmJC50eXBlPT09XCJmcm9udC1tYXR0ZXJcIn1mdW5jdGlvbiBHKCQpe2xldCBXPW5ldyBXZWFrTWFwO3JldHVybiBmdW5jdGlvbihlZSl7cmV0dXJuIFcuaGFzKGVlKXx8Vy5zZXQoZWUsU3ltYm9sKCQpKSxXLmdldChlZSl9fWZ1bmN0aW9uIHJlKCQpe2xldCBXPSQudHlwZXx8JC5raW5kfHxcIih1bmtub3duIHR5cGUpXCIsZWU9U3RyaW5nKCQubmFtZXx8JC5pZCYmKHR5cGVvZiAkLmlkPT1cIm9iamVjdFwiPyQuaWQubmFtZTokLmlkKXx8JC5rZXkmJih0eXBlb2YgJC5rZXk9PVwib2JqZWN0XCI/JC5rZXkubmFtZTokLmtleSl8fCQudmFsdWUmJih0eXBlb2YgJC52YWx1ZT09XCJvYmplY3RcIj9cIlwiOlN0cmluZygkLnZhbHVlKSl8fCQub3BlcmF0b3J8fFwiXCIpO3JldHVybiBlZS5sZW5ndGg+MjAmJihlZT1lZS5zbGljZSgwLDE5KStcIlxcdTIwMjZcIiksVysoZWU/XCIgXCIrZWU6XCJcIil9bi5leHBvcnRzPXtpbmZlclBhcnNlckJ5TGFuZ3VhZ2U6SCxnZXRTdHJpbmdXaWR0aDp1LGdldE1heENvbnRpbnVvdXNDb3VudDpTLGdldE1pbk5vdFByZXNlbnRDb250aW51b3VzQ291bnQ6ayxnZXRQZW51bHRpbWF0ZTpoLGdldExhc3Q6cyxnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXhXaXRoU3RhcnRJbmRleDpmLGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleDp3LGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXI6SSxza2lwOk4sc2tpcFdoaXRlc3BhY2U6YSxza2lwU3BhY2VzOmMsc2tpcFRvTGluZUVuZDpsLHNraXBFdmVyeXRoaW5nQnV0TmV3TGluZTpDLHNraXBJbmxpbmVDb21tZW50Om0sc2tpcFRyYWlsaW5nQ29tbWVudDpnLHNraXBOZXdsaW5lOnAsaXNOZXh0TGluZUVtcHR5QWZ0ZXJJbmRleDp2LGlzTmV4dExpbmVFbXB0eTpCLGlzUHJldmlvdXNMaW5lRW1wdHk6YixoYXNOZXdsaW5lOlQsaGFzTmV3bGluZUluUmFuZ2U6QSxoYXNTcGFjZXM6RSxnZXRBbGlnbm1lbnRTaXplOkQsZ2V0SW5kZW50U2l6ZTpkLGdldFByZWZlcnJlZFF1b3RlOnkscHJpbnRTdHJpbmc6byxwcmludE51bWJlcjpGLG1ha2VTdHJpbmc6eCxhZGRMZWFkaW5nQ29tbWVudDpPLGFkZERhbmdsaW5nQ29tbWVudDpSLGFkZFRyYWlsaW5nQ29tbWVudDpNLGlzRnJvbnRNYXR0ZXJOb2RlOlAsaXNOb25FbXB0eUFycmF5OnIsY3JlYXRlR3JvdXBJZE1hcHBlcjpHfX19KSxBaT17fTtrbihBaSx7YmFzZW5hbWU6KCk9PkJpLGRlZmF1bHQ6KCk9PndpLGRlbGltaXRlcjooKT0+Ym4sZGlybmFtZTooKT0+VGksZXh0bmFtZTooKT0+TmksaXNBYnNvbHV0ZTooKT0+V24sam9pbjooKT0+eGksbm9ybWFsaXplOigpPT5WbixyZWxhdGl2ZTooKT0+YmkscmVzb2x2ZTooKT0+eHIsc2VwOigpPT54bn0pO2Z1bmN0aW9uIFNpKGUsbil7Zm9yKHZhciB0PTAscz1lLmxlbmd0aC0xO3M+PTA7cy0tKXt2YXIgaT1lW3NdO2k9PT1cIi5cIj9lLnNwbGljZShzLDEpOmk9PT1cIi4uXCI/KGUuc3BsaWNlKHMsMSksdCsrKTp0JiYoZS5zcGxpY2UocywxKSx0LS0pfWlmKG4pZm9yKDt0LS07dCllLnVuc2hpZnQoXCIuLlwiKTtyZXR1cm4gZX1mdW5jdGlvbiB4cigpe2Zvcih2YXIgZT1cIlwiLG49ITEsdD1hcmd1bWVudHMubGVuZ3RoLTE7dD49LTEmJiFuO3QtLSl7dmFyIHM9dD49MD9hcmd1bWVudHNbdF06XCIvXCI7aWYodHlwZW9mIHMhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzXCIpO2lmKCFzKWNvbnRpbnVlO2U9cytcIi9cIitlLG49cy5jaGFyQXQoMCk9PT1cIi9cIn1yZXR1cm4gZT1TaSgkbihlLnNwbGl0KFwiL1wiKSxmdW5jdGlvbihpKXtyZXR1cm4hIWl9KSwhbikuam9pbihcIi9cIiksKG4/XCIvXCI6XCJcIikrZXx8XCIuXCJ9ZnVuY3Rpb24gVm4oZSl7dmFyIG49V24oZSksdD1faShlLC0xKT09PVwiL1wiO3JldHVybiBlPVNpKCRuKGUuc3BsaXQoXCIvXCIpLGZ1bmN0aW9uKHMpe3JldHVybiEhc30pLCFuKS5qb2luKFwiL1wiKSwhZSYmIW4mJihlPVwiLlwiKSxlJiZ0JiYoZSs9XCIvXCIpLChuP1wiL1wiOlwiXCIpK2V9ZnVuY3Rpb24gV24oZSl7cmV0dXJuIGUuY2hhckF0KDApPT09XCIvXCJ9ZnVuY3Rpb24geGkoKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIFZuKCRuKGUsZnVuY3Rpb24obix0KXtpZih0eXBlb2YgbiE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3NcIik7cmV0dXJuIG59KS5qb2luKFwiL1wiKSl9ZnVuY3Rpb24gYmkoZSxuKXtlPXhyKGUpLnN1YnN0cigxKSxuPXhyKG4pLnN1YnN0cigxKTtmdW5jdGlvbiB0KGwpe2Zvcih2YXIgQz0wO0M8bC5sZW5ndGgmJmxbQ109PT1cIlwiO0MrKyk7Zm9yKHZhciBtPWwubGVuZ3RoLTE7bT49MCYmbFttXT09PVwiXCI7bS0tKTtyZXR1cm4gQz5tP1tdOmwuc2xpY2UoQyxtLUMrMSl9Zm9yKHZhciBzPXQoZS5zcGxpdChcIi9cIikpLGk9dChuLnNwbGl0KFwiL1wiKSkscj1NYXRoLm1pbihzLmxlbmd0aCxpLmxlbmd0aCksdT1yLGE9MDthPHI7YSsrKWlmKHNbYV0hPT1pW2FdKXt1PWE7YnJlYWt9Zm9yKHZhciBjPVtdLGE9dTthPHMubGVuZ3RoO2ErKyljLnB1c2goXCIuLlwiKTtyZXR1cm4gYz1jLmNvbmNhdChpLnNsaWNlKHUpKSxjLmpvaW4oXCIvXCIpfWZ1bmN0aW9uIFRpKGUpe3ZhciBuPUJyKGUpLHQ9blswXSxzPW5bMV07cmV0dXJuIXQmJiFzP1wiLlwiOihzJiYocz1zLnN1YnN0cigwLHMubGVuZ3RoLTEpKSx0K3MpfWZ1bmN0aW9uIEJpKGUsbil7dmFyIHQ9QnIoZSlbMl07cmV0dXJuIG4mJnQuc3Vic3RyKC0xKm4ubGVuZ3RoKT09PW4mJih0PXQuc3Vic3RyKDAsdC5sZW5ndGgtbi5sZW5ndGgpKSx0fWZ1bmN0aW9uIE5pKGUpe3JldHVybiBCcihlKVszXX1mdW5jdGlvbiAkbihlLG4pe2lmKGUuZmlsdGVyKXJldHVybiBlLmZpbHRlcihuKTtmb3IodmFyIHQ9W10scz0wO3M8ZS5sZW5ndGg7cysrKW4oZVtzXSxzLGUpJiZ0LnB1c2goZVtzXSk7cmV0dXJuIHR9dmFyIERpLEJyLHhuLGJuLHdpLF9pLHlEPWJyKHtcIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHM6cGF0aFwiKCl7YWUoKSxEaT0vXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLyxCcj1mdW5jdGlvbihlKXtyZXR1cm4gRGkuZXhlYyhlKS5zbGljZSgxKX0seG49XCIvXCIsYm49XCI6XCIsd2k9e2V4dG5hbWU6TmksYmFzZW5hbWU6QmksZGlybmFtZTpUaSxzZXA6eG4sZGVsaW1pdGVyOmJuLHJlbGF0aXZlOmJpLGpvaW46eGksaXNBYnNvbHV0ZTpXbixub3JtYWxpemU6Vm4scmVzb2x2ZTp4cn0sX2k9XCJhYlwiLnN1YnN0cigtMSk9PT1cImJcIj9mdW5jdGlvbihlLG4sdCl7cmV0dXJuIGUuc3Vic3RyKG4sdCl9OmZ1bmN0aW9uKGUsbix0KXtyZXR1cm4gbjwwJiYobj1lLmxlbmd0aCtuKSxlLnN1YnN0cihuLHQpfX19KSxQaT1aKHtcIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHMtY29tbW9uanM6cGF0aFwiKGUsbil7YWUoKTt2YXIgdD0oeUQoKSxwdChBaSkpO2lmKHQmJnQuZGVmYXVsdCl7bi5leHBvcnRzPXQuZGVmYXVsdDtmb3IobGV0IHMgaW4gdCluLmV4cG9ydHNbc109dFtzXX1lbHNlIHQmJihuLmV4cG9ydHM9dCl9fSksSnQ9Wih7XCJzcmMvY29tbW9uL2Vycm9ycy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD1jbGFzcyBleHRlbmRzIEVycm9ye30scz1jbGFzcyBleHRlbmRzIEVycm9ye30saT1jbGFzcyBleHRlbmRzIEVycm9ye30scj1jbGFzcyBleHRlbmRzIEVycm9ye307bi5leHBvcnRzPXtDb25maWdFcnJvcjp0LERlYnVnRXJyb3I6cyxVbmRlZmluZWRQYXJzZXJFcnJvcjppLEFyZ0V4cGFuc2lvbkJhaWxvdXQ6cn19fSksRHQ9e307a24oRHQse19fYXNzaWduOigpPT5TcixfX2FzeW5jRGVsZWdhdG9yOigpPT53RCxfX2FzeW5jR2VuZXJhdG9yOigpPT5ORCxfX2FzeW5jVmFsdWVzOigpPT5fRCxfX2F3YWl0OigpPT5HdCxfX2F3YWl0ZXI6KCk9PkFELF9fY2xhc3NQcml2YXRlRmllbGRHZXQ6KCk9PkxELF9fY2xhc3NQcml2YXRlRmllbGRTZXQ6KCk9Pk9ELF9fY3JlYXRlQmluZGluZzooKT0+eEQsX19kZWNvcmF0ZTooKT0+RUQsX19leHBvcnRTdGFyOigpPT5iRCxfX2V4dGVuZHM6KCk9PmhELF9fZ2VuZXJhdG9yOigpPT5TRCxfX2ltcG9ydERlZmF1bHQ6KCk9PmtELF9faW1wb3J0U3RhcjooKT0+SUQsX19tYWtlVGVtcGxhdGVPYmplY3Q6KCk9PlBELF9fbWV0YWRhdGE6KCk9PkZELF9fcGFyYW06KCk9PnZELF9fcmVhZDooKT0+SWksX19yZXN0OigpPT5DRCxfX3NwcmVhZDooKT0+VEQsX19zcHJlYWRBcnJheXM6KCk9PkJELF9fdmFsdWVzOigpPT5Ubn0pO2Z1bmN0aW9uIGhEKGUsbil7QXIoZSxuKTtmdW5jdGlvbiB0KCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfWUucHJvdG90eXBlPW49PT1udWxsP09iamVjdC5jcmVhdGUobik6KHQucHJvdG90eXBlPW4ucHJvdG90eXBlLG5ldyB0KX1mdW5jdGlvbiBDRChlLG4pe3ZhciB0PXt9O2Zvcih2YXIgcyBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHMpJiZuLmluZGV4T2Yocyk8MCYmKHRbc109ZVtzXSk7aWYoZSE9bnVsbCYmdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM9PVwiZnVuY3Rpb25cIilmb3IodmFyIGk9MCxzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7aTxzLmxlbmd0aDtpKyspbi5pbmRleE9mKHNbaV0pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbaV0pJiYodFtzW2ldXT1lW3NbaV1dKTtyZXR1cm4gdH1mdW5jdGlvbiBFRChlLG4sdCxzKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoLHI9aTwzP246cz09PW51bGw/cz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk6cyx1O2lmKHR5cGVvZiBSZWZsZWN0PT1cIm9iamVjdFwiJiZ0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZT09XCJmdW5jdGlvblwiKXI9UmVmbGVjdC5kZWNvcmF0ZShlLG4sdCxzKTtlbHNlIGZvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTA7YS0tKSh1PWVbYV0pJiYocj0oaTwzP3Uocik6aT4zP3Uobix0LHIpOnUobix0KSl8fHIpO3JldHVybiBpPjMmJnImJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLHQscikscn1mdW5jdGlvbiB2RChlLG4pe3JldHVybiBmdW5jdGlvbih0LHMpe24odCxzLGUpfX1mdW5jdGlvbiBGRChlLG4pe2lmKHR5cGVvZiBSZWZsZWN0PT1cIm9iamVjdFwiJiZ0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YT09XCJmdW5jdGlvblwiKXJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGUsbil9ZnVuY3Rpb24gQUQoZSxuLHQscyl7ZnVuY3Rpb24gaShyKXtyZXR1cm4gciBpbnN0YW5jZW9mIHQ/cjpuZXcgdChmdW5jdGlvbih1KXt1KHIpfSl9cmV0dXJuIG5ldyh0fHwodD1Qcm9taXNlKSkoZnVuY3Rpb24ocix1KXtmdW5jdGlvbiBhKEMpe3RyeXtsKHMubmV4dChDKSl9Y2F0Y2gobSl7dShtKX19ZnVuY3Rpb24gYyhDKXt0cnl7bChzLnRocm93KEMpKX1jYXRjaChtKXt1KG0pfX1mdW5jdGlvbiBsKEMpe0MuZG9uZT9yKEMudmFsdWUpOmkoQy52YWx1ZSkudGhlbihhLGMpfWwoKHM9cy5hcHBseShlLG58fFtdKSkubmV4dCgpKX0pfWZ1bmN0aW9uIFNEKGUsbil7dmFyIHQ9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKHJbMF0mMSl0aHJvdyByWzFdO3JldHVybiByWzFdfSx0cnlzOltdLG9wczpbXX0scyxpLHIsdTtyZXR1cm4gdT17bmV4dDphKDApLHRocm93OmEoMSkscmV0dXJuOmEoMil9LHR5cGVvZiBTeW1ib2w9PVwiZnVuY3Rpb25cIiYmKHVbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksdTtmdW5jdGlvbiBhKGwpe3JldHVybiBmdW5jdGlvbihDKXtyZXR1cm4gYyhbbCxDXSl9fWZ1bmN0aW9uIGMobCl7aWYocyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO3Q7KXRyeXtpZihzPTEsaSYmKHI9bFswXSYyP2kucmV0dXJuOmxbMF0/aS50aHJvd3x8KChyPWkucmV0dXJuKSYmci5jYWxsKGkpLDApOmkubmV4dCkmJiEocj1yLmNhbGwoaSxsWzFdKSkuZG9uZSlyZXR1cm4gcjtzd2l0Y2goaT0wLHImJihsPVtsWzBdJjIsci52YWx1ZV0pLGxbMF0pe2Nhc2UgMDpjYXNlIDE6cj1sO2JyZWFrO2Nhc2UgNDpyZXR1cm4gdC5sYWJlbCsrLHt2YWx1ZTpsWzFdLGRvbmU6ITF9O2Nhc2UgNTp0LmxhYmVsKyssaT1sWzFdLGw9WzBdO2NvbnRpbnVlO2Nhc2UgNzpsPXQub3BzLnBvcCgpLHQudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKHI9dC50cnlzLCEocj1yLmxlbmd0aD4wJiZyW3IubGVuZ3RoLTFdKSYmKGxbMF09PT02fHxsWzBdPT09Mikpe3Q9MDtjb250aW51ZX1pZihsWzBdPT09MyYmKCFyfHxsWzFdPnJbMF0mJmxbMV08clszXSkpe3QubGFiZWw9bFsxXTticmVha31pZihsWzBdPT09NiYmdC5sYWJlbDxyWzFdKXt0LmxhYmVsPXJbMV0scj1sO2JyZWFrfWlmKHImJnQubGFiZWw8clsyXSl7dC5sYWJlbD1yWzJdLHQub3BzLnB1c2gobCk7YnJlYWt9clsyXSYmdC5vcHMucG9wKCksdC50cnlzLnBvcCgpO2NvbnRpbnVlfWw9bi5jYWxsKGUsdCl9Y2F0Y2goQyl7bD1bNixDXSxpPTB9ZmluYWxseXtzPXI9MH1pZihsWzBdJjUpdGhyb3cgbFsxXTtyZXR1cm57dmFsdWU6bFswXT9sWzFdOnZvaWQgMCxkb25lOiEwfX19ZnVuY3Rpb24geEQoZSxuLHQscyl7cz09PXZvaWQgMCYmKHM9dCksZVtzXT1uW3RdfWZ1bmN0aW9uIGJEKGUsbil7Zm9yKHZhciB0IGluIGUpdCE9PVwiZGVmYXVsdFwiJiYhbi5oYXNPd25Qcm9wZXJ0eSh0KSYmKG5bdF09ZVt0XSl9ZnVuY3Rpb24gVG4oZSl7dmFyIG49dHlwZW9mIFN5bWJvbD09XCJmdW5jdGlvblwiJiZTeW1ib2wuaXRlcmF0b3IsdD1uJiZlW25dLHM9MDtpZih0KXJldHVybiB0LmNhbGwoZSk7aWYoZSYmdHlwZW9mIGUubGVuZ3RoPT1cIm51bWJlclwiKXJldHVybntuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGUmJnM+PWUubGVuZ3RoJiYoZT12b2lkIDApLHt2YWx1ZTplJiZlW3MrK10sZG9uZTohZX19fTt0aHJvdyBuZXcgVHlwZUVycm9yKG4/XCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiOlwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKX1mdW5jdGlvbiBJaShlLG4pe3ZhciB0PXR5cGVvZiBTeW1ib2w9PVwiZnVuY3Rpb25cIiYmZVtTeW1ib2wuaXRlcmF0b3JdO2lmKCF0KXJldHVybiBlO3ZhciBzPXQuY2FsbChlKSxpLHI9W10sdTt0cnl7Zm9yKDsobj09PXZvaWQgMHx8bi0tID4wKSYmIShpPXMubmV4dCgpKS5kb25lOylyLnB1c2goaS52YWx1ZSl9Y2F0Y2goYSl7dT17ZXJyb3I6YX19ZmluYWxseXt0cnl7aSYmIWkuZG9uZSYmKHQ9cy5yZXR1cm4pJiZ0LmNhbGwocyl9ZmluYWxseXtpZih1KXRocm93IHUuZXJyb3J9fXJldHVybiByfWZ1bmN0aW9uIFREKCl7Zm9yKHZhciBlPVtdLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKWU9ZS5jb25jYXQoSWkoYXJndW1lbnRzW25dKSk7cmV0dXJuIGV9ZnVuY3Rpb24gQkQoKXtmb3IodmFyIGU9MCxuPTAsdD1hcmd1bWVudHMubGVuZ3RoO248dDtuKyspZSs9YXJndW1lbnRzW25dLmxlbmd0aDtmb3IodmFyIHM9QXJyYXkoZSksaT0wLG49MDtuPHQ7bisrKWZvcih2YXIgcj1hcmd1bWVudHNbbl0sdT0wLGE9ci5sZW5ndGg7dTxhO3UrKyxpKyspc1tpXT1yW3VdO3JldHVybiBzfWZ1bmN0aW9uIEd0KGUpe3JldHVybiB0aGlzIGluc3RhbmNlb2YgR3Q/KHRoaXMudj1lLHRoaXMpOm5ldyBHdChlKX1mdW5jdGlvbiBORChlLG4sdCl7aWYoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7dmFyIHM9dC5hcHBseShlLG58fFtdKSxpLHI9W107cmV0dXJuIGk9e30sdShcIm5leHRcIiksdShcInRocm93XCIpLHUoXCJyZXR1cm5cIiksaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30saTtmdW5jdGlvbiB1KGcpe3NbZ10mJihpW2ddPWZ1bmN0aW9uKHApe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihmLGgpe3IucHVzaChbZyxwLGYsaF0pPjF8fGEoZyxwKX0pfSl9ZnVuY3Rpb24gYShnLHApe3RyeXtjKHNbZ10ocCkpfWNhdGNoKGYpe20oclswXVszXSxmKX19ZnVuY3Rpb24gYyhnKXtnLnZhbHVlIGluc3RhbmNlb2YgR3Q/UHJvbWlzZS5yZXNvbHZlKGcudmFsdWUudikudGhlbihsLEMpOm0oclswXVsyXSxnKX1mdW5jdGlvbiBsKGcpe2EoXCJuZXh0XCIsZyl9ZnVuY3Rpb24gQyhnKXthKFwidGhyb3dcIixnKX1mdW5jdGlvbiBtKGcscCl7ZyhwKSxyLnNoaWZ0KCksci5sZW5ndGgmJmEoclswXVswXSxyWzBdWzFdKX19ZnVuY3Rpb24gd0QoZSl7dmFyIG4sdDtyZXR1cm4gbj17fSxzKFwibmV4dFwiKSxzKFwidGhyb3dcIixmdW5jdGlvbihpKXt0aHJvdyBpfSkscyhcInJldHVyblwiKSxuW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sbjtmdW5jdGlvbiBzKGkscil7bltpXT1lW2ldP2Z1bmN0aW9uKHUpe3JldHVybih0PSF0KT97dmFsdWU6R3QoZVtpXSh1KSksZG9uZTppPT09XCJyZXR1cm5cIn06cj9yKHUpOnV9OnJ9fWZ1bmN0aW9uIF9EKGUpe2lmKCFTeW1ib2wuYXN5bmNJdGVyYXRvcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO3ZhciBuPWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdLHQ7cmV0dXJuIG4/bi5jYWxsKGUpOihlPXR5cGVvZiBUbj09XCJmdW5jdGlvblwiP1RuKGUpOmVbU3ltYm9sLml0ZXJhdG9yXSgpLHQ9e30scyhcIm5leHRcIikscyhcInRocm93XCIpLHMoXCJyZXR1cm5cIiksdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sdCk7ZnVuY3Rpb24gcyhyKXt0W3JdPWVbcl0mJmZ1bmN0aW9uKHUpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihhLGMpe3U9ZVtyXSh1KSxpKGEsYyx1LmRvbmUsdS52YWx1ZSl9KX19ZnVuY3Rpb24gaShyLHUsYSxjKXtQcm9taXNlLnJlc29sdmUoYykudGhlbihmdW5jdGlvbihsKXtyKHt2YWx1ZTpsLGRvbmU6YX0pfSx1KX19ZnVuY3Rpb24gUEQoZSxuKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5P09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicmF3XCIse3ZhbHVlOm59KTplLnJhdz1uLGV9ZnVuY3Rpb24gSUQoZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSx0KSYmKG5bdF09ZVt0XSk7cmV0dXJuIG4uZGVmYXVsdD1lLG59ZnVuY3Rpb24ga0QoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIExEKGUsbil7aWYoIW4uaGFzKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBuLmdldChlKX1mdW5jdGlvbiBPRChlLG4sdCl7aWYoIW4uaGFzKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBuLnNldChlLHQpLHR9dmFyIEFyLFNyLGd0PWJyKHtcIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcIigpe2FlKCksQXI9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gQXI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQscyl7dC5fX3Byb3RvX189c318fGZ1bmN0aW9uKHQscyl7Zm9yKHZhciBpIGluIHMpcy5oYXNPd25Qcm9wZXJ0eShpKSYmKHRbaV09c1tpXSl9LEFyKGUsbil9LFNyPWZ1bmN0aW9uKCl7cmV0dXJuIFNyPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKG4pe2Zvcih2YXIgdCxzPTEsaT1hcmd1bWVudHMubGVuZ3RoO3M8aTtzKyspe3Q9YXJndW1lbnRzW3NdO2Zvcih2YXIgciBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiYobltyXT10W3JdKX1yZXR1cm4gbn0sU3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfX19KSxraT1aKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL2Rlc2NyaXB0b3JzL2FwaS5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5hcGlEZXNjcmlwdG9yPXtrZXk6bj0+L15bJF9hLXpBLVpdWyRfYS16QS1aMC05XSokLy50ZXN0KG4pP246SlNPTi5zdHJpbmdpZnkobiksdmFsdWUobil7aWYobj09PW51bGx8fHR5cGVvZiBuIT1cIm9iamVjdFwiKXJldHVybiBKU09OLnN0cmluZ2lmeShuKTtpZihBcnJheS5pc0FycmF5KG4pKXJldHVyblwiW1wiLmNvbmNhdChuLm1hcChzPT5lLmFwaURlc2NyaXB0b3IudmFsdWUocykpLmpvaW4oXCIsIFwiKSxcIl1cIik7bGV0IHQ9T2JqZWN0LmtleXMobik7cmV0dXJuIHQubGVuZ3RoPT09MD9cInt9XCI6XCJ7IFwiLmNvbmNhdCh0Lm1hcChzPT5cIlwiLmNvbmNhdChlLmFwaURlc2NyaXB0b3Iua2V5KHMpLFwiOiBcIikuY29uY2F0KGUuYXBpRGVzY3JpcHRvci52YWx1ZShuW3NdKSkpLmpvaW4oXCIsIFwiKSxcIiB9XCIpfSxwYWlyOm49PntsZXR7a2V5OnQsdmFsdWU6c309bjtyZXR1cm4gZS5hcGlEZXNjcmlwdG9yLnZhbHVlKHtbdF06c30pfX19fSksakQ9Wih7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9kZXNjcmlwdG9ycy9pbmRleC5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49KGd0KCkscHQoRHQpKTtuLl9fZXhwb3J0U3RhcihraSgpLGUpfX0pLE5yPVooe1wic2NyaXB0cy9idWlsZC9zaGltcy9jaGFsay5janNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9cz0+czt0LmdyZXk9dCx0LnJlZD10LHQuYm9sZD10LHQueWVsbG93PXQsdC5ibHVlPXQsdC5kZWZhdWx0PXQsbi5leHBvcnRzPXR9fSksTGk9Wih7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9oYW5kbGVycy9kZXByZWNhdGVkL2NvbW1vbi5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49TnIoKTtlLmNvbW1vbkRlcHJlY2F0ZWRIYW5kbGVyPSh0LHMsaSk9PntsZXR7ZGVzY3JpcHRvcjpyfT1pLHU9W1wiXCIuY29uY2F0KG4uZGVmYXVsdC55ZWxsb3codHlwZW9mIHQ9PVwic3RyaW5nXCI/ci5rZXkodCk6ci5wYWlyKHQpKSxcIiBpcyBkZXByZWNhdGVkXCIpXTtyZXR1cm4gcyYmdS5wdXNoKFwid2Ugbm93IHRyZWF0IGl0IGFzIFwiLmNvbmNhdChuLmRlZmF1bHQuYmx1ZSh0eXBlb2Ygcz09XCJzdHJpbmdcIj9yLmtleShzKTpyLnBhaXIocykpKSksdS5qb2luKFwiOyBcIikrXCIuXCJ9fX0pLHFEPVooe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvaGFuZGxlcnMvZGVwcmVjYXRlZC9pbmRleC5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49KGd0KCkscHQoRHQpKTtuLl9fZXhwb3J0U3RhcihMaSgpLGUpfX0pLE1EPVooe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvaGFuZGxlcnMvaW52YWxpZC9jb21tb24uanNcIihlKXtcInVzZSBzdHJpY3RcIjthZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPU5yKCk7ZS5jb21tb25JbnZhbGlkSGFuZGxlcj0odCxzLGkpPT5bXCJJbnZhbGlkIFwiLmNvbmNhdChuLmRlZmF1bHQucmVkKGkuZGVzY3JpcHRvci5rZXkodCkpLFwiIHZhbHVlLlwiKSxcIkV4cGVjdGVkIFwiLmNvbmNhdChuLmRlZmF1bHQuYmx1ZShpLnNjaGVtYXNbdF0uZXhwZWN0ZWQoaSkpLFwiLFwiKSxcImJ1dCByZWNlaXZlZCBcIi5jb25jYXQobi5kZWZhdWx0LnJlZChpLmRlc2NyaXB0b3IudmFsdWUocykpLFwiLlwiKV0uam9pbihcIiBcIil9fSksT2k9Wih7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9oYW5kbGVycy9pbnZhbGlkL2luZGV4LmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7YWUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj0oZ3QoKSxwdChEdCkpO24uX19leHBvcnRTdGFyKE1EKCksZSl9fSksUkQ9Wih7XCJub2RlX21vZHVsZXMvdm5vcHRzL25vZGVfbW9kdWxlcy9sZXZlbi9pbmRleC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD1bXSxzPVtdO24uZXhwb3J0cz1mdW5jdGlvbihpLHIpe2lmKGk9PT1yKXJldHVybiAwO3ZhciB1PWk7aS5sZW5ndGg+ci5sZW5ndGgmJihpPXIscj11KTt2YXIgYT1pLmxlbmd0aCxjPXIubGVuZ3RoO2lmKGE9PT0wKXJldHVybiBjO2lmKGM9PT0wKXJldHVybiBhO2Zvcig7YT4wJiZpLmNoYXJDb2RlQXQofi1hKT09PXIuY2hhckNvZGVBdCh+LWMpOylhLS0sYy0tO2lmKGE9PT0wKXJldHVybiBjO2Zvcih2YXIgbD0wO2w8YSYmaS5jaGFyQ29kZUF0KGwpPT09ci5jaGFyQ29kZUF0KGwpOylsKys7aWYoYS09bCxjLT1sLGE9PT0wKXJldHVybiBjO2Zvcih2YXIgQyxtLGcscCxmPTAsaD0wO2Y8YTspc1tsK2ZdPWkuY2hhckNvZGVBdChsK2YpLHRbZl09KytmO2Zvcig7aDxjOylmb3IoQz1yLmNoYXJDb2RlQXQobCtoKSxnPWgrKyxtPWgsZj0wO2Y8YTtmKyspcD1DPT09c1tsK2ZdP2c6ZysxLGc9dFtmXSxtPXRbZl09Zz5tP3A+bT9tKzE6cDpwPmc/ZysxOnA7cmV0dXJuIG19fX0pLGppPVooe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvaGFuZGxlcnMvdW5rbm93bi9sZXZlbi5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49TnIoKSx0PVJEKCk7ZS5sZXZlblVua25vd25IYW5kbGVyPShzLGkscik9PntsZXR7ZGVzY3JpcHRvcjp1LGxvZ2dlcjphLHNjaGVtYXM6Y309cixsPVtcIklnbm9yZWQgdW5rbm93biBvcHRpb24gXCIuY29uY2F0KG4uZGVmYXVsdC55ZWxsb3codS5wYWlyKHtrZXk6cyx2YWx1ZTppfSkpLFwiLlwiKV0sQz1PYmplY3Qua2V5cyhjKS5zb3J0KCkuZmluZChtPT50KHMsbSk8Myk7QyYmbC5wdXNoKFwiRGlkIHlvdSBtZWFuIFwiLmNvbmNhdChuLmRlZmF1bHQuYmx1ZSh1LmtleShDKSksXCI/XCIpKSxhLndhcm4obC5qb2luKFwiIFwiKSl9fX0pLFZEPVooe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvaGFuZGxlcnMvdW5rbm93bi9pbmRleC5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49KGd0KCkscHQoRHQpKTtuLl9fZXhwb3J0U3RhcihqaSgpLGUpfX0pLFdEPVooe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvaGFuZGxlcnMvaW5kZXguanNcIihlKXtcInVzZSBzdHJpY3RcIjthZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPShndCgpLHB0KER0KSk7bi5fX2V4cG9ydFN0YXIocUQoKSxlKSxuLl9fZXhwb3J0U3RhcihPaSgpLGUpLG4uX19leHBvcnRTdGFyKFZEKCksZSl9fSkseXQ9Wih7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9zY2hlbWEuanNcIihlKXtcInVzZSBzdHJpY3RcIjthZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPVtcImRlZmF1bHRcIixcImV4cGVjdGVkXCIsXCJ2YWxpZGF0ZVwiLFwiZGVwcmVjYXRlZFwiLFwiZm9yd2FyZFwiLFwicmVkaXJlY3RcIixcIm92ZXJsYXBcIixcInByZXByb2Nlc3NcIixcInBvc3Rwcm9jZXNzXCJdO2Z1bmN0aW9uIHQocix1KXtsZXQgYT1uZXcgcih1KSxjPU9iamVjdC5jcmVhdGUoYSk7Zm9yKGxldCBsIG9mIG4pbCBpbiB1JiYoY1tsXT1pKHVbbF0sYSxzLnByb3RvdHlwZVtsXS5sZW5ndGgpKTtyZXR1cm4gY31lLmNyZWF0ZVNjaGVtYT10O3ZhciBzPWNsYXNze2NvbnN0cnVjdG9yKHIpe3RoaXMubmFtZT1yLm5hbWV9c3RhdGljIGNyZWF0ZShyKXtyZXR1cm4gdCh0aGlzLHIpfWRlZmF1bHQocil7fWV4cGVjdGVkKHIpe3JldHVyblwibm90aGluZ1wifXZhbGlkYXRlKHIsdSl7cmV0dXJuITF9ZGVwcmVjYXRlZChyLHUpe3JldHVybiExfWZvcndhcmQocix1KXt9cmVkaXJlY3Qocix1KXt9b3ZlcmxhcChyLHUsYSl7cmV0dXJuIHJ9cHJlcHJvY2VzcyhyLHUpe3JldHVybiByfXBvc3Rwcm9jZXNzKHIsdSl7cmV0dXJuIHJ9fTtlLlNjaGVtYT1zO2Z1bmN0aW9uIGkocix1LGEpe3JldHVybiB0eXBlb2Ygcj09XCJmdW5jdGlvblwiP2Z1bmN0aW9uKCl7Zm9yKHZhciBjPWFyZ3VtZW50cy5sZW5ndGgsbD1uZXcgQXJyYXkoYyksQz0wO0M8YztDKyspbFtDXT1hcmd1bWVudHNbQ107cmV0dXJuIHIoLi4ubC5zbGljZSgwLGEtMSksdSwuLi5sLnNsaWNlKGEtMSkpfTooKT0+cn19fSksJEQ9Wih7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9zY2hlbWFzL2FsaWFzLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7YWUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj15dCgpLHQ9Y2xhc3MgZXh0ZW5kcyBuLlNjaGVtYXtjb25zdHJ1Y3RvcihzKXtzdXBlcihzKTt0aGlzLl9zb3VyY2VOYW1lPXMuc291cmNlTmFtZX1leHBlY3RlZChzKXtyZXR1cm4gcy5zY2hlbWFzW3RoaXMuX3NvdXJjZU5hbWVdLmV4cGVjdGVkKHMpfXZhbGlkYXRlKHMsaSl7cmV0dXJuIGkuc2NoZW1hc1t0aGlzLl9zb3VyY2VOYW1lXS52YWxpZGF0ZShzLGkpfXJlZGlyZWN0KHMsaSl7cmV0dXJuIHRoaXMuX3NvdXJjZU5hbWV9fTtlLkFsaWFzU2NoZW1hPXR9fSksSEQ9Wih7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9zY2hlbWFzL2FueS5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49eXQoKSx0PWNsYXNzIGV4dGVuZHMgbi5TY2hlbWF7ZXhwZWN0ZWQoKXtyZXR1cm5cImFueXRoaW5nXCJ9dmFsaWRhdGUoKXtyZXR1cm4hMH19O2UuQW55U2NoZW1hPXR9fSksR0Q9Wih7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9zY2hlbWFzL2FycmF5LmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7YWUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj0oZ3QoKSxwdChEdCkpLHQ9eXQoKSxzPWNsYXNzIGV4dGVuZHMgdC5TY2hlbWF7Y29uc3RydWN0b3Iocil7dmFye3ZhbHVlU2NoZW1hOnUsbmFtZTphPXUubmFtZX09cixjPW4uX19yZXN0KHIsW1widmFsdWVTY2hlbWFcIixcIm5hbWVcIl0pO3N1cGVyKE9iamVjdC5hc3NpZ24oe30sYyx7bmFtZTphfSkpO3RoaXMuX3ZhbHVlU2NoZW1hPXV9ZXhwZWN0ZWQocil7cmV0dXJuXCJhbiBhcnJheSBvZiBcIi5jb25jYXQodGhpcy5fdmFsdWVTY2hlbWEuZXhwZWN0ZWQocikpfXZhbGlkYXRlKHIsdSl7aWYoIUFycmF5LmlzQXJyYXkocikpcmV0dXJuITE7bGV0IGE9W107Zm9yKGxldCBjIG9mIHIpe2xldCBsPXUubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQodGhpcy5fdmFsdWVTY2hlbWEudmFsaWRhdGUoYyx1KSxjKTtsIT09ITAmJmEucHVzaChsLnZhbHVlKX1yZXR1cm4gYS5sZW5ndGg9PT0wPyEwOnt2YWx1ZTphfX1kZXByZWNhdGVkKHIsdSl7bGV0IGE9W107Zm9yKGxldCBjIG9mIHIpe2xldCBsPXUubm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdCh0aGlzLl92YWx1ZVNjaGVtYS5kZXByZWNhdGVkKGMsdSksYyk7bCE9PSExJiZhLnB1c2goLi4ubC5tYXAoQz0+e2xldHt2YWx1ZTptfT1DO3JldHVybnt2YWx1ZTpbbV19fSkpfXJldHVybiBhfWZvcndhcmQocix1KXtsZXQgYT1bXTtmb3IobGV0IGMgb2Ygcil7bGV0IGw9dS5ub3JtYWxpemVGb3J3YXJkUmVzdWx0KHRoaXMuX3ZhbHVlU2NoZW1hLmZvcndhcmQoYyx1KSxjKTthLnB1c2goLi4ubC5tYXAoaSkpfXJldHVybiBhfXJlZGlyZWN0KHIsdSl7bGV0IGE9W10sYz1bXTtmb3IobGV0IGwgb2Ygcil7bGV0IEM9dS5ub3JtYWxpemVSZWRpcmVjdFJlc3VsdCh0aGlzLl92YWx1ZVNjaGVtYS5yZWRpcmVjdChsLHUpLGwpO1wicmVtYWluXCJpbiBDJiZhLnB1c2goQy5yZW1haW4pLGMucHVzaCguLi5DLnJlZGlyZWN0Lm1hcChpKSl9cmV0dXJuIGEubGVuZ3RoPT09MD97cmVkaXJlY3Q6Y306e3JlZGlyZWN0OmMscmVtYWluOmF9fW92ZXJsYXAocix1KXtyZXR1cm4gci5jb25jYXQodSl9fTtlLkFycmF5U2NoZW1hPXM7ZnVuY3Rpb24gaShyKXtsZXR7ZnJvbTp1LHRvOmF9PXI7cmV0dXJue2Zyb206W3VdLHRvOmF9fX19KSxKRD1aKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL3NjaGVtYXMvYm9vbGVhbi5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49eXQoKSx0PWNsYXNzIGV4dGVuZHMgbi5TY2hlbWF7ZXhwZWN0ZWQoKXtyZXR1cm5cInRydWUgb3IgZmFsc2VcIn12YWxpZGF0ZShzKXtyZXR1cm4gdHlwZW9mIHM9PVwiYm9vbGVhblwifX07ZS5Cb29sZWFuU2NoZW1hPXR9fSksSG49Wih7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi91dGlscy5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gbihwLGYpe2xldCBoPU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGxldCBOIG9mIHApe2xldCBUPU5bZl07aWYoaFtUXSl0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgXCIuY29uY2F0KGYsXCIgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShUKSkpO2hbVF09Tn1yZXR1cm4gaH1lLnJlY29yZEZyb21BcnJheT1uO2Z1bmN0aW9uIHQocCxmKXtsZXQgaD1uZXcgTWFwO2ZvcihsZXQgTiBvZiBwKXtsZXQgVD1OW2ZdO2lmKGguaGFzKFQpKXRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBcIi5jb25jYXQoZixcIiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KFQpKSk7aC5zZXQoVCxOKX1yZXR1cm4gaH1lLm1hcEZyb21BcnJheT10O2Z1bmN0aW9uIHMoKXtsZXQgcD1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiBmPT57bGV0IGg9SlNPTi5zdHJpbmdpZnkoZik7cmV0dXJuIHBbaF0/ITA6KHBbaF09ITAsITEpfX1lLmNyZWF0ZUF1dG9DaGVja2xpc3Q9cztmdW5jdGlvbiBpKHAsZil7bGV0IGg9W10sTj1bXTtmb3IobGV0IFQgb2YgcClmKFQpP2gucHVzaChUKTpOLnB1c2goVCk7cmV0dXJuW2gsTl19ZS5wYXJ0aXRpb249aTtmdW5jdGlvbiByKHApe3JldHVybiBwPT09TWF0aC5mbG9vcihwKX1lLmlzSW50PXI7ZnVuY3Rpb24gdShwLGYpe2lmKHA9PT1mKXJldHVybiAwO2xldCBoPXR5cGVvZiBwLE49dHlwZW9mIGYsVD1bXCJ1bmRlZmluZWRcIixcIm9iamVjdFwiLFwiYm9vbGVhblwiLFwibnVtYmVyXCIsXCJzdHJpbmdcIl07cmV0dXJuIGghPT1OP1QuaW5kZXhPZihoKS1ULmluZGV4T2YoTik6aCE9PVwic3RyaW5nXCI/TnVtYmVyKHApLU51bWJlcihmKTpwLmxvY2FsZUNvbXBhcmUoZil9ZS5jb21wYXJlUHJpbWl0aXZlPXU7ZnVuY3Rpb24gYShwKXtyZXR1cm4gcD09PXZvaWQgMD97fTpwfWUubm9ybWFsaXplRGVmYXVsdFJlc3VsdD1hO2Z1bmN0aW9uIGMocCxmKXtyZXR1cm4gcD09PSEwPyEwOnA9PT0hMT97dmFsdWU6Zn06cH1lLm5vcm1hbGl6ZVZhbGlkYXRlUmVzdWx0PWM7ZnVuY3Rpb24gbChwLGYpe2xldCBoPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTohMTtyZXR1cm4gcD09PSExPyExOnA9PT0hMD9oPyEwOlt7dmFsdWU6Zn1dOlwidmFsdWVcImluIHA/W3BdOnAubGVuZ3RoPT09MD8hMTpwfWUubm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdD1sO2Z1bmN0aW9uIEMocCxmKXtyZXR1cm4gdHlwZW9mIHA9PVwic3RyaW5nXCJ8fFwia2V5XCJpbiBwP3tmcm9tOmYsdG86cH06XCJmcm9tXCJpbiBwP3tmcm9tOnAuZnJvbSx0bzpwLnRvfTp7ZnJvbTpmLHRvOnAudG99fWUubm9ybWFsaXplVHJhbnNmZXJSZXN1bHQ9QztmdW5jdGlvbiBtKHAsZil7cmV0dXJuIHA9PT12b2lkIDA/W106QXJyYXkuaXNBcnJheShwKT9wLm1hcChoPT5DKGgsZikpOltDKHAsZildfWUubm9ybWFsaXplRm9yd2FyZFJlc3VsdD1tO2Z1bmN0aW9uIGcocCxmKXtsZXQgaD1tKHR5cGVvZiBwPT1cIm9iamVjdFwiJiZcInJlZGlyZWN0XCJpbiBwP3AucmVkaXJlY3Q6cCxmKTtyZXR1cm4gaC5sZW5ndGg9PT0wP3tyZW1haW46ZixyZWRpcmVjdDpofTp0eXBlb2YgcD09XCJvYmplY3RcIiYmXCJyZW1haW5cImluIHA/e3JlbWFpbjpwLnJlbWFpbixyZWRpcmVjdDpofTp7cmVkaXJlY3Q6aH19ZS5ub3JtYWxpemVSZWRpcmVjdFJlc3VsdD1nfX0pLFVEPVooe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvc2NoZW1hcy9jaG9pY2UuanNcIihlKXtcInVzZSBzdHJpY3RcIjthZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPXl0KCksdD1IbigpLHM9Y2xhc3MgZXh0ZW5kcyBuLlNjaGVtYXtjb25zdHJ1Y3RvcihpKXtzdXBlcihpKTt0aGlzLl9jaG9pY2VzPXQubWFwRnJvbUFycmF5KGkuY2hvaWNlcy5tYXAocj0+ciYmdHlwZW9mIHI9PVwib2JqZWN0XCI/cjp7dmFsdWU6cn0pLFwidmFsdWVcIil9ZXhwZWN0ZWQoaSl7bGV0e2Rlc2NyaXB0b3I6cn09aSx1PUFycmF5LmZyb20odGhpcy5fY2hvaWNlcy5rZXlzKCkpLm1hcChsPT50aGlzLl9jaG9pY2VzLmdldChsKSkuZmlsdGVyKGw9PiFsLmRlcHJlY2F0ZWQpLm1hcChsPT5sLnZhbHVlKS5zb3J0KHQuY29tcGFyZVByaW1pdGl2ZSkubWFwKHIudmFsdWUpLGE9dS5zbGljZSgwLC0yKSxjPXUuc2xpY2UoLTIpO3JldHVybiBhLmNvbmNhdChjLmpvaW4oXCIgb3IgXCIpKS5qb2luKFwiLCBcIil9dmFsaWRhdGUoaSl7cmV0dXJuIHRoaXMuX2Nob2ljZXMuaGFzKGkpfWRlcHJlY2F0ZWQoaSl7bGV0IHI9dGhpcy5fY2hvaWNlcy5nZXQoaSk7cmV0dXJuIHImJnIuZGVwcmVjYXRlZD97dmFsdWU6aX06ITF9Zm9yd2FyZChpKXtsZXQgcj10aGlzLl9jaG9pY2VzLmdldChpKTtyZXR1cm4gcj9yLmZvcndhcmQ6dm9pZCAwfXJlZGlyZWN0KGkpe2xldCByPXRoaXMuX2Nob2ljZXMuZ2V0KGkpO3JldHVybiByP3IucmVkaXJlY3Q6dm9pZCAwfX07ZS5DaG9pY2VTY2hlbWE9c319KSxxaT1aKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL3NjaGVtYXMvbnVtYmVyLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7YWUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj15dCgpLHQ9Y2xhc3MgZXh0ZW5kcyBuLlNjaGVtYXtleHBlY3RlZCgpe3JldHVyblwiYSBudW1iZXJcIn12YWxpZGF0ZShzLGkpe3JldHVybiB0eXBlb2Ygcz09XCJudW1iZXJcIn19O2UuTnVtYmVyU2NoZW1hPXR9fSksekQ9Wih7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9zY2hlbWFzL2ludGVnZXIuanNcIihlKXtcInVzZSBzdHJpY3RcIjthZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPUhuKCksdD1xaSgpLHM9Y2xhc3MgZXh0ZW5kcyB0Lk51bWJlclNjaGVtYXtleHBlY3RlZCgpe3JldHVyblwiYW4gaW50ZWdlclwifXZhbGlkYXRlKGkscil7cmV0dXJuIHIubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQoc3VwZXIudmFsaWRhdGUoaSxyKSxpKT09PSEwJiZuLmlzSW50KGkpfX07ZS5JbnRlZ2VyU2NoZW1hPXN9fSksWEQ9Wih7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9zY2hlbWFzL3N0cmluZy5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49eXQoKSx0PWNsYXNzIGV4dGVuZHMgbi5TY2hlbWF7ZXhwZWN0ZWQoKXtyZXR1cm5cImEgc3RyaW5nXCJ9dmFsaWRhdGUocyl7cmV0dXJuIHR5cGVvZiBzPT1cInN0cmluZ1wifX07ZS5TdHJpbmdTY2hlbWE9dH19KSxLRD1aKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL3NjaGVtYXMvaW5kZXguanNcIihlKXtcInVzZSBzdHJpY3RcIjthZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPShndCgpLHB0KER0KSk7bi5fX2V4cG9ydFN0YXIoJEQoKSxlKSxuLl9fZXhwb3J0U3RhcihIRCgpLGUpLG4uX19leHBvcnRTdGFyKEdEKCksZSksbi5fX2V4cG9ydFN0YXIoSkQoKSxlKSxuLl9fZXhwb3J0U3RhcihVRCgpLGUpLG4uX19leHBvcnRTdGFyKHpEKCksZSksbi5fX2V4cG9ydFN0YXIocWkoKSxlKSxuLl9fZXhwb3J0U3RhcihYRCgpLGUpfX0pLFlEPVooe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvZGVmYXVsdHMuanNcIihlKXtcInVzZSBzdHJpY3RcIjthZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPWtpKCksdD1MaSgpLHM9T2koKSxpPWppKCk7ZS5kZWZhdWx0RGVzY3JpcHRvcj1uLmFwaURlc2NyaXB0b3IsZS5kZWZhdWx0VW5rbm93bkhhbmRsZXI9aS5sZXZlblVua25vd25IYW5kbGVyLGUuZGVmYXVsdEludmFsaWRIYW5kbGVyPXMuY29tbW9uSW52YWxpZEhhbmRsZXIsZS5kZWZhdWx0RGVwcmVjYXRlZEhhbmRsZXI9dC5jb21tb25EZXByZWNhdGVkSGFuZGxlcn19KSxRRD1aKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL25vcm1hbGl6ZS5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49WUQoKSx0PUhuKCk7ZS5ub3JtYWxpemU9KGkscix1KT0+bmV3IHMocix1KS5ub3JtYWxpemUoaSk7dmFyIHM9Y2xhc3N7Y29uc3RydWN0b3IoaSxyKXtsZXR7bG9nZ2VyOnU9Y29uc29sZSxkZXNjcmlwdG9yOmE9bi5kZWZhdWx0RGVzY3JpcHRvcix1bmtub3duOmM9bi5kZWZhdWx0VW5rbm93bkhhbmRsZXIsaW52YWxpZDpsPW4uZGVmYXVsdEludmFsaWRIYW5kbGVyLGRlcHJlY2F0ZWQ6Qz1uLmRlZmF1bHREZXByZWNhdGVkSGFuZGxlcn09cnx8e307dGhpcy5fdXRpbHM9e2Rlc2NyaXB0b3I6YSxsb2dnZXI6dXx8e3dhcm46KCk9Pnt9fSxzY2hlbWFzOnQucmVjb3JkRnJvbUFycmF5KGksXCJuYW1lXCIpLG5vcm1hbGl6ZURlZmF1bHRSZXN1bHQ6dC5ub3JtYWxpemVEZWZhdWx0UmVzdWx0LG5vcm1hbGl6ZURlcHJlY2F0ZWRSZXN1bHQ6dC5ub3JtYWxpemVEZXByZWNhdGVkUmVzdWx0LG5vcm1hbGl6ZUZvcndhcmRSZXN1bHQ6dC5ub3JtYWxpemVGb3J3YXJkUmVzdWx0LG5vcm1hbGl6ZVJlZGlyZWN0UmVzdWx0OnQubm9ybWFsaXplUmVkaXJlY3RSZXN1bHQsbm9ybWFsaXplVmFsaWRhdGVSZXN1bHQ6dC5ub3JtYWxpemVWYWxpZGF0ZVJlc3VsdH0sdGhpcy5fdW5rbm93bkhhbmRsZXI9Yyx0aGlzLl9pbnZhbGlkSGFuZGxlcj1sLHRoaXMuX2RlcHJlY2F0ZWRIYW5kbGVyPUMsdGhpcy5jbGVhbkhpc3RvcnkoKX1jbGVhbkhpc3RvcnkoKXt0aGlzLl9oYXNEZXByZWNhdGlvbldhcm5lZD10LmNyZWF0ZUF1dG9DaGVja2xpc3QoKX1ub3JtYWxpemUoaSl7bGV0IHI9e30sdT1baV0sYT0oKT0+e2Zvcig7dS5sZW5ndGghPT0wOyl7bGV0IGM9dS5zaGlmdCgpLGw9dGhpcy5fYXBwbHlOb3JtYWxpemF0aW9uKGMscik7dS5wdXNoKC4uLmwpfX07YSgpO2ZvcihsZXQgYyBvZiBPYmplY3Qua2V5cyh0aGlzLl91dGlscy5zY2hlbWFzKSl7bGV0IGw9dGhpcy5fdXRpbHMuc2NoZW1hc1tjXTtpZighKGMgaW4gcikpe2xldCBDPXQubm9ybWFsaXplRGVmYXVsdFJlc3VsdChsLmRlZmF1bHQodGhpcy5fdXRpbHMpKTtcInZhbHVlXCJpbiBDJiZ1LnB1c2goe1tjXTpDLnZhbHVlfSl9fWEoKTtmb3IobGV0IGMgb2YgT2JqZWN0LmtleXModGhpcy5fdXRpbHMuc2NoZW1hcykpe2xldCBsPXRoaXMuX3V0aWxzLnNjaGVtYXNbY107YyBpbiByJiYocltjXT1sLnBvc3Rwcm9jZXNzKHJbY10sdGhpcy5fdXRpbHMpKX1yZXR1cm4gcn1fYXBwbHlOb3JtYWxpemF0aW9uKGkscil7bGV0IHU9W10sW2EsY109dC5wYXJ0aXRpb24oT2JqZWN0LmtleXMoaSksbD0+bCBpbiB0aGlzLl91dGlscy5zY2hlbWFzKTtmb3IobGV0IGwgb2YgYSl7bGV0IEM9dGhpcy5fdXRpbHMuc2NoZW1hc1tsXSxtPUMucHJlcHJvY2VzcyhpW2xdLHRoaXMuX3V0aWxzKSxnPXQubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQoQy52YWxpZGF0ZShtLHRoaXMuX3V0aWxzKSxtKTtpZihnIT09ITApe2xldHt2YWx1ZTpUfT1nLEE9dGhpcy5faW52YWxpZEhhbmRsZXIobCxULHRoaXMuX3V0aWxzKTt0aHJvdyB0eXBlb2YgQT09XCJzdHJpbmdcIj9uZXcgRXJyb3IoQSk6QX1sZXQgcD1UPT57bGV0e2Zyb206QSx0bzpifT1UO3UucHVzaCh0eXBlb2YgYj09XCJzdHJpbmdcIj97W2JdOkF9OntbYi5rZXldOmIudmFsdWV9KX0sZj1UPT57bGV0e3ZhbHVlOkEscmVkaXJlY3RUbzpifT1ULHY9dC5ub3JtYWxpemVEZXByZWNhdGVkUmVzdWx0KEMuZGVwcmVjYXRlZChBLHRoaXMuX3V0aWxzKSxtLCEwKTtpZih2IT09ITEpaWYodj09PSEwKXRoaXMuX2hhc0RlcHJlY2F0aW9uV2FybmVkKGwpfHx0aGlzLl91dGlscy5sb2dnZXIud2Fybih0aGlzLl9kZXByZWNhdGVkSGFuZGxlcihsLGIsdGhpcy5fdXRpbHMpKTtlbHNlIGZvcihsZXR7dmFsdWU6Qn1vZiB2KXtsZXQgdz17a2V5OmwsdmFsdWU6Qn07aWYoIXRoaXMuX2hhc0RlcHJlY2F0aW9uV2FybmVkKHcpKXtsZXQgST10eXBlb2YgYj09XCJzdHJpbmdcIj97a2V5OmIsdmFsdWU6Qn06Yjt0aGlzLl91dGlscy5sb2dnZXIud2Fybih0aGlzLl9kZXByZWNhdGVkSGFuZGxlcih3LEksdGhpcy5fdXRpbHMpKX19fTt0Lm5vcm1hbGl6ZUZvcndhcmRSZXN1bHQoQy5mb3J3YXJkKG0sdGhpcy5fdXRpbHMpLG0pLmZvckVhY2gocCk7bGV0IE49dC5ub3JtYWxpemVSZWRpcmVjdFJlc3VsdChDLnJlZGlyZWN0KG0sdGhpcy5fdXRpbHMpLG0pO2lmKE4ucmVkaXJlY3QuZm9yRWFjaChwKSxcInJlbWFpblwiaW4gTil7bGV0IFQ9Ti5yZW1haW47cltsXT1sIGluIHI/Qy5vdmVybGFwKHJbbF0sVCx0aGlzLl91dGlscyk6VCxmKHt2YWx1ZTpUfSl9Zm9yKGxldHtmcm9tOlQsdG86QX1vZiBOLnJlZGlyZWN0KWYoe3ZhbHVlOlQscmVkaXJlY3RUbzpBfSl9Zm9yKGxldCBsIG9mIGMpe2xldCBDPWlbbF0sbT10aGlzLl91bmtub3duSGFuZGxlcihsLEMsdGhpcy5fdXRpbHMpO2lmKG0pZm9yKGxldCBnIG9mIE9iamVjdC5rZXlzKG0pKXtsZXQgcD17W2ddOm1bZ119O2cgaW4gdGhpcy5fdXRpbHMuc2NoZW1hcz91LnB1c2gocCk6T2JqZWN0LmFzc2lnbihyLHApfX1yZXR1cm4gdX19O2UuTm9ybWFsaXplcj1zfX0pLFpEPVooe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvaW5kZXguanNcIihlKXtcInVzZSBzdHJpY3RcIjthZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPShndCgpLHB0KER0KSk7bi5fX2V4cG9ydFN0YXIoakQoKSxlKSxuLl9fZXhwb3J0U3RhcihXRCgpLGUpLG4uX19leHBvcnRTdGFyKEtEKCksZSksbi5fX2V4cG9ydFN0YXIoUUQoKSxlKSxuLl9fZXhwb3J0U3Rhcih5dCgpLGUpfX0pLGVtPVooe1wic3JjL21haW4vb3B0aW9ucy1ub3JtYWxpemVyLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PVpEKCkscz1zdCgpLGk9e2tleTpnPT5nLmxlbmd0aD09PTE/XCItXCIuY29uY2F0KGcpOlwiLS1cIi5jb25jYXQoZyksdmFsdWU6Zz0+dC5hcGlEZXNjcmlwdG9yLnZhbHVlKGcpLHBhaXI6Zz0+e2xldHtrZXk6cCx2YWx1ZTpmfT1nO3JldHVybiBmPT09ITE/XCItLW5vLVwiLmNvbmNhdChwKTpmPT09ITA/aS5rZXkocCk6Zj09PVwiXCI/XCJcIi5jb25jYXQoaS5rZXkocCksXCIgd2l0aG91dCBhbiBhcmd1bWVudFwiKTpcIlwiLmNvbmNhdChpLmtleShwKSxcIj1cIikuY29uY2F0KGYpfX0scj1nPT57bGV0e2NvbG9yc01vZHVsZTpwLGxldmVuc2h0ZWluRGlzdGFuY2U6Zn09ZztyZXR1cm4gY2xhc3MgZXh0ZW5kcyB0LkNob2ljZVNjaGVtYXtjb25zdHJ1Y3RvcihOKXtsZXR7bmFtZTpULGZsYWdzOkF9PU47c3VwZXIoe25hbWU6VCxjaG9pY2VzOkF9KTt0aGlzLl9mbGFncz1bLi4uQV0uc29ydCgpfXByZXByb2Nlc3MoTixUKXtpZih0eXBlb2YgTj09XCJzdHJpbmdcIiYmTi5sZW5ndGg+MCYmIXRoaXMuX2ZsYWdzLmluY2x1ZGVzKE4pKXtsZXQgQT10aGlzLl9mbGFncy5maW5kKGI9PmYoYixOKTwzKTtpZihBKXJldHVybiBULmxvZ2dlci53YXJuKFtcIlVua25vd24gZmxhZyBcIi5jb25jYXQocC55ZWxsb3coVC5kZXNjcmlwdG9yLnZhbHVlKE4pKSxcIixcIiksXCJkaWQgeW91IG1lYW4gXCIuY29uY2F0KHAuYmx1ZShULmRlc2NyaXB0b3IudmFsdWUoQSkpLFwiP1wiKV0uam9pbihcIiBcIikpLEF9cmV0dXJuIE59ZXhwZWN0ZWQoKXtyZXR1cm5cImEgZmxhZ1wifX19LHU7ZnVuY3Rpb24gYShnLHApe2xldHtsb2dnZXI6Zixpc0NMSTpoPSExLHBhc3NUaHJvdWdoOk49ITEsY29sb3JzTW9kdWxlOlQsbGV2ZW5zaHRlaW5EaXN0YW5jZTpBfT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06e30sYj1OP0FycmF5LmlzQXJyYXkoTik/KEQsZCk9Pk4uaW5jbHVkZXMoRCk/e1tEXTpkfTp2b2lkIDA6KEQsZCk9Pih7W0RdOmR9KTooRCxkLHkpPT57bGV0IG89eS5zY2hlbWFzLHtfOnh9PW8sRj1fbihvLFhmKTtyZXR1cm4gdC5sZXZlblVua25vd25IYW5kbGVyKEQsZCxPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30seSkse30se3NjaGVtYXM6Rn0pKX0sdj1oP2k6dC5hcGlEZXNjcmlwdG9yLEI9YyhwLHtpc0NMSTpoLGNvbG9yc01vZHVsZTpULGxldmVuc2h0ZWluRGlzdGFuY2U6QX0pLHc9bmV3IHQuTm9ybWFsaXplcihCLHtsb2dnZXI6Zix1bmtub3duOmIsZGVzY3JpcHRvcjp2fSksST1mIT09ITE7SSYmdSYmKHcuX2hhc0RlcHJlY2F0aW9uV2FybmVkPXUpO2xldCBFPXcubm9ybWFsaXplKGcpO3JldHVybiBJJiYodT13Ll9oYXNEZXByZWNhdGlvbldhcm5lZCksaCYmRVtcInBsdWdpbi1zZWFyY2hcIl09PT0hMSYmKEVbXCJwbHVnaW4tc2VhcmNoLWRpclwiXT0hMSksRX1mdW5jdGlvbiBjKGcscCl7bGV0e2lzQ0xJOmYsY29sb3JzTW9kdWxlOmgsbGV2ZW5zaHRlaW5EaXN0YW5jZTpOfT1wLFQ9W107ZiYmVC5wdXNoKHQuQW55U2NoZW1hLmNyZWF0ZSh7bmFtZTpcIl9cIn0pKTtmb3IobGV0IEEgb2YgZylULnB1c2gobChBLHtpc0NMSTpmLG9wdGlvbkluZm9zOmcsY29sb3JzTW9kdWxlOmgsbGV2ZW5zaHRlaW5EaXN0YW5jZTpOfSkpLEEuYWxpYXMmJmYmJlQucHVzaCh0LkFsaWFzU2NoZW1hLmNyZWF0ZSh7bmFtZTpBLmFsaWFzLHNvdXJjZU5hbWU6QS5uYW1lfSkpO3JldHVybiBUfWZ1bmN0aW9uIGwoZyxwKXtsZXR7aXNDTEk6ZixvcHRpb25JbmZvczpoLGNvbG9yc01vZHVsZTpOLGxldmVuc2h0ZWluRGlzdGFuY2U6VH09cCx7bmFtZTpBfT1nO2lmKEE9PT1cInBsdWdpbi1zZWFyY2gtZGlyXCJ8fEE9PT1cInBsdWdpblNlYXJjaERpcnNcIilyZXR1cm4gdC5BbnlTY2hlbWEuY3JlYXRlKHtuYW1lOkEscHJlcHJvY2Vzcyh3KXtyZXR1cm4gdz09PSExfHwodz1BcnJheS5pc0FycmF5KHcpP3c6W3ddKSx3fSx2YWxpZGF0ZSh3KXtyZXR1cm4gdz09PSExPyEwOncuZXZlcnkoST0+dHlwZW9mIEk9PVwic3RyaW5nXCIpfSxleHBlY3RlZCgpe3JldHVyblwiZmFsc2Ugb3IgcGF0aHMgdG8gcGx1Z2luIHNlYXJjaCBkaXJcIn19KTtsZXQgYj17bmFtZTpBfSx2LEI9e307c3dpdGNoKGcudHlwZSl7Y2FzZVwiaW50XCI6dj10LkludGVnZXJTY2hlbWEsZiYmKGIucHJlcHJvY2Vzcz13PT5OdW1iZXIodykpO2JyZWFrO2Nhc2VcInN0cmluZ1wiOnY9dC5TdHJpbmdTY2hlbWE7YnJlYWs7Y2FzZVwiY2hvaWNlXCI6dj10LkNob2ljZVNjaGVtYSxiLmNob2ljZXM9Zy5jaG9pY2VzLm1hcCh3PT50eXBlb2Ygdz09XCJvYmplY3RcIiYmdy5yZWRpcmVjdD9PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdykse30se3JlZGlyZWN0Ont0bzp7a2V5OmcubmFtZSx2YWx1ZTp3LnJlZGlyZWN0fX19KTp3KTticmVhaztjYXNlXCJib29sZWFuXCI6dj10LkJvb2xlYW5TY2hlbWE7YnJlYWs7Y2FzZVwiZmxhZ1wiOnY9cih7Y29sb3JzTW9kdWxlOk4sbGV2ZW5zaHRlaW5EaXN0YW5jZTpUfSksYi5mbGFncz1oLmZsYXRNYXAodz0+W3cuYWxpYXMsdy5kZXNjcmlwdGlvbiYmdy5uYW1lLHcub3Bwb3NpdGVEZXNjcmlwdGlvbiYmXCJuby1cIi5jb25jYXQody5uYW1lKV0uZmlsdGVyKEJvb2xlYW4pKTticmVhaztjYXNlXCJwYXRoXCI6dj10LlN0cmluZ1NjaGVtYTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdHlwZSBcIi5jb25jYXQoZy50eXBlKSl9aWYoZy5leGNlcHRpb24/Yi52YWxpZGF0ZT0odyxJLEUpPT5nLmV4Y2VwdGlvbih3KXx8SS52YWxpZGF0ZSh3LEUpOmIudmFsaWRhdGU9KHcsSSxFKT0+dz09PXZvaWQgMHx8SS52YWxpZGF0ZSh3LEUpLGcucmVkaXJlY3QmJihCLnJlZGlyZWN0PXc9Pnc/e3RvOntrZXk6Zy5yZWRpcmVjdC5vcHRpb24sdmFsdWU6Zy5yZWRpcmVjdC52YWx1ZX19OnZvaWQgMCksZy5kZXByZWNhdGVkJiYoQi5kZXByZWNhdGVkPSEwKSxmJiYhZy5hcnJheSl7bGV0IHc9Yi5wcmVwcm9jZXNzfHwoST0+SSk7Yi5wcmVwcm9jZXNzPShJLEUsRCk9PkUucHJlcHJvY2Vzcyh3KEFycmF5LmlzQXJyYXkoSSk/cyhJKTpJKSxEKX1yZXR1cm4gZy5hcnJheT90LkFycmF5U2NoZW1hLmNyZWF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxmP3twcmVwcm9jZXNzOnc9PkFycmF5LmlzQXJyYXkodyk/dzpbd119Ont9KSxCKSx7fSx7dmFsdWVTY2hlbWE6di5jcmVhdGUoYil9KSk6di5jcmVhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGIpLEIpKX1mdW5jdGlvbiBDKGcscCxmKXtyZXR1cm4gYShnLHAsZil9ZnVuY3Rpb24gbShnLHAsZil7cmV0dXJuIGEoZyxwLE9iamVjdC5hc3NpZ24oe2lzQ0xJOiEwfSxmKSl9bi5leHBvcnRzPXtub3JtYWxpemVBcGlPcHRpb25zOkMsbm9ybWFsaXplQ2xpT3B0aW9uczptfX19KSxudD1aKHtcInNyYy9sYW5ndWFnZS1qcy9sb2MuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9Um4oKTtmdW5jdGlvbiBzKGMsbCl7bGV0e2lnbm9yZURlY29yYXRvcnM6Q309bHx8e307aWYoIUMpe2xldCBtPWMuZGVjbGFyYXRpb24mJmMuZGVjbGFyYXRpb24uZGVjb3JhdG9yc3x8Yy5kZWNvcmF0b3JzO2lmKHQobSkpcmV0dXJuIHMobVswXSl9cmV0dXJuIGMucmFuZ2U/Yy5yYW5nZVswXTpjLnN0YXJ0fWZ1bmN0aW9uIGkoYyl7cmV0dXJuIGMucmFuZ2U/Yy5yYW5nZVsxXTpjLmVuZH1mdW5jdGlvbiByKGMsbCl7bGV0IEM9cyhjKTtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihDKSYmQz09PXMobCl9ZnVuY3Rpb24gdShjLGwpe2xldCBDPWkoYyk7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoQykmJkM9PT1pKGwpfWZ1bmN0aW9uIGEoYyxsKXtyZXR1cm4gcihjLGwpJiZ1KGMsbCl9bi5leHBvcnRzPXtsb2NTdGFydDpzLGxvY0VuZDppLGhhc1NhbWVMb2NTdGFydDpyLGhhc1NhbWVMb2M6YX19fSksdG09Wih7XCJzY3JpcHRzL2J1aWxkL3NoaW1zL2JhYmVsLWhpZ2hsaWdodC5janNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9TnIoKSxzPXtzaG91bGRIaWdobGlnaHQ6KCk9PiExLGdldENoYWxrOigpPT50fTtuLmV4cG9ydHM9c319KSxybT1aKHtcIm5vZGVfbW9kdWxlcy9AYmFiZWwvY29kZS1mcmFtZS9saWIvaW5kZXguanNcIihlKXtcInVzZSBzdHJpY3RcIjthZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY29kZUZyYW1lQ29sdW1ucz11LGUuZGVmYXVsdD1hO3ZhciBuPXRtKCksdD0hMTtmdW5jdGlvbiBzKGMpe3JldHVybntndXR0ZXI6Yy5ncmV5LG1hcmtlcjpjLnJlZC5ib2xkLG1lc3NhZ2U6Yy5yZWQuYm9sZH19dmFyIGk9L1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldLztmdW5jdGlvbiByKGMsbCxDKXtsZXQgbT1PYmplY3QuYXNzaWduKHtjb2x1bW46MCxsaW5lOi0xfSxjLnN0YXJ0KSxnPU9iamVjdC5hc3NpZ24oe30sbSxjLmVuZCkse2xpbmVzQWJvdmU6cD0yLGxpbmVzQmVsb3c6Zj0zfT1DfHx7fSxoPW0ubGluZSxOPW0uY29sdW1uLFQ9Zy5saW5lLEE9Zy5jb2x1bW4sYj1NYXRoLm1heChoLShwKzEpLDApLHY9TWF0aC5taW4obC5sZW5ndGgsVCtmKTtoPT09LTEmJihiPTApLFQ9PT0tMSYmKHY9bC5sZW5ndGgpO2xldCBCPVQtaCx3PXt9O2lmKEIpZm9yKGxldCBJPTA7STw9QjtJKyspe2xldCBFPUkraDtpZighTil3W0VdPSEwO2Vsc2UgaWYoST09PTApe2xldCBEPWxbRS0xXS5sZW5ndGg7d1tFXT1bTixELU4rMV19ZWxzZSBpZihJPT09Qil3W0VdPVswLEFdO2Vsc2V7bGV0IEQ9bFtFLUldLmxlbmd0aDt3W0VdPVswLERdfX1lbHNlIE49PT1BP04/d1toXT1bTiwwXTp3W2hdPSEwOndbaF09W04sQS1OXTtyZXR1cm57c3RhcnQ6YixlbmQ6dixtYXJrZXJMaW5lczp3fX1mdW5jdGlvbiB1KGMsbCl7bGV0IEM9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOnt9LG09KEMuaGlnaGxpZ2h0Q29kZXx8Qy5mb3JjZUNvbG9yKSYmKDAsbi5zaG91bGRIaWdobGlnaHQpKEMpLGc9KDAsbi5nZXRDaGFsaykoQykscD1zKGcpLGY9KEksRSk9Pm0/SShFKTpFLGg9Yy5zcGxpdChpKSx7c3RhcnQ6TixlbmQ6VCxtYXJrZXJMaW5lczpBfT1yKGwsaCxDKSxiPWwuc3RhcnQmJnR5cGVvZiBsLnN0YXJ0LmNvbHVtbj09XCJudW1iZXJcIix2PVN0cmluZyhUKS5sZW5ndGgsdz0obT8oMCxuLmRlZmF1bHQpKGMsQyk6Yykuc3BsaXQoaSxUKS5zbGljZShOLFQpLm1hcCgoSSxFKT0+e2xldCBEPU4rMStFLGQ9XCIgXCIuY29uY2F0KEQpLnNsaWNlKC12KSx5PVwiIFwiLmNvbmNhdChkLFwiIHxcIiksbz1BW0RdLHg9IUFbRCsxXTtpZihvKXtsZXQgRj1cIlwiO2lmKEFycmF5LmlzQXJyYXkobykpe2xldCBTPUkuc2xpY2UoMCxNYXRoLm1heChvWzBdLTEsMCkpLnJlcGxhY2UoL1teXFx0XS9nLFwiIFwiKSxrPW9bMV18fDE7Rj1bYFxuIGAsZihwLmd1dHRlcix5LnJlcGxhY2UoL1xcZC9nLFwiIFwiKSksXCIgXCIsUyxmKHAubWFya2VyLFwiXlwiKS5yZXBlYXQoayldLmpvaW4oXCJcIikseCYmQy5tZXNzYWdlJiYoRis9XCIgXCIrZihwLm1lc3NhZ2UsQy5tZXNzYWdlKSl9cmV0dXJuW2YocC5tYXJrZXIsXCI+XCIpLGYocC5ndXR0ZXIseSksSS5sZW5ndGg+MD9cIiBcIi5jb25jYXQoSSk6XCJcIixGXS5qb2luKFwiXCIpfWVsc2UgcmV0dXJuXCIgXCIuY29uY2F0KGYocC5ndXR0ZXIseSkpLmNvbmNhdChJLmxlbmd0aD4wP1wiIFwiLmNvbmNhdChJKTpcIlwiKX0pLmpvaW4oYFxuYCk7cmV0dXJuIEMubWVzc2FnZSYmIWImJih3PVwiXCIuY29uY2F0KFwiIFwiLnJlcGVhdCh2KzEpKS5jb25jYXQoQy5tZXNzYWdlLGBcbmApLmNvbmNhdCh3KSksbT9nLnJlc2V0KHcpOnd9ZnVuY3Rpb24gYShjLGwsQyl7bGV0IG09YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT12b2lkIDA/YXJndW1lbnRzWzNdOnt9O2lmKCF0KXt0PSEwO2xldCBwPVwiUGFzc2luZyBsaW5lTnVtYmVyIGFuZCBjb2xOdW1iZXIgaXMgZGVwcmVjYXRlZCB0byBAYmFiZWwvY29kZS1mcmFtZS4gUGxlYXNlIHVzZSBgY29kZUZyYW1lQ29sdW1uc2AuXCI7aWYoeHQuZW1pdFdhcm5pbmcpeHQuZW1pdFdhcm5pbmcocCxcIkRlcHJlY2F0aW9uV2FybmluZ1wiKTtlbHNle2xldCBmPW5ldyBFcnJvcihwKTtmLm5hbWU9XCJEZXByZWNhdGlvbldhcm5pbmdcIixjb25zb2xlLndhcm4obmV3IEVycm9yKHApKX19cmV0dXJuIEM9TWF0aC5tYXgoQywwKSx1KGMse3N0YXJ0Ontjb2x1bW46QyxsaW5lOmx9fSxtKX19fSksR249Wih7XCJzcmMvbWFpbi9wYXJzZXIuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9UGkoKSx7Q29uZmlnRXJyb3I6c309SnQoKSxpPW50KCkse2xvY1N0YXJ0OnIsbG9jRW5kOnV9PWksYT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ZnVuY3Rpb24gbChnKXtsZXQgcD17fTtmb3IobGV0IGYgb2YgZy5wbHVnaW5zKWlmKCEhZi5wYXJzZXJzKWZvcihsZXQgaCBvZiBhKGYucGFyc2VycykpT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsaCxjKGYucGFyc2VycyxoKSk7cmV0dXJuIHB9ZnVuY3Rpb24gQyhnKXtsZXQgcD1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06bChnKTtpZih0eXBlb2YgZy5wYXJzZXI9PVwiZnVuY3Rpb25cIilyZXR1cm57cGFyc2U6Zy5wYXJzZXIsYXN0Rm9ybWF0OlwiZXN0cmVlXCIsbG9jU3RhcnQ6cixsb2NFbmQ6dX07aWYodHlwZW9mIGcucGFyc2VyPT1cInN0cmluZ1wiKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCxnLnBhcnNlcikpcmV0dXJuIHBbZy5wYXJzZXJdO3Rocm93IG5ldyBzKGBDb3VsZG4ndCByZXNvbHZlIHBhcnNlciBcImAuY29uY2F0KGcucGFyc2VyLCdcIi4gUGFyc2VycyBtdXN0IGJlIGV4cGxpY2l0bHkgYWRkZWQgdG8gdGhlIHN0YW5kYWxvbmUgYnVuZGxlLicpKX19ZnVuY3Rpb24gbShnLHApe2xldCBmPWwocCksaD1PYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSxPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMoZikubWFwKFQ9PltULHtlbnVtZXJhYmxlOiEwLGdldCgpe3JldHVybiBmW1RdLnBhcnNlfX1dKSkpLE49QyhwLGYpO3RyeXtyZXR1cm4gTi5wcmVwcm9jZXNzJiYoZz1OLnByZXByb2Nlc3MoZyxwKSkse3RleHQ6Zyxhc3Q6Ti5wYXJzZShnLGgscCl9fWNhdGNoKFQpe2xldHtsb2M6QX09VDtpZihBKXtsZXR7Y29kZUZyYW1lQ29sdW1uczpifT1ybSgpO3Rocm93IFQuY29kZUZyYW1lPWIoZyxBLHtoaWdobGlnaHRDb2RlOiEwfSksVC5tZXNzYWdlKz1gXG5gK1QuY29kZUZyYW1lLFR9dGhyb3cgVC5zdGFja319bi5leHBvcnRzPXtwYXJzZTptLHJlc29sdmVQYXJzZXI6Q319fSksTWk9Wih7XCJzcmMvbWFpbi9vcHRpb25zLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PVBpKCkse1VuZGVmaW5lZFBhcnNlckVycm9yOnN9PUp0KCkse2dldFN1cHBvcnRJbmZvOml9PU1uKCkscj1lbSgpLHtyZXNvbHZlUGFyc2VyOnV9PUduKCksYT17YXN0Rm9ybWF0OlwiZXN0cmVlXCIscHJpbnRlcjp7fSxvcmlnaW5hbFRleHQ6dm9pZCAwLGxvY1N0YXJ0Om51bGwsbG9jRW5kOm51bGx9O2Z1bmN0aW9uIGMobSl7bGV0IGc9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOnt9LHA9T2JqZWN0LmFzc2lnbih7fSxtKSxmPWkoe3BsdWdpbnM6bS5wbHVnaW5zLHNob3dVbnJlbGVhc2VkOiEwLHNob3dEZXByZWNhdGVkOiEwfSkub3B0aW9ucyxoPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSxPYmplY3QuZnJvbUVudHJpZXMoZi5maWx0ZXIodj0+di5kZWZhdWx0IT09dm9pZCAwKS5tYXAodj0+W3YubmFtZSx2LmRlZmF1bHRdKSkpO2lmKCFwLnBhcnNlcil7aWYoIXAuZmlsZXBhdGgpKGcubG9nZ2VyfHxjb25zb2xlKS53YXJuKFwiTm8gcGFyc2VyIGFuZCBubyBmaWxlcGF0aCBnaXZlbiwgdXNpbmcgJ2JhYmVsJyB0aGUgcGFyc2VyIG5vdyBidXQgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGluIHRoZSBmdXR1cmUuIFBsZWFzZSBzcGVjaWZ5IGEgcGFyc2VyIG9yIGEgZmlsZXBhdGggc28gb25lIGNhbiBiZSBpbmZlcnJlZC5cIikscC5wYXJzZXI9XCJiYWJlbFwiO2Vsc2UgaWYocC5wYXJzZXI9QyhwLmZpbGVwYXRoLHAucGx1Z2lucyksIXAucGFyc2VyKXRocm93IG5ldyBzKFwiTm8gcGFyc2VyIGNvdWxkIGJlIGluZmVycmVkIGZvciBmaWxlOiBcIi5jb25jYXQocC5maWxlcGF0aCkpfWxldCBOPXUoci5ub3JtYWxpemVBcGlPcHRpb25zKHAsW2YuZmluZCh2PT52Lm5hbWU9PT1cInBhcnNlclwiKV0se3Bhc3NUaHJvdWdoOiEwLGxvZ2dlcjohMX0pKTtwLmFzdEZvcm1hdD1OLmFzdEZvcm1hdCxwLmxvY0VuZD1OLmxvY0VuZCxwLmxvY1N0YXJ0PU4ubG9jU3RhcnQ7bGV0IFQ9bChwKTtwLnByaW50ZXI9VC5wcmludGVyc1twLmFzdEZvcm1hdF07bGV0IEE9T2JqZWN0LmZyb21FbnRyaWVzKGYuZmlsdGVyKHY9PnYucGx1Z2luRGVmYXVsdHMmJnYucGx1Z2luRGVmYXVsdHNbVC5uYW1lXSE9PXZvaWQgMCkubWFwKHY9Plt2Lm5hbWUsdi5wbHVnaW5EZWZhdWx0c1tULm5hbWVdXSkpLGI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGgpLEEpO2ZvcihsZXRbdixCXW9mIE9iamVjdC5lbnRyaWVzKGIpKShwW3ZdPT09bnVsbHx8cFt2XT09PXZvaWQgMCkmJihwW3ZdPUIpO3JldHVybiBwLnBhcnNlcj09PVwianNvblwiJiYocC50cmFpbGluZ0NvbW1hPVwibm9uZVwiKSxyLm5vcm1hbGl6ZUFwaU9wdGlvbnMocCxmLE9iamVjdC5hc3NpZ24oe3Bhc3NUaHJvdWdoOk9iamVjdC5rZXlzKGEpfSxnKSl9ZnVuY3Rpb24gbChtKXtsZXR7YXN0Rm9ybWF0Omd9PW07aWYoIWcpdGhyb3cgbmV3IEVycm9yKFwiZ2V0UGx1Z2luKCkgcmVxdWlyZXMgYXN0Rm9ybWF0IHRvIGJlIHNldFwiKTtsZXQgcD1tLnBsdWdpbnMuZmluZChmPT5mLnByaW50ZXJzJiZmLnByaW50ZXJzW2ddKTtpZighcCl0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgcGx1Z2luIGZvciBBU1QgZm9ybWF0IFwiYC5jb25jYXQoZywnXCInKSk7cmV0dXJuIHB9ZnVuY3Rpb24gQyhtLGcpe2xldCBwPXQuYmFzZW5hbWUobSkudG9Mb3dlckNhc2UoKSxoPWkoe3BsdWdpbnM6Z30pLmxhbmd1YWdlcy5maWx0ZXIoTj0+Ti5zaW5jZSE9PW51bGwpLmZpbmQoTj0+Ti5leHRlbnNpb25zJiZOLmV4dGVuc2lvbnMuc29tZShUPT5wLmVuZHNXaXRoKFQpKXx8Ti5maWxlbmFtZXMmJk4uZmlsZW5hbWVzLnNvbWUoVD0+VC50b0xvd2VyQ2FzZSgpPT09cCkpO3JldHVybiBoJiZoLnBhcnNlcnNbMF19bi5leHBvcnRzPXtub3JtYWxpemU6YyxoaWRkZW5EZWZhdWx0czphLGluZmVyUGFyc2VyOkN9fX0pLG5tPVooe1wic3JjL21haW4vbWFzc2FnZS1hc3QuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7ZnVuY3Rpb24gdChzLGkscil7aWYoQXJyYXkuaXNBcnJheShzKSlyZXR1cm4gcy5tYXAobD0+dChsLGkscikpLmZpbHRlcihCb29sZWFuKTtpZighc3x8dHlwZW9mIHMhPVwib2JqZWN0XCIpcmV0dXJuIHM7bGV0IHU9aS5wcmludGVyLm1hc3NhZ2VBc3ROb2RlLGE7dSYmdS5pZ25vcmVkUHJvcGVydGllcz9hPXUuaWdub3JlZFByb3BlcnRpZXM6YT1uZXcgU2V0O2xldCBjPXt9O2ZvcihsZXRbbCxDXW9mIE9iamVjdC5lbnRyaWVzKHMpKSFhLmhhcyhsKSYmdHlwZW9mIEMhPVwiZnVuY3Rpb25cIiYmKGNbbF09dChDLGkscykpO2lmKHUpe2xldCBsPXUocyxjLHIpO2lmKGw9PT1udWxsKXJldHVybjtpZihsKXJldHVybiBsfXJldHVybiBjfW4uZXhwb3J0cz10fX0pLFV0PVooe1wic2NyaXB0cy9idWlsZC9zaGltcy9hc3NlcnQuY2pzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PSgpPT57fTt0Lm9rPXQsdC5zdHJpY3RFcXVhbD10LG4uZXhwb3J0cz10fX0pLFFlPVooe1wic3JjL21haW4vY29tbWVudHMuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9VXQoKSx7YnVpbGRlcnM6e2xpbmU6cyxoYXJkbGluZTppLGJyZWFrUGFyZW50OnIsaW5kZW50OnUsbGluZVN1ZmZpeDphLGpvaW46YyxjdXJzb3I6bH19PUxlKCkse2hhc05ld2xpbmU6Qyxza2lwTmV3bGluZTptLHNraXBTcGFjZXM6Zyxpc1ByZXZpb3VzTGluZUVtcHR5OnAsYWRkTGVhZGluZ0NvbW1lbnQ6ZixhZGREYW5nbGluZ0NvbW1lbnQ6aCxhZGRUcmFpbGluZ0NvbW1lbnQ6Tn09R2UoKSxUPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIEEoTyxSLE0pe2lmKCFPKXJldHVybjtsZXR7cHJpbnRlcjpILGxvY1N0YXJ0OlAsbG9jRW5kOkd9PVI7aWYoTSl7aWYoSC5jYW5BdHRhY2hDb21tZW50JiZILmNhbkF0dGFjaENvbW1lbnQoTykpe2xldCAkO2ZvcigkPU0ubGVuZ3RoLTE7JD49MCYmIShQKE1bJF0pPD1QKE8pJiZHKE1bJF0pPD1HKE8pKTstLSQpO00uc3BsaWNlKCQrMSwwLE8pO3JldHVybn19ZWxzZSBpZihULmhhcyhPKSlyZXR1cm4gVC5nZXQoTyk7bGV0IHJlPUguZ2V0Q29tbWVudENoaWxkTm9kZXMmJkguZ2V0Q29tbWVudENoaWxkTm9kZXMoTyxSKXx8dHlwZW9mIE89PVwib2JqZWN0XCImJk9iamVjdC5lbnRyaWVzKE8pLmZpbHRlcigkPT57bGV0W1ddPSQ7cmV0dXJuIFchPT1cImVuY2xvc2luZ05vZGVcIiYmVyE9PVwicHJlY2VkaW5nTm9kZVwiJiZXIT09XCJmb2xsb3dpbmdOb2RlXCImJlchPT1cInRva2Vuc1wiJiZXIT09XCJjb21tZW50c1wiJiZXIT09XCJwYXJlbnRcIn0pLm1hcCgkPT57bGV0WyxXXT0kO3JldHVybiBXfSk7aWYoISFyZSl7TXx8KE09W10sVC5zZXQoTyxNKSk7Zm9yKGxldCAkIG9mIHJlKUEoJCxSLE0pO3JldHVybiBNfX1mdW5jdGlvbiBiKE8sUixNLEgpe2xldHtsb2NTdGFydDpQLGxvY0VuZDpHfT1NLHJlPVAoUiksJD1HKFIpLFc9QShPLE0pLGVlLFUsbmU9MCxzZT1XLmxlbmd0aDtmb3IoO25lPHNlOyl7bGV0IFY9bmUrc2U+PjEsb2U9V1tWXSxLPVAob2UpLEVlPUcob2UpO2lmKEs8PXJlJiYkPD1FZSlyZXR1cm4gYihvZSxSLE0sb2UpO2lmKEVlPD1yZSl7ZWU9b2UsbmU9VisxO2NvbnRpbnVlfWlmKCQ8PUspe1U9b2Usc2U9Vjtjb250aW51ZX10aHJvdyBuZXcgRXJyb3IoXCJDb21tZW50IGxvY2F0aW9uIG92ZXJsYXBzIHdpdGggbm9kZSBsb2NhdGlvblwiKX1pZihIJiZILnR5cGU9PT1cIlRlbXBsYXRlTGl0ZXJhbFwiKXtsZXR7cXVhc2lzOlZ9PUgsb2U9eShWLFIsTSk7ZWUmJnkoVixlZSxNKSE9PW9lJiYoZWU9bnVsbCksVSYmeShWLFUsTSkhPT1vZSYmKFU9bnVsbCl9cmV0dXJue2VuY2xvc2luZ05vZGU6SCxwcmVjZWRpbmdOb2RlOmVlLGZvbGxvd2luZ05vZGU6VX19dmFyIHY9KCk9PiExO2Z1bmN0aW9uIEIoTyxSLE0sSCl7aWYoIUFycmF5LmlzQXJyYXkoTykpcmV0dXJuO2xldCBQPVtdLHtsb2NTdGFydDpHLGxvY0VuZDpyZSxwcmludGVyOntoYW5kbGVDb21tZW50czokPXt9fX09SCx7YXZvaWRBc3RNdXRhdGlvbjpXLG93bkxpbmU6ZWU9dixlbmRPZkxpbmU6VT12LHJlbWFpbmluZzpuZT12fT0kLHNlPU8ubWFwKChWLG9lKT0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGIoUixWLEgpKSx7fSx7Y29tbWVudDpWLHRleHQ6TSxvcHRpb25zOkgsYXN0OlIsaXNMYXN0Q29tbWVudDpPLmxlbmd0aC0xPT09b2V9KSk7Zm9yKGxldFtWLG9lXW9mIHNlLmVudHJpZXMoKSl7bGV0e2NvbW1lbnQ6SyxwcmVjZWRpbmdOb2RlOkVlLGVuY2xvc2luZ05vZGU6cSxmb2xsb3dpbmdOb2RlOmxlLHRleHQ6dWUsb3B0aW9uczpRLGFzdDpkZSxpc0xhc3RDb21tZW50OmdlfT1vZTtpZihRLnBhcnNlcj09PVwianNvblwifHxRLnBhcnNlcj09PVwianNvbjVcInx8US5wYXJzZXI9PT1cIl9fanNfZXhwcmVzc2lvblwifHxRLnBhcnNlcj09PVwiX192dWVfZXhwcmVzc2lvblwiKXtpZihHKEspLUcoZGUpPD0wKXtmKGRlLEspO2NvbnRpbnVlfWlmKHJlKEspLXJlKGRlKT49MCl7TihkZSxLKTtjb250aW51ZX19bGV0IHZlO2lmKFc/dmU9W29lXTooSy5lbmNsb3NpbmdOb2RlPXEsSy5wcmVjZWRpbmdOb2RlPUVlLEsuZm9sbG93aW5nTm9kZT1sZSx2ZT1bSyx1ZSxRLGRlLGdlXSksSSh1ZSxRLHNlLFYpKUsucGxhY2VtZW50PVwib3duTGluZVwiLGVlKC4uLnZlKXx8KGxlP2YobGUsSyk6RWU/TihFZSxLKTpoKHF8fGRlLEspKTtlbHNlIGlmKEUodWUsUSxzZSxWKSlLLnBsYWNlbWVudD1cImVuZE9mTGluZVwiLFUoLi4udmUpfHwoRWU/TihFZSxLKTpsZT9mKGxlLEspOmgocXx8ZGUsSykpO2Vsc2UgaWYoSy5wbGFjZW1lbnQ9XCJyZW1haW5pbmdcIiwhbmUoLi4udmUpKWlmKEVlJiZsZSl7bGV0IHhlPVAubGVuZ3RoO3hlPjAmJlBbeGUtMV0uZm9sbG93aW5nTm9kZSE9PWxlJiZEKFAsdWUsUSksUC5wdXNoKG9lKX1lbHNlIEVlP04oRWUsSyk6bGU/ZihsZSxLKTpoKHF8fGRlLEspfWlmKEQoUCxNLEgpLCFXKWZvcihsZXQgViBvZiBPKWRlbGV0ZSBWLnByZWNlZGluZ05vZGUsZGVsZXRlIFYuZW5jbG9zaW5nTm9kZSxkZWxldGUgVi5mb2xsb3dpbmdOb2RlfXZhciB3PU89PiEvW1xcU1xcblxcdTIwMjhcXHUyMDI5XS8udGVzdChPKTtmdW5jdGlvbiBJKE8sUixNLEgpe2xldHtjb21tZW50OlAscHJlY2VkaW5nTm9kZTpHfT1NW0hdLHtsb2NTdGFydDpyZSxsb2NFbmQ6JH09UixXPXJlKFApO2lmKEcpZm9yKGxldCBlZT1ILTE7ZWU+PTA7ZWUtLSl7bGV0e2NvbW1lbnQ6VSxwcmVjZWRpbmdOb2RlOm5lfT1NW2VlXTtpZihuZSE9PUd8fCF3KE8uc2xpY2UoJChVKSxXKSkpYnJlYWs7Vz1yZShVKX1yZXR1cm4gQyhPLFcse2JhY2t3YXJkczohMH0pfWZ1bmN0aW9uIEUoTyxSLE0sSCl7bGV0e2NvbW1lbnQ6UCxmb2xsb3dpbmdOb2RlOkd9PU1bSF0se2xvY1N0YXJ0OnJlLGxvY0VuZDokfT1SLFc9JChQKTtpZihHKWZvcihsZXQgZWU9SCsxO2VlPE0ubGVuZ3RoO2VlKyspe2xldHtjb21tZW50OlUsZm9sbG93aW5nTm9kZTpuZX09TVtlZV07aWYobmUhPT1HfHwhdyhPLnNsaWNlKFcscmUoVSkpKSlicmVhaztXPSQoVSl9cmV0dXJuIEMoTyxXKX1mdW5jdGlvbiBEKE8sUixNKXtsZXQgSD1PLmxlbmd0aDtpZihIPT09MClyZXR1cm47bGV0e3ByZWNlZGluZ05vZGU6UCxmb2xsb3dpbmdOb2RlOkcsZW5jbG9zaW5nTm9kZTpyZX09T1swXSwkPU0ucHJpbnRlci5nZXRHYXBSZWdleCYmTS5wcmludGVyLmdldEdhcFJlZ2V4KHJlKXx8L15bXFxzKF0qJC8sVz1NLmxvY1N0YXJ0KEcpLGVlO2ZvcihlZT1IO2VlPjA7LS1lZSl7bGV0e2NvbW1lbnQ6VSxwcmVjZWRpbmdOb2RlOm5lLGZvbGxvd2luZ05vZGU6c2V9PU9bZWUtMV07dC5zdHJpY3RFcXVhbChuZSxQKSx0LnN0cmljdEVxdWFsKHNlLEcpO2xldCBWPVIuc2xpY2UoTS5sb2NFbmQoVSksVyk7aWYoJC50ZXN0KFYpKVc9TS5sb2NTdGFydChVKTtlbHNlIGJyZWFrfWZvcihsZXRbVSx7Y29tbWVudDpuZX1db2YgTy5lbnRyaWVzKCkpVTxlZT9OKFAsbmUpOmYoRyxuZSk7Zm9yKGxldCBVIG9mW1AsR10pVS5jb21tZW50cyYmVS5jb21tZW50cy5sZW5ndGg+MSYmVS5jb21tZW50cy5zb3J0KChuZSxzZSk9Pk0ubG9jU3RhcnQobmUpLU0ubG9jU3RhcnQoc2UpKTtPLmxlbmd0aD0wfWZ1bmN0aW9uIGQoTyxSKXtsZXQgTT1PLmdldFZhbHVlKCk7cmV0dXJuIE0ucHJpbnRlZD0hMCxSLnByaW50ZXIucHJpbnRDb21tZW50KE8sUil9ZnVuY3Rpb24geShPLFIsTSl7bGV0IEg9TS5sb2NTdGFydChSKS0xO2ZvcihsZXQgUD0xO1A8Ty5sZW5ndGg7KytQKWlmKEg8TS5sb2NTdGFydChPW1BdKSlyZXR1cm4gUC0xO3JldHVybiAwfWZ1bmN0aW9uIG8oTyxSKXtsZXQgTT1PLmdldFZhbHVlKCksSD1bZChPLFIpXSx7cHJpbnRlcjpQLG9yaWdpbmFsVGV4dDpHLGxvY1N0YXJ0OnJlLGxvY0VuZDokfT1SO2lmKFAuaXNCbG9ja0NvbW1lbnQmJlAuaXNCbG9ja0NvbW1lbnQoTSkpe2xldCBVPUMoRywkKE0pKT9DKEcscmUoTSkse2JhY2t3YXJkczohMH0pP2k6czpcIiBcIjtILnB1c2goVSl9ZWxzZSBILnB1c2goaSk7bGV0IGVlPW0oRyxnKEcsJChNKSkpO3JldHVybiBlZSE9PSExJiZDKEcsZWUpJiZILnB1c2goaSksSH1mdW5jdGlvbiB4KE8sUil7bGV0IE09Ty5nZXRWYWx1ZSgpLEg9ZChPLFIpLHtwcmludGVyOlAsb3JpZ2luYWxUZXh0OkcsbG9jU3RhcnQ6cmV9PVIsJD1QLmlzQmxvY2tDb21tZW50JiZQLmlzQmxvY2tDb21tZW50KE0pO2lmKEMoRyxyZShNKSx7YmFja3dhcmRzOiEwfSkpe2xldCBlZT1wKEcsTSxyZSk7cmV0dXJuIGEoW2ksZWU/aTpcIlwiLEhdKX1sZXQgVz1bXCIgXCIsSF07cmV0dXJuICR8fChXPVthKFcpLHJdKSxXfWZ1bmN0aW9uIEYoTyxSLE0sSCl7bGV0IFA9W10sRz1PLmdldFZhbHVlKCk7cmV0dXJuIUd8fCFHLmNvbW1lbnRzfHwoTy5lYWNoKCgpPT57bGV0IHJlPU8uZ2V0VmFsdWUoKTshcmUubGVhZGluZyYmIXJlLnRyYWlsaW5nJiYoIUh8fEgocmUpKSYmUC5wdXNoKGQoTyxSKSl9LFwiY29tbWVudHNcIiksUC5sZW5ndGg9PT0wKT9cIlwiOk0/YyhpLFApOnUoW2ksYyhpLFApXSl9ZnVuY3Rpb24gUyhPLFIsTSl7bGV0IEg9Ty5nZXRWYWx1ZSgpO2lmKCFIKXJldHVybnt9O2xldCBQPUguY29tbWVudHN8fFtdO00mJihQPVAuZmlsdGVyKFc9PiFNLmhhcyhXKSkpO2xldCBHPUg9PT1SLmN1cnNvck5vZGU7aWYoUC5sZW5ndGg9PT0wKXtsZXQgVz1HP2w6XCJcIjtyZXR1cm57bGVhZGluZzpXLHRyYWlsaW5nOld9fWxldCByZT1bXSwkPVtdO3JldHVybiBPLmVhY2goKCk9PntsZXQgVz1PLmdldFZhbHVlKCk7aWYoTSYmTS5oYXMoVykpcmV0dXJuO2xldHtsZWFkaW5nOmVlLHRyYWlsaW5nOlV9PVc7ZWU/cmUucHVzaChvKE8sUikpOlUmJiQucHVzaCh4KE8sUikpfSxcImNvbW1lbnRzXCIpLEcmJihyZS51bnNoaWZ0KGwpLCQucHVzaChsKSkse2xlYWRpbmc6cmUsdHJhaWxpbmc6JH19ZnVuY3Rpb24gayhPLFIsTSxIKXtsZXR7bGVhZGluZzpQLHRyYWlsaW5nOkd9PVMoTyxNLEgpO3JldHVybiFQJiYhRz9SOltQLFIsR119ZnVuY3Rpb24gXyhPKXtpZighIU8pZm9yKGxldCBSIG9mIE8pe2lmKCFSLnByaW50ZWQpdGhyb3cgbmV3IEVycm9yKCdDb21tZW50IFwiJytSLnZhbHVlLnRyaW0oKSsnXCIgd2FzIG5vdCBwcmludGVkLiBQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IhJyk7ZGVsZXRlIFIucHJpbnRlZH19bi5leHBvcnRzPXthdHRhY2g6QixwcmludENvbW1lbnRzOmsscHJpbnRDb21tZW50c1NlcGFyYXRlbHk6UyxwcmludERhbmdsaW5nQ29tbWVudHM6RixnZXRTb3J0ZWRDaGlsZE5vZGVzOkEsZW5zdXJlQWxsQ29tbWVudHNQcmludGVkOl99fX0pLHVtPVooe1wic3JjL2NvbW1vbi9hc3QtcGF0aC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD1zdCgpO2Z1bmN0aW9uIHModSxhKXtsZXQgYz1pKHUuc3RhY2ssYSk7cmV0dXJuIGM9PT0tMT9udWxsOnUuc3RhY2tbY119ZnVuY3Rpb24gaSh1LGEpe2ZvcihsZXQgYz11Lmxlbmd0aC0xO2M+PTA7Yy09Mil7bGV0IGw9dVtjXTtpZihsJiYhQXJyYXkuaXNBcnJheShsKSYmLS1hPDApcmV0dXJuIGN9cmV0dXJuLTF9dmFyIHI9Y2xhc3N7Y29uc3RydWN0b3IodSl7dGhpcy5zdGFjaz1bdV19Z2V0TmFtZSgpe2xldHtzdGFjazp1fT10aGlzLHtsZW5ndGg6YX09dTtyZXR1cm4gYT4xP3VbYS0yXTpudWxsfWdldFZhbHVlKCl7cmV0dXJuIHQodGhpcy5zdGFjayl9Z2V0Tm9kZSgpe2xldCB1PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTowO3JldHVybiBzKHRoaXMsdSl9Z2V0UGFyZW50Tm9kZSgpe2xldCB1PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTowO3JldHVybiBzKHRoaXMsdSsxKX1jYWxsKHUpe2xldHtzdGFjazphfT10aGlzLHtsZW5ndGg6Y309YSxsPXQoYSk7Zm9yKHZhciBDPWFyZ3VtZW50cy5sZW5ndGgsbT1uZXcgQXJyYXkoQz4xP0MtMTowKSxnPTE7ZzxDO2crKyltW2ctMV09YXJndW1lbnRzW2ddO2ZvcihsZXQgZiBvZiBtKWw9bFtmXSxhLnB1c2goZixsKTtsZXQgcD11KHRoaXMpO3JldHVybiBhLmxlbmd0aD1jLHB9Y2FsbFBhcmVudCh1KXtsZXQgYT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06MCxjPWkodGhpcy5zdGFjayxhKzEpLGw9dGhpcy5zdGFjay5zcGxpY2UoYysxKSxDPXUodGhpcyk7cmV0dXJuIHRoaXMuc3RhY2sucHVzaCguLi5sKSxDfWVhY2godSl7bGV0e3N0YWNrOmF9PXRoaXMse2xlbmd0aDpjfT1hLGw9dChhKTtmb3IodmFyIEM9YXJndW1lbnRzLmxlbmd0aCxtPW5ldyBBcnJheShDPjE/Qy0xOjApLGc9MTtnPEM7ZysrKW1bZy0xXT1hcmd1bWVudHNbZ107Zm9yKGxldCBwIG9mIG0pbD1sW3BdLGEucHVzaChwLGwpO2ZvcihsZXQgcD0wO3A8bC5sZW5ndGg7KytwKWEucHVzaChwLGxbcF0pLHUodGhpcyxwLGwpLGEubGVuZ3RoLT0yO2EubGVuZ3RoPWN9bWFwKHUpe2xldCBhPVtdO2Zvcih2YXIgYz1hcmd1bWVudHMubGVuZ3RoLGw9bmV3IEFycmF5KGM+MT9jLTE6MCksQz0xO0M8YztDKyspbFtDLTFdPWFyZ3VtZW50c1tDXTtyZXR1cm4gdGhpcy5lYWNoKChtLGcscCk9PnthW2ddPXUobSxnLHApfSwuLi5sKSxhfXRyeSh1KXtsZXR7c3RhY2s6YX09dGhpcyxjPVsuLi5hXTt0cnl7cmV0dXJuIHUoKX1maW5hbGx5e2EubGVuZ3RoPTAsYS5wdXNoKC4uLmMpfX1tYXRjaCgpe2xldCB1PXRoaXMuc3RhY2subGVuZ3RoLTEsYT1udWxsLGM9dGhpcy5zdGFja1t1LS1dO2Zvcih2YXIgbD1hcmd1bWVudHMubGVuZ3RoLEM9bmV3IEFycmF5KGwpLG09MDttPGw7bSsrKUNbbV09YXJndW1lbnRzW21dO2ZvcihsZXQgZyBvZiBDKXtpZihjPT09dm9pZCAwKXJldHVybiExO2xldCBwPW51bGw7aWYodHlwZW9mIGE9PVwibnVtYmVyXCImJihwPWEsYT10aGlzLnN0YWNrW3UtLV0sYz10aGlzLnN0YWNrW3UtLV0pLGcmJiFnKGMsYSxwKSlyZXR1cm4hMTthPXRoaXMuc3RhY2tbdS0tXSxjPXRoaXMuc3RhY2tbdS0tXX1yZXR1cm4hMH1maW5kQW5jZXN0b3IodSl7bGV0IGE9dGhpcy5zdGFjay5sZW5ndGgtMSxjPW51bGwsbD10aGlzLnN0YWNrW2EtLV07Zm9yKDtsOyl7bGV0IEM9bnVsbDtpZih0eXBlb2YgYz09XCJudW1iZXJcIiYmKEM9YyxjPXRoaXMuc3RhY2tbYS0tXSxsPXRoaXMuc3RhY2tbYS0tXSksYyE9PW51bGwmJnUobCxjLEMpKXJldHVybiBsO2M9dGhpcy5zdGFja1thLS1dLGw9dGhpcy5zdGFja1thLS1dfX19O24uZXhwb3J0cz1yfX0pLHNtPVooe1wic3JjL21haW4vbXVsdGlwYXJzZXIuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye3V0aWxzOntzdHJpcFRyYWlsaW5nSGFyZGxpbmU6dH19PUxlKCkse25vcm1hbGl6ZTpzfT1NaSgpLGk9UWUoKTtmdW5jdGlvbiByKGEsYyxsLEMpe2lmKGwucHJpbnRlci5lbWJlZCYmbC5lbWJlZGRlZExhbmd1YWdlRm9ybWF0dGluZz09PVwiYXV0b1wiKXJldHVybiBsLnByaW50ZXIuZW1iZWQoYSxjLChtLGcscCk9PnUobSxnLGwsQyxwKSxsKX1mdW5jdGlvbiB1KGEsYyxsLEMpe2xldHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6bT0hMX09YXJndW1lbnRzLmxlbmd0aD40JiZhcmd1bWVudHNbNF0hPT12b2lkIDA/YXJndW1lbnRzWzRdOnt9LGc9cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSxjKSx7fSx7cGFyZW50UGFyc2VyOmwucGFyc2VyLG9yaWdpbmFsVGV4dDphfSkse3Bhc3NUaHJvdWdoOiEwfSkscD1HbigpLnBhcnNlKGEsZykse2FzdDpmfT1wO2E9cC50ZXh0O2xldCBoPWYuY29tbWVudHM7ZGVsZXRlIGYuY29tbWVudHMsaS5hdHRhY2goaCxmLGEsZyksZ1tTeW1ib2wuZm9yKFwiY29tbWVudHNcIildPWh8fFtdLGdbU3ltYm9sLmZvcihcInRva2Vuc1wiKV09Zi50b2tlbnN8fFtdO2xldCBOPUMoZixnKTtyZXR1cm4gaS5lbnN1cmVBbGxDb21tZW50c1ByaW50ZWQoaCksbT90eXBlb2YgTj09XCJzdHJpbmdcIj9OLnJlcGxhY2UoLyg/Olxccj9cXG4pKiQvLFwiXCIpOnQoTik6Tn1uLmV4cG9ydHM9e3ByaW50U3VidHJlZTpyfX19KSxhbT1aKHtcInNyYy9tYWluL2FzdC10by1kb2MuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9dW0oKSx7YnVpbGRlcnM6e2hhcmRsaW5lOnMsYWRkQWxpZ25tZW50VG9Eb2M6aX0sdXRpbHM6e3Byb3BhZ2F0ZUJyZWFrczpyfX09TGUoKSx7cHJpbnRDb21tZW50czp1fT1RZSgpLGE9c20oKTtmdW5jdGlvbiBjKG0sZyl7bGV0IHA9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOjAse3ByaW50ZXI6Zn09ZztmLnByZXByb2Nlc3MmJihtPWYucHJlcHJvY2VzcyhtLGcpKTtsZXQgaD1uZXcgTWFwLE49bmV3IHQobSksVD1BKCk7cmV0dXJuIHA+MCYmKFQ9aShbcyxUXSxwLGcudGFiV2lkdGgpKSxyKFQpLFQ7ZnVuY3Rpb24gQSh2LEIpe3JldHVybiB2PT09dm9pZCAwfHx2PT09Tj9iKEIpOkFycmF5LmlzQXJyYXkodik/Ti5jYWxsKCgpPT5iKEIpLC4uLnYpOk4uY2FsbCgoKT0+YihCKSx2KX1mdW5jdGlvbiBiKHYpe2xldCBCPU4uZ2V0VmFsdWUoKSx3PUImJnR5cGVvZiBCPT1cIm9iamVjdFwiJiZ2PT09dm9pZCAwO2lmKHcmJmguaGFzKEIpKXJldHVybiBoLmdldChCKTtsZXQgST1DKE4sZyxBLHYpO3JldHVybiB3JiZoLnNldChCLEkpLEl9fWZ1bmN0aW9uIGwobSxnKXtsZXR7b3JpZ2luYWxUZXh0OnAsW1N5bWJvbC5mb3IoXCJjb21tZW50c1wiKV06Zixsb2NTdGFydDpoLGxvY0VuZDpOfT1nLFQ9aChtKSxBPU4obSksYj1uZXcgU2V0O2ZvcihsZXQgdiBvZiBmKWgodik+PVQmJk4odik8PUEmJih2LnByaW50ZWQ9ITAsYi5hZGQodikpO3JldHVybntkb2M6cC5zbGljZShULEEpLHByaW50ZWRDb21tZW50czpifX1mdW5jdGlvbiBDKG0sZyxwLGYpe2xldCBoPW0uZ2V0VmFsdWUoKSx7cHJpbnRlcjpOfT1nLFQsQTtpZihOLmhhc1ByZXR0aWVySWdub3JlJiZOLmhhc1ByZXR0aWVySWdub3JlKG0pKSh7ZG9jOlQscHJpbnRlZENvbW1lbnRzOkF9PWwoaCxnKSk7ZWxzZXtpZihoKXRyeXtUPWEucHJpbnRTdWJ0cmVlKG0scCxnLGMpfWNhdGNoKGIpe2lmKGdsb2JhbFRoaXMuUFJFVFRJRVJfREVCVUcpdGhyb3cgYn1UfHwoVD1OLnByaW50KG0sZyxwLGYpKX1yZXR1cm4oIU4ud2lsbFByaW50T3duQ29tbWVudHN8fCFOLndpbGxQcmludE93bkNvbW1lbnRzKG0sZykpJiYoVD11KG0sVCxnLEEpKSxUfW4uZXhwb3J0cz1jfX0pLGltPVooe1wic3JjL21haW4vcmFuZ2UtdXRpbC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD1VdCgpLHM9UWUoKSxpPWY9PntsZXR7cGFyc2VyOmh9PWY7cmV0dXJuIGg9PT1cImpzb25cInx8aD09PVwianNvbjVcInx8aD09PVwianNvbi1zdHJpbmdpZnlcIn07ZnVuY3Rpb24gcihmLGgpe2xldCBOPVtmLm5vZGUsLi4uZi5wYXJlbnROb2Rlc10sVD1uZXcgU2V0KFtoLm5vZGUsLi4uaC5wYXJlbnROb2Rlc10pO3JldHVybiBOLmZpbmQoQT0+Qy5oYXMoQS50eXBlKSYmVC5oYXMoQSkpfWZ1bmN0aW9uIHUoZil7bGV0IGg9Zi5sZW5ndGgtMTtmb3IoOzspe2xldCBOPWZbaF07aWYoTiYmKE4udHlwZT09PVwiUHJvZ3JhbVwifHxOLnR5cGU9PT1cIkZpbGVcIikpaC0tO2Vsc2UgYnJlYWt9cmV0dXJuIGYuc2xpY2UoMCxoKzEpfWZ1bmN0aW9uIGEoZixoLE4pe2xldHtsb2NTdGFydDpULGxvY0VuZDpBfT1OLGI9Zi5ub2RlLHY9aC5ub2RlO2lmKGI9PT12KXJldHVybntzdGFydE5vZGU6YixlbmROb2RlOnZ9O2xldCBCPVQoZi5ub2RlKTtmb3IobGV0IEkgb2YgdShoLnBhcmVudE5vZGVzKSlpZihUKEkpPj1CKXY9STtlbHNlIGJyZWFrO2xldCB3PUEoaC5ub2RlKTtmb3IobGV0IEkgb2YgdShmLnBhcmVudE5vZGVzKSlpZihBKEkpPD13KWI9STtlbHNlIGJyZWFrO3JldHVybntzdGFydE5vZGU6YixlbmROb2RlOnZ9fWZ1bmN0aW9uIGMoZixoLE4sVCl7bGV0IEE9YXJndW1lbnRzLmxlbmd0aD40JiZhcmd1bWVudHNbNF0hPT12b2lkIDA/YXJndW1lbnRzWzRdOltdLGI9YXJndW1lbnRzLmxlbmd0aD41P2FyZ3VtZW50c1s1XTp2b2lkIDAse2xvY1N0YXJ0OnYsbG9jRW5kOkJ9PU4sdz12KGYpLEk9QihmKTtpZighKGg+SXx8aDx3fHxiPT09XCJyYW5nZUVuZFwiJiZoPT09d3x8Yj09PVwicmFuZ2VTdGFydFwiJiZoPT09SSkpe2ZvcihsZXQgRSBvZiBzLmdldFNvcnRlZENoaWxkTm9kZXMoZixOKSl7bGV0IEQ9YyhFLGgsTixULFtmLC4uLkFdLGIpO2lmKEQpcmV0dXJuIER9aWYoIVR8fFQoZixBWzBdKSlyZXR1cm57bm9kZTpmLHBhcmVudE5vZGVzOkF9fX1mdW5jdGlvbiBsKGYsaCl7cmV0dXJuIGghPT1cIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiJiZmIT09XCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiYmKGY9PT1cIkRpcmVjdGl2ZVwifHxmPT09XCJUeXBlQWxpYXNcInx8Zj09PVwiVFNFeHBvcnRBc3NpZ25tZW50XCJ8fGYuc3RhcnRzV2l0aChcIkRlY2xhcmVcIil8fGYuc3RhcnRzV2l0aChcIlRTRGVjbGFyZVwiKXx8Zi5lbmRzV2l0aChcIlN0YXRlbWVudFwiKXx8Zi5lbmRzV2l0aChcIkRlY2xhcmF0aW9uXCIpKX12YXIgQz1uZXcgU2V0KFtcIk9iamVjdEV4cHJlc3Npb25cIixcIkFycmF5RXhwcmVzc2lvblwiLFwiU3RyaW5nTGl0ZXJhbFwiLFwiTnVtZXJpY0xpdGVyYWxcIixcIkJvb2xlYW5MaXRlcmFsXCIsXCJOdWxsTGl0ZXJhbFwiLFwiVW5hcnlFeHByZXNzaW9uXCIsXCJUZW1wbGF0ZUxpdGVyYWxcIl0pLG09bmV3IFNldChbXCJPcGVyYXRpb25EZWZpbml0aW9uXCIsXCJGcmFnbWVudERlZmluaXRpb25cIixcIlZhcmlhYmxlRGVmaW5pdGlvblwiLFwiVHlwZUV4dGVuc2lvbkRlZmluaXRpb25cIixcIk9iamVjdFR5cGVEZWZpbml0aW9uXCIsXCJGaWVsZERlZmluaXRpb25cIixcIkRpcmVjdGl2ZURlZmluaXRpb25cIixcIkVudW1UeXBlRGVmaW5pdGlvblwiLFwiRW51bVZhbHVlRGVmaW5pdGlvblwiLFwiSW5wdXRWYWx1ZURlZmluaXRpb25cIixcIklucHV0T2JqZWN0VHlwZURlZmluaXRpb25cIixcIlNjaGVtYURlZmluaXRpb25cIixcIk9wZXJhdGlvblR5cGVEZWZpbml0aW9uXCIsXCJJbnRlcmZhY2VUeXBlRGVmaW5pdGlvblwiLFwiVW5pb25UeXBlRGVmaW5pdGlvblwiLFwiU2NhbGFyVHlwZURlZmluaXRpb25cIl0pO2Z1bmN0aW9uIGcoZixoLE4pe2lmKCFoKXJldHVybiExO3N3aXRjaChmLnBhcnNlcil7Y2FzZVwiZmxvd1wiOmNhc2VcImJhYmVsXCI6Y2FzZVwiYmFiZWwtZmxvd1wiOmNhc2VcImJhYmVsLXRzXCI6Y2FzZVwidHlwZXNjcmlwdFwiOmNhc2VcImFjb3JuXCI6Y2FzZVwiZXNwcmVlXCI6Y2FzZVwibWVyaXlhaFwiOmNhc2VcIl9fYmFiZWxfZXN0cmVlXCI6cmV0dXJuIGwoaC50eXBlLE4mJk4udHlwZSk7Y2FzZVwianNvblwiOmNhc2VcImpzb241XCI6Y2FzZVwianNvbi1zdHJpbmdpZnlcIjpyZXR1cm4gQy5oYXMoaC50eXBlKTtjYXNlXCJncmFwaHFsXCI6cmV0dXJuIG0uaGFzKGgua2luZCk7Y2FzZVwidnVlXCI6cmV0dXJuIGgudGFnIT09XCJyb290XCJ9cmV0dXJuITF9ZnVuY3Rpb24gcChmLGgsTil7bGV0e3JhbmdlU3RhcnQ6VCxyYW5nZUVuZDpBLGxvY1N0YXJ0OmIsbG9jRW5kOnZ9PWg7dC5vayhBPlQpO2xldCBCPWYuc2xpY2UoVCxBKS5zZWFyY2goL1xcUy8pLHc9Qj09PS0xO2lmKCF3KWZvcihUKz1CO0E+VCYmIS9cXFMvLnRlc3QoZltBLTFdKTstLUEpO2xldCBJPWMoTixULGgsKHksbyk9PmcoaCx5LG8pLFtdLFwicmFuZ2VTdGFydFwiKSxFPXc/STpjKE4sQSxoLHk9PmcoaCx5KSxbXSxcInJhbmdlRW5kXCIpO2lmKCFJfHwhRSlyZXR1cm57cmFuZ2VTdGFydDowLHJhbmdlRW5kOjB9O2xldCBELGQ7aWYoaShoKSl7bGV0IHk9cihJLEUpO0Q9eSxkPXl9ZWxzZSh7c3RhcnROb2RlOkQsZW5kTm9kZTpkfT1hKEksRSxoKSk7cmV0dXJue3JhbmdlU3RhcnQ6TWF0aC5taW4oYihEKSxiKGQpKSxyYW5nZUVuZDpNYXRoLm1heCh2KEQpLHYoZCkpfX1uLmV4cG9ydHM9e2NhbGN1bGF0ZVJhbmdlOnAsZmluZE5vZGVBdE9mZnNldDpjfX19KSxvbT1aKHtcInNyYy9tYWluL2NvcmUuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2RpZmZBcnJheXM6dH09ckQoKSx7cHJpbnRlcjp7cHJpbnREb2NUb1N0cmluZzpzfSxkZWJ1Zzp7cHJpbnREb2NUb0RlYnVnOml9fT1MZSgpLHtnZXRBbGlnbm1lbnRTaXplOnJ9PUdlKCkse2d1ZXNzRW5kT2ZMaW5lOnUsY29udmVydEVuZE9mTGluZVRvQ2hhcnM6YSxjb3VudEVuZE9mTGluZUNoYXJzOmMsbm9ybWFsaXplRW5kT2ZMaW5lOmx9PU9uKCksQz1NaSgpLm5vcm1hbGl6ZSxtPW5tKCksZz1RZSgpLHA9R24oKSxmPWFtKCksaD1pbSgpLE49XCJcXHVGRUZGXCIsVD1TeW1ib2woXCJjdXJzb3JcIik7ZnVuY3Rpb24gQShkLHksbyl7bGV0IHg9eS5jb21tZW50cztyZXR1cm4geCYmKGRlbGV0ZSB5LmNvbW1lbnRzLGcuYXR0YWNoKHgseSxkLG8pKSxvW1N5bWJvbC5mb3IoXCJjb21tZW50c1wiKV09eHx8W10sb1tTeW1ib2wuZm9yKFwidG9rZW5zXCIpXT15LnRva2Vuc3x8W10sby5vcmlnaW5hbFRleHQ9ZCx4fWZ1bmN0aW9uIGIoZCx5KXtsZXQgbz1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06MDtpZighZHx8ZC50cmltKCkubGVuZ3RoPT09MClyZXR1cm57Zm9ybWF0dGVkOlwiXCIsY3Vyc29yT2Zmc2V0Oi0xLGNvbW1lbnRzOltdfTtsZXR7YXN0OngsdGV4dDpGfT1wLnBhcnNlKGQseSk7aWYoeS5jdXJzb3JPZmZzZXQ+PTApe2xldCBPPWguZmluZE5vZGVBdE9mZnNldCh4LHkuY3Vyc29yT2Zmc2V0LHkpO08mJk8ubm9kZSYmKHkuY3Vyc29yTm9kZT1PLm5vZGUpfWxldCBTPUEoRix4LHkpLGs9Zih4LHksbyksXz1zKGsseSk7aWYoZy5lbnN1cmVBbGxDb21tZW50c1ByaW50ZWQoUyksbz4wKXtsZXQgTz1fLmZvcm1hdHRlZC50cmltKCk7Xy5jdXJzb3JOb2RlU3RhcnQhPT12b2lkIDAmJihfLmN1cnNvck5vZGVTdGFydC09Xy5mb3JtYXR0ZWQuaW5kZXhPZihPKSksXy5mb3JtYXR0ZWQ9TythKHkuZW5kT2ZMaW5lKX1pZih5LmN1cnNvck9mZnNldD49MCl7bGV0IE8sUixNLEgsUDtpZih5LmN1cnNvck5vZGUmJl8uY3Vyc29yTm9kZVRleHQ/KE89eS5sb2NTdGFydCh5LmN1cnNvck5vZGUpLFI9Ri5zbGljZShPLHkubG9jRW5kKHkuY3Vyc29yTm9kZSkpLE09eS5jdXJzb3JPZmZzZXQtTyxIPV8uY3Vyc29yTm9kZVN0YXJ0LFA9Xy5jdXJzb3JOb2RlVGV4dCk6KE89MCxSPUYsTT15LmN1cnNvck9mZnNldCxIPTAsUD1fLmZvcm1hdHRlZCksUj09PVApcmV0dXJue2Zvcm1hdHRlZDpfLmZvcm1hdHRlZCxjdXJzb3JPZmZzZXQ6SCtNLGNvbW1lbnRzOlN9O2xldCBHPVsuLi5SXTtHLnNwbGljZShNLDAsVCk7bGV0IHJlPVsuLi5QXSwkPXQoRyxyZSksVz1IO2ZvcihsZXQgZWUgb2YgJClpZihlZS5yZW1vdmVkKXtpZihlZS52YWx1ZS5pbmNsdWRlcyhUKSlicmVha31lbHNlIFcrPWVlLmNvdW50O3JldHVybntmb3JtYXR0ZWQ6Xy5mb3JtYXR0ZWQsY3Vyc29yT2Zmc2V0OlcsY29tbWVudHM6U319cmV0dXJue2Zvcm1hdHRlZDpfLmZvcm1hdHRlZCxjdXJzb3JPZmZzZXQ6LTEsY29tbWVudHM6U319ZnVuY3Rpb24gdihkLHkpe2xldHthc3Q6byx0ZXh0Onh9PXAucGFyc2UoZCx5KSx7cmFuZ2VTdGFydDpGLHJhbmdlRW5kOlN9PWguY2FsY3VsYXRlUmFuZ2UoeCx5LG8pLGs9eC5zbGljZShGLFMpLF89TWF0aC5taW4oRix4Lmxhc3RJbmRleE9mKGBcbmAsRikrMSksTz14LnNsaWNlKF8sRikubWF0Y2goL15cXHMqLylbMF0sUj1yKE8seS50YWJXaWR0aCksTT1iKGssT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHkpLHt9LHtyYW5nZVN0YXJ0OjAscmFuZ2VFbmQ6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLGN1cnNvck9mZnNldDp5LmN1cnNvck9mZnNldD5GJiZ5LmN1cnNvck9mZnNldDw9Uz95LmN1cnNvck9mZnNldC1GOi0xLGVuZE9mTGluZTpcImxmXCJ9KSxSKSxIPU0uZm9ybWF0dGVkLnRyaW1FbmQoKSx7Y3Vyc29yT2Zmc2V0OlB9PXk7UD5TP1ArPUgubGVuZ3RoLWsubGVuZ3RoOk0uY3Vyc29yT2Zmc2V0Pj0wJiYoUD1NLmN1cnNvck9mZnNldCtGKTtsZXQgRz14LnNsaWNlKDAsRikrSCt4LnNsaWNlKFMpO2lmKHkuZW5kT2ZMaW5lIT09XCJsZlwiKXtsZXQgcmU9YSh5LmVuZE9mTGluZSk7UD49MCYmcmU9PT1gXFxyXG5gJiYoUCs9YyhHLnNsaWNlKDAsUCksYFxuYCkpLEc9Ry5yZXBsYWNlKC9cXG4vZyxyZSl9cmV0dXJue2Zvcm1hdHRlZDpHLGN1cnNvck9mZnNldDpQLGNvbW1lbnRzOk0uY29tbWVudHN9fWZ1bmN0aW9uIEIoZCx5LG8pe3JldHVybiB0eXBlb2YgeSE9XCJudW1iZXJcInx8TnVtYmVyLmlzTmFOKHkpfHx5PDB8fHk+ZC5sZW5ndGg/bzp5fWZ1bmN0aW9uIHcoZCx5KXtsZXR7Y3Vyc29yT2Zmc2V0Om8scmFuZ2VTdGFydDp4LHJhbmdlRW5kOkZ9PXk7cmV0dXJuIG89QihkLG8sLTEpLHg9QihkLHgsMCksRj1CKGQsRixkLmxlbmd0aCksT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHkpLHt9LHtjdXJzb3JPZmZzZXQ6byxyYW5nZVN0YXJ0OngscmFuZ2VFbmQ6Rn0pfWZ1bmN0aW9uIEkoZCx5KXtsZXR7Y3Vyc29yT2Zmc2V0Om8scmFuZ2VTdGFydDp4LHJhbmdlRW5kOkYsZW5kT2ZMaW5lOlN9PXcoZCx5KSxrPWQuY2hhckF0KDApPT09TjtpZihrJiYoZD1kLnNsaWNlKDEpLG8tLSx4LS0sRi0tKSxTPT09XCJhdXRvXCImJihTPXUoZCkpLGQuaW5jbHVkZXMoXCJcXHJcIikpe2xldCBfPU89PmMoZC5zbGljZSgwLE1hdGgubWF4KE8sMCkpLGBcXHJcbmApO28tPV8obykseC09Xyh4KSxGLT1fKEYpLGQ9bChkKX1yZXR1cm57aGFzQk9NOmssdGV4dDpkLG9wdGlvbnM6dyhkLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx5KSx7fSx7Y3Vyc29yT2Zmc2V0Om8scmFuZ2VTdGFydDp4LHJhbmdlRW5kOkYsZW5kT2ZMaW5lOlN9KSl9fWZ1bmN0aW9uIEUoZCx5KXtsZXQgbz1wLnJlc29sdmVQYXJzZXIoeSk7cmV0dXJuIW8uaGFzUHJhZ21hfHxvLmhhc1ByYWdtYShkKX1mdW5jdGlvbiBEKGQseSl7bGV0e2hhc0JPTTpvLHRleHQ6eCxvcHRpb25zOkZ9PUkoZCxDKHkpKTtpZihGLnJhbmdlU3RhcnQ+PUYucmFuZ2VFbmQmJnghPT1cIlwifHxGLnJlcXVpcmVQcmFnbWEmJiFFKHgsRikpcmV0dXJue2Zvcm1hdHRlZDpkLGN1cnNvck9mZnNldDp5LmN1cnNvck9mZnNldCxjb21tZW50czpbXX07bGV0IFM7cmV0dXJuIEYucmFuZ2VTdGFydD4wfHxGLnJhbmdlRW5kPHgubGVuZ3RoP1M9dih4LEYpOighRi5yZXF1aXJlUHJhZ21hJiZGLmluc2VydFByYWdtYSYmRi5wcmludGVyLmluc2VydFByYWdtYSYmIUUoeCxGKSYmKHg9Ri5wcmludGVyLmluc2VydFByYWdtYSh4KSksUz1iKHgsRikpLG8mJihTLmZvcm1hdHRlZD1OK1MuZm9ybWF0dGVkLFMuY3Vyc29yT2Zmc2V0Pj0wJiZTLmN1cnNvck9mZnNldCsrKSxTfW4uZXhwb3J0cz17Zm9ybWF0V2l0aEN1cnNvcjpELHBhcnNlKGQseSxvKXtsZXR7dGV4dDp4LG9wdGlvbnM6Rn09SShkLEMoeSkpLFM9cC5wYXJzZSh4LEYpO3JldHVybiBvJiYoUy5hc3Q9bShTLmFzdCxGKSksU30sZm9ybWF0QVNUKGQseSl7eT1DKHkpO2xldCBvPWYoZCx5KTtyZXR1cm4gcyhvLHkpfSxmb3JtYXREb2MoZCx5KXtyZXR1cm4gRChpKGQpLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx5KSx7fSx7cGFyc2VyOlwiX19qc19leHByZXNzaW9uXCJ9KSkuZm9ybWF0dGVkfSxwcmludFRvRG9jKGQseSl7eT1DKHkpO2xldHthc3Q6byx0ZXh0Onh9PXAucGFyc2UoZCx5KTtyZXR1cm4gQSh4LG8seSksZihvLHkpfSxwcmludERvY1RvU3RyaW5nKGQseSl7cmV0dXJuIHMoZCxDKHkpKX19fX0pLGNtPVooe1wic3JjL2NvbW1vbi91dGlsLXNoYXJlZC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7Z2V0TWF4Q29udGludW91c0NvdW50OnQsZ2V0U3RyaW5nV2lkdGg6cyxnZXRBbGlnbm1lbnRTaXplOmksZ2V0SW5kZW50U2l6ZTpyLHNraXA6dSxza2lwV2hpdGVzcGFjZTphLHNraXBTcGFjZXM6Yyxza2lwTmV3bGluZTpsLHNraXBUb0xpbmVFbmQ6Qyxza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmU6bSxza2lwSW5saW5lQ29tbWVudDpnLHNraXBUcmFpbGluZ0NvbW1lbnQ6cCxoYXNOZXdsaW5lOmYsaGFzTmV3bGluZUluUmFuZ2U6aCxoYXNTcGFjZXM6Tixpc05leHRMaW5lRW1wdHk6VCxpc05leHRMaW5lRW1wdHlBZnRlckluZGV4OkEsaXNQcmV2aW91c0xpbmVFbXB0eTpiLGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleDp2LG1ha2VTdHJpbmc6QixhZGRMZWFkaW5nQ29tbWVudDp3LGFkZERhbmdsaW5nQ29tbWVudDpJLGFkZFRyYWlsaW5nQ29tbWVudDpFfT1HZSgpO24uZXhwb3J0cz17Z2V0TWF4Q29udGludW91c0NvdW50OnQsZ2V0U3RyaW5nV2lkdGg6cyxnZXRBbGlnbm1lbnRTaXplOmksZ2V0SW5kZW50U2l6ZTpyLHNraXA6dSxza2lwV2hpdGVzcGFjZTphLHNraXBTcGFjZXM6Yyxza2lwTmV3bGluZTpsLHNraXBUb0xpbmVFbmQ6Qyxza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmU6bSxza2lwSW5saW5lQ29tbWVudDpnLHNraXBUcmFpbGluZ0NvbW1lbnQ6cCxoYXNOZXdsaW5lOmYsaGFzTmV3bGluZUluUmFuZ2U6aCxoYXNTcGFjZXM6Tixpc05leHRMaW5lRW1wdHk6VCxpc05leHRMaW5lRW1wdHlBZnRlckluZGV4OkEsaXNQcmV2aW91c0xpbmVFbXB0eTpiLGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleDp2LG1ha2VTdHJpbmc6QixhZGRMZWFkaW5nQ29tbWVudDp3LGFkZERhbmdsaW5nQ29tbWVudDpJLGFkZFRyYWlsaW5nQ29tbWVudDpFfX19KSxidD1aKHtcInNyYy91dGlscy9jcmVhdGUtbGFuZ3VhZ2UuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCksbi5leHBvcnRzPWZ1bmN0aW9uKHQscyl7bGV0e2xhbmd1YWdlSWQ6aX09dCxyPV9uKHQsS2YpO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe2xpbmd1aXN0TGFuZ3VhZ2VJZDppfSxyKSxzKHQpKX19fSksbG09Wih7XCJub2RlX21vZHVsZXMvZXN1dGlscy9saWIvYXN0LmpzXCIoZSxuKXthZSgpLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdChjKXtpZihjPT1udWxsKXJldHVybiExO3N3aXRjaChjLnR5cGUpe2Nhc2VcIkFycmF5RXhwcmVzc2lvblwiOmNhc2VcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6Y2FzZVwiQmluYXJ5RXhwcmVzc2lvblwiOmNhc2VcIkNhbGxFeHByZXNzaW9uXCI6Y2FzZVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6Y2FzZVwiRnVuY3Rpb25FeHByZXNzaW9uXCI6Y2FzZVwiSWRlbnRpZmllclwiOmNhc2VcIkxpdGVyYWxcIjpjYXNlXCJMb2dpY2FsRXhwcmVzc2lvblwiOmNhc2VcIk1lbWJlckV4cHJlc3Npb25cIjpjYXNlXCJOZXdFeHByZXNzaW9uXCI6Y2FzZVwiT2JqZWN0RXhwcmVzc2lvblwiOmNhc2VcIlNlcXVlbmNlRXhwcmVzc2lvblwiOmNhc2VcIlRoaXNFeHByZXNzaW9uXCI6Y2FzZVwiVW5hcnlFeHByZXNzaW9uXCI6Y2FzZVwiVXBkYXRlRXhwcmVzc2lvblwiOnJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIHMoYyl7aWYoYz09bnVsbClyZXR1cm4hMTtzd2l0Y2goYy50eXBlKXtjYXNlXCJEb1doaWxlU3RhdGVtZW50XCI6Y2FzZVwiRm9ySW5TdGF0ZW1lbnRcIjpjYXNlXCJGb3JTdGF0ZW1lbnRcIjpjYXNlXCJXaGlsZVN0YXRlbWVudFwiOnJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIGkoYyl7aWYoYz09bnVsbClyZXR1cm4hMTtzd2l0Y2goYy50eXBlKXtjYXNlXCJCbG9ja1N0YXRlbWVudFwiOmNhc2VcIkJyZWFrU3RhdGVtZW50XCI6Y2FzZVwiQ29udGludWVTdGF0ZW1lbnRcIjpjYXNlXCJEZWJ1Z2dlclN0YXRlbWVudFwiOmNhc2VcIkRvV2hpbGVTdGF0ZW1lbnRcIjpjYXNlXCJFbXB0eVN0YXRlbWVudFwiOmNhc2VcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpjYXNlXCJGb3JJblN0YXRlbWVudFwiOmNhc2VcIkZvclN0YXRlbWVudFwiOmNhc2VcIklmU3RhdGVtZW50XCI6Y2FzZVwiTGFiZWxlZFN0YXRlbWVudFwiOmNhc2VcIlJldHVyblN0YXRlbWVudFwiOmNhc2VcIlN3aXRjaFN0YXRlbWVudFwiOmNhc2VcIlRocm93U3RhdGVtZW50XCI6Y2FzZVwiVHJ5U3RhdGVtZW50XCI6Y2FzZVwiVmFyaWFibGVEZWNsYXJhdGlvblwiOmNhc2VcIldoaWxlU3RhdGVtZW50XCI6Y2FzZVwiV2l0aFN0YXRlbWVudFwiOnJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIHIoYyl7cmV0dXJuIGkoYyl8fGMhPW51bGwmJmMudHlwZT09PVwiRnVuY3Rpb25EZWNsYXJhdGlvblwifWZ1bmN0aW9uIHUoYyl7c3dpdGNoKGMudHlwZSl7Y2FzZVwiSWZTdGF0ZW1lbnRcIjpyZXR1cm4gYy5hbHRlcm5hdGUhPW51bGw/Yy5hbHRlcm5hdGU6Yy5jb25zZXF1ZW50O2Nhc2VcIkxhYmVsZWRTdGF0ZW1lbnRcIjpjYXNlXCJGb3JTdGF0ZW1lbnRcIjpjYXNlXCJGb3JJblN0YXRlbWVudFwiOmNhc2VcIldoaWxlU3RhdGVtZW50XCI6Y2FzZVwiV2l0aFN0YXRlbWVudFwiOnJldHVybiBjLmJvZHl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gYShjKXt2YXIgbDtpZihjLnR5cGUhPT1cIklmU3RhdGVtZW50XCJ8fGMuYWx0ZXJuYXRlPT1udWxsKXJldHVybiExO2w9Yy5jb25zZXF1ZW50O2Rve2lmKGwudHlwZT09PVwiSWZTdGF0ZW1lbnRcIiYmbC5hbHRlcm5hdGU9PW51bGwpcmV0dXJuITA7bD11KGwpfXdoaWxlKGwpO3JldHVybiExfW4uZXhwb3J0cz17aXNFeHByZXNzaW9uOnQsaXNTdGF0ZW1lbnQ6aSxpc0l0ZXJhdGlvblN0YXRlbWVudDpzLGlzU291cmNlRWxlbWVudDpyLGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudDphLHRyYWlsaW5nU3RhdGVtZW50OnV9fSgpfX0pLFJpPVooe1wibm9kZV9tb2R1bGVzL2VzdXRpbHMvbGliL2NvZGUuanNcIihlLG4pe2FlKCksZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdCxzLGkscix1LGE7cz17Tm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6L1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXS8sTm9uQXNjaWlJZGVudGlmaWVyUGFydDovW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA4RDQtXFx1MDhFMVxcdTA4RTMtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBBRjlcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4LVxcdTBDNUFcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgwLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTQtXFx1MEQ1N1xcdTBENUYtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQi1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRVxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNVxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10vfSx0PXtOb25Bc2NpaUlkZW50aWZpZXJTdGFydDovW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlCLVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRVxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0IwLVxcdURDRDNcXHVEQ0Q4LVxcdURDRkJcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDMDAtXFx1REMzNFxcdURDNDctXFx1REM0QVxcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM3Mi1cXHVEQzhGXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MFxcdURGOTMtXFx1REY5RlxcdURGRTBdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVERDAwLVxcdURENDNdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS8sTm9uQXNjaWlJZGVudGlmaWVyUGFydDovW1xceEFBXFx4QjVcXHhCN1xceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODYtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOEQ0LVxcdTA4RTFcXHUwOEUzLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQUY5XFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MC1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU0LVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzY5LVxcdTEzNzFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEQVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkItXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5LVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzVcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVEREZEXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REVFMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3QVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0EwLVxcdURDQTlcXHVEQ0IwLVxcdURDRDNcXHVEQ0Q4LVxcdURDRkJcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDAtXFx1REM0NlxcdURDNjYtXFx1REM2RlxcdURDN0YtXFx1RENCQVxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQzRlxcdURENTAtXFx1REQ3M1xcdURENzZcXHVERDgwLVxcdUREQzRcXHVERENBLVxcdUREQ0NcXHVEREQwLVxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTM3XFx1REUzRVxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjlcXHVERjAwLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzQy1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjUwXFx1REY1N1xcdURGNUQtXFx1REY2M1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzAwLVxcdURDNEFcXHVEQzUwLVxcdURDNTlcXHVEQzgwLVxcdURDQzVcXHVEQ0M3XFx1RENEMC1cXHVEQ0Q5XFx1REQ4MC1cXHVEREI1XFx1RERCOC1cXHVEREMwXFx1REREOC1cXHVEREREXFx1REUwMC1cXHVERTQwXFx1REU0NFxcdURFNTAtXFx1REU1OVxcdURFODAtXFx1REVCN1xcdURFQzAtXFx1REVDOVxcdURGMDAtXFx1REYxOVxcdURGMUQtXFx1REYyQlxcdURGMzAtXFx1REYzOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDRTlcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMzNlxcdURDMzgtXFx1REM0MFxcdURDNTAtXFx1REM1OVxcdURDNzItXFx1REM4RlxcdURDOTItXFx1RENBN1xcdURDQTktXFx1RENCNl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REVEMC1cXHVERUVEXFx1REVGMC1cXHVERUY0XFx1REYwMC1cXHVERjM2XFx1REY0MC1cXHVERjQzXFx1REY1MC1cXHVERjU5XFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTAtXFx1REY3RVxcdURGOEYtXFx1REY5RlxcdURGRTBdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1LVxcdURENjlcXHVERDZELVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQV18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVEQ0QwLVxcdURDRDZcXHVERDAwLVxcdURENEFcXHVERDUwLVxcdURENTldfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0vfTtmdW5jdGlvbiBjKEEpe3JldHVybiA0ODw9QSYmQTw9NTd9ZnVuY3Rpb24gbChBKXtyZXR1cm4gNDg8PUEmJkE8PTU3fHw5Nzw9QSYmQTw9MTAyfHw2NTw9QSYmQTw9NzB9ZnVuY3Rpb24gQyhBKXtyZXR1cm4gQT49NDgmJkE8PTU1fWk9WzU3NjAsODE5Miw4MTkzLDgxOTQsODE5NSw4MTk2LDgxOTcsODE5OCw4MTk5LDgyMDAsODIwMSw4MjAyLDgyMzksODI4NywxMjI4OCw2NTI3OV07ZnVuY3Rpb24gbShBKXtyZXR1cm4gQT09PTMyfHxBPT09OXx8QT09PTExfHxBPT09MTJ8fEE9PT0xNjB8fEE+PTU3NjAmJmkuaW5kZXhPZihBKT49MH1mdW5jdGlvbiBnKEEpe3JldHVybiBBPT09MTB8fEE9PT0xM3x8QT09PTgyMzJ8fEE9PT04MjMzfWZ1bmN0aW9uIHAoQSl7aWYoQTw9NjU1MzUpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQSk7dmFyIGI9U3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLmZsb29yKChBLTY1NTM2KS8xMDI0KSs1NTI5Niksdj1TdHJpbmcuZnJvbUNoYXJDb2RlKChBLTY1NTM2KSUxMDI0KzU2MzIwKTtyZXR1cm4gYit2fWZvcihyPW5ldyBBcnJheSgxMjgpLGE9MDthPDEyODsrK2EpclthXT1hPj05NyYmYTw9MTIyfHxhPj02NSYmYTw9OTB8fGE9PT0zNnx8YT09PTk1O2Zvcih1PW5ldyBBcnJheSgxMjgpLGE9MDthPDEyODsrK2EpdVthXT1hPj05NyYmYTw9MTIyfHxhPj02NSYmYTw9OTB8fGE+PTQ4JiZhPD01N3x8YT09PTM2fHxhPT09OTU7ZnVuY3Rpb24gZihBKXtyZXR1cm4gQTwxMjg/cltBXTpzLk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QocChBKSl9ZnVuY3Rpb24gaChBKXtyZXR1cm4gQTwxMjg/dVtBXTpzLk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChwKEEpKX1mdW5jdGlvbiBOKEEpe3JldHVybiBBPDEyOD9yW0FdOnQuTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChwKEEpKX1mdW5jdGlvbiBUKEEpe3JldHVybiBBPDEyOD91W0FdOnQuTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KHAoQSkpfW4uZXhwb3J0cz17aXNEZWNpbWFsRGlnaXQ6Yyxpc0hleERpZ2l0OmwsaXNPY3RhbERpZ2l0OkMsaXNXaGl0ZVNwYWNlOm0saXNMaW5lVGVybWluYXRvcjpnLGlzSWRlbnRpZmllclN0YXJ0RVM1OmYsaXNJZGVudGlmaWVyUGFydEVTNTpoLGlzSWRlbnRpZmllclN0YXJ0RVM2Ok4saXNJZGVudGlmaWVyUGFydEVTNjpUfX0oKX19KSxwbT1aKHtcIm5vZGVfbW9kdWxlcy9lc3V0aWxzL2xpYi9rZXl3b3JkLmpzXCIoZSxuKXthZSgpLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9UmkoKTtmdW5jdGlvbiBzKGYpe3N3aXRjaChmKXtjYXNlXCJpbXBsZW1lbnRzXCI6Y2FzZVwiaW50ZXJmYWNlXCI6Y2FzZVwicGFja2FnZVwiOmNhc2VcInByaXZhdGVcIjpjYXNlXCJwcm90ZWN0ZWRcIjpjYXNlXCJwdWJsaWNcIjpjYXNlXCJzdGF0aWNcIjpjYXNlXCJsZXRcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBpKGYsaCl7cmV0dXJuIWgmJmY9PT1cInlpZWxkXCI/ITE6cihmLGgpfWZ1bmN0aW9uIHIoZixoKXtpZihoJiZzKGYpKXJldHVybiEwO3N3aXRjaChmLmxlbmd0aCl7Y2FzZSAyOnJldHVybiBmPT09XCJpZlwifHxmPT09XCJpblwifHxmPT09XCJkb1wiO2Nhc2UgMzpyZXR1cm4gZj09PVwidmFyXCJ8fGY9PT1cImZvclwifHxmPT09XCJuZXdcInx8Zj09PVwidHJ5XCI7Y2FzZSA0OnJldHVybiBmPT09XCJ0aGlzXCJ8fGY9PT1cImVsc2VcInx8Zj09PVwiY2FzZVwifHxmPT09XCJ2b2lkXCJ8fGY9PT1cIndpdGhcInx8Zj09PVwiZW51bVwiO2Nhc2UgNTpyZXR1cm4gZj09PVwid2hpbGVcInx8Zj09PVwiYnJlYWtcInx8Zj09PVwiY2F0Y2hcInx8Zj09PVwidGhyb3dcInx8Zj09PVwiY29uc3RcInx8Zj09PVwieWllbGRcInx8Zj09PVwiY2xhc3NcInx8Zj09PVwic3VwZXJcIjtjYXNlIDY6cmV0dXJuIGY9PT1cInJldHVyblwifHxmPT09XCJ0eXBlb2ZcInx8Zj09PVwiZGVsZXRlXCJ8fGY9PT1cInN3aXRjaFwifHxmPT09XCJleHBvcnRcInx8Zj09PVwiaW1wb3J0XCI7Y2FzZSA3OnJldHVybiBmPT09XCJkZWZhdWx0XCJ8fGY9PT1cImZpbmFsbHlcInx8Zj09PVwiZXh0ZW5kc1wiO2Nhc2UgODpyZXR1cm4gZj09PVwiZnVuY3Rpb25cInx8Zj09PVwiY29udGludWVcInx8Zj09PVwiZGVidWdnZXJcIjtjYXNlIDEwOnJldHVybiBmPT09XCJpbnN0YW5jZW9mXCI7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gdShmLGgpe3JldHVybiBmPT09XCJudWxsXCJ8fGY9PT1cInRydWVcInx8Zj09PVwiZmFsc2VcInx8aShmLGgpfWZ1bmN0aW9uIGEoZixoKXtyZXR1cm4gZj09PVwibnVsbFwifHxmPT09XCJ0cnVlXCJ8fGY9PT1cImZhbHNlXCJ8fHIoZixoKX1mdW5jdGlvbiBjKGYpe3JldHVybiBmPT09XCJldmFsXCJ8fGY9PT1cImFyZ3VtZW50c1wifWZ1bmN0aW9uIGwoZil7dmFyIGgsTixUO2lmKGYubGVuZ3RoPT09MHx8KFQ9Zi5jaGFyQ29kZUF0KDApLCF0LmlzSWRlbnRpZmllclN0YXJ0RVM1KFQpKSlyZXR1cm4hMTtmb3IoaD0xLE49Zi5sZW5ndGg7aDxOOysraClpZihUPWYuY2hhckNvZGVBdChoKSwhdC5pc0lkZW50aWZpZXJQYXJ0RVM1KFQpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIEMoZixoKXtyZXR1cm4oZi01NTI5NikqMTAyNCsoaC01NjMyMCkrNjU1MzZ9ZnVuY3Rpb24gbShmKXt2YXIgaCxOLFQsQSxiO2lmKGYubGVuZ3RoPT09MClyZXR1cm4hMTtmb3IoYj10LmlzSWRlbnRpZmllclN0YXJ0RVM2LGg9MCxOPWYubGVuZ3RoO2g8TjsrK2gpe2lmKFQ9Zi5jaGFyQ29kZUF0KGgpLDU1Mjk2PD1UJiZUPD01NjMxOSl7aWYoKytoLGg+PU58fChBPWYuY2hhckNvZGVBdChoKSwhKDU2MzIwPD1BJiZBPD01NzM0MykpKXJldHVybiExO1Q9QyhULEEpfWlmKCFiKFQpKXJldHVybiExO2I9dC5pc0lkZW50aWZpZXJQYXJ0RVM2fXJldHVybiEwfWZ1bmN0aW9uIGcoZixoKXtyZXR1cm4gbChmKSYmIXUoZixoKX1mdW5jdGlvbiBwKGYsaCl7cmV0dXJuIG0oZikmJiFhKGYsaCl9bi5leHBvcnRzPXtpc0tleXdvcmRFUzU6aSxpc0tleXdvcmRFUzY6cixpc1Jlc2VydmVkV29yZEVTNTp1LGlzUmVzZXJ2ZWRXb3JkRVM2OmEsaXNSZXN0cmljdGVkV29yZDpjLGlzSWRlbnRpZmllck5hbWVFUzU6bCxpc0lkZW50aWZpZXJOYW1lRVM2Om0saXNJZGVudGlmaWVyRVM1OmcsaXNJZGVudGlmaWVyRVM2OnB9fSgpfX0pLGZtPVooe1wibm9kZV9tb2R1bGVzL2VzdXRpbHMvbGliL3V0aWxzLmpzXCIoZSl7YWUoKSxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2UuYXN0PWxtKCksZS5jb2RlPVJpKCksZS5rZXl3b3JkPXBtKCl9KCl9fSksUHQ9Wih7XCJzcmMvbGFuZ3VhZ2UtanMvdXRpbHMvaXMtYmxvY2stY29tbWVudC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KHMpe3JldHVybiBzLnR5cGU9PT1cIkJsb2NrXCJ8fHMudHlwZT09PVwiQ29tbWVudEJsb2NrXCJ8fHMudHlwZT09PVwiTXVsdGlMaW5lXCJ9bi5leHBvcnRzPXR9fSksWGU9Wih7XCJzcmMvbGFuZ3VhZ2UtanMvdXRpbHMvaW5kZXguanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9Zm0oKS5rZXl3b3JkLmlzSWRlbnRpZmllck5hbWVFUzUse2dldExhc3Q6cyxoYXNOZXdsaW5lOmksc2tpcFdoaXRlc3BhY2U6cixpc05vbkVtcHR5QXJyYXk6dSxpc05leHRMaW5lRW1wdHlBZnRlckluZGV4OmEsZ2V0U3RyaW5nV2lkdGg6Y309R2UoKSx7bG9jU3RhcnQ6bCxsb2NFbmQ6QyxoYXNTYW1lTG9jU3RhcnQ6bX09bnQoKSxnPVB0KCkscD1cIig/Oig/PS4pXFxcXHMpXCIsZj1uZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChwLFwiKjpcIikpLGg9bmV3IFJlZ0V4cChcIl5cIi5jb25jYXQocCxcIio6OlwiKSk7ZnVuY3Rpb24gTihMKXtyZXR1cm4gTC5leHRyYSYmTC5leHRyYS5wYXJlbnRoZXNpemVkJiZ1KEwudHJhaWxpbmdDb21tZW50cykmJmcoTC50cmFpbGluZ0NvbW1lbnRzWzBdKSYmZi50ZXN0KEwudHJhaWxpbmdDb21tZW50c1swXS52YWx1ZSl9ZnVuY3Rpb24gVChMKXtyZXR1cm4gdShMKSYmZyhMWzBdKSYmaC50ZXN0KExbMF0udmFsdWUpfWZ1bmN0aW9uIEEoTCxEZSl7aWYoIUx8fHR5cGVvZiBMIT1cIm9iamVjdFwiKXJldHVybiExO2lmKEFycmF5LmlzQXJyYXkoTCkpcmV0dXJuIEwuc29tZShXZT0+QShXZSxEZSkpO2xldCBrZT1EZShMKTtyZXR1cm4gdHlwZW9mIGtlPT1cImJvb2xlYW5cIj9rZTpPYmplY3QudmFsdWVzKEwpLnNvbWUoV2U9PkEoV2UsRGUpKX1mdW5jdGlvbiBiKEwpe3JldHVybiBMLnR5cGU9PT1cIkFzc2lnbm1lbnRFeHByZXNzaW9uXCJ8fEwudHlwZT09PVwiQmluYXJ5RXhwcmVzc2lvblwifHxMLnR5cGU9PT1cIkxvZ2ljYWxFeHByZXNzaW9uXCJ8fEwudHlwZT09PVwiTkdQaXBlRXhwcmVzc2lvblwifHxMLnR5cGU9PT1cIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwifHxFZShMKXx8cShMKXx8TC50eXBlPT09XCJTZXF1ZW5jZUV4cHJlc3Npb25cInx8TC50eXBlPT09XCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cInx8TC50eXBlPT09XCJCaW5kRXhwcmVzc2lvblwifHxMLnR5cGU9PT1cIlVwZGF0ZUV4cHJlc3Npb25cIiYmIUwucHJlZml4fHxMLnR5cGU9PT1cIlRTQXNFeHByZXNzaW9uXCJ8fEwudHlwZT09PVwiVFNOb25OdWxsRXhwcmVzc2lvblwifWZ1bmN0aW9uIHYoTCl7cmV0dXJuIEwuZXhwcmVzc2lvbnM/TC5leHByZXNzaW9uc1swXTpMLmxlZnR8fEwudGVzdHx8TC5jYWxsZWV8fEwub2JqZWN0fHxMLnRhZ3x8TC5hcmd1bWVudHx8TC5leHByZXNzaW9ufWZ1bmN0aW9uIEIoTCxEZSl7aWYoRGUuZXhwcmVzc2lvbnMpcmV0dXJuW1wiZXhwcmVzc2lvbnNcIiwwXTtpZihEZS5sZWZ0KXJldHVybltcImxlZnRcIl07aWYoRGUudGVzdClyZXR1cm5bXCJ0ZXN0XCJdO2lmKERlLm9iamVjdClyZXR1cm5bXCJvYmplY3RcIl07aWYoRGUuY2FsbGVlKXJldHVybltcImNhbGxlZVwiXTtpZihEZS50YWcpcmV0dXJuW1widGFnXCJdO2lmKERlLmFyZ3VtZW50KXJldHVybltcImFyZ3VtZW50XCJdO2lmKERlLmV4cHJlc3Npb24pcmV0dXJuW1wiZXhwcmVzc2lvblwiXTt0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgaGFzIG5vIGxlZnQgc2lkZS5cIil9ZnVuY3Rpb24gdyhMKXtyZXR1cm4gTC50eXBlPT09XCJMaW5lXCJ8fEwudHlwZT09PVwiQ29tbWVudExpbmVcInx8TC50eXBlPT09XCJTaW5nbGVMaW5lXCJ8fEwudHlwZT09PVwiSGFzaGJhbmdDb21tZW50XCJ8fEwudHlwZT09PVwiSFRNTE9wZW5cInx8TC50eXBlPT09XCJIVE1MQ2xvc2VcIn12YXIgST1uZXcgU2V0KFtcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiLFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIsXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIsXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiXSk7ZnVuY3Rpb24gRShMKXtyZXR1cm4gTCYmSS5oYXMoTC50eXBlKX1mdW5jdGlvbiBEKEwpe2xldCBEZT1MLmdldFBhcmVudE5vZGUoKTtyZXR1cm4gTC5nZXROYW1lKCk9PT1cImRlY2xhcmF0aW9uXCImJkUoRGUpP0RlOm51bGx9ZnVuY3Rpb24gZChMKXtyZXR1cm4gTC50eXBlPT09XCJCb29sZWFuTGl0ZXJhbFwifHxMLnR5cGU9PT1cIkRpcmVjdGl2ZUxpdGVyYWxcInx8TC50eXBlPT09XCJMaXRlcmFsXCJ8fEwudHlwZT09PVwiTnVsbExpdGVyYWxcInx8TC50eXBlPT09XCJOdW1lcmljTGl0ZXJhbFwifHxMLnR5cGU9PT1cIkJpZ0ludExpdGVyYWxcInx8TC50eXBlPT09XCJEZWNpbWFsTGl0ZXJhbFwifHxMLnR5cGU9PT1cIlJlZ0V4cExpdGVyYWxcInx8TC50eXBlPT09XCJTdHJpbmdMaXRlcmFsXCJ8fEwudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCJ8fEwudHlwZT09PVwiVFNUeXBlTGl0ZXJhbFwifHxMLnR5cGU9PT1cIkpTWFRleHRcIn1mdW5jdGlvbiB5KEwpe3JldHVybiBMLnR5cGU9PT1cIk51bWVyaWNMaXRlcmFsXCJ8fEwudHlwZT09PVwiTGl0ZXJhbFwiJiZ0eXBlb2YgTC52YWx1ZT09XCJudW1iZXJcIn1mdW5jdGlvbiBvKEwpe3JldHVybiBMLnR5cGU9PT1cIlVuYXJ5RXhwcmVzc2lvblwiJiYoTC5vcGVyYXRvcj09PVwiK1wifHxMLm9wZXJhdG9yPT09XCItXCIpJiZ5KEwuYXJndW1lbnQpfWZ1bmN0aW9uIHgoTCl7cmV0dXJuIEwudHlwZT09PVwiU3RyaW5nTGl0ZXJhbFwifHxMLnR5cGU9PT1cIkxpdGVyYWxcIiYmdHlwZW9mIEwudmFsdWU9PVwic3RyaW5nXCJ9ZnVuY3Rpb24gRihMKXtyZXR1cm4gTC50eXBlPT09XCJPYmplY3RUeXBlQW5ub3RhdGlvblwifHxMLnR5cGU9PT1cIlRTVHlwZUxpdGVyYWxcInx8TC50eXBlPT09XCJUU01hcHBlZFR5cGVcIn1mdW5jdGlvbiBTKEwpe3JldHVybiBMLnR5cGU9PT1cIkZ1bmN0aW9uRXhwcmVzc2lvblwifHxMLnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCJ9ZnVuY3Rpb24gayhMKXtyZXR1cm4gTC50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cInx8TC50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiJiZMLmJvZHkudHlwZT09PVwiQmxvY2tTdGF0ZW1lbnRcIn1mdW5jdGlvbiBfKEwpe3JldHVybiBMLnR5cGU9PT1cIlRlbXBsYXRlTGl0ZXJhbFwifWZ1bmN0aW9uIE8oTCl7cmV0dXJuIEVlKEwpJiZMLmNhbGxlZS50eXBlPT09XCJJZGVudGlmaWVyXCImJltcImFzeW5jXCIsXCJpbmplY3RcIixcImZha2VBc3luY1wiLFwid2FpdEZvckFzeW5jXCJdLmluY2x1ZGVzKEwuY2FsbGVlLm5hbWUpfWZ1bmN0aW9uIFIoTCl7cmV0dXJuIEwudHlwZT09PVwiSlNYRWxlbWVudFwifHxMLnR5cGU9PT1cIkpTWEZyYWdtZW50XCJ9ZnVuY3Rpb24gTShMLERlKXtpZihMLnBhcmVudFBhcnNlciE9PVwibWFya2Rvd25cIiYmTC5wYXJlbnRQYXJzZXIhPT1cIm1keFwiKXJldHVybiExO2xldCBrZT1EZS5nZXROb2RlKCk7aWYoIWtlLmV4cHJlc3Npb258fCFSKGtlLmV4cHJlc3Npb24pKXJldHVybiExO2xldCBXZT1EZS5nZXRQYXJlbnROb2RlKCk7cmV0dXJuIFdlLnR5cGU9PT1cIlByb2dyYW1cIiYmV2UuYm9keS5sZW5ndGg9PT0xfWZ1bmN0aW9uIEgoTCl7cmV0dXJuIEwua2luZD09PVwiZ2V0XCJ8fEwua2luZD09PVwic2V0XCJ9ZnVuY3Rpb24gUChMKXtyZXR1cm4gSChMKXx8bShMLEwudmFsdWUpfWZ1bmN0aW9uIEcoTCl7cmV0dXJuKEwudHlwZT09PVwiT2JqZWN0VHlwZVByb3BlcnR5XCJ8fEwudHlwZT09PVwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiKSYmTC52YWx1ZS50eXBlPT09XCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCImJiFMLnN0YXRpYyYmIVAoTCl9ZnVuY3Rpb24gcmUoTCl7cmV0dXJuKEwudHlwZT09PVwiVHlwZUFubm90YXRpb25cInx8TC50eXBlPT09XCJUU1R5cGVBbm5vdGF0aW9uXCIpJiZMLnR5cGVBbm5vdGF0aW9uLnR5cGU9PT1cIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiYmIUwuc3RhdGljJiYhbShMLEwudHlwZUFubm90YXRpb24pfXZhciAkPW5ldyBTZXQoW1wiQmluYXJ5RXhwcmVzc2lvblwiLFwiTG9naWNhbEV4cHJlc3Npb25cIixcIk5HUGlwZUV4cHJlc3Npb25cIl0pO2Z1bmN0aW9uIFcoTCl7cmV0dXJuICQuaGFzKEwudHlwZSl9ZnVuY3Rpb24gZWUoTCl7cmV0dXJuIHEoTCl8fEwudHlwZT09PVwiQmluZEV4cHJlc3Npb25cIiYmQm9vbGVhbihMLm9iamVjdCl9dmFyIFU9bmV3IFNldChbXCJBbnlUeXBlQW5ub3RhdGlvblwiLFwiVFNBbnlLZXl3b3JkXCIsXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsXCJUU051bGxLZXl3b3JkXCIsXCJUaGlzVHlwZUFubm90YXRpb25cIixcIlRTVGhpc1R5cGVcIixcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIsXCJUU051bWJlcktleXdvcmRcIixcIlZvaWRUeXBlQW5ub3RhdGlvblwiLFwiVFNWb2lkS2V5d29yZFwiLFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIsXCJUU0Jvb2xlYW5LZXl3b3JkXCIsXCJCaWdJbnRUeXBlQW5ub3RhdGlvblwiLFwiVFNCaWdJbnRLZXl3b3JkXCIsXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiLFwiVFNTeW1ib2xLZXl3b3JkXCIsXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiLFwiVFNTdHJpbmdLZXl3b3JkXCIsXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIixcIkJpZ0ludExpdGVyYWxUeXBlQW5ub3RhdGlvblwiLFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsXCJUU0xpdGVyYWxUeXBlXCIsXCJUU1RlbXBsYXRlTGl0ZXJhbFR5cGVcIixcIkVtcHR5VHlwZUFubm90YXRpb25cIixcIk1peGVkVHlwZUFubm90YXRpb25cIixcIlRTTmV2ZXJLZXl3b3JkXCIsXCJUU09iamVjdEtleXdvcmRcIixcIlRTVW5kZWZpbmVkS2V5d29yZFwiLFwiVFNVbmtub3duS2V5d29yZFwiXSk7ZnVuY3Rpb24gbmUoTCl7cmV0dXJuIEw/ISEoKEwudHlwZT09PVwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCJ8fEwudHlwZT09PVwiVFNUeXBlUmVmZXJlbmNlXCIpJiYhTC50eXBlUGFyYW1ldGVyc3x8VS5oYXMoTC50eXBlKSk6ITF9dmFyIHNlPS9eKD86c2tpcHxbZnhdPyg/Oml0fGRlc2NyaWJlfHRlc3QpKSQvO2Z1bmN0aW9uIFYoTCl7cmV0dXJuIHEoTC5jYWxsZWUpJiZMLmNhbGxlZS5vYmplY3QudHlwZT09PVwiSWRlbnRpZmllclwiJiZMLmNhbGxlZS5wcm9wZXJ0eS50eXBlPT09XCJJZGVudGlmaWVyXCImJnNlLnRlc3QoTC5jYWxsZWUub2JqZWN0Lm5hbWUpJiYoTC5jYWxsZWUucHJvcGVydHkubmFtZT09PVwib25seVwifHxMLmNhbGxlZS5wcm9wZXJ0eS5uYW1lPT09XCJza2lwXCIpfWZ1bmN0aW9uIG9lKEwpe2xldCBEZT0vXig/OmJlZm9yZXxhZnRlcikoPzpFYWNofEFsbCkkLztyZXR1cm4gTC5jYWxsZWUudHlwZT09PVwiSWRlbnRpZmllclwiJiZEZS50ZXN0KEwuY2FsbGVlLm5hbWUpJiZMLmFyZ3VtZW50cy5sZW5ndGg9PT0xfWZ1bmN0aW9uIEsoTCxEZSl7aWYoTC50eXBlIT09XCJDYWxsRXhwcmVzc2lvblwiKXJldHVybiExO2lmKEwuYXJndW1lbnRzLmxlbmd0aD09PTEpe2lmKE8oTCkmJkRlJiZLKERlKSlyZXR1cm4gUyhMLmFyZ3VtZW50c1swXSk7aWYob2UoTCkpcmV0dXJuIE8oTC5hcmd1bWVudHNbMF0pfWVsc2UgaWYoKEwuYXJndW1lbnRzLmxlbmd0aD09PTJ8fEwuYXJndW1lbnRzLmxlbmd0aD09PTMpJiYoTC5jYWxsZWUudHlwZT09PVwiSWRlbnRpZmllclwiJiZzZS50ZXN0KEwuY2FsbGVlLm5hbWUpfHxWKEwpKSYmKF8oTC5hcmd1bWVudHNbMF0pfHx4KEwuYXJndW1lbnRzWzBdKSkpcmV0dXJuIEwuYXJndW1lbnRzWzJdJiYheShMLmFyZ3VtZW50c1syXSk/ITE6KEwuYXJndW1lbnRzLmxlbmd0aD09PTI/UyhMLmFyZ3VtZW50c1sxXSk6ayhMLmFyZ3VtZW50c1sxXSkmJktlKEwuYXJndW1lbnRzWzFdKS5sZW5ndGg8PTEpfHxPKEwuYXJndW1lbnRzWzFdKTtyZXR1cm4hMX1mdW5jdGlvbiBFZShMKXtyZXR1cm4gTCYmKEwudHlwZT09PVwiQ2FsbEV4cHJlc3Npb25cInx8TC50eXBlPT09XCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpfWZ1bmN0aW9uIHEoTCl7cmV0dXJuIEwmJihMLnR5cGU9PT1cIk1lbWJlckV4cHJlc3Npb25cInx8TC50eXBlPT09XCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIil9ZnVuY3Rpb24gbGUoTCl7bGV0IERlPVwiZXhwcmVzc2lvbnNcIjtMLnR5cGU9PT1cIlRTVGVtcGxhdGVMaXRlcmFsVHlwZVwiJiYoRGU9XCJ0eXBlc1wiKTtsZXQga2U9TFtEZV07cmV0dXJuIGtlLmxlbmd0aD09PTA/ITE6a2UuZXZlcnkoV2U9PntpZihNZShXZSkpcmV0dXJuITE7aWYoV2UudHlwZT09PVwiSWRlbnRpZmllclwifHxXZS50eXBlPT09XCJUaGlzRXhwcmVzc2lvblwiKXJldHVybiEwO2lmKHEoV2UpKXtsZXQgJGU9V2U7Zm9yKDtxKCRlKTspaWYoJGUucHJvcGVydHkudHlwZSE9PVwiSWRlbnRpZmllclwiJiYkZS5wcm9wZXJ0eS50eXBlIT09XCJMaXRlcmFsXCImJiRlLnByb3BlcnR5LnR5cGUhPT1cIlN0cmluZ0xpdGVyYWxcIiYmJGUucHJvcGVydHkudHlwZSE9PVwiTnVtZXJpY0xpdGVyYWxcInx8KCRlPSRlLm9iamVjdCxNZSgkZSkpKXJldHVybiExO3JldHVybiAkZS50eXBlPT09XCJJZGVudGlmaWVyXCJ8fCRlLnR5cGU9PT1cIlRoaXNFeHByZXNzaW9uXCJ9cmV0dXJuITF9KX1mdW5jdGlvbiB1ZShMLERlKXtyZXR1cm4gTD09PVwiK1wiP1wiK1wiK0RlOkw9PT1cIi1cIj9cIi1cIitEZTpEZX1mdW5jdGlvbiBRKEwsRGUpe2xldCBrZT1sKERlKSxXZT1yKEwsQyhEZSkpO3JldHVybiBXZSE9PSExJiZMLnNsaWNlKGtlLGtlKzIpPT09XCIvKlwiJiZMLnNsaWNlKFdlLFdlKzIpPT09XCIqL1wifWZ1bmN0aW9uIGRlKEwsRGUpe3JldHVybiBSKERlKT9BZShEZSk6TWUoRGUsUGUuTGVhZGluZyxrZT0+aShMLEMoa2UpKSl9ZnVuY3Rpb24gZ2UoTCxEZSl7cmV0dXJuIERlLnBhcnNlciE9PVwianNvblwiJiZ4KEwua2V5KSYmSihMLmtleSkuc2xpY2UoMSwtMSk9PT1MLmtleS52YWx1ZSYmKHQoTC5rZXkudmFsdWUpJiYhKERlLnBhcnNlcj09PVwiYmFiZWwtdHNcIiYmTC50eXBlPT09XCJDbGFzc1Byb3BlcnR5XCJ8fERlLnBhcnNlcj09PVwidHlwZXNjcmlwdFwiJiZMLnR5cGU9PT1cIlByb3BlcnR5RGVmaW5pdGlvblwiKXx8dmUoTC5rZXkudmFsdWUpJiZTdHJpbmcoTnVtYmVyKEwua2V5LnZhbHVlKSk9PT1MLmtleS52YWx1ZSYmKERlLnBhcnNlcj09PVwiYmFiZWxcInx8RGUucGFyc2VyPT09XCJhY29yblwifHxEZS5wYXJzZXI9PT1cImVzcHJlZVwifHxEZS5wYXJzZXI9PT1cIm1lcml5YWhcInx8RGUucGFyc2VyPT09XCJfX2JhYmVsX2VzdHJlZVwiKSl9ZnVuY3Rpb24gdmUoTCl7cmV0dXJuL14oPzpcXGQrfFxcZCtcXC5cXGQrKSQvLnRlc3QoTCl9ZnVuY3Rpb24geGUoTCxEZSl7bGV0IGtlPS9eW2Z4XT8oPzpkZXNjcmliZXxpdHx0ZXN0KSQvO3JldHVybiBEZS50eXBlPT09XCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiYmRGUucXVhc2k9PT1MJiZEZS50YWcudHlwZT09PVwiTWVtYmVyRXhwcmVzc2lvblwiJiZEZS50YWcucHJvcGVydHkudHlwZT09PVwiSWRlbnRpZmllclwiJiZEZS50YWcucHJvcGVydHkubmFtZT09PVwiZWFjaFwiJiYoRGUudGFnLm9iamVjdC50eXBlPT09XCJJZGVudGlmaWVyXCImJmtlLnRlc3QoRGUudGFnLm9iamVjdC5uYW1lKXx8RGUudGFnLm9iamVjdC50eXBlPT09XCJNZW1iZXJFeHByZXNzaW9uXCImJkRlLnRhZy5vYmplY3QucHJvcGVydHkudHlwZT09PVwiSWRlbnRpZmllclwiJiYoRGUudGFnLm9iamVjdC5wcm9wZXJ0eS5uYW1lPT09XCJvbmx5XCJ8fERlLnRhZy5vYmplY3QucHJvcGVydHkubmFtZT09PVwic2tpcFwiKSYmRGUudGFnLm9iamVjdC5vYmplY3QudHlwZT09PVwiSWRlbnRpZmllclwiJiZrZS50ZXN0KERlLnRhZy5vYmplY3Qub2JqZWN0Lm5hbWUpKX1mdW5jdGlvbiB3ZShMKXtyZXR1cm4gTC5xdWFzaXMuc29tZShEZT0+RGUudmFsdWUucmF3LmluY2x1ZGVzKGBcbmApKX1mdW5jdGlvbiBmZShMLERlKXtyZXR1cm4oTC50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcIiYmd2UoTCl8fEwudHlwZT09PVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCImJndlKEwucXVhc2kpKSYmIWkoRGUsbChMKSx7YmFja3dhcmRzOiEwfSl9ZnVuY3Rpb24gcGUoTCl7aWYoIU1lKEwpKXJldHVybiExO2xldCBEZT1zKHFlKEwsUGUuRGFuZ2xpbmcpKTtyZXR1cm4gRGUmJiFnKERlKX1mdW5jdGlvbiBtZShMKXtpZihMLmxlbmd0aDw9MSlyZXR1cm4hMTtsZXQgRGU9MDtmb3IobGV0IGtlIG9mIEwpaWYoUyhrZSkpe2lmKERlKz0xLERlPjEpcmV0dXJuITB9ZWxzZSBpZihFZShrZSkpe2ZvcihsZXQgV2Ugb2Yga2UuYXJndW1lbnRzKWlmKFMoV2UpKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIGNlKEwpe2xldCBEZT1MLmdldFZhbHVlKCksa2U9TC5nZXRQYXJlbnROb2RlKCk7cmV0dXJuIEVlKERlKSYmRWUoa2UpJiZrZS5jYWxsZWU9PT1EZSYmRGUuYXJndW1lbnRzLmxlbmd0aD5rZS5hcmd1bWVudHMubGVuZ3RoJiZrZS5hcmd1bWVudHMubGVuZ3RoPjB9ZnVuY3Rpb24gaGUoTCxEZSl7aWYoRGU+PTIpcmV0dXJuITE7bGV0IGtlPSRlPT5oZSgkZSxEZSsxKSxXZT1MLnR5cGU9PT1cIkxpdGVyYWxcIiYmXCJyZWdleFwiaW4gTCYmTC5yZWdleC5wYXR0ZXJufHxMLnR5cGU9PT1cIlJlZ0V4cExpdGVyYWxcIiYmTC5wYXR0ZXJuO3JldHVybiBXZSYmYyhXZSk+NT8hMTpMLnR5cGU9PT1cIkxpdGVyYWxcInx8TC50eXBlPT09XCJCaWdJbnRMaXRlcmFsXCJ8fEwudHlwZT09PVwiRGVjaW1hbExpdGVyYWxcInx8TC50eXBlPT09XCJCb29sZWFuTGl0ZXJhbFwifHxMLnR5cGU9PT1cIk51bGxMaXRlcmFsXCJ8fEwudHlwZT09PVwiTnVtZXJpY0xpdGVyYWxcInx8TC50eXBlPT09XCJSZWdFeHBMaXRlcmFsXCJ8fEwudHlwZT09PVwiU3RyaW5nTGl0ZXJhbFwifHxMLnR5cGU9PT1cIklkZW50aWZpZXJcInx8TC50eXBlPT09XCJUaGlzRXhwcmVzc2lvblwifHxMLnR5cGU9PT1cIlN1cGVyXCJ8fEwudHlwZT09PVwiUHJpdmF0ZU5hbWVcInx8TC50eXBlPT09XCJQcml2YXRlSWRlbnRpZmllclwifHxMLnR5cGU9PT1cIkFyZ3VtZW50UGxhY2Vob2xkZXJcInx8TC50eXBlPT09XCJJbXBvcnRcIj8hMDpMLnR5cGU9PT1cIlRlbXBsYXRlTGl0ZXJhbFwiP0wucXVhc2lzLmV2ZXJ5KCRlPT4hJGUudmFsdWUucmF3LmluY2x1ZGVzKGBcbmApKSYmTC5leHByZXNzaW9ucy5ldmVyeShrZSk6TC50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCI/TC5wcm9wZXJ0aWVzLmV2ZXJ5KCRlPT4hJGUuY29tcHV0ZWQmJigkZS5zaG9ydGhhbmR8fCRlLnZhbHVlJiZrZSgkZS52YWx1ZSkpKTpMLnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwiP0wuZWxlbWVudHMuZXZlcnkoJGU9PiRlPT09bnVsbHx8a2UoJGUpKTpydChMKT8oTC50eXBlPT09XCJJbXBvcnRFeHByZXNzaW9uXCJ8fGhlKEwuY2FsbGVlLERlKSkmJkJlKEwpLmV2ZXJ5KGtlKTpxKEwpP2hlKEwub2JqZWN0LERlKSYmaGUoTC5wcm9wZXJ0eSxEZSk6TC50eXBlPT09XCJVbmFyeUV4cHJlc3Npb25cIiYmKEwub3BlcmF0b3I9PT1cIiFcInx8TC5vcGVyYXRvcj09PVwiLVwiKT9oZShMLmFyZ3VtZW50LERlKTpMLnR5cGU9PT1cIlRTTm9uTnVsbEV4cHJlc3Npb25cIj9oZShMLmV4cHJlc3Npb24sRGUpOiExfWZ1bmN0aW9uIEooTCl7cmV0dXJuIEwuZXh0cmE/TC5leHRyYS5yYXc6TC5yYXd9ZnVuY3Rpb24geWUoTCl7cmV0dXJuIEx9ZnVuY3Rpb24gWChMKXtyZXR1cm4gTC5maWxlcGF0aCYmL1xcLnRzeCQvaS50ZXN0KEwuZmlsZXBhdGgpfWZ1bmN0aW9uIFkoTCl7bGV0IERlPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTpcImVzNVwiO3JldHVybiBMLnRyYWlsaW5nQ29tbWE9PT1cImVzNVwiJiZEZT09PVwiZXM1XCJ8fEwudHJhaWxpbmdDb21tYT09PVwiYWxsXCImJihEZT09PVwiYWxsXCJ8fERlPT09XCJlczVcIil9ZnVuY3Rpb24gdGUoTCxEZSl7c3dpdGNoKEw9dHQoTCksTC50eXBlKXtjYXNlXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpjYXNlXCJDbGFzc0V4cHJlc3Npb25cIjpjYXNlXCJEb0V4cHJlc3Npb25cIjpyZXR1cm4gRGU7Y2FzZVwiT2JqZWN0RXhwcmVzc2lvblwiOnJldHVybiEwO2Nhc2VcIk1lbWJlckV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpyZXR1cm4gdGUoTC5vYmplY3QsRGUpO2Nhc2VcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOnJldHVybiBMLnRhZy50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cIj8hMTp0ZShMLnRhZyxEZSk7Y2FzZVwiQ2FsbEV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6cmV0dXJuIEwuY2FsbGVlLnR5cGU9PT1cIkZ1bmN0aW9uRXhwcmVzc2lvblwiPyExOnRlKEwuY2FsbGVlLERlKTtjYXNlXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpyZXR1cm4gdGUoTC50ZXN0LERlKTtjYXNlXCJVcGRhdGVFeHByZXNzaW9uXCI6cmV0dXJuIUwucHJlZml4JiZ0ZShMLmFyZ3VtZW50LERlKTtjYXNlXCJCaW5kRXhwcmVzc2lvblwiOnJldHVybiBMLm9iamVjdCYmdGUoTC5vYmplY3QsRGUpO2Nhc2VcIlNlcXVlbmNlRXhwcmVzc2lvblwiOnJldHVybiB0ZShMLmV4cHJlc3Npb25zWzBdLERlKTtjYXNlXCJUU0FzRXhwcmVzc2lvblwiOmNhc2VcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpyZXR1cm4gdGUoTC5leHByZXNzaW9uLERlKTtkZWZhdWx0OnJldHVybiExfX12YXIgej17XCI9PVwiOiEwLFwiIT1cIjohMCxcIj09PVwiOiEwLFwiIT09XCI6ITB9LGo9e1wiKlwiOiEwLFwiL1wiOiEwLFwiJVwiOiEwfSxDZT17XCI+PlwiOiEwLFwiPj4+XCI6ITAsXCI8PFwiOiEwfTtmdW5jdGlvbiBOZShMLERlKXtyZXR1cm4hKFVlKERlKSE9PVVlKEwpfHxMPT09XCIqKlwifHx6W0xdJiZ6W0RlXXx8RGU9PT1cIiVcIiYmaltMXXx8TD09PVwiJVwiJiZqW0RlXXx8RGUhPT1MJiZqW0RlXSYmaltMXXx8Q2VbTF0mJkNlW0RlXSl9dmFyIGplPXt9O2ZvcihsZXRbTCxEZV1vZltbXCJ8PlwiXSxbXCI/P1wiXSxbXCJ8fFwiXSxbXCImJlwiXSxbXCJ8XCJdLFtcIl5cIl0sW1wiJlwiXSxbXCI9PVwiLFwiPT09XCIsXCIhPVwiLFwiIT09XCJdLFtcIjxcIixcIj5cIixcIjw9XCIsXCI+PVwiLFwiaW5cIixcImluc3RhbmNlb2ZcIl0sW1wiPj5cIixcIjw8XCIsXCI+Pj5cIl0sW1wiK1wiLFwiLVwiXSxbXCIqXCIsXCIvXCIsXCIlXCJdLFtcIioqXCJdXS5lbnRyaWVzKCkpZm9yKGxldCBrZSBvZiBEZSlqZVtrZV09TDtmdW5jdGlvbiBVZShMKXtyZXR1cm4gamVbTF19ZnVuY3Rpb24gdHQoTCl7Zm9yKDtMLmxlZnQ7KUw9TC5sZWZ0O3JldHVybiBMfWZ1bmN0aW9uIFRlKEwpe3JldHVybiBCb29sZWFuKENlW0xdKXx8TD09PVwifFwifHxMPT09XCJeXCJ8fEw9PT1cIiZcIn1mdW5jdGlvbiBfZShMKXtpZihMLnJlc3QpcmV0dXJuITA7bGV0IERlPUtlKEwpO3JldHVybiBEZS5sZW5ndGg+MCYmcyhEZSkudHlwZT09PVwiUmVzdEVsZW1lbnRcIn12YXIgRmU9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gS2UoTCl7aWYoRmUuaGFzKEwpKXJldHVybiBGZS5nZXQoTCk7bGV0IERlPVtdO3JldHVybiBMLnRoaXMmJkRlLnB1c2goTC50aGlzKSxBcnJheS5pc0FycmF5KEwucGFyYW1ldGVycyk/RGUucHVzaCguLi5MLnBhcmFtZXRlcnMpOkFycmF5LmlzQXJyYXkoTC5wYXJhbXMpJiZEZS5wdXNoKC4uLkwucGFyYW1zKSxMLnJlc3QmJkRlLnB1c2goTC5yZXN0KSxGZS5zZXQoTCxEZSksRGV9ZnVuY3Rpb24gU2UoTCxEZSl7bGV0IGtlPUwuZ2V0VmFsdWUoKSxXZT0wLCRlPXV0PT5EZSh1dCxXZSsrKTtrZS50aGlzJiZMLmNhbGwoJGUsXCJ0aGlzXCIpLEFycmF5LmlzQXJyYXkoa2UucGFyYW1ldGVycyk/TC5lYWNoKCRlLFwicGFyYW1ldGVyc1wiKTpBcnJheS5pc0FycmF5KGtlLnBhcmFtcykmJkwuZWFjaCgkZSxcInBhcmFtc1wiKSxrZS5yZXN0JiZMLmNhbGwoJGUsXCJyZXN0XCIpfXZhciB6ZT1uZXcgV2Vha01hcDtmdW5jdGlvbiBCZShMKXtpZih6ZS5oYXMoTCkpcmV0dXJuIHplLmdldChMKTtsZXQgRGU9TC5hcmd1bWVudHM7cmV0dXJuIEwudHlwZT09PVwiSW1wb3J0RXhwcmVzc2lvblwiJiYoRGU9W0wuc291cmNlXSxMLmF0dHJpYnV0ZXMmJkRlLnB1c2goTC5hdHRyaWJ1dGVzKSksemUuc2V0KEwsRGUpLERlfWZ1bmN0aW9uIEllKEwsRGUpe2xldCBrZT1MLmdldFZhbHVlKCk7a2UudHlwZT09PVwiSW1wb3J0RXhwcmVzc2lvblwiPyhMLmNhbGwoV2U9PkRlKFdlLDApLFwic291cmNlXCIpLGtlLmF0dHJpYnV0ZXMmJkwuY2FsbChXZT0+RGUoV2UsMSksXCJhdHRyaWJ1dGVzXCIpKTpMLmVhY2goRGUsXCJhcmd1bWVudHNcIil9ZnVuY3Rpb24gVmUoTCl7cmV0dXJuIEwudmFsdWUudHJpbSgpPT09XCJwcmV0dGllci1pZ25vcmVcIiYmIUwudW5pZ25vcmV9ZnVuY3Rpb24gQWUoTCl7cmV0dXJuIEwmJihMLnByZXR0aWVySWdub3JlfHxNZShMLFBlLlByZXR0aWVySWdub3JlKSl9ZnVuY3Rpb24gT2UoTCl7bGV0IERlPUwuZ2V0VmFsdWUoKTtyZXR1cm4gQWUoRGUpfXZhciBQZT17TGVhZGluZzoxPDwxLFRyYWlsaW5nOjE8PDIsRGFuZ2xpbmc6MTw8MyxCbG9jazoxPDw0LExpbmU6MTw8NSxQcmV0dGllcklnbm9yZToxPDw2LEZpcnN0OjE8PDcsTGFzdDoxPDw4fSxpZT0oTCxEZSk9PntpZih0eXBlb2YgTD09XCJmdW5jdGlvblwiJiYoRGU9TCxMPTApLEx8fERlKXJldHVybihrZSxXZSwkZSk9PiEoTCZQZS5MZWFkaW5nJiYha2UubGVhZGluZ3x8TCZQZS5UcmFpbGluZyYmIWtlLnRyYWlsaW5nfHxMJlBlLkRhbmdsaW5nJiYoa2UubGVhZGluZ3x8a2UudHJhaWxpbmcpfHxMJlBlLkJsb2NrJiYhZyhrZSl8fEwmUGUuTGluZSYmIXcoa2UpfHxMJlBlLkZpcnN0JiZXZSE9PTB8fEwmUGUuTGFzdCYmV2UhPT0kZS5sZW5ndGgtMXx8TCZQZS5QcmV0dGllcklnbm9yZSYmIVZlKGtlKXx8RGUmJiFEZShrZSkpfTtmdW5jdGlvbiBNZShMLERlLGtlKXtpZighTHx8IXUoTC5jb21tZW50cykpcmV0dXJuITE7bGV0IFdlPWllKERlLGtlKTtyZXR1cm4gV2U/TC5jb21tZW50cy5zb21lKFdlKTohMH1mdW5jdGlvbiBxZShMLERlLGtlKXtpZighTHx8IUFycmF5LmlzQXJyYXkoTC5jb21tZW50cykpcmV0dXJuW107bGV0IFdlPWllKERlLGtlKTtyZXR1cm4gV2U/TC5jb21tZW50cy5maWx0ZXIoV2UpOkwuY29tbWVudHN9dmFyIEplPShMLERlKT0+e2xldHtvcmlnaW5hbFRleHQ6a2V9PURlO3JldHVybiBhKGtlLEMoTCkpfTtmdW5jdGlvbiBydChMKXtyZXR1cm4gRWUoTCl8fEwudHlwZT09PVwiTmV3RXhwcmVzc2lvblwifHxMLnR5cGU9PT1cIkltcG9ydEV4cHJlc3Npb25cIn1mdW5jdGlvbiBaZShMKXtyZXR1cm4gTCYmKEwudHlwZT09PVwiT2JqZWN0UHJvcGVydHlcInx8TC50eXBlPT09XCJQcm9wZXJ0eVwiJiYhTC5tZXRob2QmJkwua2luZD09PVwiaW5pdFwiKX1mdW5jdGlvbiBjdChMKXtyZXR1cm4gQm9vbGVhbihMLl9faXNVc2luZ0hhY2tQaXBlbGluZSl9dmFyIHF0PVN5bWJvbChcImlmV2l0aG91dEJsb2NrQW5kU2FtZUxpbmVDb21tZW50XCIpO24uZXhwb3J0cz17Z2V0RnVuY3Rpb25QYXJhbWV0ZXJzOktlLGl0ZXJhdGVGdW5jdGlvblBhcmFtZXRlcnNQYXRoOlNlLGdldENhbGxBcmd1bWVudHM6QmUsaXRlcmF0ZUNhbGxBcmd1bWVudHNQYXRoOkllLGhhc1Jlc3RQYXJhbWV0ZXI6X2UsZ2V0TGVmdFNpZGU6dixnZXRMZWZ0U2lkZVBhdGhOYW1lOkIsZ2V0UGFyZW50RXhwb3J0RGVjbGFyYXRpb246RCxnZXRUeXBlU2NyaXB0TWFwcGVkVHlwZU1vZGlmaWVyOnVlLGhhc0Zsb3dBbm5vdGF0aW9uQ29tbWVudDpULGhhc0Zsb3dTaG9ydGhhbmRBbm5vdGF0aW9uQ29tbWVudDpOLGhhc0xlYWRpbmdPd25MaW5lQ29tbWVudDpkZSxoYXNOYWtlZExlZnRTaWRlOmIsaGFzTm9kZTpBLGhhc0lnbm9yZUNvbW1lbnQ6T2UsaGFzTm9kZUlnbm9yZUNvbW1lbnQ6QWUsaWRlbnRpdHk6eWUsaXNCaW5hcnlpc2g6Vyxpc0NhbGxMaWtlRXhwcmVzc2lvbjpydCxpc0VuYWJsZWRIYWNrUGlwZWxpbmU6Y3QsaXNMaW5lQ29tbWVudDp3LGlzUHJldHRpZXJJZ25vcmVDb21tZW50OlZlLGlzQ2FsbEV4cHJlc3Npb246RWUsaXNNZW1iZXJFeHByZXNzaW9uOnEsaXNFeHBvcnREZWNsYXJhdGlvbjpFLGlzRmxvd0Fubm90YXRpb25Db21tZW50OlEsaXNGdW5jdGlvbkNvbXBvc2l0aW9uQXJnczptZSxpc0Z1bmN0aW9uTm90YXRpb246UCxpc0Z1bmN0aW9uT3JBcnJvd0V4cHJlc3Npb246Uyxpc0dldHRlck9yU2V0dGVyOkgsaXNKZXN0RWFjaFRlbXBsYXRlTGl0ZXJhbDp4ZSxpc0pzeE5vZGU6Uixpc0xpdGVyYWw6ZCxpc0xvbmdDdXJyaWVkQ2FsbEV4cHJlc3Npb246Y2UsaXNTaW1wbGVDYWxsQXJndW1lbnQ6aGUsaXNNZW1iZXJpc2g6ZWUsaXNOdW1lcmljTGl0ZXJhbDp5LGlzU2lnbmVkTnVtZXJpY0xpdGVyYWw6byxpc09iamVjdFByb3BlcnR5OlplLGlzT2JqZWN0VHlwZTpGLGlzT2JqZWN0VHlwZVByb3BlcnR5QUZ1bmN0aW9uOkcsaXNTaW1wbGVUeXBlOm5lLGlzU2ltcGxlTnVtYmVyOnZlLGlzU2ltcGxlVGVtcGxhdGVMaXRlcmFsOmxlLGlzU3RyaW5nTGl0ZXJhbDp4LGlzU3RyaW5nUHJvcFNhZmVUb1VucXVvdGU6Z2UsaXNUZW1wbGF0ZU9uSXRzT3duTGluZTpmZSxpc1Rlc3RDYWxsOkssaXNUaGVPbmx5SnN4RWxlbWVudEluTWFya2Rvd246TSxpc1RTWEZpbGU6WCxpc1R5cGVBbm5vdGF0aW9uQUZ1bmN0aW9uOnJlLGlzTmV4dExpbmVFbXB0eTpKZSxuZWVkc0hhcmRsaW5lQWZ0ZXJEYW5nbGluZ0NvbW1lbnQ6cGUscmF3VGV4dDpKLHNob3VsZFByaW50Q29tbWE6WSxpc0JpdHdpc2VPcGVyYXRvcjpUZSxzaG91bGRGbGF0dGVuOk5lLHN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuOnRlLGdldFByZWNlZGVuY2U6VWUsaGFzQ29tbWVudDpNZSxnZXRDb21tZW50czpxZSxDb21tZW50Q2hlY2tGbGFnczpQZSxtYXJrZXJGb3JJZldpdGhvdXRCbG9ja0FuZFNhbWVMaW5lQ29tbWVudDpxdH19fSksSXQ9Wih7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvdGVtcGxhdGUtbGl0ZXJhbC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD1zdCgpLHtnZXRTdHJpbmdXaWR0aDpzLGdldEluZGVudFNpemU6aX09R2UoKSx7YnVpbGRlcnM6e2pvaW46cixoYXJkbGluZTp1LHNvZnRsaW5lOmEsZ3JvdXA6YyxpbmRlbnQ6bCxhbGlnbjpDLGxpbmVTdWZmaXhCb3VuZGFyeTptLGFkZEFsaWdubWVudFRvRG9jOmd9LHByaW50ZXI6e3ByaW50RG9jVG9TdHJpbmc6cH0sdXRpbHM6e21hcERvYzpmfX09TGUoKSx7aXNCaW5hcnlpc2g6aCxpc0plc3RFYWNoVGVtcGxhdGVMaXRlcmFsOk4saXNTaW1wbGVUZW1wbGF0ZUxpdGVyYWw6VCxoYXNDb21tZW50OkEsaXNNZW1iZXJFeHByZXNzaW9uOmJ9PVhlKCk7ZnVuY3Rpb24gdihkLHksbyl7bGV0IHg9ZC5nZXRWYWx1ZSgpO2lmKHgudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCImJk4oeCxkLmdldFBhcmVudE5vZGUoKSkpe2xldCBSPUIoZCxvLHkpO2lmKFIpcmV0dXJuIFJ9bGV0IFM9XCJleHByZXNzaW9uc1wiO3gudHlwZT09PVwiVFNUZW1wbGF0ZUxpdGVyYWxUeXBlXCImJihTPVwidHlwZXNcIik7bGV0IGs9W10sXz1kLm1hcCh5LFMpLE89VCh4KTtyZXR1cm4gTyYmKF89Xy5tYXAoUj0+cChSLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxvKSx7fSx7cHJpbnRXaWR0aDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9KSkuZm9ybWF0dGVkKSksay5wdXNoKG0sXCJgXCIpLGQuZWFjaChSPT57bGV0IE09Ui5nZXROYW1lKCk7aWYoay5wdXNoKHkoKSksTTxfLmxlbmd0aCl7bGV0e3RhYldpZHRoOkh9PW8sUD1SLmdldFZhbHVlKCksRz1pKFAudmFsdWUucmF3LEgpLHJlPV9bTV07aWYoIU8pe2xldCBXPXhbU11bTV07KEEoVyl8fGIoVyl8fFcudHlwZT09PVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCJ8fFcudHlwZT09PVwiU2VxdWVuY2VFeHByZXNzaW9uXCJ8fFcudHlwZT09PVwiVFNBc0V4cHJlc3Npb25cInx8aChXKSkmJihyZT1bbChbYSxyZV0pLGFdKX1sZXQgJD1HPT09MCYmUC52YWx1ZS5yYXcuZW5kc1dpdGgoYFxuYCk/QyhOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkscmUpOmcocmUsRyxIKTtrLnB1c2goYyhbXCIke1wiLCQsbSxcIn1cIl0pKX19LFwicXVhc2lzXCIpLGsucHVzaChcImBcIiksa31mdW5jdGlvbiBCKGQseSxvKXtsZXQgeD1kLmdldE5vZGUoKSxGPXgucXVhc2lzWzBdLnZhbHVlLnJhdy50cmltKCkuc3BsaXQoL1xccypcXHxcXHMqLyk7aWYoRi5sZW5ndGg+MXx8Ri5zb21lKFM9PlMubGVuZ3RoPjApKXt5Ll9faW5KZXN0RWFjaD0hMDtsZXQgUz1kLm1hcChvLFwiZXhwcmVzc2lvbnNcIik7eS5fX2luSmVzdEVhY2g9ITE7bGV0IGs9W10sXz1TLm1hcChQPT5cIiR7XCIrcChQLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx5KSx7fSx7cHJpbnRXaWR0aDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksZW5kT2ZMaW5lOlwibGZcIn0pKS5mb3JtYXR0ZWQrXCJ9XCIpLE89W3toYXNMaW5lQnJlYWs6ITEsY2VsbHM6W119XTtmb3IobGV0IFA9MTtQPHgucXVhc2lzLmxlbmd0aDtQKyspe2xldCBHPXQoTykscmU9X1tQLTFdO0cuY2VsbHMucHVzaChyZSkscmUuaW5jbHVkZXMoYFxuYCkmJihHLmhhc0xpbmVCcmVhaz0hMCkseC5xdWFzaXNbUF0udmFsdWUucmF3LmluY2x1ZGVzKGBcbmApJiZPLnB1c2goe2hhc0xpbmVCcmVhazohMSxjZWxsczpbXX0pfWxldCBSPU1hdGgubWF4KEYubGVuZ3RoLC4uLk8ubWFwKFA9PlAuY2VsbHMubGVuZ3RoKSksTT1BcnJheS5mcm9tKHtsZW5ndGg6Un0pLmZpbGwoMCksSD1be2NlbGxzOkZ9LC4uLk8uZmlsdGVyKFA9PlAuY2VsbHMubGVuZ3RoPjApXTtmb3IobGV0e2NlbGxzOlB9b2YgSC5maWx0ZXIoRz0+IUcuaGFzTGluZUJyZWFrKSlmb3IobGV0W0cscmVdb2YgUC5lbnRyaWVzKCkpTVtHXT1NYXRoLm1heChNW0ddLHMocmUpKTtyZXR1cm4gay5wdXNoKG0sXCJgXCIsbChbdSxyKHUsSC5tYXAoUD0+cihcIiB8IFwiLFAuY2VsbHMubWFwKChHLHJlKT0+UC5oYXNMaW5lQnJlYWs/RzpHK1wiIFwiLnJlcGVhdChNW3JlXS1zKEcpKSkpKSldKSx1LFwiYFwiKSxrfX1mdW5jdGlvbiB3KGQseSl7bGV0IG89ZC5nZXRWYWx1ZSgpLHg9eSgpO3JldHVybiBBKG8pJiYoeD1jKFtsKFthLHhdKSxhXSkpLFtcIiR7XCIseCxtLFwifVwiXX1mdW5jdGlvbiBJKGQseSl7cmV0dXJuIGQubWFwKG89Pncobyx5KSxcImV4cHJlc3Npb25zXCIpfWZ1bmN0aW9uIEUoZCx5KXtyZXR1cm4gZihkLG89PnR5cGVvZiBvPT1cInN0cmluZ1wiP3k/by5yZXBsYWNlKC8oXFxcXCopYC9nLFwiJDEkMVxcXFxgXCIpOkQobyk6byl9ZnVuY3Rpb24gRChkKXtyZXR1cm4gZC5yZXBsYWNlKC8oW1xcXFxgXXxcXCR7KS9nLFwiXFxcXCQxXCIpfW4uZXhwb3J0cz17cHJpbnRUZW1wbGF0ZUxpdGVyYWw6dixwcmludFRlbXBsYXRlRXhwcmVzc2lvbnM6SSxlc2NhcGVUZW1wbGF0ZUNoYXJhY3RlcnM6RSx1bmNvb2tUZW1wbGF0ZUVsZW1lbnRWYWx1ZTpEfX19KSxEbT1aKHtcInNyYy9sYW5ndWFnZS1qcy9lbWJlZC9tYXJrZG93bi5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7YnVpbGRlcnM6e2luZGVudDp0LHNvZnRsaW5lOnMsbGl0ZXJhbGxpbmU6aSxkZWRlbnRUb1Jvb3Q6cn19PUxlKCkse2VzY2FwZVRlbXBsYXRlQ2hhcmFjdGVyczp1fT1JdCgpO2Z1bmN0aW9uIGEobCxDLG0pe2xldCBwPWwuZ2V0VmFsdWUoKS5xdWFzaXNbMF0udmFsdWUucmF3LnJlcGxhY2UoLygoPzpcXFxcXFxcXCkqKVxcXFxgL2csKFQsQSk9PlwiXFxcXFwiLnJlcGVhdChBLmxlbmd0aC8yKStcImBcIiksZj1jKHApLGg9ZiE9PVwiXCI7aCYmKHA9cC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KGYpLFwiZ21cIiksXCJcIikpO2xldCBOPXUobShwLHtwYXJzZXI6XCJtYXJrZG93blwiLF9faW5Kc1RlbXBsYXRlOiEwfSx7c3RyaXBUcmFpbGluZ0hhcmRsaW5lOiEwfSksITApO3JldHVybltcImBcIixoP3QoW3MsTl0pOltpLHIoTildLHMsXCJgXCJdfWZ1bmN0aW9uIGMobCl7bGV0IEM9bC5tYXRjaCgvXihbXlxcU1xcbl0qKVxcUy9tKTtyZXR1cm4gQz09PW51bGw/XCJcIjpDWzFdfW4uZXhwb3J0cz1hfX0pLG1tPVooe1wic3JjL2xhbmd1YWdlLWpzL2VtYmVkL2Nzcy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7aXNOb25FbXB0eUFycmF5OnR9PUdlKCkse2J1aWxkZXJzOntpbmRlbnQ6cyxoYXJkbGluZTppLHNvZnRsaW5lOnJ9LHV0aWxzOnttYXBEb2M6dSxyZXBsYWNlRW5kT2ZMaW5lOmEsY2xlYW5Eb2M6Y319PUxlKCkse3ByaW50VGVtcGxhdGVFeHByZXNzaW9uczpsfT1JdCgpO2Z1bmN0aW9uIEMocCxmLGgpe2xldCBOPXAuZ2V0VmFsdWUoKSxUPU4ucXVhc2lzLm1hcCh3PT53LnZhbHVlLnJhdyksQT0wLGI9VC5yZWR1Y2UoKHcsSSxFKT0+RT09PTA/STp3K1wiQHByZXR0aWVyLXBsYWNlaG9sZGVyLVwiK0ErKytcIi1pZFwiK0ksXCJcIiksdj1oKGIse3BhcnNlcjpcInNjc3NcIn0se3N0cmlwVHJhaWxpbmdIYXJkbGluZTohMH0pLEI9bChwLGYpO3JldHVybiBtKHYsTixCKX1mdW5jdGlvbiBtKHAsZixoKXtpZihmLnF1YXNpcy5sZW5ndGg9PT0xJiYhZi5xdWFzaXNbMF0udmFsdWUucmF3LnRyaW0oKSlyZXR1cm5cImBgXCI7bGV0IFQ9ZyhwLGgpO2lmKCFUKXRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGluc2VydCBhbGwgdGhlIGV4cHJlc3Npb25zXCIpO3JldHVybltcImBcIixzKFtpLFRdKSxyLFwiYFwiXX1mdW5jdGlvbiBnKHAsZil7aWYoIXQoZikpcmV0dXJuIHA7bGV0IGg9MCxOPXUoYyhwKSxUPT50eXBlb2YgVCE9XCJzdHJpbmdcInx8IVQuaW5jbHVkZXMoXCJAcHJldHRpZXItcGxhY2Vob2xkZXJcIik/VDpULnNwbGl0KC9AcHJldHRpZXItcGxhY2Vob2xkZXItKFxcZCspLWlkLykubWFwKChBLGIpPT5iJTI9PT0wP2EoQSk6KGgrKyxmW0FdKSkpO3JldHVybiBmLmxlbmd0aD09PWg/TjpudWxsfW4uZXhwb3J0cz1DfX0pLGRtPVooe1wic3JjL2xhbmd1YWdlLWpzL2VtYmVkL2dyYXBocWwuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2J1aWxkZXJzOntpbmRlbnQ6dCxqb2luOnMsaGFyZGxpbmU6aX19PUxlKCkse2VzY2FwZVRlbXBsYXRlQ2hhcmFjdGVyczpyLHByaW50VGVtcGxhdGVFeHByZXNzaW9uczp1fT1JdCgpO2Z1bmN0aW9uIGEobCxDLG0pe2xldCBnPWwuZ2V0VmFsdWUoKSxwPWcucXVhc2lzLmxlbmd0aDtpZihwPT09MSYmZy5xdWFzaXNbMF0udmFsdWUucmF3LnRyaW0oKT09PVwiXCIpcmV0dXJuXCJgYFwiO2xldCBmPXUobCxDKSxoPVtdO2ZvcihsZXQgTj0wO048cDtOKyspe2xldCBUPWcucXVhc2lzW05dLEE9Tj09PTAsYj1OPT09cC0xLHY9VC52YWx1ZS5jb29rZWQsQj12LnNwbGl0KGBcbmApLHc9Qi5sZW5ndGgsST1mW05dLEU9dz4yJiZCWzBdLnRyaW0oKT09PVwiXCImJkJbMV0udHJpbSgpPT09XCJcIixEPXc+MiYmQlt3LTFdLnRyaW0oKT09PVwiXCImJkJbdy0yXS50cmltKCk9PT1cIlwiLGQ9Qi5ldmVyeShvPT4vXlxccyooPzojW15cXG5cXHJdKik/JC8udGVzdChvKSk7aWYoIWImJi8jW15cXG5cXHJdKiQvLnRlc3QoQlt3LTFdKSlyZXR1cm4gbnVsbDtsZXQgeT1udWxsO2Q/eT1jKEIpOnk9bSh2LHtwYXJzZXI6XCJncmFwaHFsXCJ9LHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6ITB9KSx5Pyh5PXIoeSwhMSksIUEmJkUmJmgucHVzaChcIlwiKSxoLnB1c2goeSksIWImJkQmJmgucHVzaChcIlwiKSk6IUEmJiFiJiZFJiZoLnB1c2goXCJcIiksSSYmaC5wdXNoKEkpfXJldHVybltcImBcIix0KFtpLHMoaSxoKV0pLGksXCJgXCJdfWZ1bmN0aW9uIGMobCl7bGV0IEM9W10sbT0hMSxnPWwubWFwKHA9PnAudHJpbSgpKTtmb3IobGV0W3AsZl1vZiBnLmVudHJpZXMoKSlmIT09XCJcIiYmKGdbcC0xXT09PVwiXCImJm0/Qy5wdXNoKFtpLGZdKTpDLnB1c2goZiksbT0hMCk7cmV0dXJuIEMubGVuZ3RoPT09MD9udWxsOnMoaSxDKX1uLmV4cG9ydHM9YX19KSxnbT1aKHtcInNyYy9sYW5ndWFnZS1qcy9lbWJlZC9odG1sLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntidWlsZGVyczp7aW5kZW50OnQsbGluZTpzLGhhcmRsaW5lOmksZ3JvdXA6cn0sdXRpbHM6e21hcERvYzp1fX09TGUoKSx7cHJpbnRUZW1wbGF0ZUV4cHJlc3Npb25zOmEsdW5jb29rVGVtcGxhdGVFbGVtZW50VmFsdWU6Y309SXQoKSxsPTA7ZnVuY3Rpb24gQyhtLGcscCxmLGgpe2xldHtwYXJzZXI6Tn09aCxUPW0uZ2V0VmFsdWUoKSxBPWw7bD1sKzE+Pj4wO2xldCBiPXg9PlwiUFJFVFRJRVJfSFRNTF9QTEFDRUhPTERFUl9cIi5jb25jYXQoeCxcIl9cIikuY29uY2F0KEEsXCJfSU5fSlNcIiksdj1ULnF1YXNpcy5tYXAoKHgsRixTKT0+Rj09PVMubGVuZ3RoLTE/eC52YWx1ZS5jb29rZWQ6eC52YWx1ZS5jb29rZWQrYihGKSkuam9pbihcIlwiKSxCPWEobSxnKTtpZihCLmxlbmd0aD09PTAmJnYudHJpbSgpLmxlbmd0aD09PTApcmV0dXJuXCJgYFwiO2xldCB3PW5ldyBSZWdFeHAoYihcIihcXFxcZCspXCIpLFwiZ1wiKSxJPTAsRT1wKHYse3BhcnNlcjpOLF9fb25IdG1sUm9vdCh4KXtJPXguY2hpbGRyZW4ubGVuZ3RofX0se3N0cmlwVHJhaWxpbmdIYXJkbGluZTohMH0pLEQ9dShFLHg9PntpZih0eXBlb2YgeCE9XCJzdHJpbmdcIilyZXR1cm4geDtsZXQgRj1bXSxTPXguc3BsaXQodyk7Zm9yKGxldCBrPTA7azxTLmxlbmd0aDtrKyspe2xldCBfPVNba107aWYoayUyPT09MCl7XyYmKF89YyhfKSxmLl9fZW1iZWRkZWRJbkh0bWwmJihfPV8ucmVwbGFjZSgvPFxcLyhzY3JpcHQpXFxiL2dpLFwiPFxcXFwvJDFcIikpLEYucHVzaChfKSk7Y29udGludWV9bGV0IE89TnVtYmVyKF8pO0YucHVzaChCW09dKX1yZXR1cm4gRn0pLGQ9L15cXHMvLnRlc3Qodik/XCIgXCI6XCJcIix5PS9cXHMkLy50ZXN0KHYpP1wiIFwiOlwiXCIsbz1mLmh0bWxXaGl0ZXNwYWNlU2Vuc2l0aXZpdHk9PT1cImlnbm9yZVwiP2k6ZCYmeT9zOm51bGw7cmV0dXJuIHIobz9bXCJgXCIsdChbbyxyKEQpXSksbyxcImBcIl06W1wiYFwiLGQsST4xP3QocihEKSk6cihEKSx5LFwiYFwiXSl9bi5leHBvcnRzPUN9fSkseW09Wih7XCJzcmMvbGFuZ3VhZ2UtanMvZW1iZWQuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2hhc0NvbW1lbnQ6dCxDb21tZW50Q2hlY2tGbGFnczpzLGlzT2JqZWN0UHJvcGVydHk6aX09WGUoKSxyPURtKCksdT1tbSgpLGE9ZG0oKSxjPWdtKCk7ZnVuY3Rpb24gbChFKXtpZihnKEUpfHxOKEUpfHxUKEUpfHxwKEUpKXJldHVyblwiY3NzXCI7aWYodihFKSlyZXR1cm5cImdyYXBocWxcIjtpZih3KEUpKXJldHVyblwiaHRtbFwiO2lmKGYoRSkpcmV0dXJuXCJhbmd1bGFyXCI7aWYobShFKSlyZXR1cm5cIm1hcmtkb3duXCJ9ZnVuY3Rpb24gQyhFLEQsZCx5KXtsZXQgbz1FLmdldFZhbHVlKCk7aWYoby50eXBlIT09XCJUZW1wbGF0ZUxpdGVyYWxcInx8SShvKSlyZXR1cm47bGV0IHg9bChFKTtpZighIXgpe2lmKHg9PT1cIm1hcmtkb3duXCIpcmV0dXJuIHIoRSxELGQpO2lmKHg9PT1cImNzc1wiKXJldHVybiB1KEUsRCxkKTtpZih4PT09XCJncmFwaHFsXCIpcmV0dXJuIGEoRSxELGQpO2lmKHg9PT1cImh0bWxcInx8eD09PVwiYW5ndWxhclwiKXJldHVybiBjKEUsRCxkLHkse3BhcnNlcjp4fSl9fWZ1bmN0aW9uIG0oRSl7bGV0IEQ9RS5nZXRWYWx1ZSgpLGQ9RS5nZXRQYXJlbnROb2RlKCk7cmV0dXJuIGQmJmQudHlwZT09PVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCImJkQucXVhc2lzLmxlbmd0aD09PTEmJmQudGFnLnR5cGU9PT1cIklkZW50aWZpZXJcIiYmKGQudGFnLm5hbWU9PT1cIm1kXCJ8fGQudGFnLm5hbWU9PT1cIm1hcmtkb3duXCIpfWZ1bmN0aW9uIGcoRSl7bGV0IEQ9RS5nZXRWYWx1ZSgpLGQ9RS5nZXRQYXJlbnROb2RlKCkseT1FLmdldFBhcmVudE5vZGUoMSk7cmV0dXJuIHkmJkQucXVhc2lzJiZkLnR5cGU9PT1cIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiYmeS50eXBlPT09XCJKU1hFbGVtZW50XCImJnkub3BlbmluZ0VsZW1lbnQubmFtZS5uYW1lPT09XCJzdHlsZVwiJiZ5Lm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXMuc29tZShvPT5vLm5hbWUubmFtZT09PVwianN4XCIpfHxkJiZkLnR5cGU9PT1cIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiJiZkLnRhZy50eXBlPT09XCJJZGVudGlmaWVyXCImJmQudGFnLm5hbWU9PT1cImNzc1wifHxkJiZkLnR5cGU9PT1cIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiJiZkLnRhZy50eXBlPT09XCJNZW1iZXJFeHByZXNzaW9uXCImJmQudGFnLm9iamVjdC5uYW1lPT09XCJjc3NcIiYmKGQudGFnLnByb3BlcnR5Lm5hbWU9PT1cImdsb2JhbFwifHxkLnRhZy5wcm9wZXJ0eS5uYW1lPT09XCJyZXNvbHZlXCIpfWZ1bmN0aW9uIHAoRSl7cmV0dXJuIEUubWF0Y2goRD0+RC50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcIiwoRCxkKT0+RC50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cIiYmZD09PVwiZWxlbWVudHNcIiwoRCxkKT0+aShEKSYmRC5rZXkudHlwZT09PVwiSWRlbnRpZmllclwiJiZELmtleS5uYW1lPT09XCJzdHlsZXNcIiYmZD09PVwidmFsdWVcIiwuLi5oKX1mdW5jdGlvbiBmKEUpe3JldHVybiBFLm1hdGNoKEQ9PkQudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCIsKEQsZCk9PmkoRCkmJkQua2V5LnR5cGU9PT1cIklkZW50aWZpZXJcIiYmRC5rZXkubmFtZT09PVwidGVtcGxhdGVcIiYmZD09PVwidmFsdWVcIiwuLi5oKX12YXIgaD1bKEUsRCk9PkUudHlwZT09PVwiT2JqZWN0RXhwcmVzc2lvblwiJiZEPT09XCJwcm9wZXJ0aWVzXCIsKEUsRCk9PkUudHlwZT09PVwiQ2FsbEV4cHJlc3Npb25cIiYmRS5jYWxsZWUudHlwZT09PVwiSWRlbnRpZmllclwiJiZFLmNhbGxlZS5uYW1lPT09XCJDb21wb25lbnRcIiYmRD09PVwiYXJndW1lbnRzXCIsKEUsRCk9PkUudHlwZT09PVwiRGVjb3JhdG9yXCImJkQ9PT1cImV4cHJlc3Npb25cIl07ZnVuY3Rpb24gTihFKXtsZXQgRD1FLmdldFBhcmVudE5vZGUoKTtpZighRHx8RC50eXBlIT09XCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIilyZXR1cm4hMTtsZXQgZD1ELnRhZy50eXBlPT09XCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiP0QudGFnLmV4cHJlc3Npb246RC50YWc7c3dpdGNoKGQudHlwZSl7Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOnJldHVybiBBKGQub2JqZWN0KXx8YihkKTtjYXNlXCJDYWxsRXhwcmVzc2lvblwiOnJldHVybiBBKGQuY2FsbGVlKXx8ZC5jYWxsZWUudHlwZT09PVwiTWVtYmVyRXhwcmVzc2lvblwiJiYoZC5jYWxsZWUub2JqZWN0LnR5cGU9PT1cIk1lbWJlckV4cHJlc3Npb25cIiYmKEEoZC5jYWxsZWUub2JqZWN0Lm9iamVjdCl8fGIoZC5jYWxsZWUub2JqZWN0KSl8fGQuY2FsbGVlLm9iamVjdC50eXBlPT09XCJDYWxsRXhwcmVzc2lvblwiJiZBKGQuY2FsbGVlLm9iamVjdC5jYWxsZWUpKTtjYXNlXCJJZGVudGlmaWVyXCI6cmV0dXJuIGQubmFtZT09PVwiY3NzXCI7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gVChFKXtsZXQgRD1FLmdldFBhcmVudE5vZGUoKSxkPUUuZ2V0UGFyZW50Tm9kZSgxKTtyZXR1cm4gZCYmRC50eXBlPT09XCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCImJmQudHlwZT09PVwiSlNYQXR0cmlidXRlXCImJmQubmFtZS50eXBlPT09XCJKU1hJZGVudGlmaWVyXCImJmQubmFtZS5uYW1lPT09XCJjc3NcIn1mdW5jdGlvbiBBKEUpe3JldHVybiBFLnR5cGU9PT1cIklkZW50aWZpZXJcIiYmRS5uYW1lPT09XCJzdHlsZWRcIn1mdW5jdGlvbiBiKEUpe3JldHVybi9eW0EtWl0vLnRlc3QoRS5vYmplY3QubmFtZSkmJkUucHJvcGVydHkubmFtZT09PVwiZXh0ZW5kXCJ9ZnVuY3Rpb24gdihFKXtsZXQgRD1FLmdldFZhbHVlKCksZD1FLmdldFBhcmVudE5vZGUoKTtyZXR1cm4gQihELFwiR3JhcGhRTFwiKXx8ZCYmKGQudHlwZT09PVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCImJihkLnRhZy50eXBlPT09XCJNZW1iZXJFeHByZXNzaW9uXCImJmQudGFnLm9iamVjdC5uYW1lPT09XCJncmFwaHFsXCImJmQudGFnLnByb3BlcnR5Lm5hbWU9PT1cImV4cGVyaW1lbnRhbFwifHxkLnRhZy50eXBlPT09XCJJZGVudGlmaWVyXCImJihkLnRhZy5uYW1lPT09XCJncWxcInx8ZC50YWcubmFtZT09PVwiZ3JhcGhxbFwiKSl8fGQudHlwZT09PVwiQ2FsbEV4cHJlc3Npb25cIiYmZC5jYWxsZWUudHlwZT09PVwiSWRlbnRpZmllclwiJiZkLmNhbGxlZS5uYW1lPT09XCJncmFwaHFsXCIpfWZ1bmN0aW9uIEIoRSxEKXtyZXR1cm4gdChFLHMuQmxvY2t8cy5MZWFkaW5nLGQ9PntsZXR7dmFsdWU6eX09ZDtyZXR1cm4geT09PVwiIFwiLmNvbmNhdChELFwiIFwiKX0pfWZ1bmN0aW9uIHcoRSl7cmV0dXJuIEIoRS5nZXRWYWx1ZSgpLFwiSFRNTFwiKXx8RS5tYXRjaChEPT5ELnR5cGU9PT1cIlRlbXBsYXRlTGl0ZXJhbFwiLChELGQpPT5ELnR5cGU9PT1cIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiJiZELnRhZy50eXBlPT09XCJJZGVudGlmaWVyXCImJkQudGFnLm5hbWU9PT1cImh0bWxcIiYmZD09PVwicXVhc2lcIil9ZnVuY3Rpb24gSShFKXtsZXR7cXVhc2lzOkR9PUU7cmV0dXJuIEQuc29tZShkPT57bGV0e3ZhbHVlOntjb29rZWQ6eX19PWQ7cmV0dXJuIHk9PT1udWxsfSl9bi5leHBvcnRzPUN9fSksaG09Wih7XCJzcmMvbGFuZ3VhZ2UtanMvY2xlYW4uanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9UHQoKSxzPW5ldyBTZXQoW1wicmFuZ2VcIixcInJhd1wiLFwiY29tbWVudHNcIixcImxlYWRpbmdDb21tZW50c1wiLFwidHJhaWxpbmdDb21tZW50c1wiLFwiaW5uZXJDb21tZW50c1wiLFwiZXh0cmFcIixcInN0YXJ0XCIsXCJlbmRcIixcImxvY1wiLFwiZmxhZ3NcIixcImVycm9yc1wiLFwidG9rZW5zXCJdKSxpPXU9Pntmb3IobGV0IGEgb2YgdS5xdWFzaXMpZGVsZXRlIGEudmFsdWV9O2Z1bmN0aW9uIHIodSxhLGMpe2lmKHUudHlwZT09PVwiUHJvZ3JhbVwiJiZkZWxldGUgYS5zb3VyY2VUeXBlLCh1LnR5cGU9PT1cIkJpZ0ludExpdGVyYWxcInx8dS50eXBlPT09XCJCaWdJbnRMaXRlcmFsVHlwZUFubm90YXRpb25cIikmJmEudmFsdWUmJihhLnZhbHVlPWEudmFsdWUudG9Mb3dlckNhc2UoKSksKHUudHlwZT09PVwiQmlnSW50TGl0ZXJhbFwifHx1LnR5cGU9PT1cIkxpdGVyYWxcIikmJmEuYmlnaW50JiYoYS5iaWdpbnQ9YS5iaWdpbnQudG9Mb3dlckNhc2UoKSksdS50eXBlPT09XCJEZWNpbWFsTGl0ZXJhbFwiJiYoYS52YWx1ZT1OdW1iZXIoYS52YWx1ZSkpLHUudHlwZT09PVwiTGl0ZXJhbFwiJiZhLmRlY2ltYWwmJihhLmRlY2ltYWw9TnVtYmVyKGEuZGVjaW1hbCkpLHUudHlwZT09PVwiRW1wdHlTdGF0ZW1lbnRcInx8dS50eXBlPT09XCJKU1hUZXh0XCJ8fHUudHlwZT09PVwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiJiYodS5leHByZXNzaW9uLnR5cGU9PT1cIkxpdGVyYWxcInx8dS5leHByZXNzaW9uLnR5cGU9PT1cIlN0cmluZ0xpdGVyYWxcIikmJnUuZXhwcmVzc2lvbi52YWx1ZT09PVwiIFwiKXJldHVybiBudWxsO2lmKCh1LnR5cGU9PT1cIlByb3BlcnR5XCJ8fHUudHlwZT09PVwiT2JqZWN0UHJvcGVydHlcInx8dS50eXBlPT09XCJNZXRob2REZWZpbml0aW9uXCJ8fHUudHlwZT09PVwiQ2xhc3NQcm9wZXJ0eVwifHx1LnR5cGU9PT1cIkNsYXNzTWV0aG9kXCJ8fHUudHlwZT09PVwiUHJvcGVydHlEZWZpbml0aW9uXCJ8fHUudHlwZT09PVwiVFNEZWNsYXJlTWV0aG9kXCJ8fHUudHlwZT09PVwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwifHx1LnR5cGU9PT1cIk9iamVjdFR5cGVQcm9wZXJ0eVwiKSYmdHlwZW9mIHUua2V5PT1cIm9iamVjdFwiJiZ1LmtleSYmKHUua2V5LnR5cGU9PT1cIkxpdGVyYWxcInx8dS5rZXkudHlwZT09PVwiTnVtZXJpY0xpdGVyYWxcInx8dS5rZXkudHlwZT09PVwiU3RyaW5nTGl0ZXJhbFwifHx1LmtleS50eXBlPT09XCJJZGVudGlmaWVyXCIpJiZkZWxldGUgYS5rZXksdS50eXBlPT09XCJKU1hFbGVtZW50XCImJnUub3BlbmluZ0VsZW1lbnQubmFtZS5uYW1lPT09XCJzdHlsZVwiJiZ1Lm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXMuc29tZShDPT5DLm5hbWUubmFtZT09PVwianN4XCIpKWZvcihsZXR7dHlwZTpDLGV4cHJlc3Npb246bX1vZiBhLmNoaWxkcmVuKUM9PT1cIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiYmbS50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcIiYmaShtKTt1LnR5cGU9PT1cIkpTWEF0dHJpYnV0ZVwiJiZ1Lm5hbWUubmFtZT09PVwiY3NzXCImJnUudmFsdWUudHlwZT09PVwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiJiZ1LnZhbHVlLmV4cHJlc3Npb24udHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCImJmkoYS52YWx1ZS5leHByZXNzaW9uKSx1LnR5cGU9PT1cIkpTWEF0dHJpYnV0ZVwiJiZ1LnZhbHVlJiZ1LnZhbHVlLnR5cGU9PT1cIkxpdGVyYWxcIiYmL1tcIiddfCZxdW90O3wmYXBvczsvLnRlc3QodS52YWx1ZS52YWx1ZSkmJihhLnZhbHVlLnZhbHVlPWEudmFsdWUudmFsdWUucmVwbGFjZSgvW1wiJ118JnF1b3Q7fCZhcG9zOy9nLCdcIicpKTtsZXQgbD11LmV4cHJlc3Npb258fHUuY2FsbGVlO2lmKHUudHlwZT09PVwiRGVjb3JhdG9yXCImJmwudHlwZT09PVwiQ2FsbEV4cHJlc3Npb25cIiYmbC5jYWxsZWUubmFtZT09PVwiQ29tcG9uZW50XCImJmwuYXJndW1lbnRzLmxlbmd0aD09PTEpe2xldCBDPXUuZXhwcmVzc2lvbi5hcmd1bWVudHNbMF0ucHJvcGVydGllcztmb3IobGV0W20sZ11vZiBhLmV4cHJlc3Npb24uYXJndW1lbnRzWzBdLnByb3BlcnRpZXMuZW50cmllcygpKXN3aXRjaChDW21dLmtleS5uYW1lKXtjYXNlXCJzdHlsZXNcIjpnLnZhbHVlLnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwiJiZpKGcudmFsdWUuZWxlbWVudHNbMF0pO2JyZWFrO2Nhc2VcInRlbXBsYXRlXCI6Zy52YWx1ZS50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcIiYmaShnLnZhbHVlKTticmVha319aWYodS50eXBlPT09XCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiYmKHUudGFnLnR5cGU9PT1cIk1lbWJlckV4cHJlc3Npb25cInx8dS50YWcudHlwZT09PVwiSWRlbnRpZmllclwiJiYodS50YWcubmFtZT09PVwiZ3FsXCJ8fHUudGFnLm5hbWU9PT1cImdyYXBocWxcInx8dS50YWcubmFtZT09PVwiY3NzXCJ8fHUudGFnLm5hbWU9PT1cIm1kXCJ8fHUudGFnLm5hbWU9PT1cIm1hcmtkb3duXCJ8fHUudGFnLm5hbWU9PT1cImh0bWxcIil8fHUudGFnLnR5cGU9PT1cIkNhbGxFeHByZXNzaW9uXCIpJiZpKGEucXVhc2kpLHUudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCImJih1LmxlYWRpbmdDb21tZW50cyYmdS5sZWFkaW5nQ29tbWVudHMuc29tZShtPT50KG0pJiZbXCJHcmFwaFFMXCIsXCJIVE1MXCJdLnNvbWUoZz0+bS52YWx1ZT09PVwiIFwiLmNvbmNhdChnLFwiIFwiKSkpfHxjLnR5cGU9PT1cIkNhbGxFeHByZXNzaW9uXCImJmMuY2FsbGVlLm5hbWU9PT1cImdyYXBocWxcInx8IXUubGVhZGluZ0NvbW1lbnRzKSYmaShhKSx1LnR5cGU9PT1cIkludGVycHJldGVyRGlyZWN0aXZlXCImJihhLnZhbHVlPWEudmFsdWUudHJpbUVuZCgpKSwodS50eXBlPT09XCJUU0ludGVyc2VjdGlvblR5cGVcInx8dS50eXBlPT09XCJUU1VuaW9uVHlwZVwiKSYmdS50eXBlcy5sZW5ndGg9PT0xKXJldHVybiBhLnR5cGVzWzBdfXIuaWdub3JlZFByb3BlcnRpZXM9cyxuLmV4cG9ydHM9cn19KSxWaT17fTtrbihWaSx7RU9MOigpPT53bixhcmNoOigpPT5DbSxjcHVzOigpPT56aSxkZWZhdWx0OigpPT5aaSxlbmRpYW5uZXNzOigpPT5XaSxmcmVlbWVtOigpPT5KaSxnZXROZXR3b3JrSW50ZXJmYWNlczooKT0+UWksaG9zdG5hbWU6KCk9PiRpLGxvYWRhdmc6KCk9PkhpLG5ldHdvcmtJbnRlcmZhY2VzOigpPT5ZaSxwbGF0Zm9ybTooKT0+RW0scmVsZWFzZTooKT0+S2ksdG1wRGlyOigpPT5Cbix0bXBkaXI6KCk9Pk5uLHRvdGFsbWVtOigpPT5VaSx0eXBlOigpPT5YaSx1cHRpbWU6KCk9PkdpfSk7ZnVuY3Rpb24gV2koKXtpZih0eXBlb2YgRnI+XCJ1XCIpe3ZhciBlPW5ldyBBcnJheUJ1ZmZlcigyKSxuPW5ldyBVaW50OEFycmF5KGUpLHQ9bmV3IFVpbnQxNkFycmF5KGUpO2lmKG5bMF09MSxuWzFdPTIsdFswXT09PTI1OClGcj1cIkJFXCI7ZWxzZSBpZih0WzBdPT09NTEzKUZyPVwiTEVcIjtlbHNlIHRocm93IG5ldyBFcnJvcihcInVuYWJsZSB0byBmaWd1cmUgb3V0IGVuZGlhbmVzc1wiKX1yZXR1cm4gRnJ9ZnVuY3Rpb24gJGkoKXtyZXR1cm4gdHlwZW9mIGdsb2JhbFRoaXMubG9jYXRpb248XCJ1XCI/Z2xvYmFsVGhpcy5sb2NhdGlvbi5ob3N0bmFtZTpcIlwifWZ1bmN0aW9uIEhpKCl7cmV0dXJuW119ZnVuY3Rpb24gR2koKXtyZXR1cm4gMH1mdW5jdGlvbiBKaSgpe3JldHVybiBOdW1iZXIuTUFYX1ZBTFVFfWZ1bmN0aW9uIFVpKCl7cmV0dXJuIE51bWJlci5NQVhfVkFMVUV9ZnVuY3Rpb24gemkoKXtyZXR1cm5bXX1mdW5jdGlvbiBYaSgpe3JldHVyblwiQnJvd3NlclwifWZ1bmN0aW9uIEtpKCl7cmV0dXJuIHR5cGVvZiBnbG9iYWxUaGlzLm5hdmlnYXRvcjxcInVcIj9nbG9iYWxUaGlzLm5hdmlnYXRvci5hcHBWZXJzaW9uOlwiXCJ9ZnVuY3Rpb24gWWkoKXt9ZnVuY3Rpb24gUWkoKXt9ZnVuY3Rpb24gQ20oKXtyZXR1cm5cImphdmFzY3JpcHRcIn1mdW5jdGlvbiBFbSgpe3JldHVyblwiYnJvd3NlclwifWZ1bmN0aW9uIEJuKCl7cmV0dXJuXCIvdG1wXCJ9dmFyIEZyLE5uLHduLFppLHZtPWJyKHtcIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHM6b3NcIigpe2FlKCksTm49Qm4sd249YFxuYCxaaT17RU9MOnduLHRtcGRpcjpObix0bXBEaXI6Qm4sbmV0d29ya0ludGVyZmFjZXM6WWksZ2V0TmV0d29ya0ludGVyZmFjZXM6UWkscmVsZWFzZTpLaSx0eXBlOlhpLGNwdXM6emksdG90YWxtZW06VWksZnJlZW1lbTpKaSx1cHRpbWU6R2ksbG9hZGF2ZzpIaSxob3N0bmFtZTokaSxlbmRpYW5uZXNzOldpfX19KSxGbT1aKHtcIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHMtY29tbW9uanM6b3NcIihlLG4pe2FlKCk7dmFyIHQ9KHZtKCkscHQoVmkpKTtpZih0JiZ0LmRlZmF1bHQpe24uZXhwb3J0cz10LmRlZmF1bHQ7Zm9yKGxldCBzIGluIHQpbi5leHBvcnRzW3NdPXRbc119ZWxzZSB0JiYobi5leHBvcnRzPXQpfX0pLEFtPVooe1wibm9kZV9tb2R1bGVzL2RldGVjdC1uZXdsaW5lL2luZGV4LmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PXM9PntpZih0eXBlb2YgcyE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIik7bGV0IGk9cy5tYXRjaCgvKD86XFxyP1xcbikvZyl8fFtdO2lmKGkubGVuZ3RoPT09MClyZXR1cm47bGV0IHI9aS5maWx0ZXIoYT0+YT09PWBcXHJcbmApLmxlbmd0aCx1PWkubGVuZ3RoLXI7cmV0dXJuIHI+dT9gXFxyXG5gOmBcbmB9O24uZXhwb3J0cz10LG4uZXhwb3J0cy5ncmFjZWZ1bD1zPT50eXBlb2Ygcz09XCJzdHJpbmdcIiYmdChzKXx8YFxuYH19KSxTbT1aKHtcIm5vZGVfbW9kdWxlcy9qZXN0LWRvY2Jsb2NrL2J1aWxkL2luZGV4LmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7YWUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmV4dHJhY3Q9cCxlLnBhcnNlPWgsZS5wYXJzZVdpdGhDb21tZW50cz1OLGUucHJpbnQ9VCxlLnN0cmlwPWY7ZnVuY3Rpb24gbigpe2xldCBiPUZtKCk7cmV0dXJuIG49ZnVuY3Rpb24oKXtyZXR1cm4gYn0sYn1mdW5jdGlvbiB0KCl7bGV0IGI9cyhBbSgpKTtyZXR1cm4gdD1mdW5jdGlvbigpe3JldHVybiBifSxifWZ1bmN0aW9uIHMoYil7cmV0dXJuIGImJmIuX19lc01vZHVsZT9iOntkZWZhdWx0OmJ9fXZhciBpPS9cXCpcXC8kLyxyPS9eXFwvXFwqXFwqLyx1PS9eXFxzKihcXC9cXCpcXCo/KC58XFxyP1xcbikqP1xcKlxcLykvLGE9LyhefFxccyspXFwvXFwvKFteXFxyXFxuXSopL2csYz0vXihcXHI/XFxuKSsvLGw9Lyg/Ol58XFxyP1xcbikgKihAW15cXHJcXG5dKj8pICpcXHI/XFxuICooPyFbXkBcXHJcXG5dKlxcL1xcL1teXSopKFteQFxcclxcblxcc11bXkBcXHJcXG5dKz8pICpcXHI/XFxuL2csQz0vKD86XnxcXHI/XFxuKSAqQChcXFMrKSAqKFteXFxyXFxuXSopL2csbT0vKFxccj9cXG58XikgKlxcKiA/L2csZz1bXTtmdW5jdGlvbiBwKGIpe2xldCB2PWIubWF0Y2godSk7cmV0dXJuIHY/dlswXS50cmltTGVmdCgpOlwiXCJ9ZnVuY3Rpb24gZihiKXtsZXQgdj1iLm1hdGNoKHUpO3JldHVybiB2JiZ2WzBdP2Iuc3Vic3RyaW5nKHZbMF0ubGVuZ3RoKTpifWZ1bmN0aW9uIGgoYil7cmV0dXJuIE4oYikucHJhZ21hc31mdW5jdGlvbiBOKGIpe2xldCB2PSgwLHQoKS5kZWZhdWx0KShiKXx8bigpLkVPTDtiPWIucmVwbGFjZShyLFwiXCIpLnJlcGxhY2UoaSxcIlwiKS5yZXBsYWNlKG0sXCIkMVwiKTtsZXQgQj1cIlwiO2Zvcig7QiE9PWI7KUI9YixiPWIucmVwbGFjZShsLFwiXCIuY29uY2F0KHYsXCIkMSAkMlwiKS5jb25jYXQodikpO2I9Yi5yZXBsYWNlKGMsXCJcIikudHJpbVJpZ2h0KCk7bGV0IHc9T2JqZWN0LmNyZWF0ZShudWxsKSxJPWIucmVwbGFjZShDLFwiXCIpLnJlcGxhY2UoYyxcIlwiKS50cmltUmlnaHQoKSxFO2Zvcig7RT1DLmV4ZWMoYik7KXtsZXQgRD1FWzJdLnJlcGxhY2UoYSxcIlwiKTt0eXBlb2Ygd1tFWzFdXT09XCJzdHJpbmdcInx8QXJyYXkuaXNBcnJheSh3W0VbMV1dKT93W0VbMV1dPWcuY29uY2F0KHdbRVsxXV0sRCk6d1tFWzFdXT1EfXJldHVybntjb21tZW50czpJLHByYWdtYXM6d319ZnVuY3Rpb24gVChiKXtsZXR7Y29tbWVudHM6dj1cIlwiLHByYWdtYXM6Qj17fX09Yix3PSgwLHQoKS5kZWZhdWx0KSh2KXx8bigpLkVPTCxJPVwiLyoqXCIsRT1cIiAqXCIsRD1cIiAqL1wiLGQ9T2JqZWN0LmtleXMoQikseT1kLm1hcCh4PT5BKHgsQlt4XSkpLnJlZHVjZSgoeCxGKT0+eC5jb25jYXQoRiksW10pLm1hcCh4PT5FK1wiIFwiK3grdykuam9pbihcIlwiKTtpZighdil7aWYoZC5sZW5ndGg9PT0wKXJldHVyblwiXCI7aWYoZC5sZW5ndGg9PT0xJiYhQXJyYXkuaXNBcnJheShCW2RbMF1dKSl7bGV0IHg9QltkWzBdXTtyZXR1cm5cIlwiLmNvbmNhdChJLFwiIFwiKS5jb25jYXQoQShkWzBdLHgpWzBdKS5jb25jYXQoRCl9fWxldCBvPXYuc3BsaXQodykubWFwKHg9PlwiXCIuY29uY2F0KEUsXCIgXCIpLmNvbmNhdCh4KSkuam9pbih3KSt3O3JldHVybiBJK3crKHY/bzpcIlwiKSsodiYmZC5sZW5ndGg/RSt3OlwiXCIpK3krRH1mdW5jdGlvbiBBKGIsdil7cmV0dXJuIGcuY29uY2F0KHYpLm1hcChCPT5cIkBcIi5jb25jYXQoYixcIiBcIikuY29uY2F0KEIpLnRyaW0oKSl9fX0pLHhtPVooe1wic3JjL2xhbmd1YWdlLWpzL3V0aWxzL2dldC1zaGViYW5nLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO2Z1bmN0aW9uIHQocyl7aWYoIXMuc3RhcnRzV2l0aChcIiMhXCIpKXJldHVyblwiXCI7bGV0IGk9cy5pbmRleE9mKGBcbmApO3JldHVybiBpPT09LTE/czpzLnNsaWNlKDAsaSl9bi5leHBvcnRzPXR9fSksZW89Wih7XCJzcmMvbGFuZ3VhZ2UtanMvcHJhZ21hLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntwYXJzZVdpdGhDb21tZW50czp0LHN0cmlwOnMsZXh0cmFjdDppLHByaW50OnJ9PVNtKCkse25vcm1hbGl6ZUVuZE9mTGluZTp1fT1PbigpLGE9eG0oKTtmdW5jdGlvbiBjKG0pe2xldCBnPWEobSk7ZyYmKG09bS5zbGljZShnLmxlbmd0aCsxKSk7bGV0IHA9aShtKSx7cHJhZ21hczpmLGNvbW1lbnRzOmh9PXQocCk7cmV0dXJue3NoZWJhbmc6Zyx0ZXh0Om0scHJhZ21hczpmLGNvbW1lbnRzOmh9fWZ1bmN0aW9uIGwobSl7bGV0IGc9T2JqZWN0LmtleXMoYyhtKS5wcmFnbWFzKTtyZXR1cm4gZy5pbmNsdWRlcyhcInByZXR0aWVyXCIpfHxnLmluY2x1ZGVzKFwiZm9ybWF0XCIpfWZ1bmN0aW9uIEMobSl7bGV0e3NoZWJhbmc6Zyx0ZXh0OnAscHJhZ21hczpmLGNvbW1lbnRzOmh9PWMobSksTj1zKHApLFQ9cih7cHJhZ21hczpPYmplY3QuYXNzaWduKHtmb3JtYXQ6XCJcIn0sZiksY29tbWVudHM6aC50cmltU3RhcnQoKX0pO3JldHVybihnP1wiXCIuY29uY2F0KGcsYFxuYCk6XCJcIikrdShUKSsoTi5zdGFydHNXaXRoKGBcbmApP2BcbmA6YFxuXG5gKStOfW4uZXhwb3J0cz17aGFzUHJhZ21hOmwsaW5zZXJ0UHJhZ21hOkN9fX0pLHRvPVooe1wic3JjL2xhbmd1YWdlLWpzL2NvbW1lbnRzLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntnZXRMYXN0OnQsaGFzTmV3bGluZTpzLGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4OmksZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlcjpyLGhhc05ld2xpbmVJblJhbmdlOnUsYWRkTGVhZGluZ0NvbW1lbnQ6YSxhZGRUcmFpbGluZ0NvbW1lbnQ6YyxhZGREYW5nbGluZ0NvbW1lbnQ6bCxnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXg6Qyxpc05vbkVtcHR5QXJyYXk6bX09R2UoKSx7Z2V0RnVuY3Rpb25QYXJhbWV0ZXJzOmcsaXNQcmV0dGllcklnbm9yZUNvbW1lbnQ6cCxpc0pzeE5vZGU6ZixoYXNGbG93U2hvcnRoYW5kQW5ub3RhdGlvbkNvbW1lbnQ6aCxoYXNGbG93QW5ub3RhdGlvbkNvbW1lbnQ6TixoYXNJZ25vcmVDb21tZW50OlQsaXNDYWxsTGlrZUV4cHJlc3Npb246QSxnZXRDYWxsQXJndW1lbnRzOmIsaXNDYWxsRXhwcmVzc2lvbjp2LGlzTWVtYmVyRXhwcmVzc2lvbjpCLGlzT2JqZWN0UHJvcGVydHk6dyxpc0xpbmVDb21tZW50OkksZ2V0Q29tbWVudHM6RSxDb21tZW50Q2hlY2tGbGFnczpELG1hcmtlckZvcklmV2l0aG91dEJsb2NrQW5kU2FtZUxpbmVDb21tZW50OmR9PVhlKCkse2xvY1N0YXJ0OnksbG9jRW5kOm99PW50KCkseD1QdCgpO2Z1bmN0aW9uIEYoWCl7cmV0dXJuW2ZlLFYsRyxNLEgsUCxXLG9lLGRlLGxlLFEsZ2UsdmUsZWUsSyxFZV0uc29tZShZPT5ZKFgpKX1mdW5jdGlvbiBTKFgpe3JldHVybltSLFYscmUsb2UsTSxILFAsVyxLLHEsdWUsUSx4ZSxFZSxtZV0uc29tZShZPT5ZKFgpKX1mdW5jdGlvbiBrKFgpe3JldHVybltmZSxNLEgsJCxzZSxlZSxRLG5lLFUscGUsRWUsd2VdLnNvbWUoWT0+WShYKSl9ZnVuY3Rpb24gXyhYLFkpe2xldCB0ZT0oWC5ib2R5fHxYLnByb3BlcnRpZXMpLmZpbmQoej0+e2xldHt0eXBlOmp9PXo7cmV0dXJuIGohPT1cIkVtcHR5U3RhdGVtZW50XCJ9KTt0ZT9hKHRlLFkpOmwoWCxZKX1mdW5jdGlvbiBPKFgsWSl7WC50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwiP18oWCxZKTphKFgsWSl9ZnVuY3Rpb24gUihYKXtsZXR7Y29tbWVudDpZLGZvbGxvd2luZ05vZGU6dGV9PVg7cmV0dXJuIHRlJiZKKFkpPyhhKHRlLFkpLCEwKTohMX1mdW5jdGlvbiBNKFgpe2xldHtjb21tZW50OlkscHJlY2VkaW5nTm9kZTp0ZSxlbmNsb3NpbmdOb2RlOnosZm9sbG93aW5nTm9kZTpqLHRleHQ6Q2V9PVg7aWYoIXp8fHoudHlwZSE9PVwiSWZTdGF0ZW1lbnRcInx8IWopcmV0dXJuITE7aWYocihDZSxZLG8pPT09XCIpXCIpcmV0dXJuIGModGUsWSksITA7aWYodGU9PT16LmNvbnNlcXVlbnQmJmo9PT16LmFsdGVybmF0ZSl7aWYodGUudHlwZT09PVwiQmxvY2tTdGF0ZW1lbnRcIiljKHRlLFkpO2Vsc2V7bGV0IGplPVkudHlwZT09PVwiU2luZ2xlTGluZVwifHxZLmxvYy5zdGFydC5saW5lPT09WS5sb2MuZW5kLmxpbmUsVWU9WS5sb2Muc3RhcnQubGluZT09PXRlLmxvYy5zdGFydC5saW5lO2plJiZVZT9sKHRlLFksZCk6bCh6LFkpfXJldHVybiEwfXJldHVybiBqLnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCI/KF8oaixZKSwhMCk6ai50eXBlPT09XCJJZlN0YXRlbWVudFwiPyhPKGouY29uc2VxdWVudCxZKSwhMCk6ei5jb25zZXF1ZW50PT09aj8oYShqLFkpLCEwKTohMX1mdW5jdGlvbiBIKFgpe2xldHtjb21tZW50OlkscHJlY2VkaW5nTm9kZTp0ZSxlbmNsb3NpbmdOb2RlOnosZm9sbG93aW5nTm9kZTpqLHRleHQ6Q2V9PVg7cmV0dXJuIXp8fHoudHlwZSE9PVwiV2hpbGVTdGF0ZW1lbnRcInx8IWo/ITE6cihDZSxZLG8pPT09XCIpXCI/KGModGUsWSksITApOmoudHlwZT09PVwiQmxvY2tTdGF0ZW1lbnRcIj8oXyhqLFkpLCEwKTp6LmJvZHk9PT1qPyhhKGosWSksITApOiExfWZ1bmN0aW9uIFAoWCl7bGV0e2NvbW1lbnQ6WSxwcmVjZWRpbmdOb2RlOnRlLGVuY2xvc2luZ05vZGU6eixmb2xsb3dpbmdOb2RlOmp9PVg7cmV0dXJuIXp8fHoudHlwZSE9PVwiVHJ5U3RhdGVtZW50XCImJnoudHlwZSE9PVwiQ2F0Y2hDbGF1c2VcInx8IWo/ITE6ei50eXBlPT09XCJDYXRjaENsYXVzZVwiJiZ0ZT8oYyh0ZSxZKSwhMCk6ai50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwiPyhfKGosWSksITApOmoudHlwZT09PVwiVHJ5U3RhdGVtZW50XCI/KE8oai5maW5hbGl6ZXIsWSksITApOmoudHlwZT09PVwiQ2F0Y2hDbGF1c2VcIj8oTyhqLmJvZHksWSksITApOiExfWZ1bmN0aW9uIEcoWCl7bGV0e2NvbW1lbnQ6WSxlbmNsb3NpbmdOb2RlOnRlLGZvbGxvd2luZ05vZGU6en09WDtyZXR1cm4gQih0ZSkmJnomJnoudHlwZT09PVwiSWRlbnRpZmllclwiPyhhKHRlLFkpLCEwKTohMX1mdW5jdGlvbiByZShYKXtsZXR7Y29tbWVudDpZLHByZWNlZGluZ05vZGU6dGUsZW5jbG9zaW5nTm9kZTp6LGZvbGxvd2luZ05vZGU6aix0ZXh0OkNlfT1YLE5lPXRlJiYhdShDZSxvKHRlKSx5KFkpKTtyZXR1cm4oIXRlfHwhTmUpJiZ6JiYoei50eXBlPT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cInx8ei50eXBlPT09XCJUU0NvbmRpdGlvbmFsVHlwZVwiKSYmaj8oYShqLFkpLCEwKTohMX1mdW5jdGlvbiAkKFgpe2xldHtjb21tZW50OlkscHJlY2VkaW5nTm9kZTp0ZSxlbmNsb3NpbmdOb2RlOnp9PVg7cmV0dXJuIHcoeikmJnouc2hvcnRoYW5kJiZ6LmtleT09PXRlJiZ6LnZhbHVlLnR5cGU9PT1cIkFzc2lnbm1lbnRQYXR0ZXJuXCI/KGMoei52YWx1ZS5sZWZ0LFkpLCEwKTohMX1mdW5jdGlvbiBXKFgpe2xldHtjb21tZW50OlkscHJlY2VkaW5nTm9kZTp0ZSxlbmNsb3NpbmdOb2RlOnosZm9sbG93aW5nTm9kZTpqfT1YO2lmKHomJih6LnR5cGU9PT1cIkNsYXNzRGVjbGFyYXRpb25cInx8ei50eXBlPT09XCJDbGFzc0V4cHJlc3Npb25cInx8ei50eXBlPT09XCJEZWNsYXJlQ2xhc3NcInx8ei50eXBlPT09XCJEZWNsYXJlSW50ZXJmYWNlXCJ8fHoudHlwZT09PVwiSW50ZXJmYWNlRGVjbGFyYXRpb25cInx8ei50eXBlPT09XCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIpKXtpZihtKHouZGVjb3JhdG9ycykmJiEoaiYmai50eXBlPT09XCJEZWNvcmF0b3JcIikpcmV0dXJuIGModCh6LmRlY29yYXRvcnMpLFkpLCEwO2lmKHouYm9keSYmaj09PXouYm9keSlyZXR1cm4gXyh6LmJvZHksWSksITA7aWYoail7aWYoei5zdXBlckNsYXNzJiZqPT09ei5zdXBlckNsYXNzJiZ0ZSYmKHRlPT09ei5pZHx8dGU9PT16LnR5cGVQYXJhbWV0ZXJzKSlyZXR1cm4gYyh0ZSxZKSwhMDtmb3IobGV0IENlIG9mW1wiaW1wbGVtZW50c1wiLFwiZXh0ZW5kc1wiLFwibWl4aW5zXCJdKWlmKHpbQ2VdJiZqPT09eltDZV1bMF0pcmV0dXJuIHRlJiYodGU9PT16LmlkfHx0ZT09PXoudHlwZVBhcmFtZXRlcnN8fHRlPT09ei5zdXBlckNsYXNzKT9jKHRlLFkpOmwoeixZLENlKSwhMH19cmV0dXJuITF9ZnVuY3Rpb24gZWUoWCl7bGV0e2NvbW1lbnQ6WSxwcmVjZWRpbmdOb2RlOnRlLGVuY2xvc2luZ05vZGU6eix0ZXh0Omp9PVg7cmV0dXJuIHomJnRlJiZyKGosWSxvKT09PVwiKFwiJiYoei50eXBlPT09XCJQcm9wZXJ0eVwifHx6LnR5cGU9PT1cIlRTRGVjbGFyZU1ldGhvZFwifHx6LnR5cGU9PT1cIlRTQWJzdHJhY3RNZXRob2REZWZpbml0aW9uXCIpJiZ0ZS50eXBlPT09XCJJZGVudGlmaWVyXCImJnoua2V5PT09dGUmJnIoaix0ZSxvKSE9PVwiOlwifHx0ZSYmeiYmdGUudHlwZT09PVwiRGVjb3JhdG9yXCImJih6LnR5cGU9PT1cIkNsYXNzTWV0aG9kXCJ8fHoudHlwZT09PVwiQ2xhc3NQcm9wZXJ0eVwifHx6LnR5cGU9PT1cIlByb3BlcnR5RGVmaW5pdGlvblwifHx6LnR5cGU9PT1cIlRTQWJzdHJhY3RQcm9wZXJ0eURlZmluaXRpb25cInx8ei50eXBlPT09XCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwifHx6LnR5cGU9PT1cIlRTRGVjbGFyZU1ldGhvZFwifHx6LnR5cGU9PT1cIk1ldGhvZERlZmluaXRpb25cIik/KGModGUsWSksITApOiExfWZ1bmN0aW9uIFUoWCl7bGV0e2NvbW1lbnQ6WSxwcmVjZWRpbmdOb2RlOnRlLGVuY2xvc2luZ05vZGU6eix0ZXh0Omp9PVg7cmV0dXJuIHIoaixZLG8pIT09XCIoXCI/ITE6dGUmJnomJih6LnR5cGU9PT1cIkZ1bmN0aW9uRGVjbGFyYXRpb25cInx8ei50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cInx8ei50eXBlPT09XCJDbGFzc01ldGhvZFwifHx6LnR5cGU9PT1cIk1ldGhvZERlZmluaXRpb25cInx8ei50eXBlPT09XCJPYmplY3RNZXRob2RcIik/KGModGUsWSksITApOiExfWZ1bmN0aW9uIG5lKFgpe2xldHtjb21tZW50OlksZW5jbG9zaW5nTm9kZTp0ZSx0ZXh0Onp9PVg7aWYoISh0ZSYmdGUudHlwZT09PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikpcmV0dXJuITE7bGV0IGo9Qyh6LFksbyk7cmV0dXJuIGohPT0hMSYmei5zbGljZShqLGorMik9PT1cIj0+XCI/KGwodGUsWSksITApOiExfWZ1bmN0aW9uIHNlKFgpe2xldHtjb21tZW50OlksZW5jbG9zaW5nTm9kZTp0ZSx0ZXh0Onp9PVg7cmV0dXJuIHIoeixZLG8pIT09XCIpXCI/ITE6dGUmJihjZSh0ZSkmJmcodGUpLmxlbmd0aD09PTB8fEEodGUpJiZiKHRlKS5sZW5ndGg9PT0wKT8obCh0ZSxZKSwhMCk6dGUmJih0ZS50eXBlPT09XCJNZXRob2REZWZpbml0aW9uXCJ8fHRlLnR5cGU9PT1cIlRTQWJzdHJhY3RNZXRob2REZWZpbml0aW9uXCIpJiZnKHRlLnZhbHVlKS5sZW5ndGg9PT0wPyhsKHRlLnZhbHVlLFkpLCEwKTohMX1mdW5jdGlvbiBWKFgpe2xldHtjb21tZW50OlkscHJlY2VkaW5nTm9kZTp0ZSxlbmNsb3NpbmdOb2RlOnosZm9sbG93aW5nTm9kZTpqLHRleHQ6Q2V9PVg7aWYodGUmJnRlLnR5cGU9PT1cIkZ1bmN0aW9uVHlwZVBhcmFtXCImJnomJnoudHlwZT09PVwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiJiZqJiZqLnR5cGUhPT1cIkZ1bmN0aW9uVHlwZVBhcmFtXCJ8fHRlJiYodGUudHlwZT09PVwiSWRlbnRpZmllclwifHx0ZS50eXBlPT09XCJBc3NpZ25tZW50UGF0dGVyblwiKSYmeiYmY2UoeikmJnIoQ2UsWSxvKT09PVwiKVwiKXJldHVybiBjKHRlLFkpLCEwO2lmKHomJnoudHlwZT09PVwiRnVuY3Rpb25EZWNsYXJhdGlvblwiJiZqJiZqLnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCIpe2xldCBOZT0oKCk9PntsZXQgamU9Zyh6KTtpZihqZS5sZW5ndGg+MClyZXR1cm4gaShDZSxvKHQoamUpKSk7bGV0IFVlPWkoQ2Usbyh6LmlkKSk7cmV0dXJuIFVlIT09ITEmJmkoQ2UsVWUrMSl9KSgpO2lmKHkoWSk+TmUpcmV0dXJuIF8oaixZKSwhMH1yZXR1cm4hMX1mdW5jdGlvbiBvZShYKXtsZXR7Y29tbWVudDpZLGVuY2xvc2luZ05vZGU6dGV9PVg7cmV0dXJuIHRlJiZ0ZS50eXBlPT09XCJJbXBvcnRTcGVjaWZpZXJcIj8oYSh0ZSxZKSwhMCk6ITF9ZnVuY3Rpb24gSyhYKXtsZXR7Y29tbWVudDpZLGVuY2xvc2luZ05vZGU6dGV9PVg7cmV0dXJuIHRlJiZ0ZS50eXBlPT09XCJMYWJlbGVkU3RhdGVtZW50XCI/KGEodGUsWSksITApOiExfWZ1bmN0aW9uIEVlKFgpe2xldHtjb21tZW50OlksZW5jbG9zaW5nTm9kZTp0ZX09WDtyZXR1cm4gdGUmJih0ZS50eXBlPT09XCJDb250aW51ZVN0YXRlbWVudFwifHx0ZS50eXBlPT09XCJCcmVha1N0YXRlbWVudFwiKSYmIXRlLmxhYmVsPyhjKHRlLFkpLCEwKTohMX1mdW5jdGlvbiBxKFgpe2xldHtjb21tZW50OlkscHJlY2VkaW5nTm9kZTp0ZSxlbmNsb3NpbmdOb2RlOnp9PVg7cmV0dXJuIHYoeikmJnRlJiZ6LmNhbGxlZT09PXRlJiZ6LmFyZ3VtZW50cy5sZW5ndGg+MD8oYSh6LmFyZ3VtZW50c1swXSxZKSwhMCk6ITF9ZnVuY3Rpb24gbGUoWCl7bGV0e2NvbW1lbnQ6WSxwcmVjZWRpbmdOb2RlOnRlLGVuY2xvc2luZ05vZGU6eixmb2xsb3dpbmdOb2RlOmp9PVg7cmV0dXJuIHomJih6LnR5cGU9PT1cIlVuaW9uVHlwZUFubm90YXRpb25cInx8ei50eXBlPT09XCJUU1VuaW9uVHlwZVwiKT8ocChZKSYmKGoucHJldHRpZXJJZ25vcmU9ITAsWS51bmlnbm9yZT0hMCksdGU/KGModGUsWSksITApOiExKTooaiYmKGoudHlwZT09PVwiVW5pb25UeXBlQW5ub3RhdGlvblwifHxqLnR5cGU9PT1cIlRTVW5pb25UeXBlXCIpJiZwKFkpJiYoai50eXBlc1swXS5wcmV0dGllcklnbm9yZT0hMCxZLnVuaWdub3JlPSEwKSwhMSl9ZnVuY3Rpb24gdWUoWCl7bGV0e2NvbW1lbnQ6WSxlbmNsb3NpbmdOb2RlOnRlfT1YO3JldHVybiB3KHRlKT8oYSh0ZSxZKSwhMCk6ITF9ZnVuY3Rpb24gUShYKXtsZXR7Y29tbWVudDpZLGVuY2xvc2luZ05vZGU6dGUsZm9sbG93aW5nTm9kZTp6LGFzdDpqLGlzTGFzdENvbW1lbnQ6Q2V9PVg7cmV0dXJuIGomJmouYm9keSYmai5ib2R5Lmxlbmd0aD09PTA/KENlP2woaixZKTphKGosWSksITApOnRlJiZ0ZS50eXBlPT09XCJQcm9ncmFtXCImJnRlLmJvZHkubGVuZ3RoPT09MCYmIW0odGUuZGlyZWN0aXZlcyk/KENlP2wodGUsWSk6YSh0ZSxZKSwhMCk6eiYmei50eXBlPT09XCJQcm9ncmFtXCImJnouYm9keS5sZW5ndGg9PT0wJiZ0ZSYmdGUudHlwZT09PVwiTW9kdWxlRXhwcmVzc2lvblwiPyhsKHosWSksITApOiExfWZ1bmN0aW9uIGRlKFgpe2xldHtjb21tZW50OlksZW5jbG9zaW5nTm9kZTp0ZX09WDtyZXR1cm4gdGUmJih0ZS50eXBlPT09XCJGb3JJblN0YXRlbWVudFwifHx0ZS50eXBlPT09XCJGb3JPZlN0YXRlbWVudFwiKT8oYSh0ZSxZKSwhMCk6ITF9ZnVuY3Rpb24gZ2UoWCl7bGV0e2NvbW1lbnQ6WSxwcmVjZWRpbmdOb2RlOnRlLGVuY2xvc2luZ05vZGU6eix0ZXh0Omp9PVg7cmV0dXJuIHRlJiZ0ZS50eXBlPT09XCJJbXBvcnRTcGVjaWZpZXJcIiYmeiYmei50eXBlPT09XCJJbXBvcnREZWNsYXJhdGlvblwiJiZzKGosbyhZKSk/KGModGUsWSksITApOiExfWZ1bmN0aW9uIHZlKFgpe2xldHtjb21tZW50OlksZW5jbG9zaW5nTm9kZTp0ZX09WDtyZXR1cm4gdGUmJnRlLnR5cGU9PT1cIkFzc2lnbm1lbnRQYXR0ZXJuXCI/KGEodGUsWSksITApOiExfWZ1bmN0aW9uIHhlKFgpe2xldHtjb21tZW50OlksZW5jbG9zaW5nTm9kZTp0ZSxmb2xsb3dpbmdOb2RlOnp9PVg7cmV0dXJuIHRlJiYodGUudHlwZT09PVwiVmFyaWFibGVEZWNsYXJhdG9yXCJ8fHRlLnR5cGU9PT1cIkFzc2lnbm1lbnRFeHByZXNzaW9uXCJ8fHRlLnR5cGU9PT1cIlR5cGVBbGlhc1wifHx0ZS50eXBlPT09XCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIpJiZ6JiYoei50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCJ8fHoudHlwZT09PVwiQXJyYXlFeHByZXNzaW9uXCJ8fHoudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCJ8fHoudHlwZT09PVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCJ8fHoudHlwZT09PVwiT2JqZWN0VHlwZUFubm90YXRpb25cInx8ei50eXBlPT09XCJUU1R5cGVMaXRlcmFsXCJ8fHgoWSkpPyhhKHosWSksITApOiExfWZ1bmN0aW9uIHdlKFgpe2xldHtjb21tZW50OlksZW5jbG9zaW5nTm9kZTp0ZSxmb2xsb3dpbmdOb2RlOnosdGV4dDpqfT1YO3JldHVybiF6JiZ0ZSYmKHRlLnR5cGU9PT1cIlRTTWV0aG9kU2lnbmF0dXJlXCJ8fHRlLnR5cGU9PT1cIlRTRGVjbGFyZUZ1bmN0aW9uXCJ8fHRlLnR5cGU9PT1cIlRTQWJzdHJhY3RNZXRob2REZWZpbml0aW9uXCIpJiZyKGosWSxvKT09PVwiO1wiPyhjKHRlLFkpLCEwKTohMX1mdW5jdGlvbiBmZShYKXtsZXR7Y29tbWVudDpZLGVuY2xvc2luZ05vZGU6dGUsZm9sbG93aW5nTm9kZTp6fT1YO2lmKHAoWSkmJnRlJiZ0ZS50eXBlPT09XCJUU01hcHBlZFR5cGVcIiYmeiYmei50eXBlPT09XCJUU1R5cGVQYXJhbWV0ZXJcIiYmei5jb25zdHJhaW50KXJldHVybiB0ZS5wcmV0dGllcklnbm9yZT0hMCxZLnVuaWdub3JlPSEwLCEwfWZ1bmN0aW9uIHBlKFgpe2xldHtjb21tZW50OlkscHJlY2VkaW5nTm9kZTp0ZSxlbmNsb3NpbmdOb2RlOnosZm9sbG93aW5nTm9kZTpqfT1YO3JldHVybiF6fHx6LnR5cGUhPT1cIlRTTWFwcGVkVHlwZVwiPyExOmomJmoudHlwZT09PVwiVFNUeXBlUGFyYW1ldGVyXCImJmoubmFtZT8oYShqLm5hbWUsWSksITApOnRlJiZ0ZS50eXBlPT09XCJUU1R5cGVQYXJhbWV0ZXJcIiYmdGUuY29uc3RyYWludD8oYyh0ZS5jb25zdHJhaW50LFkpLCEwKTohMX1mdW5jdGlvbiBtZShYKXtsZXR7Y29tbWVudDpZLGVuY2xvc2luZ05vZGU6dGUsZm9sbG93aW5nTm9kZTp6fT1YO3JldHVybiF0ZXx8dGUudHlwZSE9PVwiU3dpdGNoQ2FzZVwifHx0ZS50ZXN0PyExOih6LnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCImJkkoWSk/Xyh6LFkpOmwodGUsWSksITApfWZ1bmN0aW9uIGNlKFgpe3JldHVybiBYLnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCJ8fFgudHlwZT09PVwiRnVuY3Rpb25FeHByZXNzaW9uXCJ8fFgudHlwZT09PVwiRnVuY3Rpb25EZWNsYXJhdGlvblwifHxYLnR5cGU9PT1cIk9iamVjdE1ldGhvZFwifHxYLnR5cGU9PT1cIkNsYXNzTWV0aG9kXCJ8fFgudHlwZT09PVwiVFNEZWNsYXJlRnVuY3Rpb25cInx8WC50eXBlPT09XCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwifHxYLnR5cGU9PT1cIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cInx8WC50eXBlPT09XCJUU01ldGhvZFNpZ25hdHVyZVwifHxYLnR5cGU9PT1cIlRTQ29uc3RydWN0b3JUeXBlXCJ8fFgudHlwZT09PVwiVFNGdW5jdGlvblR5cGVcInx8WC50eXBlPT09XCJUU0RlY2xhcmVNZXRob2RcIn1mdW5jdGlvbiBoZShYLFkpe2lmKChZLnBhcnNlcj09PVwidHlwZXNjcmlwdFwifHxZLnBhcnNlcj09PVwiZmxvd1wifHxZLnBhcnNlcj09PVwiYWNvcm5cInx8WS5wYXJzZXI9PT1cImVzcHJlZVwifHxZLnBhcnNlcj09PVwibWVyaXlhaFwifHxZLnBhcnNlcj09PVwiX19iYWJlbF9lc3RyZWVcIikmJlgudHlwZT09PVwiTWV0aG9kRGVmaW5pdGlvblwiJiZYLnZhbHVlJiZYLnZhbHVlLnR5cGU9PT1cIkZ1bmN0aW9uRXhwcmVzc2lvblwiJiZnKFgudmFsdWUpLmxlbmd0aD09PTAmJiFYLnZhbHVlLnJldHVyblR5cGUmJiFtKFgudmFsdWUudHlwZVBhcmFtZXRlcnMpJiZYLnZhbHVlLmJvZHkpcmV0dXJuWy4uLlguZGVjb3JhdG9yc3x8W10sWC5rZXksWC52YWx1ZS5ib2R5XX1mdW5jdGlvbiBKKFgpe3JldHVybiB4KFgpJiZYLnZhbHVlWzBdPT09XCIqXCImJi9AdHlwZVxcYi8udGVzdChYLnZhbHVlKX1mdW5jdGlvbiB5ZShYKXtsZXQgWT1YLmdldFZhbHVlKCksdGU9WC5nZXRQYXJlbnROb2RlKCksej1qPT5OKEUoaixELkxlYWRpbmcpKXx8TihFKGosRC5UcmFpbGluZykpO3JldHVybihZJiYoZihZKXx8aChZKXx8dih0ZSkmJnooWSkpfHx0ZSYmKHRlLnR5cGU9PT1cIkpTWFNwcmVhZEF0dHJpYnV0ZVwifHx0ZS50eXBlPT09XCJKU1hTcHJlYWRDaGlsZFwifHx0ZS50eXBlPT09XCJVbmlvblR5cGVBbm5vdGF0aW9uXCJ8fHRlLnR5cGU9PT1cIlRTVW5pb25UeXBlXCJ8fCh0ZS50eXBlPT09XCJDbGFzc0RlY2xhcmF0aW9uXCJ8fHRlLnR5cGU9PT1cIkNsYXNzRXhwcmVzc2lvblwiKSYmdGUuc3VwZXJDbGFzcz09PVkpKSYmKCFUKFgpfHx0ZS50eXBlPT09XCJVbmlvblR5cGVBbm5vdGF0aW9uXCJ8fHRlLnR5cGU9PT1cIlRTVW5pb25UeXBlXCIpfW4uZXhwb3J0cz17aGFuZGxlT3duTGluZUNvbW1lbnQ6RixoYW5kbGVFbmRPZkxpbmVDb21tZW50OlMsaGFuZGxlUmVtYWluaW5nQ29tbWVudDprLGlzVHlwZUNhc3RDb21tZW50OkosZ2V0Q29tbWVudENoaWxkTm9kZXM6aGUsd2lsbFByaW50T3duQ29tbWVudHM6eWV9fX0pLGt0PVooe1wic3JjL2xhbmd1YWdlLWpzL25lZWRzLXBhcmVucy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD1zdCgpLHM9Um4oKSx7Z2V0RnVuY3Rpb25QYXJhbWV0ZXJzOmksZ2V0TGVmdFNpZGVQYXRoTmFtZTpyLGhhc0Zsb3dTaG9ydGhhbmRBbm5vdGF0aW9uQ29tbWVudDp1LGhhc05ha2VkTGVmdFNpZGU6YSxoYXNOb2RlOmMsaXNCaXR3aXNlT3BlcmF0b3I6bCxzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbjpDLHNob3VsZEZsYXR0ZW46bSxnZXRQcmVjZWRlbmNlOmcsaXNDYWxsRXhwcmVzc2lvbjpwLGlzTWVtYmVyRXhwcmVzc2lvbjpmLGlzT2JqZWN0UHJvcGVydHk6aH09WGUoKTtmdW5jdGlvbiBOKEksRSl7bGV0IEQ9SS5nZXRQYXJlbnROb2RlKCk7aWYoIUQpcmV0dXJuITE7bGV0IGQ9SS5nZXROYW1lKCkseT1JLmdldE5vZGUoKTtpZihFLl9faXNJbkh0bWxJbnRlcnBvbGF0aW9uJiYhRS5icmFja2V0U3BhY2luZyYmdih5KSYmQihJKSlyZXR1cm4hMDtpZihUKHkpKXJldHVybiExO2lmKEUucGFyc2VyIT09XCJmbG93XCImJnUoSS5nZXRWYWx1ZSgpKSlyZXR1cm4hMDtpZih5LnR5cGU9PT1cIklkZW50aWZpZXJcIilyZXR1cm4hISh5LmV4dHJhJiZ5LmV4dHJhLnBhcmVudGhlc2l6ZWQmJi9eUFJFVFRJRVJfSFRNTF9QTEFDRUhPTERFUl9cXGQrX1xcZCtfSU5fSlMkLy50ZXN0KHkubmFtZSl8fGQ9PT1cImxlZnRcIiYmeS5uYW1lPT09XCJhc3luY1wiJiZELnR5cGU9PT1cIkZvck9mU3RhdGVtZW50XCImJiFELmF3YWl0KTtzd2l0Y2goRC50eXBlKXtjYXNlXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOnJldHVybiExO2Nhc2VcIkNsYXNzRGVjbGFyYXRpb25cIjpjYXNlXCJDbGFzc0V4cHJlc3Npb25cIjp7aWYoZD09PVwic3VwZXJDbGFzc1wiJiYoeS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwifHx5LnR5cGU9PT1cIkFzc2lnbm1lbnRFeHByZXNzaW9uXCJ8fHkudHlwZT09PVwiQXdhaXRFeHByZXNzaW9uXCJ8fHkudHlwZT09PVwiQmluYXJ5RXhwcmVzc2lvblwifHx5LnR5cGU9PT1cIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwifHx5LnR5cGU9PT1cIkxvZ2ljYWxFeHByZXNzaW9uXCJ8fHkudHlwZT09PVwiTmV3RXhwcmVzc2lvblwifHx5LnR5cGU9PT1cIk9iamVjdEV4cHJlc3Npb25cInx8eS50eXBlPT09XCJTZXF1ZW5jZUV4cHJlc3Npb25cInx8eS50eXBlPT09XCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cInx8eS50eXBlPT09XCJVbmFyeUV4cHJlc3Npb25cInx8eS50eXBlPT09XCJVcGRhdGVFeHByZXNzaW9uXCJ8fHkudHlwZT09PVwiWWllbGRFeHByZXNzaW9uXCJ8fHkudHlwZT09PVwiVFNOb25OdWxsRXhwcmVzc2lvblwiKSlyZXR1cm4hMDticmVha31jYXNlXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIjpyZXR1cm4gdyhJLEUpfHx5LnR5cGU9PT1cIlNlcXVlbmNlRXhwcmVzc2lvblwiO2Nhc2VcIkRlY29yYXRvclwiOntpZihkPT09XCJleHByZXNzaW9uXCIpe2xldCBvPSExLHg9ITEsRj15O2Zvcig7Rjspc3dpdGNoKEYudHlwZSl7Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOng9ITAsRj1GLm9iamVjdDticmVhaztjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmlmKHh8fG8pcmV0dXJuIEUucGFyc2VyIT09XCJ0eXBlc2NyaXB0XCI7bz0hMCxGPUYuY2FsbGVlO2JyZWFrO2Nhc2VcIklkZW50aWZpZXJcIjpyZXR1cm4hMTtjYXNlXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpyZXR1cm4gRS5wYXJzZXIhPT1cInR5cGVzY3JpcHRcIjtkZWZhdWx0OnJldHVybiEwfXJldHVybiEwfWJyZWFrfWNhc2VcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjp7aWYoQyh5LCEwKSlyZXR1cm4hMDticmVha31jYXNlXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOntpZihkPT09XCJib2R5XCImJnkudHlwZSE9PVwiU2VxdWVuY2VFeHByZXNzaW9uXCImJkMoeSwhMSkpcmV0dXJuITA7YnJlYWt9fXN3aXRjaCh5LnR5cGUpe2Nhc2VcIlVwZGF0ZUV4cHJlc3Npb25cIjppZihELnR5cGU9PT1cIlVuYXJ5RXhwcmVzc2lvblwiKXJldHVybiB5LnByZWZpeCYmKHkub3BlcmF0b3I9PT1cIisrXCImJkQub3BlcmF0b3I9PT1cIitcInx8eS5vcGVyYXRvcj09PVwiLS1cIiYmRC5vcGVyYXRvcj09PVwiLVwiKTtjYXNlXCJVbmFyeUV4cHJlc3Npb25cIjpzd2l0Y2goRC50eXBlKXtjYXNlXCJVbmFyeUV4cHJlc3Npb25cIjpyZXR1cm4geS5vcGVyYXRvcj09PUQub3BlcmF0b3ImJih5Lm9wZXJhdG9yPT09XCIrXCJ8fHkub3BlcmF0b3I9PT1cIi1cIik7Y2FzZVwiQmluZEV4cHJlc3Npb25cIjpyZXR1cm4hMDtjYXNlXCJNZW1iZXJFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6cmV0dXJuIGQ9PT1cIm9iamVjdFwiO2Nhc2VcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOnJldHVybiEwO2Nhc2VcIk5ld0V4cHJlc3Npb25cIjpjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpyZXR1cm4gZD09PVwiY2FsbGVlXCI7Y2FzZVwiQmluYXJ5RXhwcmVzc2lvblwiOnJldHVybiBkPT09XCJsZWZ0XCImJkQub3BlcmF0b3I9PT1cIioqXCI7Y2FzZVwiVFNOb25OdWxsRXhwcmVzc2lvblwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9Y2FzZVwiQmluYXJ5RXhwcmVzc2lvblwiOntpZihELnR5cGU9PT1cIlVwZGF0ZUV4cHJlc3Npb25cInx8eS5vcGVyYXRvcj09PVwiaW5cIiYmQShJKSlyZXR1cm4hMDtpZih5Lm9wZXJhdG9yPT09XCJ8PlwiJiZ5LmV4dHJhJiZ5LmV4dHJhLnBhcmVudGhlc2l6ZWQpe2xldCBvPUkuZ2V0UGFyZW50Tm9kZSgxKTtpZihvLnR5cGU9PT1cIkJpbmFyeUV4cHJlc3Npb25cIiYmby5vcGVyYXRvcj09PVwifD5cIilyZXR1cm4hMH19Y2FzZVwiVFNUeXBlQXNzZXJ0aW9uXCI6Y2FzZVwiVFNBc0V4cHJlc3Npb25cIjpjYXNlXCJMb2dpY2FsRXhwcmVzc2lvblwiOnN3aXRjaChELnR5cGUpe2Nhc2VcIlRTQXNFeHByZXNzaW9uXCI6cmV0dXJuIHkudHlwZSE9PVwiVFNBc0V4cHJlc3Npb25cIjtjYXNlXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpyZXR1cm4geS50eXBlPT09XCJUU0FzRXhwcmVzc2lvblwiO2Nhc2VcIkNhbGxFeHByZXNzaW9uXCI6Y2FzZVwiTmV3RXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpyZXR1cm4gZD09PVwiY2FsbGVlXCI7Y2FzZVwiQ2xhc3NFeHByZXNzaW9uXCI6Y2FzZVwiQ2xhc3NEZWNsYXJhdGlvblwiOnJldHVybiBkPT09XCJzdXBlckNsYXNzXCI7Y2FzZVwiVFNUeXBlQXNzZXJ0aW9uXCI6Y2FzZVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6Y2FzZVwiVW5hcnlFeHByZXNzaW9uXCI6Y2FzZVwiSlNYU3ByZWFkQXR0cmlidXRlXCI6Y2FzZVwiU3ByZWFkRWxlbWVudFwiOmNhc2VcIlNwcmVhZFByb3BlcnR5XCI6Y2FzZVwiQmluZEV4cHJlc3Npb25cIjpjYXNlXCJBd2FpdEV4cHJlc3Npb25cIjpjYXNlXCJUU05vbk51bGxFeHByZXNzaW9uXCI6Y2FzZVwiVXBkYXRlRXhwcmVzc2lvblwiOnJldHVybiEwO2Nhc2VcIk1lbWJlckV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpyZXR1cm4gZD09PVwib2JqZWN0XCI7Y2FzZVwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpjYXNlXCJBc3NpZ25tZW50UGF0dGVyblwiOnJldHVybiBkPT09XCJsZWZ0XCImJih5LnR5cGU9PT1cIlRTVHlwZUFzc2VydGlvblwifHx5LnR5cGU9PT1cIlRTQXNFeHByZXNzaW9uXCIpO2Nhc2VcIkxvZ2ljYWxFeHByZXNzaW9uXCI6aWYoeS50eXBlPT09XCJMb2dpY2FsRXhwcmVzc2lvblwiKXJldHVybiBELm9wZXJhdG9yIT09eS5vcGVyYXRvcjtjYXNlXCJCaW5hcnlFeHByZXNzaW9uXCI6e2xldHtvcGVyYXRvcjpvLHR5cGU6eH09eTtpZighbyYmeCE9PVwiVFNUeXBlQXNzZXJ0aW9uXCIpcmV0dXJuITA7bGV0IEY9ZyhvKSxTPUQub3BlcmF0b3Isaz1nKFMpO3JldHVybiBrPkZ8fGQ9PT1cInJpZ2h0XCImJms9PT1GfHxrPT09RiYmIW0oUyxvKT8hMDprPEYmJm89PT1cIiVcIj9TPT09XCIrXCJ8fFM9PT1cIi1cIjohIWwoUyl9ZGVmYXVsdDpyZXR1cm4hMX1jYXNlXCJTZXF1ZW5jZUV4cHJlc3Npb25cIjpzd2l0Y2goRC50eXBlKXtjYXNlXCJSZXR1cm5TdGF0ZW1lbnRcIjpyZXR1cm4hMTtjYXNlXCJGb3JTdGF0ZW1lbnRcIjpyZXR1cm4hMTtjYXNlXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6cmV0dXJuIGQhPT1cImV4cHJlc3Npb25cIjtjYXNlXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOnJldHVybiBkIT09XCJib2R5XCI7ZGVmYXVsdDpyZXR1cm4hMH1jYXNlXCJZaWVsZEV4cHJlc3Npb25cIjppZihELnR5cGU9PT1cIlVuYXJ5RXhwcmVzc2lvblwifHxELnR5cGU9PT1cIkF3YWl0RXhwcmVzc2lvblwifHxELnR5cGU9PT1cIlRTQXNFeHByZXNzaW9uXCJ8fEQudHlwZT09PVwiVFNOb25OdWxsRXhwcmVzc2lvblwiKXJldHVybiEwO2Nhc2VcIkF3YWl0RXhwcmVzc2lvblwiOnN3aXRjaChELnR5cGUpe2Nhc2VcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOmNhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOmNhc2VcIkxvZ2ljYWxFeHByZXNzaW9uXCI6Y2FzZVwiU3ByZWFkRWxlbWVudFwiOmNhc2VcIlNwcmVhZFByb3BlcnR5XCI6Y2FzZVwiVFNBc0V4cHJlc3Npb25cIjpjYXNlXCJUU05vbk51bGxFeHByZXNzaW9uXCI6Y2FzZVwiQmluZEV4cHJlc3Npb25cIjpyZXR1cm4hMDtjYXNlXCJNZW1iZXJFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6cmV0dXJuIGQ9PT1cIm9iamVjdFwiO2Nhc2VcIk5ld0V4cHJlc3Npb25cIjpjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpyZXR1cm4gZD09PVwiY2FsbGVlXCI7Y2FzZVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6cmV0dXJuIGQ9PT1cInRlc3RcIjtjYXNlXCJCaW5hcnlFeHByZXNzaW9uXCI6cmV0dXJuISgheS5hcmd1bWVudCYmRC5vcGVyYXRvcj09PVwifD5cIik7ZGVmYXVsdDpyZXR1cm4hMX1jYXNlXCJUU0NvbmRpdGlvbmFsVHlwZVwiOmlmKGQ9PT1cImV4dGVuZHNUeXBlXCImJkQudHlwZT09PVwiVFNDb25kaXRpb25hbFR5cGVcIilyZXR1cm4hMDtjYXNlXCJUU0Z1bmN0aW9uVHlwZVwiOmNhc2VcIlRTQ29uc3RydWN0b3JUeXBlXCI6aWYoZD09PVwiY2hlY2tUeXBlXCImJkQudHlwZT09PVwiVFNDb25kaXRpb25hbFR5cGVcIilyZXR1cm4hMDtjYXNlXCJUU1VuaW9uVHlwZVwiOmNhc2VcIlRTSW50ZXJzZWN0aW9uVHlwZVwiOmlmKChELnR5cGU9PT1cIlRTVW5pb25UeXBlXCJ8fEQudHlwZT09PVwiVFNJbnRlcnNlY3Rpb25UeXBlXCIpJiZELnR5cGVzLmxlbmd0aD4xJiYoIXkudHlwZXN8fHkudHlwZXMubGVuZ3RoPjEpKXJldHVybiEwO2Nhc2VcIlRTSW5mZXJUeXBlXCI6aWYoeS50eXBlPT09XCJUU0luZmVyVHlwZVwiJiZELnR5cGU9PT1cIlRTUmVzdFR5cGVcIilyZXR1cm4hMTtjYXNlXCJUU1R5cGVPcGVyYXRvclwiOnJldHVybiBELnR5cGU9PT1cIlRTQXJyYXlUeXBlXCJ8fEQudHlwZT09PVwiVFNPcHRpb25hbFR5cGVcInx8RC50eXBlPT09XCJUU1Jlc3RUeXBlXCJ8fGQ9PT1cIm9iamVjdFR5cGVcIiYmRC50eXBlPT09XCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCJ8fEQudHlwZT09PVwiVFNUeXBlT3BlcmF0b3JcInx8RC50eXBlPT09XCJUU1R5cGVBbm5vdGF0aW9uXCImJkkuZ2V0UGFyZW50Tm9kZSgxKS50eXBlLnN0YXJ0c1dpdGgoXCJUU0pTRG9jXCIpO2Nhc2VcIkFycmF5VHlwZUFubm90YXRpb25cIjpyZXR1cm4gRC50eXBlPT09XCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCI7Y2FzZVwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIjpjYXNlXCJVbmlvblR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIEQudHlwZT09PVwiQXJyYXlUeXBlQW5ub3RhdGlvblwifHxELnR5cGU9PT1cIk51bGxhYmxlVHlwZUFubm90YXRpb25cInx8RC50eXBlPT09XCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwifHxELnR5cGU9PT1cIlVuaW9uVHlwZUFubm90YXRpb25cInx8ZD09PVwib2JqZWN0VHlwZVwiJiYoRC50eXBlPT09XCJJbmRleGVkQWNjZXNzVHlwZVwifHxELnR5cGU9PT1cIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIik7Y2FzZVwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiOnJldHVybiBELnR5cGU9PT1cIkFycmF5VHlwZUFubm90YXRpb25cInx8ZD09PVwib2JqZWN0VHlwZVwiJiYoRC50eXBlPT09XCJJbmRleGVkQWNjZXNzVHlwZVwifHxELnR5cGU9PT1cIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIik7Y2FzZVwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiOntsZXQgbz1ELnR5cGU9PT1cIk51bGxhYmxlVHlwZUFubm90YXRpb25cIj9JLmdldFBhcmVudE5vZGUoMSk6RDtyZXR1cm4gby50eXBlPT09XCJVbmlvblR5cGVBbm5vdGF0aW9uXCJ8fG8udHlwZT09PVwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cInx8by50eXBlPT09XCJBcnJheVR5cGVBbm5vdGF0aW9uXCJ8fGQ9PT1cIm9iamVjdFR5cGVcIiYmKG8udHlwZT09PVwiSW5kZXhlZEFjY2Vzc1R5cGVcInx8by50eXBlPT09XCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCIpfHxvLnR5cGU9PT1cIk51bGxhYmxlVHlwZUFubm90YXRpb25cInx8RC50eXBlPT09XCJGdW5jdGlvblR5cGVQYXJhbVwiJiZELm5hbWU9PT1udWxsJiZpKHkpLnNvbWUoeD0+eC50eXBlQW5ub3RhdGlvbiYmeC50eXBlQW5ub3RhdGlvbi50eXBlPT09XCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIpfWNhc2VcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIjpyZXR1cm4gZD09PVwib2JqZWN0VHlwZVwiJiZELnR5cGU9PT1cIkluZGV4ZWRBY2Nlc3NUeXBlXCI7Y2FzZVwiVHlwZW9mVHlwZUFubm90YXRpb25cIjpyZXR1cm4gZD09PVwib2JqZWN0VHlwZVwiJiYoRC50eXBlPT09XCJJbmRleGVkQWNjZXNzVHlwZVwifHxELnR5cGU9PT1cIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIik7Y2FzZVwiU3RyaW5nTGl0ZXJhbFwiOmNhc2VcIk51bWVyaWNMaXRlcmFsXCI6Y2FzZVwiTGl0ZXJhbFwiOmlmKHR5cGVvZiB5LnZhbHVlPT1cInN0cmluZ1wiJiZELnR5cGU9PT1cIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiYmIUQuZGlyZWN0aXZlKXtsZXQgbz1JLmdldFBhcmVudE5vZGUoMSk7cmV0dXJuIG8udHlwZT09PVwiUHJvZ3JhbVwifHxvLnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCJ9cmV0dXJuIGQ9PT1cIm9iamVjdFwiJiZELnR5cGU9PT1cIk1lbWJlckV4cHJlc3Npb25cIiYmdHlwZW9mIHkudmFsdWU9PVwibnVtYmVyXCI7Y2FzZVwiQXNzaWdubWVudEV4cHJlc3Npb25cIjp7bGV0IG89SS5nZXRQYXJlbnROb2RlKDEpO3JldHVybiBkPT09XCJib2R5XCImJkQudHlwZT09PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIj8hMDpkPT09XCJrZXlcIiYmKEQudHlwZT09PVwiQ2xhc3NQcm9wZXJ0eVwifHxELnR5cGU9PT1cIlByb3BlcnR5RGVmaW5pdGlvblwiKSYmRC5jb21wdXRlZHx8KGQ9PT1cImluaXRcInx8ZD09PVwidXBkYXRlXCIpJiZELnR5cGU9PT1cIkZvclN0YXRlbWVudFwiPyExOkQudHlwZT09PVwiRXhwcmVzc2lvblN0YXRlbWVudFwiP3kubGVmdC50eXBlPT09XCJPYmplY3RQYXR0ZXJuXCI6IShkPT09XCJrZXlcIiYmRC50eXBlPT09XCJUU1Byb3BlcnR5U2lnbmF0dXJlXCJ8fEQudHlwZT09PVwiQXNzaWdubWVudEV4cHJlc3Npb25cInx8RC50eXBlPT09XCJTZXF1ZW5jZUV4cHJlc3Npb25cIiYmbyYmby50eXBlPT09XCJGb3JTdGF0ZW1lbnRcIiYmKG8uaW5pdD09PUR8fG8udXBkYXRlPT09RCl8fGQ9PT1cInZhbHVlXCImJkQudHlwZT09PVwiUHJvcGVydHlcIiYmbyYmby50eXBlPT09XCJPYmplY3RQYXR0ZXJuXCImJm8ucHJvcGVydGllcy5pbmNsdWRlcyhEKXx8RC50eXBlPT09XCJOR0NoYWluZWRFeHByZXNzaW9uXCIpfWNhc2VcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOnN3aXRjaChELnR5cGUpe2Nhc2VcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOmNhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOmNhc2VcIlNwcmVhZEVsZW1lbnRcIjpjYXNlXCJTcHJlYWRQcm9wZXJ0eVwiOmNhc2VcIkJpbmFyeUV4cHJlc3Npb25cIjpjYXNlXCJMb2dpY2FsRXhwcmVzc2lvblwiOmNhc2VcIk5HUGlwZUV4cHJlc3Npb25cIjpjYXNlXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIjpjYXNlXCJBd2FpdEV4cHJlc3Npb25cIjpjYXNlXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIjpjYXNlXCJUU1R5cGVBc3NlcnRpb25cIjpjYXNlXCJUeXBlQ2FzdEV4cHJlc3Npb25cIjpjYXNlXCJUU0FzRXhwcmVzc2lvblwiOmNhc2VcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpyZXR1cm4hMDtjYXNlXCJOZXdFeHByZXNzaW9uXCI6Y2FzZVwiQ2FsbEV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6cmV0dXJuIGQ9PT1cImNhbGxlZVwiO2Nhc2VcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOnJldHVybiBkPT09XCJ0ZXN0XCI7Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOnJldHVybiBkPT09XCJvYmplY3RcIjtkZWZhdWx0OnJldHVybiExfWNhc2VcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOnN3aXRjaChELnR5cGUpe2Nhc2VcIk5ld0V4cHJlc3Npb25cIjpjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpyZXR1cm4gZD09PVwiY2FsbGVlXCI7Y2FzZVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX1jYXNlXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOnN3aXRjaChELnR5cGUpe2Nhc2VcIkJpbmFyeUV4cHJlc3Npb25cIjpyZXR1cm4gRC5vcGVyYXRvciE9PVwifD5cInx8eS5leHRyYSYmeS5leHRyYS5wYXJlbnRoZXNpemVkO2Nhc2VcIk5ld0V4cHJlc3Npb25cIjpjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpyZXR1cm4gZD09PVwiY2FsbGVlXCI7Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOnJldHVybiBkPT09XCJvYmplY3RcIjtjYXNlXCJUU0FzRXhwcmVzc2lvblwiOmNhc2VcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpjYXNlXCJCaW5kRXhwcmVzc2lvblwiOmNhc2VcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOmNhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOmNhc2VcIkxvZ2ljYWxFeHByZXNzaW9uXCI6Y2FzZVwiQXdhaXRFeHByZXNzaW9uXCI6Y2FzZVwiVFNUeXBlQXNzZXJ0aW9uXCI6cmV0dXJuITA7Y2FzZVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6cmV0dXJuIGQ9PT1cInRlc3RcIjtkZWZhdWx0OnJldHVybiExfWNhc2VcIkNsYXNzRXhwcmVzc2lvblwiOmlmKHMoeS5kZWNvcmF0b3JzKSlyZXR1cm4hMDtzd2l0Y2goRC50eXBlKXtjYXNlXCJOZXdFeHByZXNzaW9uXCI6cmV0dXJuIGQ9PT1cImNhbGxlZVwiO2RlZmF1bHQ6cmV0dXJuITF9Y2FzZVwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOntsZXQgbz1JLmdldFBhcmVudE5vZGUoMSk7aWYoZD09PVwib2JqZWN0XCImJkQudHlwZT09PVwiTWVtYmVyRXhwcmVzc2lvblwifHxkPT09XCJjYWxsZWVcIiYmKEQudHlwZT09PVwiQ2FsbEV4cHJlc3Npb25cInx8RC50eXBlPT09XCJOZXdFeHByZXNzaW9uXCIpfHxELnR5cGU9PT1cIlRTTm9uTnVsbEV4cHJlc3Npb25cIiYmby50eXBlPT09XCJNZW1iZXJFeHByZXNzaW9uXCImJm8ub2JqZWN0PT09RClyZXR1cm4hMH1jYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIk1lbWJlckV4cHJlc3Npb25cIjpjYXNlXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpjYXNlXCJUU05vbk51bGxFeHByZXNzaW9uXCI6aWYoZD09PVwiY2FsbGVlXCImJihELnR5cGU9PT1cIkJpbmRFeHByZXNzaW9uXCJ8fEQudHlwZT09PVwiTmV3RXhwcmVzc2lvblwiKSl7bGV0IG89eTtmb3IoO287KXN3aXRjaChvLnR5cGUpe2Nhc2VcIkNhbGxFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOnJldHVybiEwO2Nhc2VcIk1lbWJlckV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpjYXNlXCJCaW5kRXhwcmVzc2lvblwiOm89by5vYmplY3Q7YnJlYWs7Y2FzZVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6bz1vLnRhZzticmVhaztjYXNlXCJUU05vbk51bGxFeHByZXNzaW9uXCI6bz1vLmV4cHJlc3Npb247YnJlYWs7ZGVmYXVsdDpyZXR1cm4hMX19cmV0dXJuITE7Y2FzZVwiQmluZEV4cHJlc3Npb25cIjpyZXR1cm4gZD09PVwiY2FsbGVlXCImJihELnR5cGU9PT1cIkJpbmRFeHByZXNzaW9uXCJ8fEQudHlwZT09PVwiTmV3RXhwcmVzc2lvblwiKXx8ZD09PVwib2JqZWN0XCImJmYoRCk7Y2FzZVwiTkdQaXBlRXhwcmVzc2lvblwiOnJldHVybiEoRC50eXBlPT09XCJOR1Jvb3RcInx8RC50eXBlPT09XCJOR01pY3Jvc3ludGF4RXhwcmVzc2lvblwifHxELnR5cGU9PT1cIk9iamVjdFByb3BlcnR5XCImJiEoeS5leHRyYSYmeS5leHRyYS5wYXJlbnRoZXNpemVkKXx8RC50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cInx8cChEKSYmRC5hcmd1bWVudHNbZF09PT15fHxkPT09XCJyaWdodFwiJiZELnR5cGU9PT1cIk5HUGlwZUV4cHJlc3Npb25cInx8ZD09PVwicHJvcGVydHlcIiYmRC50eXBlPT09XCJNZW1iZXJFeHByZXNzaW9uXCJ8fEQudHlwZT09PVwiQXNzaWdubWVudEV4cHJlc3Npb25cIik7Y2FzZVwiSlNYRnJhZ21lbnRcIjpjYXNlXCJKU1hFbGVtZW50XCI6cmV0dXJuIGQ9PT1cImNhbGxlZVwifHxkPT09XCJsZWZ0XCImJkQudHlwZT09PVwiQmluYXJ5RXhwcmVzc2lvblwiJiZELm9wZXJhdG9yPT09XCI8XCJ8fEQudHlwZSE9PVwiQXJyYXlFeHByZXNzaW9uXCImJkQudHlwZSE9PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiYmRC50eXBlIT09XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiJiZELnR5cGUhPT1cIkFzc2lnbm1lbnRQYXR0ZXJuXCImJkQudHlwZSE9PVwiQmluYXJ5RXhwcmVzc2lvblwiJiZELnR5cGUhPT1cIk5ld0V4cHJlc3Npb25cIiYmRC50eXBlIT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiYmRC50eXBlIT09XCJFeHByZXNzaW9uU3RhdGVtZW50XCImJkQudHlwZSE9PVwiSnNFeHByZXNzaW9uUm9vdFwiJiZELnR5cGUhPT1cIkpTWEF0dHJpYnV0ZVwiJiZELnR5cGUhPT1cIkpTWEVsZW1lbnRcIiYmRC50eXBlIT09XCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCImJkQudHlwZSE9PVwiSlNYRnJhZ21lbnRcIiYmRC50eXBlIT09XCJMb2dpY2FsRXhwcmVzc2lvblwiJiYhcChEKSYmIWgoRCkmJkQudHlwZSE9PVwiUmV0dXJuU3RhdGVtZW50XCImJkQudHlwZSE9PVwiVGhyb3dTdGF0ZW1lbnRcIiYmRC50eXBlIT09XCJUeXBlQ2FzdEV4cHJlc3Npb25cIiYmRC50eXBlIT09XCJWYXJpYWJsZURlY2xhcmF0b3JcIiYmRC50eXBlIT09XCJZaWVsZEV4cHJlc3Npb25cIjtjYXNlXCJUeXBlQW5ub3RhdGlvblwiOnJldHVybiBkPT09XCJyZXR1cm5UeXBlXCImJkQudHlwZT09PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiYmYih5KX1yZXR1cm4hMX1mdW5jdGlvbiBUKEkpe3JldHVybiBJLnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCJ8fEkudHlwZT09PVwiQnJlYWtTdGF0ZW1lbnRcInx8SS50eXBlPT09XCJDbGFzc0JvZHlcInx8SS50eXBlPT09XCJDbGFzc0RlY2xhcmF0aW9uXCJ8fEkudHlwZT09PVwiQ2xhc3NNZXRob2RcInx8SS50eXBlPT09XCJDbGFzc1Byb3BlcnR5XCJ8fEkudHlwZT09PVwiUHJvcGVydHlEZWZpbml0aW9uXCJ8fEkudHlwZT09PVwiQ2xhc3NQcml2YXRlUHJvcGVydHlcInx8SS50eXBlPT09XCJDb250aW51ZVN0YXRlbWVudFwifHxJLnR5cGU9PT1cIkRlYnVnZ2VyU3RhdGVtZW50XCJ8fEkudHlwZT09PVwiRGVjbGFyZUNsYXNzXCJ8fEkudHlwZT09PVwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCJ8fEkudHlwZT09PVwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCJ8fEkudHlwZT09PVwiRGVjbGFyZUZ1bmN0aW9uXCJ8fEkudHlwZT09PVwiRGVjbGFyZUludGVyZmFjZVwifHxJLnR5cGU9PT1cIkRlY2xhcmVNb2R1bGVcInx8SS50eXBlPT09XCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wifHxJLnR5cGU9PT1cIkRlY2xhcmVWYXJpYWJsZVwifHxJLnR5cGU9PT1cIkRvV2hpbGVTdGF0ZW1lbnRcInx8SS50eXBlPT09XCJFbnVtRGVjbGFyYXRpb25cInx8SS50eXBlPT09XCJFeHBvcnRBbGxEZWNsYXJhdGlvblwifHxJLnR5cGU9PT1cIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwifHxJLnR5cGU9PT1cIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cInx8SS50eXBlPT09XCJFeHByZXNzaW9uU3RhdGVtZW50XCJ8fEkudHlwZT09PVwiRm9ySW5TdGF0ZW1lbnRcInx8SS50eXBlPT09XCJGb3JPZlN0YXRlbWVudFwifHxJLnR5cGU9PT1cIkZvclN0YXRlbWVudFwifHxJLnR5cGU9PT1cIkZ1bmN0aW9uRGVjbGFyYXRpb25cInx8SS50eXBlPT09XCJJZlN0YXRlbWVudFwifHxJLnR5cGU9PT1cIkltcG9ydERlY2xhcmF0aW9uXCJ8fEkudHlwZT09PVwiSW50ZXJmYWNlRGVjbGFyYXRpb25cInx8SS50eXBlPT09XCJMYWJlbGVkU3RhdGVtZW50XCJ8fEkudHlwZT09PVwiTWV0aG9kRGVmaW5pdGlvblwifHxJLnR5cGU9PT1cIlJldHVyblN0YXRlbWVudFwifHxJLnR5cGU9PT1cIlN3aXRjaFN0YXRlbWVudFwifHxJLnR5cGU9PT1cIlRocm93U3RhdGVtZW50XCJ8fEkudHlwZT09PVwiVHJ5U3RhdGVtZW50XCJ8fEkudHlwZT09PVwiVFNEZWNsYXJlRnVuY3Rpb25cInx8SS50eXBlPT09XCJUU0VudW1EZWNsYXJhdGlvblwifHxJLnR5cGU9PT1cIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cInx8SS50eXBlPT09XCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCJ8fEkudHlwZT09PVwiVFNNb2R1bGVEZWNsYXJhdGlvblwifHxJLnR5cGU9PT1cIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cInx8SS50eXBlPT09XCJUeXBlQWxpYXNcInx8SS50eXBlPT09XCJWYXJpYWJsZURlY2xhcmF0aW9uXCJ8fEkudHlwZT09PVwiV2hpbGVTdGF0ZW1lbnRcInx8SS50eXBlPT09XCJXaXRoU3RhdGVtZW50XCJ9ZnVuY3Rpb24gQShJKXtsZXQgRT0wLEQ9SS5nZXRWYWx1ZSgpO2Zvcig7RDspe2xldCBkPUkuZ2V0UGFyZW50Tm9kZShFKyspO2lmKGQmJmQudHlwZT09PVwiRm9yU3RhdGVtZW50XCImJmQuaW5pdD09PUQpcmV0dXJuITA7RD1kfXJldHVybiExfWZ1bmN0aW9uIGIoSSl7cmV0dXJuIGMoSSxFPT5FLnR5cGU9PT1cIk9iamVjdFR5cGVBbm5vdGF0aW9uXCImJmMoRSxEPT5ELnR5cGU9PT1cIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cInx8dm9pZCAwKXx8dm9pZCAwKX1mdW5jdGlvbiB2KEkpe3N3aXRjaChJLnR5cGUpe2Nhc2VcIk9iamVjdEV4cHJlc3Npb25cIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBCKEkpe2xldCBFPUkuZ2V0VmFsdWUoKSxEPUkuZ2V0UGFyZW50Tm9kZSgpLGQ9SS5nZXROYW1lKCk7c3dpdGNoKEQudHlwZSl7Y2FzZVwiTkdQaXBlRXhwcmVzc2lvblwiOmlmKHR5cGVvZiBkPT1cIm51bWJlclwiJiZELmFyZ3VtZW50c1tkXT09PUUmJkQuYXJndW1lbnRzLmxlbmd0aC0xPT09ZClyZXR1cm4gSS5jYWxsUGFyZW50KEIpO2JyZWFrO2Nhc2VcIk9iamVjdFByb3BlcnR5XCI6aWYoZD09PVwidmFsdWVcIil7bGV0IHk9SS5nZXRQYXJlbnROb2RlKDEpO3JldHVybiB0KHkucHJvcGVydGllcyk9PT1EfWJyZWFrO2Nhc2VcIkJpbmFyeUV4cHJlc3Npb25cIjpjYXNlXCJMb2dpY2FsRXhwcmVzc2lvblwiOmlmKGQ9PT1cInJpZ2h0XCIpcmV0dXJuIEkuY2FsbFBhcmVudChCKTticmVhaztjYXNlXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjppZihkPT09XCJhbHRlcm5hdGVcIilyZXR1cm4gSS5jYWxsUGFyZW50KEIpO2JyZWFrO2Nhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOmlmKEQucHJlZml4KXJldHVybiBJLmNhbGxQYXJlbnQoQik7YnJlYWt9cmV0dXJuITF9ZnVuY3Rpb24gdyhJLEUpe2xldCBEPUkuZ2V0VmFsdWUoKSxkPUkuZ2V0UGFyZW50Tm9kZSgpO3JldHVybiBELnR5cGU9PT1cIkZ1bmN0aW9uRXhwcmVzc2lvblwifHxELnR5cGU9PT1cIkNsYXNzRXhwcmVzc2lvblwiP2QudHlwZT09PVwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCJ8fCFOKEksRSk6IWEoRCl8fGQudHlwZSE9PVwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCImJk4oSSxFKT8hMTpJLmNhbGwoeT0+dyh5LEUpLC4uLnIoSSxEKSl9bi5leHBvcnRzPU59fSkscm89Wih7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQtcHJlcHJvY2Vzcy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KHMsaSl7c3dpdGNoKGkucGFyc2VyKXtjYXNlXCJqc29uXCI6Y2FzZVwianNvbjVcIjpjYXNlXCJqc29uLXN0cmluZ2lmeVwiOmNhc2VcIl9fanNfZXhwcmVzc2lvblwiOmNhc2VcIl9fdnVlX2V4cHJlc3Npb25cIjpyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHt9LHt0eXBlOmkucGFyc2VyLnN0YXJ0c1dpdGgoXCJfX1wiKT9cIkpzRXhwcmVzc2lvblJvb3RcIjpcIkpzb25Sb290XCIsbm9kZTpzLGNvbW1lbnRzOltdLHJvb3RNYXJrZXI6aS5yb290TWFya2VyfSk7ZGVmYXVsdDpyZXR1cm4gc319bi5leHBvcnRzPXR9fSksYm09Wih7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvaHRtbC1iaW5kaW5nLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntidWlsZGVyczp7am9pbjp0LGxpbmU6cyxncm91cDppLHNvZnRsaW5lOnIsaW5kZW50OnV9fT1MZSgpO2Z1bmN0aW9uIGEobCxDLG0pe2xldCBnPWwuZ2V0VmFsdWUoKTtpZihDLl9fb25IdG1sQmluZGluZ1Jvb3QmJmwuZ2V0TmFtZSgpPT09bnVsbCYmQy5fX29uSHRtbEJpbmRpbmdSb290KGcsQyksZy50eXBlPT09XCJGaWxlXCIpe2lmKEMuX19pc1Z1ZUZvckJpbmRpbmdMZWZ0KXJldHVybiBsLmNhbGwocD0+e2xldCBmPXQoW1wiLFwiLHNdLHAubWFwKG0sXCJwYXJhbXNcIikpLHtwYXJhbXM6aH09cC5nZXRWYWx1ZSgpO3JldHVybiBoLmxlbmd0aD09PTE/ZjpbXCIoXCIsdShbcixpKGYpXSkscixcIilcIl19LFwicHJvZ3JhbVwiLFwiYm9keVwiLDApO2lmKEMuX19pc1Z1ZUJpbmRpbmdzKXJldHVybiBsLmNhbGwocD0+dChbXCIsXCIsc10scC5tYXAobSxcInBhcmFtc1wiKSksXCJwcm9ncmFtXCIsXCJib2R5XCIsMCl9fWZ1bmN0aW9uIGMobCl7c3dpdGNoKGwudHlwZSl7Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOnN3aXRjaChsLnByb3BlcnR5LnR5cGUpe2Nhc2VcIklkZW50aWZpZXJcIjpjYXNlXCJOdW1lcmljTGl0ZXJhbFwiOmNhc2VcIlN0cmluZ0xpdGVyYWxcIjpyZXR1cm4gYyhsLm9iamVjdCl9cmV0dXJuITE7Y2FzZVwiSWRlbnRpZmllclwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fW4uZXhwb3J0cz17aXNWdWVFdmVudEJpbmRpbmdFeHByZXNzaW9uOmMscHJpbnRIdG1sQmluZGluZzphfX19KSxKbj1aKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9iaW5hcnlpc2guanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye3ByaW50Q29tbWVudHM6dH09UWUoKSx7Z2V0TGFzdDpzfT1HZSgpLHtidWlsZGVyczp7am9pbjppLGxpbmU6cixzb2Z0bGluZTp1LGdyb3VwOmEsaW5kZW50OmMsYWxpZ246bCxpZkJyZWFrOkMsaW5kZW50SWZCcmVhazptfSx1dGlsczp7Y2xlYW5Eb2M6ZyxnZXREb2NQYXJ0czpwLGlzQ29uY2F0OmZ9fT1MZSgpLHtoYXNMZWFkaW5nT3duTGluZUNvbW1lbnQ6aCxpc0JpbmFyeWlzaDpOLGlzSnN4Tm9kZTpULHNob3VsZEZsYXR0ZW46QSxoYXNDb21tZW50OmIsQ29tbWVudENoZWNrRmxhZ3M6dixpc0NhbGxFeHByZXNzaW9uOkIsaXNNZW1iZXJFeHByZXNzaW9uOncsaXNPYmplY3RQcm9wZXJ0eTpJLGlzRW5hYmxlZEhhY2tQaXBlbGluZTpFfT1YZSgpLEQ9MDtmdW5jdGlvbiBkKHgsRixTKXtsZXQgaz14LmdldFZhbHVlKCksXz14LmdldFBhcmVudE5vZGUoKSxPPXguZ2V0UGFyZW50Tm9kZSgxKSxSPWshPT1fLmJvZHkmJihfLnR5cGU9PT1cIklmU3RhdGVtZW50XCJ8fF8udHlwZT09PVwiV2hpbGVTdGF0ZW1lbnRcInx8Xy50eXBlPT09XCJTd2l0Y2hTdGF0ZW1lbnRcInx8Xy50eXBlPT09XCJEb1doaWxlU3RhdGVtZW50XCIpLE09RShGKSYmay5vcGVyYXRvcj09PVwifD5cIixIPXkoeCxTLEYsITEsUik7aWYoUilyZXR1cm4gSDtpZihNKXJldHVybiBhKEgpO2lmKEIoXykmJl8uY2FsbGVlPT09a3x8Xy50eXBlPT09XCJVbmFyeUV4cHJlc3Npb25cInx8dyhfKSYmIV8uY29tcHV0ZWQpcmV0dXJuIGEoW2MoW3UsLi4uSF0pLHVdKTtsZXQgUD1fLnR5cGU9PT1cIlJldHVyblN0YXRlbWVudFwifHxfLnR5cGU9PT1cIlRocm93U3RhdGVtZW50XCJ8fF8udHlwZT09PVwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiJiZPLnR5cGU9PT1cIkpTWEF0dHJpYnV0ZVwifHxrLm9wZXJhdG9yIT09XCJ8XCImJl8udHlwZT09PVwiSnNFeHByZXNzaW9uUm9vdFwifHxrLnR5cGUhPT1cIk5HUGlwZUV4cHJlc3Npb25cIiYmKF8udHlwZT09PVwiTkdSb290XCImJkYucGFyc2VyPT09XCJfX25nX2JpbmRpbmdcInx8Xy50eXBlPT09XCJOR01pY3Jvc3ludGF4RXhwcmVzc2lvblwiJiZPLnR5cGU9PT1cIk5HTWljcm9zeW50YXhcIiYmTy5ib2R5Lmxlbmd0aD09PTEpfHxrPT09Xy5ib2R5JiZfLnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCJ8fGshPT1fLmJvZHkmJl8udHlwZT09PVwiRm9yU3RhdGVtZW50XCJ8fF8udHlwZT09PVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCImJk8udHlwZSE9PVwiUmV0dXJuU3RhdGVtZW50XCImJk8udHlwZSE9PVwiVGhyb3dTdGF0ZW1lbnRcIiYmIUIoTyl8fF8udHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCIsRz1fLnR5cGU9PT1cIkFzc2lnbm1lbnRFeHByZXNzaW9uXCJ8fF8udHlwZT09PVwiVmFyaWFibGVEZWNsYXJhdG9yXCJ8fF8udHlwZT09PVwiQ2xhc3NQcm9wZXJ0eVwifHxfLnR5cGU9PT1cIlByb3BlcnR5RGVmaW5pdGlvblwifHxfLnR5cGU9PT1cIlRTQWJzdHJhY3RQcm9wZXJ0eURlZmluaXRpb25cInx8Xy50eXBlPT09XCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwifHxJKF8pLHJlPU4oay5sZWZ0KSYmQShrLm9wZXJhdG9yLGsubGVmdC5vcGVyYXRvcik7aWYoUHx8byhrKSYmIXJlfHwhbyhrKSYmRylyZXR1cm4gYShIKTtpZihILmxlbmd0aD09PTApcmV0dXJuXCJcIjtsZXQgJD1UKGsucmlnaHQpLFc9SC5maW5kSW5kZXgob2U9PnR5cGVvZiBvZSE9XCJzdHJpbmdcIiYmIUFycmF5LmlzQXJyYXkob2UpJiZvZS50eXBlPT09XCJncm91cFwiKSxlZT1ILnNsaWNlKDAsVz09PS0xPzE6VysxKSxVPUguc2xpY2UoZWUubGVuZ3RoLCQ/LTE6dm9pZCAwKSxuZT1TeW1ib2woXCJsb2dpY2FsQ2hhaW4tXCIrICsrRCksc2U9YShbLi4uZWUsYyhVKV0se2lkOm5lfSk7aWYoISQpcmV0dXJuIHNlO2xldCBWPXMoSCk7cmV0dXJuIGEoW3NlLG0oVix7Z3JvdXBJZDpuZX0pXSl9ZnVuY3Rpb24geSh4LEYsUyxrLF8pe2xldCBPPXguZ2V0VmFsdWUoKTtpZighTihPKSlyZXR1cm5bYShGKCkpXTtsZXQgUj1bXTtBKE8ub3BlcmF0b3IsTy5sZWZ0Lm9wZXJhdG9yKT9SPXguY2FsbChVPT55KFUsRixTLCEwLF8pLFwibGVmdFwiKTpSLnB1c2goYShGKFwibGVmdFwiKSkpO2xldCBNPW8oTyksSD0oTy5vcGVyYXRvcj09PVwifD5cInx8Ty50eXBlPT09XCJOR1BpcGVFeHByZXNzaW9uXCJ8fE8ub3BlcmF0b3I9PT1cInxcIiYmUy5wYXJzZXI9PT1cIl9fdnVlX2V4cHJlc3Npb25cIikmJiFoKFMub3JpZ2luYWxUZXh0LE8ucmlnaHQpLFA9Ty50eXBlPT09XCJOR1BpcGVFeHByZXNzaW9uXCI/XCJ8XCI6Ty5vcGVyYXRvcixHPU8udHlwZT09PVwiTkdQaXBlRXhwcmVzc2lvblwiJiZPLmFyZ3VtZW50cy5sZW5ndGg+MD9hKGMoW3UsXCI6IFwiLGkoW3UsXCI6XCIsQyhcIiBcIildLHgubWFwKEYsXCJhcmd1bWVudHNcIikubWFwKFU9PmwoMixhKFUpKSkpXSkpOlwiXCIscmU7aWYoTSlyZT1bUCxcIiBcIixGKFwicmlnaHRcIiksR107ZWxzZXtsZXQgbmU9RShTKSYmUD09PVwifD5cIj94LmNhbGwoc2U9Pnkoc2UsRixTLCEwLF8pLFwicmlnaHRcIik6RihcInJpZ2h0XCIpO3JlPVtIP3I6XCJcIixQLEg/XCIgXCI6cixuZSxHXX1sZXQgJD14LmdldFBhcmVudE5vZGUoKSxXPWIoTy5sZWZ0LHYuVHJhaWxpbmd8di5MaW5lKSxlZT1XfHwhKF8mJk8udHlwZT09PVwiTG9naWNhbEV4cHJlc3Npb25cIikmJiQudHlwZSE9PU8udHlwZSYmTy5sZWZ0LnR5cGUhPT1PLnR5cGUmJk8ucmlnaHQudHlwZSE9PU8udHlwZTtpZihSLnB1c2goSD9cIlwiOlwiIFwiLGVlP2EocmUse3Nob3VsZEJyZWFrOld9KTpyZSksayYmYihPKSl7bGV0IFU9Zyh0KHgsUixTKSk7cmV0dXJuIGYoVSl8fFUudHlwZT09PVwiZmlsbFwiP3AoVSk6W1VdfXJldHVybiBSfWZ1bmN0aW9uIG8oeCl7cmV0dXJuIHgudHlwZSE9PVwiTG9naWNhbEV4cHJlc3Npb25cIj8hMTohISh4LnJpZ2h0LnR5cGU9PT1cIk9iamVjdEV4cHJlc3Npb25cIiYmeC5yaWdodC5wcm9wZXJ0aWVzLmxlbmd0aD4wfHx4LnJpZ2h0LnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwiJiZ4LnJpZ2h0LmVsZW1lbnRzLmxlbmd0aD4wfHxUKHgucmlnaHQpKX1uLmV4cG9ydHM9e3ByaW50QmluYXJ5aXNoRXhwcmVzc2lvbjpkLHNob3VsZElubGluZUxvZ2ljYWxFeHByZXNzaW9uOm99fX0pLFRtPVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L2FuZ3VsYXIuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2J1aWxkZXJzOntqb2luOnQsbGluZTpzLGdyb3VwOml9fT1MZSgpLHtoYXNOb2RlOnIsaGFzQ29tbWVudDp1LGdldENvbW1lbnRzOmF9PVhlKCkse3ByaW50QmluYXJ5aXNoRXhwcmVzc2lvbjpjfT1KbigpO2Z1bmN0aW9uIGwoZyxwLGYpe2xldCBoPWcuZ2V0VmFsdWUoKTtpZighIWgudHlwZS5zdGFydHNXaXRoKFwiTkdcIikpc3dpdGNoKGgudHlwZSl7Y2FzZVwiTkdSb290XCI6cmV0dXJuW2YoXCJub2RlXCIpLHUoaC5ub2RlKT9cIiAvL1wiK2EoaC5ub2RlKVswXS52YWx1ZS50cmltRW5kKCk6XCJcIl07Y2FzZVwiTkdQaXBlRXhwcmVzc2lvblwiOnJldHVybiBjKGcscCxmKTtjYXNlXCJOR0NoYWluZWRFeHByZXNzaW9uXCI6cmV0dXJuIGkodChbXCI7XCIsc10sZy5tYXAoTj0+bShOKT9mKCk6W1wiKFwiLGYoKSxcIilcIl0sXCJleHByZXNzaW9uc1wiKSkpO2Nhc2VcIk5HRW1wdHlFeHByZXNzaW9uXCI6cmV0dXJuXCJcIjtjYXNlXCJOR1F1b3RlZEV4cHJlc3Npb25cIjpyZXR1cm5baC5wcmVmaXgsXCI6IFwiLGgudmFsdWUudHJpbSgpXTtjYXNlXCJOR01pY3Jvc3ludGF4XCI6cmV0dXJuIGcubWFwKChOLFQpPT5bVD09PTA/XCJcIjpDKE4uZ2V0VmFsdWUoKSxULGgpP1wiIFwiOltcIjtcIixzXSxmKCldLFwiYm9keVwiKTtjYXNlXCJOR01pY3Jvc3ludGF4S2V5XCI6cmV0dXJuL15bJF9hLXpdW1xcdyRdKig/Oi1bJF9hLXpdW1xcdyRdKSokL2kudGVzdChoLm5hbWUpP2gubmFtZTpKU09OLnN0cmluZ2lmeShoLm5hbWUpO2Nhc2VcIk5HTWljcm9zeW50YXhFeHByZXNzaW9uXCI6cmV0dXJuW2YoXCJleHByZXNzaW9uXCIpLGguYWxpYXM9PT1udWxsP1wiXCI6W1wiIGFzIFwiLGYoXCJhbGlhc1wiKV1dO2Nhc2VcIk5HTWljcm9zeW50YXhLZXllZEV4cHJlc3Npb25cIjp7bGV0IE49Zy5nZXROYW1lKCksVD1nLmdldFBhcmVudE5vZGUoKSxBPUMoaCxOLFQpfHwoTj09PTEmJihoLmtleS5uYW1lPT09XCJ0aGVuXCJ8fGgua2V5Lm5hbWU9PT1cImVsc2VcIil8fE49PT0yJiZoLmtleS5uYW1lPT09XCJlbHNlXCImJlQuYm9keVtOLTFdLnR5cGU9PT1cIk5HTWljcm9zeW50YXhLZXllZEV4cHJlc3Npb25cIiYmVC5ib2R5W04tMV0ua2V5Lm5hbWU9PT1cInRoZW5cIikmJlQuYm9keVswXS50eXBlPT09XCJOR01pY3Jvc3ludGF4RXhwcmVzc2lvblwiO3JldHVybltmKFwia2V5XCIpLEE/XCIgXCI6XCI6IFwiLGYoXCJleHByZXNzaW9uXCIpXX1jYXNlXCJOR01pY3Jvc3ludGF4TGV0XCI6cmV0dXJuW1wibGV0IFwiLGYoXCJrZXlcIiksaC52YWx1ZT09PW51bGw/XCJcIjpbXCIgPSBcIixmKFwidmFsdWVcIildXTtjYXNlXCJOR01pY3Jvc3ludGF4QXNcIjpyZXR1cm5bZihcImtleVwiKSxcIiBhcyBcIixmKFwiYWxpYXNcIildO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBBbmd1bGFyIG5vZGUgdHlwZTogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGgudHlwZSksXCIuXCIpKX19ZnVuY3Rpb24gQyhnLHAsZil7cmV0dXJuIGcudHlwZT09PVwiTkdNaWNyb3N5bnRheEtleWVkRXhwcmVzc2lvblwiJiZnLmtleS5uYW1lPT09XCJvZlwiJiZwPT09MSYmZi5ib2R5WzBdLnR5cGU9PT1cIk5HTWljcm9zeW50YXhMZXRcIiYmZi5ib2R5WzBdLnZhbHVlPT09bnVsbH1mdW5jdGlvbiBtKGcpe3JldHVybiByKGcuZ2V0VmFsdWUoKSxwPT57c3dpdGNoKHAudHlwZSl7Y2FzZSB2b2lkIDA6cmV0dXJuITE7Y2FzZVwiQ2FsbEV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6Y2FzZVwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpyZXR1cm4hMH19KX1uLmV4cG9ydHM9e3ByaW50QW5ndWxhcjpsfX19KSxCbT1aKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9qc3guanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye3ByaW50Q29tbWVudHM6dCxwcmludERhbmdsaW5nQ29tbWVudHM6c309UWUoKSx7YnVpbGRlcnM6e2xpbmU6aSxoYXJkbGluZTpyLHNvZnRsaW5lOnUsZ3JvdXA6YSxpbmRlbnQ6Yyxjb25kaXRpb25hbEdyb3VwOmwsZmlsbDpDLGlmQnJlYWs6bSxsaW5lU3VmZml4Qm91bmRhcnk6Zyxqb2luOnB9LHV0aWxzOnt3aWxsQnJlYWs6Zn19PUxlKCkse2dldExhc3Q6aCxnZXRQcmVmZXJyZWRRdW90ZTpOfT1HZSgpLHtpc0pzeE5vZGU6VCxyYXdUZXh0OkEsaXNMaXRlcmFsOmIsaXNDYWxsRXhwcmVzc2lvbjp2LGlzU3RyaW5nTGl0ZXJhbDpCLGlzQmluYXJ5aXNoOncsaGFzQ29tbWVudDpJLENvbW1lbnRDaGVja0ZsYWdzOkUsaGFzTm9kZUlnbm9yZUNvbW1lbnQ6RH09WGUoKSxkPWt0KCkse3dpbGxQcmludE93bkNvbW1lbnRzOnl9PXRvKCksbz1xPT5xPT09XCJcInx8cT09PWl8fHE9PT1yfHxxPT09dTtmdW5jdGlvbiB4KHEsbGUsdWUpe2xldCBRPXEuZ2V0VmFsdWUoKTtpZihRLnR5cGU9PT1cIkpTWEVsZW1lbnRcIiYmVihRKSlyZXR1cm5bdWUoXCJvcGVuaW5nRWxlbWVudFwiKSx1ZShcImNsb3NpbmdFbGVtZW50XCIpXTtsZXQgZGU9US50eXBlPT09XCJKU1hFbGVtZW50XCI/dWUoXCJvcGVuaW5nRWxlbWVudFwiKTp1ZShcIm9wZW5pbmdGcmFnbWVudFwiKSxnZT1RLnR5cGU9PT1cIkpTWEVsZW1lbnRcIj91ZShcImNsb3NpbmdFbGVtZW50XCIpOnVlKFwiY2xvc2luZ0ZyYWdtZW50XCIpO2lmKFEuY2hpbGRyZW4ubGVuZ3RoPT09MSYmUS5jaGlsZHJlblswXS50eXBlPT09XCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCImJihRLmNoaWxkcmVuWzBdLmV4cHJlc3Npb24udHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCJ8fFEuY2hpbGRyZW5bMF0uZXhwcmVzc2lvbi50eXBlPT09XCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIikpcmV0dXJuW2RlLC4uLnEubWFwKHVlLFwiY2hpbGRyZW5cIiksZ2VdO1EuY2hpbGRyZW49US5jaGlsZHJlbi5tYXAoej0+Syh6KT97dHlwZTpcIkpTWFRleHRcIix2YWx1ZTpcIiBcIixyYXc6XCIgXCJ9OnopO2xldCB2ZT1RLmNoaWxkcmVuLnNvbWUoVCkseGU9US5jaGlsZHJlbi5maWx0ZXIoej0+ei50eXBlPT09XCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIpLmxlbmd0aD4xLHdlPVEudHlwZT09PVwiSlNYRWxlbWVudFwiJiZRLm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXMubGVuZ3RoPjEsZmU9ZihkZSl8fHZlfHx3ZXx8eGUscGU9cS5nZXRQYXJlbnROb2RlKCkucm9vdE1hcmtlcj09PVwibWR4XCIsbWU9bGUuc2luZ2xlUXVvdGU/XCJ7JyAnfVwiOid7XCIgXCJ9JyxjZT1wZT9cIiBcIjptKFttZSx1XSxcIiBcIiksaGU9US5vcGVuaW5nRWxlbWVudCYmUS5vcGVuaW5nRWxlbWVudC5uYW1lJiZRLm9wZW5pbmdFbGVtZW50Lm5hbWUubmFtZT09PVwiZmJ0XCIsSj1GKHEsbGUsdWUsY2UsaGUpLHllPVEuY2hpbGRyZW4uc29tZSh6PT5vZSh6KSk7Zm9yKGxldCB6PUoubGVuZ3RoLTI7ej49MDt6LS0pe2xldCBqPUpbel09PT1cIlwiJiZKW3orMV09PT1cIlwiLENlPUpbel09PT1yJiZKW3orMV09PT1cIlwiJiZKW3orMl09PT1yLE5lPShKW3pdPT09dXx8Slt6XT09PXIpJiZKW3orMV09PT1cIlwiJiZKW3orMl09PT1jZSxqZT1KW3pdPT09Y2UmJkpbeisxXT09PVwiXCImJihKW3orMl09PT11fHxKW3orMl09PT1yKSxVZT1KW3pdPT09Y2UmJkpbeisxXT09PVwiXCImJkpbeisyXT09PWNlLHR0PUpbel09PT11JiZKW3orMV09PT1cIlwiJiZKW3orMl09PT1yfHxKW3pdPT09ciYmSlt6KzFdPT09XCJcIiYmSlt6KzJdPT09dTtDZSYmeWV8fGp8fE5lfHxVZXx8dHQ/Si5zcGxpY2UoeiwyKTpqZSYmSi5zcGxpY2UoeisxLDIpfWZvcig7Si5sZW5ndGg+MCYmbyhoKEopKTspSi5wb3AoKTtmb3IoO0oubGVuZ3RoPjEmJm8oSlswXSkmJm8oSlsxXSk7KUouc2hpZnQoKSxKLnNoaWZ0KCk7bGV0IFg9W107Zm9yKGxldFt6LGpdb2YgSi5lbnRyaWVzKCkpe2lmKGo9PT1jZSl7aWYoej09PTEmJkpbei0xXT09PVwiXCIpe2lmKEoubGVuZ3RoPT09Mil7WC5wdXNoKG1lKTtjb250aW51ZX1YLnB1c2goW21lLHJdKTtjb250aW51ZX1lbHNlIGlmKHo9PT1KLmxlbmd0aC0xKXtYLnB1c2gobWUpO2NvbnRpbnVlfWVsc2UgaWYoSlt6LTFdPT09XCJcIiYmSlt6LTJdPT09cil7WC5wdXNoKG1lKTtjb250aW51ZX19WC5wdXNoKGopLGYoaikmJihmZT0hMCl9bGV0IFk9eWU/QyhYKTphKFgse3Nob3VsZEJyZWFrOiEwfSk7aWYocGUpcmV0dXJuIFk7bGV0IHRlPWEoW2RlLGMoW3IsWV0pLHIsZ2VdKTtyZXR1cm4gZmU/dGU6bChbYShbZGUsLi4uSixnZV0pLHRlXSl9ZnVuY3Rpb24gRihxLGxlLHVlLFEsZGUpe2xldCBnZT1bXTtyZXR1cm4gcS5lYWNoKCh2ZSx4ZSx3ZSk9PntsZXQgZmU9dmUuZ2V0VmFsdWUoKTtpZihiKGZlKSl7bGV0IHBlPUEoZmUpO2lmKG9lKGZlKSl7bGV0IG1lPXBlLnNwbGl0KFUpO2lmKG1lWzBdPT09XCJcIil7aWYoZ2UucHVzaChcIlwiKSxtZS5zaGlmdCgpLC9cXG4vLnRlc3QobWVbMF0pKXtsZXQgaGU9d2VbeGUrMV07Z2UucHVzaChrKGRlLG1lWzFdLGZlLGhlKSl9ZWxzZSBnZS5wdXNoKFEpO21lLnNoaWZ0KCl9bGV0IGNlO2lmKGgobWUpPT09XCJcIiYmKG1lLnBvcCgpLGNlPW1lLnBvcCgpKSxtZS5sZW5ndGg9PT0wKXJldHVybjtmb3IobGV0W2hlLEpdb2YgbWUuZW50cmllcygpKWhlJTI9PT0xP2dlLnB1c2goaSk6Z2UucHVzaChKKTtpZihjZSE9PXZvaWQgMClpZigvXFxuLy50ZXN0KGNlKSl7bGV0IGhlPXdlW3hlKzFdO2dlLnB1c2goayhkZSxoKGdlKSxmZSxoZSkpfWVsc2UgZ2UucHVzaChRKTtlbHNle2xldCBoZT13ZVt4ZSsxXTtnZS5wdXNoKFMoZGUsaChnZSksZmUsaGUpKX19ZWxzZS9cXG4vLnRlc3QocGUpP3BlLm1hdGNoKC9cXG4vZykubGVuZ3RoPjEmJmdlLnB1c2goXCJcIixyKTpnZS5wdXNoKFwiXCIsUSl9ZWxzZXtsZXQgcGU9dWUoKTtnZS5wdXNoKHBlKTtsZXQgbWU9d2VbeGUrMV07aWYobWUmJm9lKG1lKSl7bGV0IGhlPXNlKEEobWUpKS5zcGxpdChVKVswXTtnZS5wdXNoKFMoZGUsaGUsZmUsbWUpKX1lbHNlIGdlLnB1c2gocil9fSxcImNoaWxkcmVuXCIpLGdlfWZ1bmN0aW9uIFMocSxsZSx1ZSxRKXtyZXR1cm4gcT9cIlwiOnVlLnR5cGU9PT1cIkpTWEVsZW1lbnRcIiYmIXVlLmNsb3NpbmdFbGVtZW50fHxRJiZRLnR5cGU9PT1cIkpTWEVsZW1lbnRcIiYmIVEuY2xvc2luZ0VsZW1lbnQ/bGUubGVuZ3RoPT09MT91OnI6dX1mdW5jdGlvbiBrKHEsbGUsdWUsUSl7cmV0dXJuIHE/cjpsZS5sZW5ndGg9PT0xP3VlLnR5cGU9PT1cIkpTWEVsZW1lbnRcIiYmIXVlLmNsb3NpbmdFbGVtZW50fHxRJiZRLnR5cGU9PT1cIkpTWEVsZW1lbnRcIiYmIVEuY2xvc2luZ0VsZW1lbnQ/cjp1OnJ9ZnVuY3Rpb24gXyhxLGxlLHVlKXtsZXQgUT1xLmdldFBhcmVudE5vZGUoKTtpZighUXx8e0FycmF5RXhwcmVzc2lvbjohMCxKU1hBdHRyaWJ1dGU6ITAsSlNYRWxlbWVudDohMCxKU1hFeHByZXNzaW9uQ29udGFpbmVyOiEwLEpTWEZyYWdtZW50OiEwLEV4cHJlc3Npb25TdGF0ZW1lbnQ6ITAsQ2FsbEV4cHJlc3Npb246ITAsT3B0aW9uYWxDYWxsRXhwcmVzc2lvbjohMCxDb25kaXRpb25hbEV4cHJlc3Npb246ITAsSnNFeHByZXNzaW9uUm9vdDohMH1bUS50eXBlXSlyZXR1cm4gbGU7bGV0IGdlPXEubWF0Y2godm9pZCAwLHhlPT54ZS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiLHYseGU9PnhlLnR5cGU9PT1cIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiksdmU9ZChxLHVlKTtyZXR1cm4gYShbdmU/XCJcIjptKFwiKFwiKSxjKFt1LGxlXSksdSx2ZT9cIlwiOm0oXCIpXCIpXSx7c2hvdWxkQnJlYWs6Z2V9KX1mdW5jdGlvbiBPKHEsbGUsdWUpe2xldCBRPXEuZ2V0VmFsdWUoKSxkZT1bXTtpZihkZS5wdXNoKHVlKFwibmFtZVwiKSksUS52YWx1ZSl7bGV0IGdlO2lmKEIoUS52YWx1ZSkpe2xldCB4ZT1BKFEudmFsdWUpLnNsaWNlKDEsLTEpLnJlcGxhY2UoLyZhcG9zOy9nLFwiJ1wiKS5yZXBsYWNlKC8mcXVvdDsvZywnXCInKSx7ZXNjYXBlZDp3ZSxxdW90ZTpmZSxyZWdleDpwZX09Tih4ZSxsZS5qc3hTaW5nbGVRdW90ZT9cIidcIjonXCInKTt4ZT14ZS5yZXBsYWNlKHBlLHdlKSxnZT1bZmUseGUsZmVdfWVsc2UgZ2U9dWUoXCJ2YWx1ZVwiKTtkZS5wdXNoKFwiPVwiLGdlKX1yZXR1cm4gZGV9ZnVuY3Rpb24gUihxLGxlLHVlKXtsZXQgUT1xLmdldFZhbHVlKCksZGU9KGdlLHZlKT0+Z2UudHlwZT09PVwiSlNYRW1wdHlFeHByZXNzaW9uXCJ8fCFJKGdlKSYmKGdlLnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwifHxnZS50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCJ8fGdlLnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCJ8fGdlLnR5cGU9PT1cIkF3YWl0RXhwcmVzc2lvblwiJiYoZGUoZ2UuYXJndW1lbnQsZ2UpfHxnZS5hcmd1bWVudC50eXBlPT09XCJKU1hFbGVtZW50XCIpfHx2KGdlKXx8Z2UudHlwZT09PVwiRnVuY3Rpb25FeHByZXNzaW9uXCJ8fGdlLnR5cGU9PT1cIlRlbXBsYXRlTGl0ZXJhbFwifHxnZS50eXBlPT09XCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cInx8Z2UudHlwZT09PVwiRG9FeHByZXNzaW9uXCJ8fFQodmUpJiYoZ2UudHlwZT09PVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCJ8fHcoZ2UpKSk7cmV0dXJuIGRlKFEuZXhwcmVzc2lvbixxLmdldFBhcmVudE5vZGUoMCkpP2EoW1wie1wiLHVlKFwiZXhwcmVzc2lvblwiKSxnLFwifVwiXSk6YShbXCJ7XCIsYyhbdSx1ZShcImV4cHJlc3Npb25cIildKSx1LGcsXCJ9XCJdKX1mdW5jdGlvbiBNKHEsbGUsdWUpe2xldCBRPXEuZ2V0VmFsdWUoKSxkZT1RLm5hbWUmJkkoUS5uYW1lKXx8US50eXBlUGFyYW1ldGVycyYmSShRLnR5cGVQYXJhbWV0ZXJzKTtpZihRLnNlbGZDbG9zaW5nJiZRLmF0dHJpYnV0ZXMubGVuZ3RoPT09MCYmIWRlKXJldHVybltcIjxcIix1ZShcIm5hbWVcIiksdWUoXCJ0eXBlUGFyYW1ldGVyc1wiKSxcIiAvPlwiXTtpZihRLmF0dHJpYnV0ZXMmJlEuYXR0cmlidXRlcy5sZW5ndGg9PT0xJiZRLmF0dHJpYnV0ZXNbMF0udmFsdWUmJkIoUS5hdHRyaWJ1dGVzWzBdLnZhbHVlKSYmIVEuYXR0cmlidXRlc1swXS52YWx1ZS52YWx1ZS5pbmNsdWRlcyhgXG5gKSYmIWRlJiYhSShRLmF0dHJpYnV0ZXNbMF0pKXJldHVybiBhKFtcIjxcIix1ZShcIm5hbWVcIiksdWUoXCJ0eXBlUGFyYW1ldGVyc1wiKSxcIiBcIiwuLi5xLm1hcCh1ZSxcImF0dHJpYnV0ZXNcIiksUS5zZWxmQ2xvc2luZz9cIiAvPlwiOlwiPlwiXSk7bGV0IGdlPVEuYXR0cmlidXRlcy5sZW5ndGg+MCYmSShoKFEuYXR0cmlidXRlcyksRS5UcmFpbGluZyksdmU9US5hdHRyaWJ1dGVzLmxlbmd0aD09PTAmJiFkZXx8KGxlLmJyYWNrZXRTYW1lTGluZXx8bGUuanN4QnJhY2tldFNhbWVMaW5lKSYmKCFkZXx8US5hdHRyaWJ1dGVzLmxlbmd0aD4wKSYmIWdlLHhlPVEuYXR0cmlidXRlcyYmUS5hdHRyaWJ1dGVzLnNvbWUoZmU9PmZlLnZhbHVlJiZCKGZlLnZhbHVlKSYmZmUudmFsdWUudmFsdWUuaW5jbHVkZXMoYFxuYCkpLHdlPWxlLnNpbmdsZUF0dHJpYnV0ZVBlckxpbmUmJlEuYXR0cmlidXRlcy5sZW5ndGg+MT9yOmk7cmV0dXJuIGEoW1wiPFwiLHVlKFwibmFtZVwiKSx1ZShcInR5cGVQYXJhbWV0ZXJzXCIpLGMocS5tYXAoKCk9Plt3ZSx1ZSgpXSxcImF0dHJpYnV0ZXNcIikpLFEuc2VsZkNsb3Npbmc/aTp2ZT9cIj5cIjp1LFEuc2VsZkNsb3Npbmc/XCIvPlwiOnZlP1wiXCI6XCI+XCJdLHtzaG91bGRCcmVhazp4ZX0pfWZ1bmN0aW9uIEgocSxsZSx1ZSl7bGV0IFE9cS5nZXRWYWx1ZSgpLGRlPVtdO2RlLnB1c2goXCI8L1wiKTtsZXQgZ2U9dWUoXCJuYW1lXCIpO3JldHVybiBJKFEubmFtZSxFLkxlYWRpbmd8RS5MaW5lKT9kZS5wdXNoKGMoW3IsZ2VdKSxyKTpJKFEubmFtZSxFLkxlYWRpbmd8RS5CbG9jayk/ZGUucHVzaChcIiBcIixnZSk6ZGUucHVzaChnZSksZGUucHVzaChcIj5cIiksZGV9ZnVuY3Rpb24gUChxLGxlKXtsZXQgdWU9cS5nZXRWYWx1ZSgpLFE9SSh1ZSksZGU9SSh1ZSxFLkxpbmUpLGdlPXVlLnR5cGU9PT1cIkpTWE9wZW5pbmdGcmFnbWVudFwiO3JldHVybltnZT9cIjxcIjpcIjwvXCIsYyhbZGU/cjpRJiYhZ2U/XCIgXCI6XCJcIixzKHEsbGUsITApXSksZGU/cjpcIlwiLFwiPlwiXX1mdW5jdGlvbiBHKHEsbGUsdWUpe2xldCBRPXQocSx4KHEsbGUsdWUpLGxlKTtyZXR1cm4gXyhxLFEsbGUpfWZ1bmN0aW9uIHJlKHEsbGUpe2xldCB1ZT1xLmdldFZhbHVlKCksUT1JKHVlLEUuTGluZSk7cmV0dXJuW3MocSxsZSwhUSksUT9yOlwiXCJdfWZ1bmN0aW9uICQocSxsZSx1ZSl7bGV0IFE9cS5nZXRWYWx1ZSgpO3JldHVybltcIntcIixxLmNhbGwoZGU9PntsZXQgZ2U9W1wiLi4uXCIsdWUoKV0sdmU9ZGUuZ2V0VmFsdWUoKTtyZXR1cm4hSSh2ZSl8fCF5KGRlKT9nZTpbYyhbdSx0KGRlLGdlLGxlKV0pLHVdfSxRLnR5cGU9PT1cIkpTWFNwcmVhZEF0dHJpYnV0ZVwiP1wiYXJndW1lbnRcIjpcImV4cHJlc3Npb25cIiksXCJ9XCJdfWZ1bmN0aW9uIFcocSxsZSx1ZSl7bGV0IFE9cS5nZXRWYWx1ZSgpO2lmKCEhUS50eXBlLnN0YXJ0c1dpdGgoXCJKU1hcIikpc3dpdGNoKFEudHlwZSl7Y2FzZVwiSlNYQXR0cmlidXRlXCI6cmV0dXJuIE8ocSxsZSx1ZSk7Y2FzZVwiSlNYSWRlbnRpZmllclwiOnJldHVybiBTdHJpbmcoUS5uYW1lKTtjYXNlXCJKU1hOYW1lc3BhY2VkTmFtZVwiOnJldHVybiBwKFwiOlwiLFt1ZShcIm5hbWVzcGFjZVwiKSx1ZShcIm5hbWVcIildKTtjYXNlXCJKU1hNZW1iZXJFeHByZXNzaW9uXCI6cmV0dXJuIHAoXCIuXCIsW3VlKFwib2JqZWN0XCIpLHVlKFwicHJvcGVydHlcIildKTtjYXNlXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIjpyZXR1cm4gJChxLGxlLHVlKTtjYXNlXCJKU1hTcHJlYWRDaGlsZFwiOnJldHVybiAkKHEsbGUsdWUpO2Nhc2VcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIjpyZXR1cm4gUihxLGxlLHVlKTtjYXNlXCJKU1hGcmFnbWVudFwiOmNhc2VcIkpTWEVsZW1lbnRcIjpyZXR1cm4gRyhxLGxlLHVlKTtjYXNlXCJKU1hPcGVuaW5nRWxlbWVudFwiOnJldHVybiBNKHEsbGUsdWUpO2Nhc2VcIkpTWENsb3NpbmdFbGVtZW50XCI6cmV0dXJuIEgocSxsZSx1ZSk7Y2FzZVwiSlNYT3BlbmluZ0ZyYWdtZW50XCI6Y2FzZVwiSlNYQ2xvc2luZ0ZyYWdtZW50XCI6cmV0dXJuIFAocSxsZSk7Y2FzZVwiSlNYRW1wdHlFeHByZXNzaW9uXCI6cmV0dXJuIHJlKHEsbGUpO2Nhc2VcIkpTWFRleHRcIjp0aHJvdyBuZXcgRXJyb3IoXCJKU1hUZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IEpTWEVsZW1lbnRcIik7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEpTWCBub2RlIHR5cGU6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShRLnR5cGUpLFwiLlwiKSl9fXZhciBlZT1gIFxuXFxyXHRgLFU9bmV3IFJlZ0V4cChcIihbXCIrZWUrXCJdKylcIiksbmU9bmV3IFJlZ0V4cChcIlteXCIrZWUrXCJdXCIpLHNlPXE9PnEucmVwbGFjZShuZXcgUmVnRXhwKFwiKD86XlwiK1Uuc291cmNlK1wifFwiK1Uuc291cmNlK1wiJClcIiksXCJcIik7ZnVuY3Rpb24gVihxKXtpZihxLmNoaWxkcmVuLmxlbmd0aD09PTApcmV0dXJuITA7aWYocS5jaGlsZHJlbi5sZW5ndGg+MSlyZXR1cm4hMTtsZXQgbGU9cS5jaGlsZHJlblswXTtyZXR1cm4gYihsZSkmJiFvZShsZSl9ZnVuY3Rpb24gb2UocSl7cmV0dXJuIGIocSkmJihuZS50ZXN0KEEocSkpfHwhL1xcbi8udGVzdChBKHEpKSl9ZnVuY3Rpb24gSyhxKXtyZXR1cm4gcS50eXBlPT09XCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCImJmIocS5leHByZXNzaW9uKSYmcS5leHByZXNzaW9uLnZhbHVlPT09XCIgXCImJiFJKHEuZXhwcmVzc2lvbil9ZnVuY3Rpb24gRWUocSl7bGV0IGxlPXEuZ2V0VmFsdWUoKSx1ZT1xLmdldFBhcmVudE5vZGUoKTtpZighdWV8fCFsZXx8IVQobGUpfHwhVCh1ZSkpcmV0dXJuITE7bGV0IFE9dWUuY2hpbGRyZW4uaW5kZXhPZihsZSksZGU9bnVsbDtmb3IobGV0IGdlPVE7Z2U+MDtnZS0tKXtsZXQgdmU9dWUuY2hpbGRyZW5bZ2UtMV07aWYoISh2ZS50eXBlPT09XCJKU1hUZXh0XCImJiFvZSh2ZSkpKXtkZT12ZTticmVha319cmV0dXJuIGRlJiZkZS50eXBlPT09XCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCImJmRlLmV4cHJlc3Npb24udHlwZT09PVwiSlNYRW1wdHlFeHByZXNzaW9uXCImJkQoZGUuZXhwcmVzc2lvbil9bi5leHBvcnRzPXtoYXNKc3hJZ25vcmVDb21tZW50OkVlLHByaW50SnN4Old9fX0pLG90PVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L21pc2MuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2lzTm9uRW1wdHlBcnJheTp0fT1HZSgpLHtidWlsZGVyczp7aW5kZW50OnMsam9pbjppLGxpbmU6cn19PUxlKCkse2lzRmxvd0Fubm90YXRpb25Db21tZW50OnV9PVhlKCk7ZnVuY3Rpb24gYShoKXtsZXQgTj1oLmdldFZhbHVlKCk7cmV0dXJuIU4ub3B0aW9uYWx8fE4udHlwZT09PVwiSWRlbnRpZmllclwiJiZOPT09aC5nZXRQYXJlbnROb2RlKCkua2V5P1wiXCI6Ti50eXBlPT09XCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCJ8fE4udHlwZT09PVwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCImJk4uY29tcHV0ZWQ/XCI/LlwiOlwiP1wifWZ1bmN0aW9uIGMoaCl7cmV0dXJuIGguZ2V0VmFsdWUoKS5kZWZpbml0ZXx8aC5tYXRjaCh2b2lkIDAsKE4sVCk9PlQ9PT1cImlkXCImJk4udHlwZT09PVwiVmFyaWFibGVEZWNsYXJhdG9yXCImJk4uZGVmaW5pdGUpP1wiIVwiOlwiXCJ9ZnVuY3Rpb24gbChoLE4sVCl7bGV0IEE9aC5nZXRWYWx1ZSgpO3JldHVybiBBLnR5cGVBcmd1bWVudHM/VChcInR5cGVBcmd1bWVudHNcIik6QS50eXBlUGFyYW1ldGVycz9UKFwidHlwZVBhcmFtZXRlcnNcIik6XCJcIn1mdW5jdGlvbiBDKGgsTixUKXtsZXQgQT1oLmdldFZhbHVlKCk7aWYoIUEudHlwZUFubm90YXRpb24pcmV0dXJuXCJcIjtsZXQgYj1oLmdldFBhcmVudE5vZGUoKSx2PWIudHlwZT09PVwiRGVjbGFyZUZ1bmN0aW9uXCImJmIuaWQ9PT1BO3JldHVybiB1KE4ub3JpZ2luYWxUZXh0LEEudHlwZUFubm90YXRpb24pP1tcIiAvKjogXCIsVChcInR5cGVBbm5vdGF0aW9uXCIpLFwiICovXCJdOlt2P1wiXCI6XCI6IFwiLFQoXCJ0eXBlQW5ub3RhdGlvblwiKV19ZnVuY3Rpb24gbShoLE4sVCl7cmV0dXJuW1wiOjpcIixUKFwiY2FsbGVlXCIpXX1mdW5jdGlvbiBnKGgsTixUKXtsZXQgQT1oLmdldFZhbHVlKCk7cmV0dXJuIHQoQS5tb2RpZmllcnMpP1tpKFwiIFwiLGgubWFwKFQsXCJtb2RpZmllcnNcIikpLFwiIFwiXTpcIlwifWZ1bmN0aW9uIHAoaCxOLFQpe3JldHVybiBoLnR5cGU9PT1cIkVtcHR5U3RhdGVtZW50XCI/XCI7XCI6aC50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwifHxUP1tcIiBcIixOXTpzKFtyLE5dKX1mdW5jdGlvbiBmKGgsTixUKXtyZXR1cm5bXCIuLi5cIixUKFwiYXJndW1lbnRcIiksQyhoLE4sVCldfW4uZXhwb3J0cz17cHJpbnRPcHRpb25hbFRva2VuOmEscHJpbnREZWZpbml0ZVRva2VuOmMscHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzOmwscHJpbnRCaW5kRXhwcmVzc2lvbkNhbGxlZTptLHByaW50VHlwZVNjcmlwdE1vZGlmaWVyczpnLHByaW50VHlwZUFubm90YXRpb246QyxwcmludFJlc3RTcHJlYWQ6ZixhZGp1c3RDbGF1c2U6cH19fSksenQ9Wih7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvYXJyYXkuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye3ByaW50RGFuZ2xpbmdDb21tZW50czp0fT1RZSgpLHtidWlsZGVyczp7bGluZTpzLHNvZnRsaW5lOmksaGFyZGxpbmU6cixncm91cDp1LGluZGVudDphLGlmQnJlYWs6YyxmaWxsOmx9fT1MZSgpLHtnZXRMYXN0OkMsaGFzTmV3bGluZTptfT1HZSgpLHtzaG91bGRQcmludENvbW1hOmcsaGFzQ29tbWVudDpwLENvbW1lbnRDaGVja0ZsYWdzOmYsaXNOZXh0TGluZUVtcHR5OmgsaXNOdW1lcmljTGl0ZXJhbDpOLGlzU2lnbmVkTnVtZXJpY0xpdGVyYWw6VH09WGUoKSx7bG9jU3RhcnQ6QX09bnQoKSx7cHJpbnRPcHRpb25hbFRva2VuOmIscHJpbnRUeXBlQW5ub3RhdGlvbjp2fT1vdCgpO2Z1bmN0aW9uIEIoRCxkLHkpe2xldCBvPUQuZ2V0VmFsdWUoKSx4PVtdLEY9by50eXBlPT09XCJUdXBsZUV4cHJlc3Npb25cIj9cIiNbXCI6XCJbXCIsUz1cIl1cIjtpZihvLmVsZW1lbnRzLmxlbmd0aD09PTApcChvLGYuRGFuZ2xpbmcpP3gucHVzaCh1KFtGLHQoRCxkKSxpLFNdKSk6eC5wdXNoKEYsUyk7ZWxzZXtsZXQgaz1DKG8uZWxlbWVudHMpLF89IShrJiZrLnR5cGU9PT1cIlJlc3RFbGVtZW50XCIpLE89az09PW51bGwsUj1TeW1ib2woXCJhcnJheVwiKSxNPSFkLl9faW5KZXN0RWFjaCYmby5lbGVtZW50cy5sZW5ndGg+MSYmby5lbGVtZW50cy5ldmVyeSgoRyxyZSwkKT0+e2xldCBXPUcmJkcudHlwZTtpZihXIT09XCJBcnJheUV4cHJlc3Npb25cIiYmVyE9PVwiT2JqZWN0RXhwcmVzc2lvblwiKXJldHVybiExO2xldCBlZT0kW3JlKzFdO2lmKGVlJiZXIT09ZWUudHlwZSlyZXR1cm4hMTtsZXQgVT1XPT09XCJBcnJheUV4cHJlc3Npb25cIj9cImVsZW1lbnRzXCI6XCJwcm9wZXJ0aWVzXCI7cmV0dXJuIEdbVV0mJkdbVV0ubGVuZ3RoPjF9KSxIPXcobyxkKSxQPV8/Tz9cIixcIjpnKGQpP0g/YyhcIixcIixcIlwiLHtncm91cElkOlJ9KTpjKFwiLFwiKTpcIlwiOlwiXCI7eC5wdXNoKHUoW0YsYShbaSxIP0UoRCxkLHksUCk6W0koRCxkLFwiZWxlbWVudHNcIix5KSxQXSx0KEQsZCwhMCldKSxpLFNdLHtzaG91bGRCcmVhazpNLGlkOlJ9KSl9cmV0dXJuIHgucHVzaChiKEQpLHYoRCxkLHkpKSx4fWZ1bmN0aW9uIHcoRCxkKXtyZXR1cm4gRC5lbGVtZW50cy5sZW5ndGg+MSYmRC5lbGVtZW50cy5ldmVyeSh5PT55JiYoTih5KXx8VCh5KSYmIXAoeS5hcmd1bWVudCkpJiYhcCh5LGYuVHJhaWxpbmd8Zi5MaW5lLG89PiFtKGQub3JpZ2luYWxUZXh0LEEobykse2JhY2t3YXJkczohMH0pKSl9ZnVuY3Rpb24gSShELGQseSxvKXtsZXQgeD1bXSxGPVtdO3JldHVybiBELmVhY2goUz0+e3gucHVzaChGLHUobygpKSksRj1bXCIsXCIsc10sUy5nZXRWYWx1ZSgpJiZoKFMuZ2V0VmFsdWUoKSxkKSYmRi5wdXNoKGkpfSx5KSx4fWZ1bmN0aW9uIEUoRCxkLHksbyl7bGV0IHg9W107cmV0dXJuIEQuZWFjaCgoRixTLGspPT57bGV0IF89Uz09PWsubGVuZ3RoLTE7eC5wdXNoKFt5KCksXz9vOlwiLFwiXSksX3x8eC5wdXNoKGgoRi5nZXRWYWx1ZSgpLGQpP1tyLHJdOnAoa1tTKzFdLGYuTGVhZGluZ3xmLkxpbmUpP3I6cyl9LFwiZWxlbWVudHNcIiksbCh4KX1uLmV4cG9ydHM9e3ByaW50QXJyYXk6QixwcmludEFycmF5SXRlbXM6SSxpc0NvbmNpc2VseVByaW50ZWRBcnJheTp3fX19KSxubz1aKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9jYWxsLWFyZ3VtZW50cy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7cHJpbnREYW5nbGluZ0NvbW1lbnRzOnR9PVFlKCkse2dldExhc3Q6cyxnZXRQZW51bHRpbWF0ZTppfT1HZSgpLHtnZXRGdW5jdGlvblBhcmFtZXRlcnM6cixoYXNDb21tZW50OnUsQ29tbWVudENoZWNrRmxhZ3M6YSxpc0Z1bmN0aW9uQ29tcG9zaXRpb25BcmdzOmMsaXNKc3hOb2RlOmwsaXNMb25nQ3VycmllZENhbGxFeHByZXNzaW9uOkMsc2hvdWxkUHJpbnRDb21tYTptLGdldENhbGxBcmd1bWVudHM6ZyxpdGVyYXRlQ2FsbEFyZ3VtZW50c1BhdGg6cCxpc05leHRMaW5lRW1wdHk6Zixpc0NhbGxFeHByZXNzaW9uOmgsaXNTdHJpbmdMaXRlcmFsOk4saXNPYmplY3RQcm9wZXJ0eTpUfT1YZSgpLHtidWlsZGVyczp7bGluZTpBLGhhcmRsaW5lOmIsc29mdGxpbmU6dixncm91cDpCLGluZGVudDp3LGNvbmRpdGlvbmFsR3JvdXA6SSxpZkJyZWFrOkUsYnJlYWtQYXJlbnQ6RH0sdXRpbHM6e3dpbGxCcmVhazpkfX09TGUoKSx7QXJnRXhwYW5zaW9uQmFpbG91dDp5fT1KdCgpLHtpc0NvbmNpc2VseVByaW50ZWRBcnJheTpvfT16dCgpO2Z1bmN0aW9uIHgoTSxILFApe2xldCBHPU0uZ2V0VmFsdWUoKSxyZT1HLnR5cGU9PT1cIkltcG9ydEV4cHJlc3Npb25cIiwkPWcoRyk7aWYoJC5sZW5ndGg9PT0wKXJldHVybltcIihcIix0KE0sSCwhMCksXCIpXCJdO2lmKF8oJCkpcmV0dXJuW1wiKFwiLFAoW1wiYXJndW1lbnRzXCIsMF0pLFwiLCBcIixQKFtcImFyZ3VtZW50c1wiLDFdKSxcIilcIl07bGV0IFc9ITEsZWU9ITEsVT0kLmxlbmd0aC0xLG5lPVtdO3AoTSwocSxsZSk9PntsZXQgdWU9cS5nZXROb2RlKCksUT1bUCgpXTtsZT09PVV8fChmKHVlLEgpPyhsZT09PTAmJihlZT0hMCksVz0hMCxRLnB1c2goXCIsXCIsYixiKSk6US5wdXNoKFwiLFwiLEEpKSxuZS5wdXNoKFEpfSk7bGV0IHNlPSEocmV8fEcuY2FsbGVlJiZHLmNhbGxlZS50eXBlPT09XCJJbXBvcnRcIikmJm0oSCxcImFsbFwiKT9cIixcIjpcIlwiO2Z1bmN0aW9uIFYoKXtyZXR1cm4gQihbXCIoXCIsdyhbQSwuLi5uZV0pLHNlLEEsXCIpXCJdLHtzaG91bGRCcmVhazohMH0pfWlmKFd8fE0uZ2V0UGFyZW50Tm9kZSgpLnR5cGUhPT1cIkRlY29yYXRvclwiJiZjKCQpKXJldHVybiBWKCk7bGV0IG9lPWsoJCksSz1TKCQsSCk7aWYob2V8fEspe2lmKG9lP25lLnNsaWNlKDEpLnNvbWUoZCk6bmUuc2xpY2UoMCwtMSkuc29tZShkKSlyZXR1cm4gVigpO2xldCBxPVtdO3RyeXtNLnRyeSgoKT0+e3AoTSwobGUsdWUpPT57b2UmJnVlPT09MCYmKHE9W1tQKFtdLHtleHBhbmRGaXJzdEFyZzohMH0pLG5lLmxlbmd0aD4xP1wiLFwiOlwiXCIsZWU/YjpBLGVlP2I6XCJcIl0sLi4ubmUuc2xpY2UoMSldKSxLJiZ1ZT09PVUmJihxPVsuLi5uZS5zbGljZSgwLC0xKSxQKFtdLHtleHBhbmRMYXN0QXJnOiEwfSldKX0pfSl9Y2F0Y2gobGUpe2lmKGxlIGluc3RhbmNlb2YgeSlyZXR1cm4gVigpO3Rocm93IGxlfXJldHVybltuZS5zb21lKGQpP0Q6XCJcIixJKFtbXCIoXCIsLi4ucSxcIilcIl0sb2U/W1wiKFwiLEIocVswXSx7c2hvdWxkQnJlYWs6ITB9KSwuLi5xLnNsaWNlKDEpLFwiKVwiXTpbXCIoXCIsLi4ubmUuc2xpY2UoMCwtMSksQihzKHEpLHtzaG91bGRCcmVhazohMH0pLFwiKVwiXSxWKCldKV19bGV0IEVlPVtcIihcIix3KFt2LC4uLm5lXSksRShzZSksdixcIilcIl07cmV0dXJuIEMoTSk/RWU6QihFZSx7c2hvdWxkQnJlYWs6bmUuc29tZShkKXx8V30pfWZ1bmN0aW9uIEYoTSl7bGV0IEg9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiExO3JldHVybiBNLnR5cGU9PT1cIk9iamVjdEV4cHJlc3Npb25cIiYmKE0ucHJvcGVydGllcy5sZW5ndGg+MHx8dShNKSl8fE0udHlwZT09PVwiQXJyYXlFeHByZXNzaW9uXCImJihNLmVsZW1lbnRzLmxlbmd0aD4wfHx1KE0pKXx8TS50eXBlPT09XCJUU1R5cGVBc3NlcnRpb25cIiYmRihNLmV4cHJlc3Npb24pfHxNLnR5cGU9PT1cIlRTQXNFeHByZXNzaW9uXCImJkYoTS5leHByZXNzaW9uKXx8TS50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cInx8TS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiJiYoIU0ucmV0dXJuVHlwZXx8IU0ucmV0dXJuVHlwZS50eXBlQW5ub3RhdGlvbnx8TS5yZXR1cm5UeXBlLnR5cGVBbm5vdGF0aW9uLnR5cGUhPT1cIlRTVHlwZVJlZmVyZW5jZVwifHxPKE0uYm9keSkpJiYoTS5ib2R5LnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCJ8fE0uYm9keS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiJiZGKE0uYm9keSwhMCl8fE0uYm9keS50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCJ8fE0uYm9keS50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cInx8IUgmJihoKE0uYm9keSl8fE0uYm9keS50eXBlPT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIil8fGwoTS5ib2R5KSl8fE0udHlwZT09PVwiRG9FeHByZXNzaW9uXCJ8fE0udHlwZT09PVwiTW9kdWxlRXhwcmVzc2lvblwifWZ1bmN0aW9uIFMoTSxIKXtsZXQgUD1zKE0pLEc9aShNKTtyZXR1cm4hdShQLGEuTGVhZGluZykmJiF1KFAsYS5UcmFpbGluZykmJkYoUCkmJighR3x8Ry50eXBlIT09UC50eXBlKSYmKE0ubGVuZ3RoIT09Mnx8Ry50eXBlIT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwifHxQLnR5cGUhPT1cIkFycmF5RXhwcmVzc2lvblwiKSYmIShNLmxlbmd0aD4xJiZQLnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwiJiZvKFAsSCkpfWZ1bmN0aW9uIGsoTSl7aWYoTS5sZW5ndGghPT0yKXJldHVybiExO2xldFtILFBdPU07cmV0dXJuIEgudHlwZT09PVwiTW9kdWxlRXhwcmVzc2lvblwiJiZSKFApPyEwOiF1KEgpJiYoSC50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cInx8SC50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiJiZILmJvZHkudHlwZT09PVwiQmxvY2tTdGF0ZW1lbnRcIikmJlAudHlwZSE9PVwiRnVuY3Rpb25FeHByZXNzaW9uXCImJlAudHlwZSE9PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiYmUC50eXBlIT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiYmIUYoUCl9ZnVuY3Rpb24gXyhNKXtyZXR1cm4gTS5sZW5ndGg9PT0yJiZNWzBdLnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCImJnIoTVswXSkubGVuZ3RoPT09MCYmTVswXS5ib2R5LnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCImJk1bMV0udHlwZT09PVwiQXJyYXlFeHByZXNzaW9uXCImJiFNLnNvbWUoSD0+dShIKSl9ZnVuY3Rpb24gTyhNKXtyZXR1cm4gTS50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwiJiYoTS5ib2R5LnNvbWUoSD0+SC50eXBlIT09XCJFbXB0eVN0YXRlbWVudFwiKXx8dShNLGEuRGFuZ2xpbmcpKX1mdW5jdGlvbiBSKE0pe3JldHVybiBNLnR5cGU9PT1cIk9iamVjdEV4cHJlc3Npb25cIiYmTS5wcm9wZXJ0aWVzLmxlbmd0aD09PTEmJlQoTS5wcm9wZXJ0aWVzWzBdKSYmTS5wcm9wZXJ0aWVzWzBdLmtleS50eXBlPT09XCJJZGVudGlmaWVyXCImJk0ucHJvcGVydGllc1swXS5rZXkubmFtZT09PVwidHlwZVwiJiZOKE0ucHJvcGVydGllc1swXS52YWx1ZSkmJk0ucHJvcGVydGllc1swXS52YWx1ZS52YWx1ZT09PVwibW9kdWxlXCJ9bi5leHBvcnRzPXh9fSksdW89Wih7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvbWVtYmVyLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntidWlsZGVyczp7c29mdGxpbmU6dCxncm91cDpzLGluZGVudDppLGxhYmVsOnJ9fT1MZSgpLHtpc051bWVyaWNMaXRlcmFsOnUsaXNNZW1iZXJFeHByZXNzaW9uOmEsaXNDYWxsRXhwcmVzc2lvbjpjfT1YZSgpLHtwcmludE9wdGlvbmFsVG9rZW46bH09b3QoKTtmdW5jdGlvbiBDKGcscCxmKXtsZXQgaD1nLmdldFZhbHVlKCksTj1nLmdldFBhcmVudE5vZGUoKSxULEE9MDtkbyBUPWcuZ2V0UGFyZW50Tm9kZShBKSxBKys7d2hpbGUoVCYmKGEoVCl8fFQudHlwZT09PVwiVFNOb25OdWxsRXhwcmVzc2lvblwiKSk7bGV0IGI9ZihcIm9iamVjdFwiKSx2PW0oZyxwLGYpLEI9VCYmKFQudHlwZT09PVwiTmV3RXhwcmVzc2lvblwifHxULnR5cGU9PT1cIkJpbmRFeHByZXNzaW9uXCJ8fFQudHlwZT09PVwiQXNzaWdubWVudEV4cHJlc3Npb25cIiYmVC5sZWZ0LnR5cGUhPT1cIklkZW50aWZpZXJcIil8fGguY29tcHV0ZWR8fGgub2JqZWN0LnR5cGU9PT1cIklkZW50aWZpZXJcIiYmaC5wcm9wZXJ0eS50eXBlPT09XCJJZGVudGlmaWVyXCImJiFhKE4pfHwoTi50eXBlPT09XCJBc3NpZ25tZW50RXhwcmVzc2lvblwifHxOLnR5cGU9PT1cIlZhcmlhYmxlRGVjbGFyYXRvclwiKSYmKGMoaC5vYmplY3QpJiZoLm9iamVjdC5hcmd1bWVudHMubGVuZ3RoPjB8fGgub2JqZWN0LnR5cGU9PT1cIlRTTm9uTnVsbEV4cHJlc3Npb25cIiYmYyhoLm9iamVjdC5leHByZXNzaW9uKSYmaC5vYmplY3QuZXhwcmVzc2lvbi5hcmd1bWVudHMubGVuZ3RoPjB8fGIubGFiZWw9PT1cIm1lbWJlci1jaGFpblwiKTtyZXR1cm4gcihiLmxhYmVsPT09XCJtZW1iZXItY2hhaW5cIj9cIm1lbWJlci1jaGFpblwiOlwibWVtYmVyXCIsW2IsQj92OnMoaShbdCx2XSkpXSl9ZnVuY3Rpb24gbShnLHAsZil7bGV0IGg9ZihcInByb3BlcnR5XCIpLE49Zy5nZXRWYWx1ZSgpLFQ9bChnKTtyZXR1cm4gTi5jb21wdXRlZD8hTi5wcm9wZXJ0eXx8dShOLnByb3BlcnR5KT9bVCxcIltcIixoLFwiXVwiXTpzKFtULFwiW1wiLGkoW3QsaF0pLHQsXCJdXCJdKTpbVCxcIi5cIixoXX1uLmV4cG9ydHM9e3ByaW50TWVtYmVyRXhwcmVzc2lvbjpDLHByaW50TWVtYmVyTG9va3VwOm19fX0pLE5tPVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L21lbWJlci1jaGFpbi5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7cHJpbnRDb21tZW50czp0fT1RZSgpLHtnZXRMYXN0OnMsaXNOZXh0TGluZUVtcHR5QWZ0ZXJJbmRleDppLGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleDpyfT1HZSgpLHU9a3QoKSx7aXNDYWxsRXhwcmVzc2lvbjphLGlzTWVtYmVyRXhwcmVzc2lvbjpjLGlzRnVuY3Rpb25PckFycm93RXhwcmVzc2lvbjpsLGlzTG9uZ0N1cnJpZWRDYWxsRXhwcmVzc2lvbjpDLGlzTWVtYmVyaXNoOm0saXNOdW1lcmljTGl0ZXJhbDpnLGlzU2ltcGxlQ2FsbEFyZ3VtZW50OnAsaGFzQ29tbWVudDpmLENvbW1lbnRDaGVja0ZsYWdzOmgsaXNOZXh0TGluZUVtcHR5Ok59PVhlKCkse2xvY0VuZDpUfT1udCgpLHtidWlsZGVyczp7am9pbjpBLGhhcmRsaW5lOmIsZ3JvdXA6dixpbmRlbnQ6Qixjb25kaXRpb25hbEdyb3VwOncsYnJlYWtQYXJlbnQ6SSxsYWJlbDpFfSx1dGlsczp7d2lsbEJyZWFrOkR9fT1MZSgpLGQ9bm8oKSx7cHJpbnRNZW1iZXJMb29rdXA6eX09dW8oKSx7cHJpbnRPcHRpb25hbFRva2VuOm8scHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzOngscHJpbnRCaW5kRXhwcmVzc2lvbkNhbGxlZTpGfT1vdCgpO2Z1bmN0aW9uIFMoayxfLE8pe2xldCBSPWsuZ2V0UGFyZW50Tm9kZSgpLE09IVJ8fFIudHlwZT09PVwiRXhwcmVzc2lvblN0YXRlbWVudFwiLEg9W107ZnVuY3Rpb24gUChtZSl7bGV0e29yaWdpbmFsVGV4dDpjZX09XyxoZT1yKGNlLG1lLFQpO3JldHVybiBjZS5jaGFyQXQoaGUpPT09XCIpXCI/aGUhPT0hMSYmaShjZSxoZSsxKTpOKG1lLF8pfWZ1bmN0aW9uIEcobWUpe2xldCBjZT1tZS5nZXRWYWx1ZSgpO2EoY2UpJiYobShjZS5jYWxsZWUpfHxhKGNlLmNhbGxlZSkpPyhILnVuc2hpZnQoe25vZGU6Y2UscHJpbnRlZDpbdChtZSxbbyhtZSkseChtZSxfLE8pLGQobWUsXyxPKV0sXyksUChjZSk/YjpcIlwiXX0pLG1lLmNhbGwoaGU9PkcoaGUpLFwiY2FsbGVlXCIpKTptKGNlKT8oSC51bnNoaWZ0KHtub2RlOmNlLG5lZWRzUGFyZW5zOnUobWUsXykscHJpbnRlZDp0KG1lLGMoY2UpP3kobWUsXyxPKTpGKG1lLF8sTyksXyl9KSxtZS5jYWxsKGhlPT5HKGhlKSxcIm9iamVjdFwiKSk6Y2UudHlwZT09PVwiVFNOb25OdWxsRXhwcmVzc2lvblwiPyhILnVuc2hpZnQoe25vZGU6Y2UscHJpbnRlZDp0KG1lLFwiIVwiLF8pfSksbWUuY2FsbChoZT0+RyhoZSksXCJleHByZXNzaW9uXCIpKTpILnVuc2hpZnQoe25vZGU6Y2UscHJpbnRlZDpPKCl9KX1sZXQgcmU9ay5nZXRWYWx1ZSgpO0gudW5zaGlmdCh7bm9kZTpyZSxwcmludGVkOltvKGspLHgoayxfLE8pLGQoayxfLE8pXX0pLHJlLmNhbGxlZSYmay5jYWxsKG1lPT5HKG1lKSxcImNhbGxlZVwiKTtsZXQgJD1bXSxXPVtIWzBdXSxlZT0xO2Zvcig7ZWU8SC5sZW5ndGgmJihIW2VlXS5ub2RlLnR5cGU9PT1cIlRTTm9uTnVsbEV4cHJlc3Npb25cInx8YShIW2VlXS5ub2RlKXx8YyhIW2VlXS5ub2RlKSYmSFtlZV0ubm9kZS5jb21wdXRlZCYmZyhIW2VlXS5ub2RlLnByb3BlcnR5KSk7KytlZSlXLnB1c2goSFtlZV0pO2lmKCFhKEhbMF0ubm9kZSkpZm9yKDtlZSsxPEgubGVuZ3RoJiYobShIW2VlXS5ub2RlKSYmbShIW2VlKzFdLm5vZGUpKTsrK2VlKVcucHVzaChIW2VlXSk7JC5wdXNoKFcpLFc9W107bGV0IFU9ITE7Zm9yKDtlZTxILmxlbmd0aDsrK2VlKXtpZihVJiZtKEhbZWVdLm5vZGUpKXtpZihIW2VlXS5ub2RlLmNvbXB1dGVkJiZnKEhbZWVdLm5vZGUucHJvcGVydHkpKXtXLnB1c2goSFtlZV0pO2NvbnRpbnVlfSQucHVzaChXKSxXPVtdLFU9ITF9KGEoSFtlZV0ubm9kZSl8fEhbZWVdLm5vZGUudHlwZT09PVwiSW1wb3J0RXhwcmVzc2lvblwiKSYmKFU9ITApLFcucHVzaChIW2VlXSksZihIW2VlXS5ub2RlLGguVHJhaWxpbmcpJiYoJC5wdXNoKFcpLFc9W10sVT0hMSl9Vy5sZW5ndGg+MCYmJC5wdXNoKFcpO2Z1bmN0aW9uIG5lKG1lKXtyZXR1cm4vXltBLVpdfF5bJF9dKyQvLnRlc3QobWUpfWZ1bmN0aW9uIHNlKG1lKXtyZXR1cm4gbWUubGVuZ3RoPD1fLnRhYldpZHRofWZ1bmN0aW9uIFYobWUpe2xldCBjZT1tZVsxXS5sZW5ndGg+MCYmbWVbMV1bMF0ubm9kZS5jb21wdXRlZDtpZihtZVswXS5sZW5ndGg9PT0xKXtsZXQgSj1tZVswXVswXS5ub2RlO3JldHVybiBKLnR5cGU9PT1cIlRoaXNFeHByZXNzaW9uXCJ8fEoudHlwZT09PVwiSWRlbnRpZmllclwiJiYobmUoSi5uYW1lKXx8TSYmc2UoSi5uYW1lKXx8Y2UpfWxldCBoZT1zKG1lWzBdKS5ub2RlO3JldHVybiBjKGhlKSYmaGUucHJvcGVydHkudHlwZT09PVwiSWRlbnRpZmllclwiJiYobmUoaGUucHJvcGVydHkubmFtZSl8fGNlKX1sZXQgb2U9JC5sZW5ndGg+PTImJiFmKCRbMV1bMF0ubm9kZSkmJlYoJCk7ZnVuY3Rpb24gSyhtZSl7bGV0IGNlPW1lLm1hcChoZT0+aGUucHJpbnRlZCk7cmV0dXJuIG1lLmxlbmd0aD4wJiZzKG1lKS5uZWVkc1BhcmVucz9bXCIoXCIsLi4uY2UsXCIpXCJdOmNlfWZ1bmN0aW9uIEVlKG1lKXtyZXR1cm4gbWUubGVuZ3RoPT09MD9cIlwiOkIodihbYixBKGIsbWUubWFwKEspKV0pKX1sZXQgcT0kLm1hcChLKSxsZT1xLHVlPW9lPzM6MixRPSQuZmxhdCgpLGRlPVEuc2xpY2UoMSwtMSkuc29tZShtZT0+ZihtZS5ub2RlLGguTGVhZGluZykpfHxRLnNsaWNlKDAsLTEpLnNvbWUobWU9PmYobWUubm9kZSxoLlRyYWlsaW5nKSl8fCRbdWVdJiZmKCRbdWVdWzBdLm5vZGUsaC5MZWFkaW5nKTtpZigkLmxlbmd0aDw9dWUmJiFkZSlyZXR1cm4gQyhrKT9sZTp2KGxlKTtsZXQgZ2U9cygkW29lPzE6MF0pLm5vZGUsdmU9IWEoZ2UpJiZQKGdlKSx4ZT1bSygkWzBdKSxvZT8kLnNsaWNlKDEsMikubWFwKEspOlwiXCIsdmU/YjpcIlwiLEVlKCQuc2xpY2Uob2U/MjoxKSldLHdlPUgubWFwKG1lPT57bGV0e25vZGU6Y2V9PW1lO3JldHVybiBjZX0pLmZpbHRlcihhKTtmdW5jdGlvbiBmZSgpe2xldCBtZT1zKHMoJCkpLm5vZGUsY2U9cyhxKTtyZXR1cm4gYShtZSkmJkQoY2UpJiZ3ZS5zbGljZSgwLC0xKS5zb21lKGhlPT5oZS5hcmd1bWVudHMuc29tZShsKSl9bGV0IHBlO3JldHVybiBkZXx8d2UubGVuZ3RoPjImJndlLnNvbWUobWU9PiFtZS5hcmd1bWVudHMuZXZlcnkoY2U9PnAoY2UsMCkpKXx8cS5zbGljZSgwLC0xKS5zb21lKEQpfHxmZSgpP3BlPXYoeGUpOnBlPVtEKGxlKXx8dmU/STpcIlwiLHcoW2xlLHhlXSldLEUoXCJtZW1iZXItY2hhaW5cIixwZSl9bi5leHBvcnRzPVN9fSksc289Wih7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvY2FsbC1leHByZXNzaW9uLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntidWlsZGVyczp7am9pbjp0LGdyb3VwOnN9fT1MZSgpLGk9a3QoKSx7Z2V0Q2FsbEFyZ3VtZW50czpyLGhhc0Zsb3dBbm5vdGF0aW9uQ29tbWVudDp1LGlzQ2FsbEV4cHJlc3Npb246YSxpc01lbWJlcmlzaDpjLGlzU3RyaW5nTGl0ZXJhbDpsLGlzVGVtcGxhdGVPbkl0c093bkxpbmU6Qyxpc1Rlc3RDYWxsOm0saXRlcmF0ZUNhbGxBcmd1bWVudHNQYXRoOmd9PVhlKCkscD1ObSgpLGY9bm8oKSx7cHJpbnRPcHRpb25hbFRva2VuOmgscHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzOk59PW90KCk7ZnVuY3Rpb24gVChiLHYsQil7bGV0IHc9Yi5nZXRWYWx1ZSgpLEk9Yi5nZXRQYXJlbnROb2RlKCksRT13LnR5cGU9PT1cIk5ld0V4cHJlc3Npb25cIixEPXcudHlwZT09PVwiSW1wb3J0RXhwcmVzc2lvblwiLGQ9aChiKSx5PXIodyk7aWYoeS5sZW5ndGg+MCYmKCFEJiYhRSYmQSh3LEkpfHx5Lmxlbmd0aD09PTEmJkMoeVswXSx2Lm9yaWdpbmFsVGV4dCl8fCFFJiZtKHcsSSkpKXtsZXQgRj1bXTtyZXR1cm4gZyhiLCgpPT57Ri5wdXNoKEIoKSl9KSxbRT9cIm5ldyBcIjpcIlwiLEIoXCJjYWxsZWVcIiksZCxOKGIsdixCKSxcIihcIix0KFwiLCBcIixGKSxcIilcIl19bGV0IG89KHYucGFyc2VyPT09XCJiYWJlbFwifHx2LnBhcnNlcj09PVwiYmFiZWwtZmxvd1wiKSYmdy5jYWxsZWUmJncuY2FsbGVlLnR5cGU9PT1cIklkZW50aWZpZXJcIiYmdSh3LmNhbGxlZS50cmFpbGluZ0NvbW1lbnRzKTtpZihvJiYody5jYWxsZWUudHJhaWxpbmdDb21tZW50c1swXS5wcmludGVkPSEwKSwhRCYmIUUmJmMody5jYWxsZWUpJiYhYi5jYWxsKEY9PmkoRix2KSxcImNhbGxlZVwiKSlyZXR1cm4gcChiLHYsQik7bGV0IHg9W0U/XCJuZXcgXCI6XCJcIixEP1wiaW1wb3J0XCI6QihcImNhbGxlZVwiKSxkLG8/XCIvKjo6IFwiLmNvbmNhdCh3LmNhbGxlZS50cmFpbGluZ0NvbW1lbnRzWzBdLnZhbHVlLnNsaWNlKDIpLnRyaW0oKSxcIiAqL1wiKTpcIlwiLE4oYix2LEIpLGYoYix2LEIpXTtyZXR1cm4gRHx8YSh3LmNhbGxlZSk/cyh4KTp4fWZ1bmN0aW9uIEEoYix2KXtpZihiLmNhbGxlZS50eXBlIT09XCJJZGVudGlmaWVyXCIpcmV0dXJuITE7aWYoYi5jYWxsZWUubmFtZT09PVwicmVxdWlyZVwiKXJldHVybiEwO2lmKGIuY2FsbGVlLm5hbWU9PT1cImRlZmluZVwiKXtsZXQgQj1yKGIpO3JldHVybiB2LnR5cGU9PT1cIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiYmKEIubGVuZ3RoPT09MXx8Qi5sZW5ndGg9PT0yJiZCWzBdLnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwifHxCLmxlbmd0aD09PTMmJmwoQlswXSkmJkJbMV0udHlwZT09PVwiQXJyYXlFeHByZXNzaW9uXCIpfXJldHVybiExfW4uZXhwb3J0cz17cHJpbnRDYWxsRXhwcmVzc2lvbjpUfX19KSxYdD1aKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9hc3NpZ25tZW50LmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3Zhcntpc05vbkVtcHR5QXJyYXk6dCxnZXRTdHJpbmdXaWR0aDpzfT1HZSgpLHtidWlsZGVyczp7bGluZTppLGdyb3VwOnIsaW5kZW50OnUsaW5kZW50SWZCcmVhazphLGxpbmVTdWZmaXhCb3VuZGFyeTpjfSx1dGlsczp7Y2xlYW5Eb2M6bCx3aWxsQnJlYWs6QyxjYW5CcmVhazptfX09TGUoKSx7aGFzTGVhZGluZ093bkxpbmVDb21tZW50OmcsaXNCaW5hcnlpc2g6cCxpc1N0cmluZ0xpdGVyYWw6Zixpc0xpdGVyYWw6aCxpc051bWVyaWNMaXRlcmFsOk4saXNDYWxsRXhwcmVzc2lvbjpULGlzTWVtYmVyRXhwcmVzc2lvbjpBLGdldENhbGxBcmd1bWVudHM6YixyYXdUZXh0OnYsaGFzQ29tbWVudDpCLGlzU2lnbmVkTnVtZXJpY0xpdGVyYWw6dyxpc09iamVjdFByb3BlcnR5Okl9PVhlKCkse3Nob3VsZElubGluZUxvZ2ljYWxFeHByZXNzaW9uOkV9PUpuKCkse3ByaW50Q2FsbEV4cHJlc3Npb246RH09c28oKTtmdW5jdGlvbiBkKFYsb2UsSyxFZSxxLGxlKXtsZXQgdWU9eChWLG9lLEssRWUsbGUpLFE9SyhsZSx7YXNzaWdubWVudExheW91dDp1ZX0pO3N3aXRjaCh1ZSl7Y2FzZVwiYnJlYWstYWZ0ZXItb3BlcmF0b3JcIjpyZXR1cm4gcihbcihFZSkscSxyKHUoW2ksUV0pKV0pO2Nhc2VcIm5ldmVyLWJyZWFrLWFmdGVyLW9wZXJhdG9yXCI6cmV0dXJuIHIoW3IoRWUpLHEsXCIgXCIsUV0pO2Nhc2VcImZsdWlkXCI6e2xldCBkZT1TeW1ib2woXCJhc3NpZ25tZW50XCIpO3JldHVybiByKFtyKEVlKSxxLHIodShpKSx7aWQ6ZGV9KSxjLGEoUSx7Z3JvdXBJZDpkZX0pXSl9Y2FzZVwiYnJlYWstbGhzXCI6cmV0dXJuIHIoW0VlLHEsXCIgXCIscihRKV0pO2Nhc2VcImNoYWluXCI6cmV0dXJuW3IoRWUpLHEsaSxRXTtjYXNlXCJjaGFpbi10YWlsXCI6cmV0dXJuW3IoRWUpLHEsdShbaSxRXSldO2Nhc2VcImNoYWluLXRhaWwtYXJyb3ctY2hhaW5cIjpyZXR1cm5bcihFZSkscSxRXTtjYXNlXCJvbmx5LWxlZnRcIjpyZXR1cm4gRWV9fWZ1bmN0aW9uIHkoVixvZSxLKXtsZXQgRWU9Vi5nZXRWYWx1ZSgpO3JldHVybiBkKFYsb2UsSyxLKFwibGVmdFwiKSxbXCIgXCIsRWUub3BlcmF0b3JdLFwicmlnaHRcIil9ZnVuY3Rpb24gbyhWLG9lLEspe3JldHVybiBkKFYsb2UsSyxLKFwiaWRcIiksXCIgPVwiLFwiaW5pdFwiKX1mdW5jdGlvbiB4KFYsb2UsSyxFZSxxKXtsZXQgbGU9Vi5nZXRWYWx1ZSgpLHVlPWxlW3FdO2lmKCF1ZSlyZXR1cm5cIm9ubHktbGVmdFwiO2xldCBRPSFrKHVlKTtpZihWLm1hdGNoKGssXyx4ZT0+IVF8fHhlLnR5cGUhPT1cIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiYmeGUudHlwZSE9PVwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSlyZXR1cm4gUT91ZS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiJiZ1ZS5ib2R5LnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI/XCJjaGFpbi10YWlsLWFycm93LWNoYWluXCI6XCJjaGFpbi10YWlsXCI6XCJjaGFpblwiO2lmKCFRJiZrKHVlLnJpZ2h0KXx8ZyhvZS5vcmlnaW5hbFRleHQsdWUpKXJldHVyblwiYnJlYWstYWZ0ZXItb3BlcmF0b3JcIjtpZih1ZS50eXBlPT09XCJDYWxsRXhwcmVzc2lvblwiJiZ1ZS5jYWxsZWUubmFtZT09PVwicmVxdWlyZVwifHxvZS5wYXJzZXI9PT1cImpzb241XCJ8fG9lLnBhcnNlcj09PVwianNvblwiKXJldHVyblwibmV2ZXItYnJlYWstYWZ0ZXItb3BlcmF0b3JcIjtpZihTKGxlKXx8TyhsZSl8fEgobGUpfHxQKGxlKSYmbShFZSkpcmV0dXJuXCJicmVhay1saHNcIjtsZXQgdmU9VShsZSxFZSxvZSk7cmV0dXJuIFYuY2FsbCgoKT0+RihWLG9lLEssdmUpLHEpP1wiYnJlYWstYWZ0ZXItb3BlcmF0b3JcIjp2ZXx8dWUudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCJ8fHVlLnR5cGU9PT1cIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwifHx1ZS50eXBlPT09XCJCb29sZWFuTGl0ZXJhbFwifHxOKHVlKXx8dWUudHlwZT09PVwiQ2xhc3NFeHByZXNzaW9uXCI/XCJuZXZlci1icmVhay1hZnRlci1vcGVyYXRvclwiOlwiZmx1aWRcIn1mdW5jdGlvbiBGKFYsb2UsSyxFZSl7bGV0IHE9Vi5nZXRWYWx1ZSgpO2lmKHAocSkmJiFFKHEpKXJldHVybiEwO3N3aXRjaChxLnR5cGUpe2Nhc2VcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiOmNhc2VcIlNlcXVlbmNlRXhwcmVzc2lvblwiOnJldHVybiEwO2Nhc2VcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOntsZXR7dGVzdDpRfT1xO3JldHVybiBwKFEpJiYhRShRKX1jYXNlXCJDbGFzc0V4cHJlc3Npb25cIjpyZXR1cm4gdChxLmRlY29yYXRvcnMpfWlmKEVlKXJldHVybiExO2xldCBsZT1xLHVlPVtdO2Zvcig7OylpZihsZS50eXBlPT09XCJVbmFyeUV4cHJlc3Npb25cIilsZT1sZS5hcmd1bWVudCx1ZS5wdXNoKFwiYXJndW1lbnRcIik7ZWxzZSBpZihsZS50eXBlPT09XCJUU05vbk51bGxFeHByZXNzaW9uXCIpbGU9bGUuZXhwcmVzc2lvbix1ZS5wdXNoKFwiZXhwcmVzc2lvblwiKTtlbHNlIGJyZWFrO3JldHVybiEhKGYobGUpfHxWLmNhbGwoKCk9PiQoVixvZSxLKSwuLi51ZSkpfWZ1bmN0aW9uIFMoVil7aWYoXyhWKSl7bGV0IG9lPVYubGVmdHx8Vi5pZDtyZXR1cm4gb2UudHlwZT09PVwiT2JqZWN0UGF0dGVyblwiJiZvZS5wcm9wZXJ0aWVzLmxlbmd0aD4yJiZvZS5wcm9wZXJ0aWVzLnNvbWUoSz0+SShLKSYmKCFLLnNob3J0aGFuZHx8Sy52YWx1ZSYmSy52YWx1ZS50eXBlPT09XCJBc3NpZ25tZW50UGF0dGVyblwiKSl9cmV0dXJuITF9ZnVuY3Rpb24gayhWKXtyZXR1cm4gVi50eXBlPT09XCJBc3NpZ25tZW50RXhwcmVzc2lvblwifWZ1bmN0aW9uIF8oVil7cmV0dXJuIGsoVil8fFYudHlwZT09PVwiVmFyaWFibGVEZWNsYXJhdG9yXCJ9ZnVuY3Rpb24gTyhWKXtsZXQgb2U9UihWKTtpZih0KG9lKSl7bGV0IEs9Vi50eXBlPT09XCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCI/XCJjb25zdHJhaW50XCI6XCJib3VuZFwiO2lmKG9lLmxlbmd0aD4xJiZvZS5zb21lKEVlPT5FZVtLXXx8RWUuZGVmYXVsdCkpcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gUihWKXtyZXR1cm4gTShWKSYmVi50eXBlUGFyYW1ldGVycyYmVi50eXBlUGFyYW1ldGVycy5wYXJhbXM/Vi50eXBlUGFyYW1ldGVycy5wYXJhbXM6bnVsbH1mdW5jdGlvbiBNKFYpe3JldHVybiBWLnR5cGU9PT1cIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cInx8Vi50eXBlPT09XCJUeXBlQWxpYXNcIn1mdW5jdGlvbiBIKFYpe2lmKFYudHlwZSE9PVwiVmFyaWFibGVEZWNsYXJhdG9yXCIpcmV0dXJuITE7bGV0e3R5cGVBbm5vdGF0aW9uOm9lfT1WLmlkO2lmKCFvZXx8IW9lLnR5cGVBbm5vdGF0aW9uKXJldHVybiExO2xldCBLPUcob2UudHlwZUFubm90YXRpb24pO3JldHVybiB0KEspJiZLLmxlbmd0aD4xJiZLLnNvbWUoRWU9PnQoRyhFZSkpfHxFZS50eXBlPT09XCJUU0NvbmRpdGlvbmFsVHlwZVwiKX1mdW5jdGlvbiBQKFYpe3JldHVybiBWLnR5cGU9PT1cIlZhcmlhYmxlRGVjbGFyYXRvclwiJiZWLmluaXQmJlYuaW5pdC50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwifWZ1bmN0aW9uIEcoVil7cmV0dXJuIHJlKFYpJiZWLnR5cGVQYXJhbWV0ZXJzJiZWLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcz9WLnR5cGVQYXJhbWV0ZXJzLnBhcmFtczpudWxsfWZ1bmN0aW9uIHJlKFYpe3JldHVybiBWLnR5cGU9PT1cIlRTVHlwZVJlZmVyZW5jZVwifHxWLnR5cGU9PT1cIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwifWZ1bmN0aW9uICQoVixvZSxLKXtsZXQgRWU9YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT12b2lkIDA/YXJndW1lbnRzWzNdOiExLHE9Vi5nZXRWYWx1ZSgpLGxlPSgpPT4kKFYsb2UsSywhMCk7aWYocS50eXBlPT09XCJUU05vbk51bGxFeHByZXNzaW9uXCIpcmV0dXJuIFYuY2FsbChsZSxcImV4cHJlc3Npb25cIik7aWYoVChxKSl7aWYoRChWLG9lLEspLmxhYmVsPT09XCJtZW1iZXItY2hhaW5cIilyZXR1cm4hMTtsZXQgUT1iKHEpO3JldHVybiEoUS5sZW5ndGg9PT0wfHxRLmxlbmd0aD09PTEmJmVlKFFbMF0sb2UpKXx8bmUocSxLKT8hMTpWLmNhbGwobGUsXCJjYWxsZWVcIil9cmV0dXJuIEEocSk/Vi5jYWxsKGxlLFwib2JqZWN0XCIpOkVlJiYocS50eXBlPT09XCJJZGVudGlmaWVyXCJ8fHEudHlwZT09PVwiVGhpc0V4cHJlc3Npb25cIil9dmFyIFc9LjI1O2Z1bmN0aW9uIGVlKFYsb2Upe2xldHtwcmludFdpZHRoOkt9PW9lO2lmKEIoVikpcmV0dXJuITE7bGV0IEVlPUsqVztpZihWLnR5cGU9PT1cIlRoaXNFeHByZXNzaW9uXCJ8fFYudHlwZT09PVwiSWRlbnRpZmllclwiJiZWLm5hbWUubGVuZ3RoPD1FZXx8dyhWKSYmIUIoVi5hcmd1bWVudCkpcmV0dXJuITA7bGV0IHE9Vi50eXBlPT09XCJMaXRlcmFsXCImJlwicmVnZXhcImluIFYmJlYucmVnZXgucGF0dGVybnx8Vi50eXBlPT09XCJSZWdFeHBMaXRlcmFsXCImJlYucGF0dGVybjtyZXR1cm4gcT9xLmxlbmd0aDw9RWU6ZihWKT92KFYpLmxlbmd0aDw9RWU6Vi50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcIj9WLmV4cHJlc3Npb25zLmxlbmd0aD09PTAmJlYucXVhc2lzWzBdLnZhbHVlLnJhdy5sZW5ndGg8PUVlJiYhVi5xdWFzaXNbMF0udmFsdWUucmF3LmluY2x1ZGVzKGBcbmApOmgoVil9ZnVuY3Rpb24gVShWLG9lLEspe2lmKCFJKFYpKXJldHVybiExO29lPWwob2UpO2xldCBFZT0zO3JldHVybiB0eXBlb2Ygb2U9PVwic3RyaW5nXCImJnMob2UpPEsudGFiV2lkdGgrRWV9ZnVuY3Rpb24gbmUoVixvZSl7bGV0IEs9c2UoVik7aWYodChLKSl7aWYoSy5sZW5ndGg+MSlyZXR1cm4hMDtpZihLLmxlbmd0aD09PTEpe2xldCBxPUtbMF07aWYocS50eXBlPT09XCJUU1VuaW9uVHlwZVwifHxxLnR5cGU9PT1cIlVuaW9uVHlwZUFubm90YXRpb25cInx8cS50eXBlPT09XCJUU0ludGVyc2VjdGlvblR5cGVcInx8cS50eXBlPT09XCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwifHxxLnR5cGU9PT1cIlRTVHlwZUxpdGVyYWxcInx8cS50eXBlPT09XCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKXJldHVybiEwfWxldCBFZT1WLnR5cGVQYXJhbWV0ZXJzP1widHlwZVBhcmFtZXRlcnNcIjpcInR5cGVBcmd1bWVudHNcIjtpZihDKG9lKEVlKSkpcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gc2UoVil7cmV0dXJuIFYudHlwZVBhcmFtZXRlcnMmJlYudHlwZVBhcmFtZXRlcnMucGFyYW1zfHxWLnR5cGVBcmd1bWVudHMmJlYudHlwZUFyZ3VtZW50cy5wYXJhbXN9bi5leHBvcnRzPXtwcmludFZhcmlhYmxlRGVjbGFyYXRvcjpvLHByaW50QXNzaWdubWVudEV4cHJlc3Npb246eSxwcmludEFzc2lnbm1lbnQ6ZCxpc0Fycm93RnVuY3Rpb25WYXJpYWJsZURlY2xhcmF0b3I6UH19fSksd3I9Wih7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvZnVuY3Rpb24tcGFyYW1ldGVycy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7Z2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3Rlcjp0fT1HZSgpLHtwcmludERhbmdsaW5nQ29tbWVudHM6c309UWUoKSx7YnVpbGRlcnM6e2xpbmU6aSxoYXJkbGluZTpyLHNvZnRsaW5lOnUsZ3JvdXA6YSxpbmRlbnQ6YyxpZkJyZWFrOmx9LHV0aWxzOntyZW1vdmVMaW5lczpDLHdpbGxCcmVhazptfX09TGUoKSx7Z2V0RnVuY3Rpb25QYXJhbWV0ZXJzOmcsaXRlcmF0ZUZ1bmN0aW9uUGFyYW1ldGVyc1BhdGg6cCxpc1NpbXBsZVR5cGU6Zixpc1Rlc3RDYWxsOmgsaXNUeXBlQW5ub3RhdGlvbkFGdW5jdGlvbjpOLGlzT2JqZWN0VHlwZTpULGlzT2JqZWN0VHlwZVByb3BlcnR5QUZ1bmN0aW9uOkEsaGFzUmVzdFBhcmFtZXRlcjpiLHNob3VsZFByaW50Q29tbWE6dixoYXNDb21tZW50OkIsaXNOZXh0TGluZUVtcHR5Ond9PVhlKCkse2xvY0VuZDpJfT1udCgpLHtBcmdFeHBhbnNpb25CYWlsb3V0OkV9PUp0KCkse3ByaW50RnVuY3Rpb25UeXBlUGFyYW1ldGVyczpEfT1vdCgpO2Z1bmN0aW9uIGQoRixTLGssXyxPKXtsZXQgUj1GLmdldFZhbHVlKCksTT1nKFIpLEg9Tz9EKEYsayxTKTpcIlwiO2lmKE0ubGVuZ3RoPT09MClyZXR1cm5bSCxcIihcIixzKEYsaywhMCxVPT50KGsub3JpZ2luYWxUZXh0LFUsSSk9PT1cIilcIiksXCIpXCJdO2xldCBQPUYuZ2V0UGFyZW50Tm9kZSgpLEc9aChQKSxyZT15KFIpLCQ9W107aWYocChGLChVLG5lKT0+e2xldCBzZT1uZT09PU0ubGVuZ3RoLTE7c2UmJlIucmVzdCYmJC5wdXNoKFwiLi4uXCIpLCQucHVzaChTKCkpLCFzZSYmKCQucHVzaChcIixcIiksR3x8cmU/JC5wdXNoKFwiIFwiKTp3KE1bbmVdLGspPyQucHVzaChyLHIpOiQucHVzaChpKSl9KSxfKXtpZihtKEgpfHxtKCQpKXRocm93IG5ldyBFO3JldHVybiBhKFtDKEgpLFwiKFwiLEMoJCksXCIpXCJdKX1sZXQgVz1NLmV2ZXJ5KFU9PiFVLmRlY29yYXRvcnMpO3JldHVybiByZSYmVz9bSCxcIihcIiwuLi4kLFwiKVwiXTpHP1tILFwiKFwiLC4uLiQsXCIpXCJdOihBKFApfHxOKFApfHxQLnR5cGU9PT1cIlR5cGVBbGlhc1wifHxQLnR5cGU9PT1cIlVuaW9uVHlwZUFubm90YXRpb25cInx8UC50eXBlPT09XCJUU1VuaW9uVHlwZVwifHxQLnR5cGU9PT1cIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCJ8fFAudHlwZT09PVwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiJiZQLnJldHVyblR5cGU9PT1SKSYmTS5sZW5ndGg9PT0xJiZNWzBdLm5hbWU9PT1udWxsJiZSLnRoaXMhPT1NWzBdJiZNWzBdLnR5cGVBbm5vdGF0aW9uJiZSLnR5cGVQYXJhbWV0ZXJzPT09bnVsbCYmZihNWzBdLnR5cGVBbm5vdGF0aW9uKSYmIVIucmVzdD9rLmFycm93UGFyZW5zPT09XCJhbHdheXNcIj9bXCIoXCIsLi4uJCxcIilcIl06JDpbSCxcIihcIixjKFt1LC4uLiRdKSxsKCFiKFIpJiZ2KGssXCJhbGxcIik/XCIsXCI6XCJcIiksdSxcIilcIl19ZnVuY3Rpb24geShGKXtpZighRilyZXR1cm4hMTtsZXQgUz1nKEYpO2lmKFMubGVuZ3RoIT09MSlyZXR1cm4hMTtsZXRba109UztyZXR1cm4hQihrKSYmKGsudHlwZT09PVwiT2JqZWN0UGF0dGVyblwifHxrLnR5cGU9PT1cIkFycmF5UGF0dGVyblwifHxrLnR5cGU9PT1cIklkZW50aWZpZXJcIiYmay50eXBlQW5ub3RhdGlvbiYmKGsudHlwZUFubm90YXRpb24udHlwZT09PVwiVHlwZUFubm90YXRpb25cInx8ay50eXBlQW5ub3RhdGlvbi50eXBlPT09XCJUU1R5cGVBbm5vdGF0aW9uXCIpJiZUKGsudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24pfHxrLnR5cGU9PT1cIkZ1bmN0aW9uVHlwZVBhcmFtXCImJlQoay50eXBlQW5ub3RhdGlvbil8fGsudHlwZT09PVwiQXNzaWdubWVudFBhdHRlcm5cIiYmKGsubGVmdC50eXBlPT09XCJPYmplY3RQYXR0ZXJuXCJ8fGsubGVmdC50eXBlPT09XCJBcnJheVBhdHRlcm5cIikmJihrLnJpZ2h0LnR5cGU9PT1cIklkZW50aWZpZXJcInx8ay5yaWdodC50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCImJmsucmlnaHQucHJvcGVydGllcy5sZW5ndGg9PT0wfHxrLnJpZ2h0LnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwiJiZrLnJpZ2h0LmVsZW1lbnRzLmxlbmd0aD09PTApKX1mdW5jdGlvbiBvKEYpe2xldCBTO3JldHVybiBGLnJldHVyblR5cGU/KFM9Ri5yZXR1cm5UeXBlLFMudHlwZUFubm90YXRpb24mJihTPVMudHlwZUFubm90YXRpb24pKTpGLnR5cGVBbm5vdGF0aW9uJiYoUz1GLnR5cGVBbm5vdGF0aW9uKSxTfWZ1bmN0aW9uIHgoRixTKXtsZXQgaz1vKEYpO2lmKCFrKXJldHVybiExO2xldCBfPUYudHlwZVBhcmFtZXRlcnMmJkYudHlwZVBhcmFtZXRlcnMucGFyYW1zO2lmKF8pe2lmKF8ubGVuZ3RoPjEpcmV0dXJuITE7aWYoXy5sZW5ndGg9PT0xKXtsZXQgTz1fWzBdO2lmKE8uY29uc3RyYWludHx8Ty5kZWZhdWx0KXJldHVybiExfX1yZXR1cm4gZyhGKS5sZW5ndGg9PT0xJiYoVChrKXx8bShTKSl9bi5leHBvcnRzPXtwcmludEZ1bmN0aW9uUGFyYW1ldGVyczpkLHNob3VsZEh1Z0Z1bmN0aW9uUGFyYW1ldGVyczp5LHNob3VsZEdyb3VwRnVuY3Rpb25QYXJhbWV0ZXJzOnh9fX0pLF9yPVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L3R5cGUtYW5ub3RhdGlvbi5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7cHJpbnRDb21tZW50czp0LHByaW50RGFuZ2xpbmdDb21tZW50czpzfT1RZSgpLHtpc05vbkVtcHR5QXJyYXk6aX09R2UoKSx7YnVpbGRlcnM6e2dyb3VwOnIsam9pbjp1LGxpbmU6YSxzb2Z0bGluZTpjLGluZGVudDpsLGFsaWduOkMsaWZCcmVhazptfX09TGUoKSxnPWt0KCkse2xvY1N0YXJ0OnB9PW50KCkse2lzU2ltcGxlVHlwZTpmLGlzT2JqZWN0VHlwZTpoLGhhc0xlYWRpbmdPd25MaW5lQ29tbWVudDpOLGlzT2JqZWN0VHlwZVByb3BlcnR5QUZ1bmN0aW9uOlQsc2hvdWxkUHJpbnRDb21tYTpBfT1YZSgpLHtwcmludEFzc2lnbm1lbnQ6Yn09WHQoKSx7cHJpbnRGdW5jdGlvblBhcmFtZXRlcnM6dixzaG91bGRHcm91cEZ1bmN0aW9uUGFyYW1ldGVyczpCfT13cigpLHtwcmludEFycmF5SXRlbXM6d309enQoKTtmdW5jdGlvbiBJKFMpe2lmKGYoUyl8fGgoUykpcmV0dXJuITA7aWYoUy50eXBlPT09XCJVbmlvblR5cGVBbm5vdGF0aW9uXCJ8fFMudHlwZT09PVwiVFNVbmlvblR5cGVcIil7bGV0IGs9Uy50eXBlcy5maWx0ZXIoTz0+Ty50eXBlPT09XCJWb2lkVHlwZUFubm90YXRpb25cInx8Ty50eXBlPT09XCJUU1ZvaWRLZXl3b3JkXCJ8fE8udHlwZT09PVwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwifHxPLnR5cGU9PT1cIlRTTnVsbEtleXdvcmRcIikubGVuZ3RoLF89Uy50eXBlcy5zb21lKE89Pk8udHlwZT09PVwiT2JqZWN0VHlwZUFubm90YXRpb25cInx8Ty50eXBlPT09XCJUU1R5cGVMaXRlcmFsXCJ8fE8udHlwZT09PVwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCJ8fE8udHlwZT09PVwiVFNUeXBlUmVmZXJlbmNlXCIpO2lmKFMudHlwZXMubGVuZ3RoLTE9PT1rJiZfKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIEUoUyxrLF8pe2xldCBPPWsuc2VtaT9cIjtcIjpcIlwiLFI9Uy5nZXRWYWx1ZSgpLE09W107cmV0dXJuIE0ucHVzaChcIm9wYXF1ZSB0eXBlIFwiLF8oXCJpZFwiKSxfKFwidHlwZVBhcmFtZXRlcnNcIikpLFIuc3VwZXJ0eXBlJiZNLnB1c2goXCI6IFwiLF8oXCJzdXBlcnR5cGVcIikpLFIuaW1wbHR5cGUmJk0ucHVzaChcIiA9IFwiLF8oXCJpbXBsdHlwZVwiKSksTS5wdXNoKE8pLE19ZnVuY3Rpb24gRChTLGssXyl7bGV0IE89ay5zZW1pP1wiO1wiOlwiXCIsUj1TLmdldFZhbHVlKCksTT1bXTtSLmRlY2xhcmUmJk0ucHVzaChcImRlY2xhcmUgXCIpLE0ucHVzaChcInR5cGUgXCIsXyhcImlkXCIpLF8oXCJ0eXBlUGFyYW1ldGVyc1wiKSk7bGV0IEg9Ui50eXBlPT09XCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCI/XCJ0eXBlQW5ub3RhdGlvblwiOlwicmlnaHRcIjtyZXR1cm5bYihTLGssXyxNLFwiID1cIixIKSxPXX1mdW5jdGlvbiBkKFMsayxfKXtsZXQgTz1TLmdldFZhbHVlKCksUj1TLm1hcChfLFwidHlwZXNcIiksTT1bXSxIPSExO2ZvcihsZXQgUD0wO1A8Ui5sZW5ndGg7KytQKVA9PT0wP00ucHVzaChSW1BdKTpoKE8udHlwZXNbUC0xXSkmJmgoTy50eXBlc1tQXSk/TS5wdXNoKFtcIiAmIFwiLEg/bChSW1BdKTpSW1BdXSk6IWgoTy50eXBlc1tQLTFdKSYmIWgoTy50eXBlc1tQXSk/TS5wdXNoKGwoW1wiICZcIixhLFJbUF1dKSk6KFA+MSYmKEg9ITApLE0ucHVzaChcIiAmIFwiLFA+MT9sKFJbUF0pOlJbUF0pKTtyZXR1cm4gcihNKX1mdW5jdGlvbiB5KFMsayxfKXtsZXQgTz1TLmdldFZhbHVlKCksUj1TLmdldFBhcmVudE5vZGUoKSxNPVIudHlwZSE9PVwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiYmUi50eXBlIT09XCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCImJlIudHlwZSE9PVwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCImJlIudHlwZSE9PVwiVFNUeXBlUmVmZXJlbmNlXCImJlIudHlwZSE9PVwiVFNUeXBlQXNzZXJ0aW9uXCImJlIudHlwZSE9PVwiVHVwbGVUeXBlQW5ub3RhdGlvblwiJiZSLnR5cGUhPT1cIlRTVHVwbGVUeXBlXCImJiEoUi50eXBlPT09XCJGdW5jdGlvblR5cGVQYXJhbVwiJiYhUi5uYW1lJiZTLmdldFBhcmVudE5vZGUoMSkudGhpcyE9PVIpJiYhKChSLnR5cGU9PT1cIlR5cGVBbGlhc1wifHxSLnR5cGU9PT1cIlZhcmlhYmxlRGVjbGFyYXRvclwifHxSLnR5cGU9PT1cIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIikmJk4oay5vcmlnaW5hbFRleHQsTykpLEg9SShPKSxQPVMubWFwKCQ9PntsZXQgVz1fKCk7cmV0dXJuIEh8fChXPUMoMixXKSksdCgkLFcsayl9LFwidHlwZXNcIik7aWYoSClyZXR1cm4gdShcIiB8IFwiLFApO2xldCBHPU0mJiFOKGsub3JpZ2luYWxUZXh0LE8pLHJlPVttKFtHP2E6XCJcIixcInwgXCJdKSx1KFthLFwifCBcIl0sUCldO3JldHVybiBnKFMsayk/cihbbChyZSksY10pOlIudHlwZT09PVwiVHVwbGVUeXBlQW5ub3RhdGlvblwiJiZSLnR5cGVzLmxlbmd0aD4xfHxSLnR5cGU9PT1cIlRTVHVwbGVUeXBlXCImJlIuZWxlbWVudFR5cGVzLmxlbmd0aD4xP3IoW2woW20oW1wiKFwiLGNdKSxyZV0pLGMsbShcIilcIildKTpyKE0/bChyZSk6cmUpfWZ1bmN0aW9uIG8oUyxrLF8pe2xldCBPPVMuZ2V0VmFsdWUoKSxSPVtdLE09Uy5nZXRQYXJlbnROb2RlKDApLEg9Uy5nZXRQYXJlbnROb2RlKDEpLFA9Uy5nZXRQYXJlbnROb2RlKDIpLEc9Ty50eXBlPT09XCJUU0Z1bmN0aW9uVHlwZVwifHwhKChNLnR5cGU9PT1cIk9iamVjdFR5cGVQcm9wZXJ0eVwifHxNLnR5cGU9PT1cIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIikmJiFNLnZhcmlhbmNlJiYhTS5vcHRpb25hbCYmcChNKT09PXAoTyl8fE0udHlwZT09PVwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwifHxQJiZQLnR5cGU9PT1cIkRlY2xhcmVGdW5jdGlvblwiKSxyZT1HJiYoTS50eXBlPT09XCJUeXBlQW5ub3RhdGlvblwifHxNLnR5cGU9PT1cIlRTVHlwZUFubm90YXRpb25cIiksJD1yZSYmRyYmKE0udHlwZT09PVwiVHlwZUFubm90YXRpb25cInx8TS50eXBlPT09XCJUU1R5cGVBbm5vdGF0aW9uXCIpJiZILnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI7VChNKSYmKEc9ITAscmU9ITApLCQmJlIucHVzaChcIihcIik7bGV0IFc9dihTLF8saywhMSwhMCksZWU9Ty5yZXR1cm5UeXBlfHxPLnByZWRpY2F0ZXx8Ty50eXBlQW5ub3RhdGlvbj9bRz9cIiA9PiBcIjpcIjogXCIsXyhcInJldHVyblR5cGVcIiksXyhcInByZWRpY2F0ZVwiKSxfKFwidHlwZUFubm90YXRpb25cIildOlwiXCIsVT1CKE8sZWUpO3JldHVybiBSLnB1c2goVT9yKFcpOlcpLGVlJiZSLnB1c2goZWUpLCQmJlIucHVzaChcIilcIikscihSKX1mdW5jdGlvbiB4KFMsayxfKXtsZXQgTz1TLmdldFZhbHVlKCksUj1PLnR5cGU9PT1cIlRTVHVwbGVUeXBlXCI/XCJlbGVtZW50VHlwZXNcIjpcInR5cGVzXCIsTT1PW1JdLEg9aShNKSxQPUg/YzpcIlwiO3JldHVybiByKFtcIltcIixsKFtQLHcoUyxrLFIsXyldKSxtKEgmJkEoayxcImFsbFwiKT9cIixcIjpcIlwiKSxzKFMsaywhMCksUCxcIl1cIl0pfWZ1bmN0aW9uIEYoUyxrLF8pe2xldCBPPVMuZ2V0VmFsdWUoKSxSPU8udHlwZT09PVwiT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZVwiJiZPLm9wdGlvbmFsP1wiPy5bXCI6XCJbXCI7cmV0dXJuW18oXCJvYmplY3RUeXBlXCIpLFIsXyhcImluZGV4VHlwZVwiKSxcIl1cIl19bi5leHBvcnRzPXtwcmludE9wYXF1ZVR5cGU6RSxwcmludFR5cGVBbGlhczpELHByaW50SW50ZXJzZWN0aW9uVHlwZTpkLHByaW50VW5pb25UeXBlOnkscHJpbnRGdW5jdGlvblR5cGU6byxwcmludFR1cGxlVHlwZTp4LHByaW50SW5kZXhlZEFjY2Vzc1R5cGU6RixzaG91bGRIdWdUeXBlOkl9fX0pLFByPVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L3R5cGUtcGFyYW1ldGVycy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7cHJpbnREYW5nbGluZ0NvbW1lbnRzOnR9PVFlKCkse2J1aWxkZXJzOntqb2luOnMsbGluZTppLGhhcmRsaW5lOnIsc29mdGxpbmU6dSxncm91cDphLGluZGVudDpjLGlmQnJlYWs6bH19PUxlKCkse2lzVGVzdENhbGw6QyxoYXNDb21tZW50Om0sQ29tbWVudENoZWNrRmxhZ3M6Zyxpc1RTWEZpbGU6cCxzaG91bGRQcmludENvbW1hOmYsZ2V0RnVuY3Rpb25QYXJhbWV0ZXJzOmgsaXNPYmplY3RUeXBlOk59PVhlKCkse2NyZWF0ZUdyb3VwSWRNYXBwZXI6VH09R2UoKSx7c2hvdWxkSHVnVHlwZTpBfT1fcigpLHtpc0Fycm93RnVuY3Rpb25WYXJpYWJsZURlY2xhcmF0b3I6Yn09WHQoKSx2PVQoXCJ0eXBlUGFyYW1ldGVyc1wiKTtmdW5jdGlvbiBCKEUsRCxkLHkpe2xldCBvPUUuZ2V0VmFsdWUoKTtpZighb1t5XSlyZXR1cm5cIlwiO2lmKCFBcnJheS5pc0FycmF5KG9beV0pKXJldHVybiBkKHkpO2xldCB4PUUuZ2V0Tm9kZSgyKSxGPXgmJkMoeCk7aWYoIUUubWF0Y2goTz0+IShPW3ldLmxlbmd0aD09PTEmJk4oT1t5XVswXSkpLHZvaWQgMCwoTyxSKT0+Uj09PVwidHlwZUFubm90YXRpb25cIixPPT5PLnR5cGU9PT1cIklkZW50aWZpZXJcIixiKSYmKEZ8fG9beV0ubGVuZ3RoPT09MHx8b1t5XS5sZW5ndGg9PT0xJiYob1t5XVswXS50eXBlPT09XCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCJ8fEEob1t5XVswXSkpKSlyZXR1cm5bXCI8XCIscyhcIiwgXCIsRS5tYXAoZCx5KSksdyhFLEQpLFwiPlwiXTtsZXQgXz1vLnR5cGU9PT1cIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIj9cIlwiOmgobykubGVuZ3RoPT09MSYmcChEKSYmIW9beV1bMF0uY29uc3RyYWludCYmRS5nZXRQYXJlbnROb2RlKCkudHlwZT09PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIj9cIixcIjpmKEQsXCJhbGxcIik/bChcIixcIik6XCJcIjtyZXR1cm4gYShbXCI8XCIsYyhbdSxzKFtcIixcIixpXSxFLm1hcChkLHkpKV0pLF8sdSxcIj5cIl0se2lkOnYobyl9KX1mdW5jdGlvbiB3KEUsRCl7bGV0IGQ9RS5nZXRWYWx1ZSgpO2lmKCFtKGQsZy5EYW5nbGluZykpcmV0dXJuXCJcIjtsZXQgeT0hbShkLGcuTGluZSksbz10KEUsRCx5KTtyZXR1cm4geT9vOltvLHJdfWZ1bmN0aW9uIEkoRSxELGQpe2xldCB5PUUuZ2V0VmFsdWUoKSxvPVtdLHg9RS5nZXRQYXJlbnROb2RlKCk7cmV0dXJuIHgudHlwZT09PVwiVFNNYXBwZWRUeXBlXCI/KG8ucHVzaChcIltcIixkKFwibmFtZVwiKSkseS5jb25zdHJhaW50JiZvLnB1c2goXCIgaW4gXCIsZChcImNvbnN0cmFpbnRcIikpLHgubmFtZVR5cGUmJm8ucHVzaChcIiBhcyBcIixFLmNhbGxQYXJlbnQoKCk9PmQoXCJuYW1lVHlwZVwiKSkpLG8ucHVzaChcIl1cIiksbyk6KHkudmFyaWFuY2UmJm8ucHVzaChkKFwidmFyaWFuY2VcIikpLG8ucHVzaChkKFwibmFtZVwiKSkseS5ib3VuZCYmby5wdXNoKFwiOiBcIixkKFwiYm91bmRcIikpLHkuY29uc3RyYWludCYmby5wdXNoKFwiIGV4dGVuZHMgXCIsZChcImNvbnN0cmFpbnRcIikpLHkuZGVmYXVsdCYmby5wdXNoKFwiID0gXCIsZChcImRlZmF1bHRcIikpLG8pfW4uZXhwb3J0cz17cHJpbnRUeXBlUGFyYW1ldGVyOkkscHJpbnRUeXBlUGFyYW1ldGVyczpCLGdldFR5cGVQYXJhbWV0ZXJzR3JvdXBJZDp2fX19KSxLdD1aKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9wcm9wZXJ0eS5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7cHJpbnRDb21tZW50czp0fT1RZSgpLHtwcmludFN0cmluZzpzLHByaW50TnVtYmVyOml9PUdlKCkse2lzTnVtZXJpY0xpdGVyYWw6cixpc1NpbXBsZU51bWJlcjp1LGlzU3RyaW5nTGl0ZXJhbDphLGlzU3RyaW5nUHJvcFNhZmVUb1VucXVvdGU6YyxyYXdUZXh0Omx9PVhlKCkse3ByaW50QXNzaWdubWVudDpDfT1YdCgpLG09bmV3IFdlYWtNYXA7ZnVuY3Rpb24gZyhmLGgsTil7bGV0IFQ9Zi5nZXROb2RlKCk7aWYoVC5jb21wdXRlZClyZXR1cm5bXCJbXCIsTihcImtleVwiKSxcIl1cIl07bGV0IEE9Zi5nZXRQYXJlbnROb2RlKCkse2tleTpifT1UO2lmKFQudHlwZT09PVwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiYmYi50eXBlPT09XCJJZGVudGlmaWVyXCIpcmV0dXJuW1wiI1wiLE4oXCJrZXlcIildO2lmKGgucXVvdGVQcm9wcz09PVwiY29uc2lzdGVudFwiJiYhbS5oYXMoQSkpe2xldCB2PShBLnByb3BlcnRpZXN8fEEuYm9keXx8QS5tZW1iZXJzKS5zb21lKEI9PiFCLmNvbXB1dGVkJiZCLmtleSYmYShCLmtleSkmJiFjKEIsaCkpO20uc2V0KEEsdil9aWYoKGIudHlwZT09PVwiSWRlbnRpZmllclwifHxyKGIpJiZ1KGkobChiKSkpJiZTdHJpbmcoYi52YWx1ZSk9PT1pKGwoYikpJiYhKGgucGFyc2VyPT09XCJ0eXBlc2NyaXB0XCJ8fGgucGFyc2VyPT09XCJiYWJlbC10c1wiKSkmJihoLnBhcnNlcj09PVwianNvblwifHxoLnF1b3RlUHJvcHM9PT1cImNvbnNpc3RlbnRcIiYmbS5nZXQoQSkpKXtsZXQgdj1zKEpTT04uc3RyaW5naWZ5KGIudHlwZT09PVwiSWRlbnRpZmllclwiP2IubmFtZTpiLnZhbHVlLnRvU3RyaW5nKCkpLGgpO3JldHVybiBmLmNhbGwoQj0+dChCLHYsaCksXCJrZXlcIil9cmV0dXJuIGMoVCxoKSYmKGgucXVvdGVQcm9wcz09PVwiYXMtbmVlZGVkXCJ8fGgucXVvdGVQcm9wcz09PVwiY29uc2lzdGVudFwiJiYhbS5nZXQoQSkpP2YuY2FsbCh2PT50KHYsL15cXGQvLnRlc3QoYi52YWx1ZSk/aShiLnZhbHVlKTpiLnZhbHVlLGgpLFwia2V5XCIpOk4oXCJrZXlcIil9ZnVuY3Rpb24gcChmLGgsTil7cmV0dXJuIGYuZ2V0VmFsdWUoKS5zaG9ydGhhbmQ/TihcInZhbHVlXCIpOkMoZixoLE4sZyhmLGgsTiksXCI6XCIsXCJ2YWx1ZVwiKX1uLmV4cG9ydHM9e3ByaW50UHJvcGVydHk6cCxwcmludFByb3BlcnR5S2V5Omd9fX0pLElyPVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L2Z1bmN0aW9uLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PVV0KCkse3ByaW50RGFuZ2xpbmdDb21tZW50czpzLHByaW50Q29tbWVudHNTZXBhcmF0ZWx5Oml9PVFlKCkscj1zdCgpLHtnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXg6dX09R2UoKSx7YnVpbGRlcnM6e2xpbmU6YSxzb2Z0bGluZTpjLGdyb3VwOmwsaW5kZW50OkMsaWZCcmVhazptLGhhcmRsaW5lOmcsam9pbjpwLGluZGVudElmQnJlYWs6Zn0sdXRpbHM6e3JlbW92ZUxpbmVzOmgsd2lsbEJyZWFrOk59fT1MZSgpLHtBcmdFeHBhbnNpb25CYWlsb3V0OlR9PUp0KCkse2dldEZ1bmN0aW9uUGFyYW1ldGVyczpBLGhhc0xlYWRpbmdPd25MaW5lQ29tbWVudDpiLGlzRmxvd0Fubm90YXRpb25Db21tZW50OnYsaXNKc3hOb2RlOkIsaXNUZW1wbGF0ZU9uSXRzT3duTGluZTp3LHNob3VsZFByaW50Q29tbWE6SSxzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbjpFLGlzQmluYXJ5aXNoOkQsaXNMaW5lQ29tbWVudDpkLGhhc0NvbW1lbnQ6eSxnZXRDb21tZW50czpvLENvbW1lbnRDaGVja0ZsYWdzOngsaXNDYWxsTGlrZUV4cHJlc3Npb246Rixpc0NhbGxFeHByZXNzaW9uOlMsZ2V0Q2FsbEFyZ3VtZW50czprLGhhc05ha2VkTGVmdFNpZGU6XyxnZXRMZWZ0U2lkZTpPfT1YZSgpLHtsb2NFbmQ6Un09bnQoKSx7cHJpbnRGdW5jdGlvblBhcmFtZXRlcnM6TSxzaG91bGRHcm91cEZ1bmN0aW9uUGFyYW1ldGVyczpIfT13cigpLHtwcmludFByb3BlcnR5S2V5OlB9PUt0KCkse3ByaW50RnVuY3Rpb25UeXBlUGFyYW1ldGVyczpHfT1vdCgpO2Z1bmN0aW9uIHJlKHVlLFEsZGUsZ2Upe2xldCB2ZT11ZS5nZXRWYWx1ZSgpLHhlPSExO2lmKCh2ZS50eXBlPT09XCJGdW5jdGlvbkRlY2xhcmF0aW9uXCJ8fHZlLnR5cGU9PT1cIkZ1bmN0aW9uRXhwcmVzc2lvblwiKSYmZ2UmJmdlLmV4cGFuZExhc3RBcmcpe2xldCBjZT11ZS5nZXRQYXJlbnROb2RlKCk7UyhjZSkmJmsoY2UpLmxlbmd0aD4xJiYoeGU9ITApfWxldCB3ZT1bXTt2ZS50eXBlPT09XCJUU0RlY2xhcmVGdW5jdGlvblwiJiZ2ZS5kZWNsYXJlJiZ3ZS5wdXNoKFwiZGVjbGFyZSBcIiksdmUuYXN5bmMmJndlLnB1c2goXCJhc3luYyBcIiksdmUuZ2VuZXJhdG9yP3dlLnB1c2goXCJmdW5jdGlvbiogXCIpOndlLnB1c2goXCJmdW5jdGlvbiBcIiksdmUuaWQmJndlLnB1c2goUShcImlkXCIpKTtsZXQgZmU9TSh1ZSxRLGRlLHhlKSxwZT1vZSh1ZSxRLGRlKSxtZT1IKHZlLHBlKTtyZXR1cm4gd2UucHVzaChHKHVlLGRlLFEpLGwoW21lP2woZmUpOmZlLHBlXSksdmUuYm9keT9cIiBcIjpcIlwiLFEoXCJib2R5XCIpKSxkZS5zZW1pJiYodmUuZGVjbGFyZXx8IXZlLmJvZHkpJiZ3ZS5wdXNoKFwiO1wiKSx3ZX1mdW5jdGlvbiAkKHVlLFEsZGUpe2xldCBnZT11ZS5nZXROb2RlKCkse2tpbmQ6dmV9PWdlLHhlPWdlLnZhbHVlfHxnZSx3ZT1bXTtyZXR1cm4hdmV8fHZlPT09XCJpbml0XCJ8fHZlPT09XCJtZXRob2RcInx8dmU9PT1cImNvbnN0cnVjdG9yXCI/eGUuYXN5bmMmJndlLnB1c2goXCJhc3luYyBcIik6KHQub2sodmU9PT1cImdldFwifHx2ZT09PVwic2V0XCIpLHdlLnB1c2godmUsXCIgXCIpKSx4ZS5nZW5lcmF0b3ImJndlLnB1c2goXCIqXCIpLHdlLnB1c2goUCh1ZSxRLGRlKSxnZS5vcHRpb25hbHx8Z2Uua2V5Lm9wdGlvbmFsP1wiP1wiOlwiXCIpLGdlPT09eGU/d2UucHVzaChXKHVlLFEsZGUpKTp4ZS50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cIj93ZS5wdXNoKHVlLmNhbGwoZmU9PlcoZmUsUSxkZSksXCJ2YWx1ZVwiKSk6d2UucHVzaChkZShcInZhbHVlXCIpKSx3ZX1mdW5jdGlvbiBXKHVlLFEsZGUpe2xldCBnZT11ZS5nZXROb2RlKCksdmU9TSh1ZSxkZSxRKSx4ZT1vZSh1ZSxkZSxRKSx3ZT1IKGdlLHhlKSxmZT1bRyh1ZSxRLGRlKSxsKFt3ZT9sKHZlKTp2ZSx4ZV0pXTtyZXR1cm4gZ2UuYm9keT9mZS5wdXNoKFwiIFwiLGRlKFwiYm9keVwiKSk6ZmUucHVzaChRLnNlbWk/XCI7XCI6XCJcIiksZmV9ZnVuY3Rpb24gZWUodWUsUSxkZSxnZSl7bGV0IHZlPXVlLmdldFZhbHVlKCkseGU9W107aWYodmUuYXN5bmMmJnhlLnB1c2goXCJhc3luYyBcIiksVih1ZSxRKSl4ZS5wdXNoKGRlKFtcInBhcmFtc1wiLDBdKSk7ZWxzZXtsZXQgZmU9Z2UmJihnZS5leHBhbmRMYXN0QXJnfHxnZS5leHBhbmRGaXJzdEFyZykscGU9b2UodWUsZGUsUSk7aWYoZmUpe2lmKE4ocGUpKXRocm93IG5ldyBUO3BlPWwoaChwZSkpfXhlLnB1c2gobChbTSh1ZSxkZSxRLGZlLCEwKSxwZV0pKX1sZXQgd2U9cyh1ZSxRLCEwLGZlPT57bGV0IHBlPXUoUS5vcmlnaW5hbFRleHQsZmUsUik7cmV0dXJuIHBlIT09ITEmJlEub3JpZ2luYWxUZXh0LnNsaWNlKHBlLHBlKzIpPT09XCI9PlwifSk7cmV0dXJuIHdlJiZ4ZS5wdXNoKFwiIFwiLHdlKSx4ZX1mdW5jdGlvbiBVKHVlLFEsZGUsZ2UsdmUseGUpe2xldCB3ZT11ZS5nZXROYW1lKCksZmU9dWUuZ2V0UGFyZW50Tm9kZSgpLHBlPUYoZmUpJiZ3ZT09PVwiY2FsbGVlXCIsbWU9Qm9vbGVhbihRJiZRLmFzc2lnbm1lbnRMYXlvdXQpLGNlPXhlLmJvZHkudHlwZSE9PVwiQmxvY2tTdGF0ZW1lbnRcIiYmeGUuYm9keS50eXBlIT09XCJPYmplY3RFeHByZXNzaW9uXCImJnhlLmJvZHkudHlwZSE9PVwiU2VxdWVuY2VFeHByZXNzaW9uXCIsaGU9cGUmJmNlfHxRJiZRLmFzc2lnbm1lbnRMYXlvdXQ9PT1cImNoYWluLXRhaWwtYXJyb3ctY2hhaW5cIixKPVN5bWJvbChcImFycm93LWNoYWluXCIpO3JldHVybiB4ZS5ib2R5LnR5cGU9PT1cIlNlcXVlbmNlRXhwcmVzc2lvblwiJiYodmU9bChbXCIoXCIsQyhbYyx2ZV0pLGMsXCIpXCJdKSksbChbbChDKFtwZXx8bWU/YzpcIlwiLGwocChbXCIgPT5cIixhXSxkZSkse3Nob3VsZEJyZWFrOmdlfSldKSx7aWQ6SixzaG91bGRCcmVhazpoZX0pLFwiID0+XCIsZihjZT9DKFthLHZlXSk6W1wiIFwiLHZlXSx7Z3JvdXBJZDpKfSkscGU/bShjLFwiXCIse2dyb3VwSWQ6Sn0pOlwiXCJdKX1mdW5jdGlvbiBuZSh1ZSxRLGRlLGdlKXtsZXQgdmU9dWUuZ2V0VmFsdWUoKSx4ZT1bXSx3ZT1bXSxmZT0hMTtpZihmdW5jdGlvbiBKKCl7bGV0IHllPWVlKHVlLFEsZGUsZ2UpO2lmKHhlLmxlbmd0aD09PTApeGUucHVzaCh5ZSk7ZWxzZXtsZXR7bGVhZGluZzpYLHRyYWlsaW5nOll9PWkodWUsUSk7eGUucHVzaChbWCx5ZV0pLHdlLnVuc2hpZnQoWSl9ZmU9ZmV8fHZlLnJldHVyblR5cGUmJkEodmUpLmxlbmd0aD4wfHx2ZS50eXBlUGFyYW1ldGVyc3x8QSh2ZSkuc29tZShYPT5YLnR5cGUhPT1cIklkZW50aWZpZXJcIiksdmUuYm9keS50eXBlIT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwifHxnZSYmZ2UuZXhwYW5kTGFzdEFyZz93ZS51bnNoaWZ0KGRlKFwiYm9keVwiLGdlKSk6KHZlPXZlLmJvZHksdWUuY2FsbChKLFwiYm9keVwiKSl9KCkseGUubGVuZ3RoPjEpcmV0dXJuIFUodWUsZ2UseGUsZmUsd2UsdmUpO2xldCBwZT14ZTtpZihwZS5wdXNoKFwiID0+XCIpLCFiKFEub3JpZ2luYWxUZXh0LHZlLmJvZHkpJiYodmUuYm9keS50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cInx8dmUuYm9keS50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCJ8fHZlLmJvZHkudHlwZT09PVwiQmxvY2tTdGF0ZW1lbnRcInx8Qih2ZS5ib2R5KXx8dyh2ZS5ib2R5LFEub3JpZ2luYWxUZXh0KXx8dmUuYm9keS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwifHx2ZS5ib2R5LnR5cGU9PT1cIkRvRXhwcmVzc2lvblwiKSlyZXR1cm4gbChbLi4ucGUsXCIgXCIsd2VdKTtpZih2ZS5ib2R5LnR5cGU9PT1cIlNlcXVlbmNlRXhwcmVzc2lvblwiKXJldHVybiBsKFsuLi5wZSxsKFtcIiAoXCIsQyhbYyx3ZV0pLGMsXCIpXCJdKV0pO2xldCBtZT0oZ2UmJmdlLmV4cGFuZExhc3RBcmd8fHVlLmdldFBhcmVudE5vZGUoKS50eXBlPT09XCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIpJiYheSh2ZSksY2U9Z2UmJmdlLmV4cGFuZExhc3RBcmcmJkkoUSxcImFsbFwiKSxoZT12ZS5ib2R5LnR5cGU9PT1cIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiJiYhRSh2ZS5ib2R5LCExKTtyZXR1cm4gbChbLi4ucGUsbChbQyhbYSxoZT9tKFwiXCIsXCIoXCIpOlwiXCIsd2UsaGU/bShcIlwiLFwiKVwiKTpcIlwiXSksbWU/W20oY2U/XCIsXCI6XCJcIiksY106XCJcIl0pXSl9ZnVuY3Rpb24gc2UodWUpe2xldCBRPUEodWUpO3JldHVybiBRLmxlbmd0aD09PTEmJiF1ZS50eXBlUGFyYW1ldGVycyYmIXkodWUseC5EYW5nbGluZykmJlFbMF0udHlwZT09PVwiSWRlbnRpZmllclwiJiYhUVswXS50eXBlQW5ub3RhdGlvbiYmIXkoUVswXSkmJiFRWzBdLm9wdGlvbmFsJiYhdWUucHJlZGljYXRlJiYhdWUucmV0dXJuVHlwZX1mdW5jdGlvbiBWKHVlLFEpe2lmKFEuYXJyb3dQYXJlbnM9PT1cImFsd2F5c1wiKXJldHVybiExO2lmKFEuYXJyb3dQYXJlbnM9PT1cImF2b2lkXCIpe2xldCBkZT11ZS5nZXRWYWx1ZSgpO3JldHVybiBzZShkZSl9cmV0dXJuITF9ZnVuY3Rpb24gb2UodWUsUSxkZSl7bGV0IGdlPXVlLmdldFZhbHVlKCksdmU9UShcInJldHVyblR5cGVcIik7aWYoZ2UucmV0dXJuVHlwZSYmdihkZS5vcmlnaW5hbFRleHQsZ2UucmV0dXJuVHlwZSkpcmV0dXJuW1wiIC8qOiBcIix2ZSxcIiAqL1wiXTtsZXQgeGU9W3ZlXTtyZXR1cm4gZ2UucmV0dXJuVHlwZSYmZ2UucmV0dXJuVHlwZS50eXBlQW5ub3RhdGlvbiYmeGUudW5zaGlmdChcIjogXCIpLGdlLnByZWRpY2F0ZSYmeGUucHVzaChnZS5yZXR1cm5UeXBlP1wiIFwiOlwiOiBcIixRKFwicHJlZGljYXRlXCIpKSx4ZX1mdW5jdGlvbiBLKHVlLFEsZGUpe2xldCBnZT11ZS5nZXRWYWx1ZSgpLHZlPVEuc2VtaT9cIjtcIjpcIlwiLHhlPVtdO2dlLmFyZ3VtZW50JiYobGUoUSxnZS5hcmd1bWVudCk/eGUucHVzaChbXCIgKFwiLEMoW2csZGUoXCJhcmd1bWVudFwiKV0pLGcsXCIpXCJdKTpEKGdlLmFyZ3VtZW50KXx8Z2UuYXJndW1lbnQudHlwZT09PVwiU2VxdWVuY2VFeHByZXNzaW9uXCI/eGUucHVzaChsKFttKFwiIChcIixcIiBcIiksQyhbYyxkZShcImFyZ3VtZW50XCIpXSksYyxtKFwiKVwiKV0pKTp4ZS5wdXNoKFwiIFwiLGRlKFwiYXJndW1lbnRcIikpKTtsZXQgd2U9byhnZSksZmU9cih3ZSkscGU9ZmUmJmQoZmUpO3JldHVybiBwZSYmeGUucHVzaCh2ZSkseShnZSx4LkRhbmdsaW5nKSYmeGUucHVzaChcIiBcIixzKHVlLFEsITApKSxwZXx8eGUucHVzaCh2ZSkseGV9ZnVuY3Rpb24gRWUodWUsUSxkZSl7cmV0dXJuW1wicmV0dXJuXCIsSyh1ZSxRLGRlKV19ZnVuY3Rpb24gcSh1ZSxRLGRlKXtyZXR1cm5bXCJ0aHJvd1wiLEsodWUsUSxkZSldfWZ1bmN0aW9uIGxlKHVlLFEpe2lmKGIodWUub3JpZ2luYWxUZXh0LFEpKXJldHVybiEwO2lmKF8oUSkpe2xldCBkZT1RLGdlO2Zvcig7Z2U9TyhkZSk7KWlmKGRlPWdlLGIodWUub3JpZ2luYWxUZXh0LGRlKSlyZXR1cm4hMH1yZXR1cm4hMX1uLmV4cG9ydHM9e3ByaW50RnVuY3Rpb246cmUscHJpbnRBcnJvd0Z1bmN0aW9uOm5lLHByaW50TWV0aG9kOiQscHJpbnRSZXR1cm5TdGF0ZW1lbnQ6RWUscHJpbnRUaHJvd1N0YXRlbWVudDpxLHByaW50TWV0aG9kSW50ZXJuYWw6VyxzaG91bGRQcmludFBhcmFtc1dpdGhvdXRQYXJlbnM6Vn19fSksVW49Wih7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvZGVjb3JhdG9ycy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7aXNOb25FbXB0eUFycmF5OnQsaGFzTmV3bGluZTpzfT1HZSgpLHtidWlsZGVyczp7bGluZTppLGhhcmRsaW5lOnIsam9pbjp1LGJyZWFrUGFyZW50OmEsZ3JvdXA6Y319PUxlKCkse2xvY1N0YXJ0OmwsbG9jRW5kOkN9PW50KCkse2dldFBhcmVudEV4cG9ydERlY2xhcmF0aW9uOm19PVhlKCk7ZnVuY3Rpb24gZyhULEEsYil7bGV0IHY9VC5nZXRWYWx1ZSgpO3JldHVybiBjKFt1KGksVC5tYXAoYixcImRlY29yYXRvcnNcIikpLGgodixBKT9yOmldKX1mdW5jdGlvbiBwKFQsQSxiKXtyZXR1cm5bdShyLFQubWFwKGIsXCJkZWNsYXJhdGlvblwiLFwiZGVjb3JhdG9yc1wiKSkscl19ZnVuY3Rpb24gZihULEEsYil7bGV0IHY9VC5nZXRWYWx1ZSgpLHtkZWNvcmF0b3JzOkJ9PXY7aWYoIXQoQil8fE4oVC5nZXRQYXJlbnROb2RlKCkpKXJldHVybjtsZXQgdz12LnR5cGU9PT1cIkNsYXNzRXhwcmVzc2lvblwifHx2LnR5cGU9PT1cIkNsYXNzRGVjbGFyYXRpb25cInx8aCh2LEEpO3JldHVyblttKFQpP3I6dz9hOlwiXCIsdShpLFQubWFwKGIsXCJkZWNvcmF0b3JzXCIpKSxpXX1mdW5jdGlvbiBoKFQsQSl7cmV0dXJuIFQuZGVjb3JhdG9ycy5zb21lKGI9PnMoQS5vcmlnaW5hbFRleHQsQyhiKSkpfWZ1bmN0aW9uIE4oVCl7aWYoVC50eXBlIT09XCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiYmVC50eXBlIT09XCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCImJlQudHlwZSE9PVwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpcmV0dXJuITE7bGV0IEE9VC5kZWNsYXJhdGlvbiYmVC5kZWNsYXJhdGlvbi5kZWNvcmF0b3JzO3JldHVybiB0KEEpJiZsKFQse2lnbm9yZURlY29yYXRvcnM6ITB9KT5sKEFbMF0pfW4uZXhwb3J0cz17cHJpbnREZWNvcmF0b3JzOmYscHJpbnRDbGFzc01lbWJlckRlY29yYXRvcnM6ZyxwcmludERlY29yYXRvcnNCZWZvcmVFeHBvcnQ6cCxoYXNEZWNvcmF0b3JzQmVmb3JlRXhwb3J0Ok59fX0pLFl0PVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L2NsYXNzLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3Zhcntpc05vbkVtcHR5QXJyYXk6dCxjcmVhdGVHcm91cElkTWFwcGVyOnN9PUdlKCkse3ByaW50Q29tbWVudHM6aSxwcmludERhbmdsaW5nQ29tbWVudHM6cn09UWUoKSx7YnVpbGRlcnM6e2pvaW46dSxsaW5lOmEsaGFyZGxpbmU6Yyxzb2Z0bGluZTpsLGdyb3VwOkMsaW5kZW50Om0saWZCcmVhazpnfX09TGUoKSx7aGFzQ29tbWVudDpwLENvbW1lbnRDaGVja0ZsYWdzOmZ9PVhlKCkse2dldFR5cGVQYXJhbWV0ZXJzR3JvdXBJZDpofT1QcigpLHtwcmludE1ldGhvZDpOfT1JcigpLHtwcmludE9wdGlvbmFsVG9rZW46VCxwcmludFR5cGVBbm5vdGF0aW9uOkEscHJpbnREZWZpbml0ZVRva2VuOmJ9PW90KCkse3ByaW50UHJvcGVydHlLZXk6dn09S3QoKSx7cHJpbnRBc3NpZ25tZW50OkJ9PVh0KCkse3ByaW50Q2xhc3NNZW1iZXJEZWNvcmF0b3JzOnd9PVVuKCk7ZnVuY3Rpb24gSShrLF8sTyl7bGV0IFI9ay5nZXRWYWx1ZSgpLE09W107Ui5kZWNsYXJlJiZNLnB1c2goXCJkZWNsYXJlIFwiKSxSLmFic3RyYWN0JiZNLnB1c2goXCJhYnN0cmFjdCBcIiksTS5wdXNoKFwiY2xhc3NcIik7bGV0IEg9Ui5pZCYmcChSLmlkLGYuVHJhaWxpbmcpfHxSLnR5cGVQYXJhbWV0ZXJzJiZwKFIudHlwZVBhcmFtZXRlcnMsZi5UcmFpbGluZyl8fFIuc3VwZXJDbGFzcyYmcChSLnN1cGVyQ2xhc3MpfHx0KFIuZXh0ZW5kcyl8fHQoUi5taXhpbnMpfHx0KFIuaW1wbGVtZW50cyksUD1bXSxHPVtdO2lmKFIuaWQmJlAucHVzaChcIiBcIixPKFwiaWRcIikpLFAucHVzaChPKFwidHlwZVBhcmFtZXRlcnNcIikpLFIuc3VwZXJDbGFzcyl7bGV0IHJlPVt4KGssXyxPKSxPKFwic3VwZXJUeXBlUGFyYW1ldGVyc1wiKV0sJD1rLmNhbGwoVz0+W1wiZXh0ZW5kcyBcIixpKFcscmUsXyldLFwic3VwZXJDbGFzc1wiKTtIP0cucHVzaChhLEMoJCkpOkcucHVzaChcIiBcIiwkKX1lbHNlIEcucHVzaChvKGssXyxPLFwiZXh0ZW5kc1wiKSk7aWYoRy5wdXNoKG8oayxfLE8sXCJtaXhpbnNcIiksbyhrLF8sTyxcImltcGxlbWVudHNcIikpLEgpe2xldCByZTt5KFIpP3JlPVsuLi5QLG0oRyldOnJlPW0oWy4uLlAsR10pLE0ucHVzaChDKHJlLHtpZDpFKFIpfSkpfWVsc2UgTS5wdXNoKC4uLlAsLi4uRyk7cmV0dXJuIE0ucHVzaChcIiBcIixPKFwiYm9keVwiKSksTX12YXIgRT1zKFwiaGVyaXRhZ2VHcm91cFwiKTtmdW5jdGlvbiBEKGspe3JldHVybiBnKGMsXCJcIix7Z3JvdXBJZDpFKGspfSl9ZnVuY3Rpb24gZChrKXtyZXR1cm5bXCJzdXBlckNsYXNzXCIsXCJleHRlbmRzXCIsXCJtaXhpbnNcIixcImltcGxlbWVudHNcIl0uZmlsdGVyKF89PkJvb2xlYW4oa1tfXSkpLmxlbmd0aD4xfWZ1bmN0aW9uIHkoayl7cmV0dXJuIGsudHlwZVBhcmFtZXRlcnMmJiFwKGsudHlwZVBhcmFtZXRlcnMsZi5UcmFpbGluZ3xmLkxpbmUpJiYhZChrKX1mdW5jdGlvbiBvKGssXyxPLFIpe2xldCBNPWsuZ2V0VmFsdWUoKTtpZighdChNW1JdKSlyZXR1cm5cIlwiO2xldCBIPXIoayxfLCEwLFA9PntsZXR7bWFya2VyOkd9PVA7cmV0dXJuIEc9PT1SfSk7cmV0dXJuW3koTSk/ZyhcIiBcIixhLHtncm91cElkOmgoTS50eXBlUGFyYW1ldGVycyl9KTphLEgsSCYmYyxSLEMobShbYSx1KFtcIixcIixhXSxrLm1hcChPLFIpKV0pKV19ZnVuY3Rpb24geChrLF8sTyl7bGV0IFI9TyhcInN1cGVyQ2xhc3NcIik7cmV0dXJuIGsuZ2V0UGFyZW50Tm9kZSgpLnR5cGU9PT1cIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI/QyhnKFtcIihcIixtKFtsLFJdKSxsLFwiKVwiXSxSKSk6Un1mdW5jdGlvbiBGKGssXyxPKXtsZXQgUj1rLmdldFZhbHVlKCksTT1bXTtyZXR1cm4gdChSLmRlY29yYXRvcnMpJiZNLnB1c2godyhrLF8sTykpLFIuYWNjZXNzaWJpbGl0eSYmTS5wdXNoKFIuYWNjZXNzaWJpbGl0eStcIiBcIiksUi5yZWFkb25seSYmTS5wdXNoKFwicmVhZG9ubHkgXCIpLFIuZGVjbGFyZSYmTS5wdXNoKFwiZGVjbGFyZSBcIiksUi5zdGF0aWMmJk0ucHVzaChcInN0YXRpYyBcIiksKFIudHlwZT09PVwiVFNBYnN0cmFjdE1ldGhvZERlZmluaXRpb25cInx8Ui5hYnN0cmFjdCkmJk0ucHVzaChcImFic3RyYWN0IFwiKSxSLm92ZXJyaWRlJiZNLnB1c2goXCJvdmVycmlkZSBcIiksTS5wdXNoKE4oayxfLE8pKSxNfWZ1bmN0aW9uIFMoayxfLE8pe2xldCBSPWsuZ2V0VmFsdWUoKSxNPVtdLEg9Xy5zZW1pP1wiO1wiOlwiXCI7cmV0dXJuIHQoUi5kZWNvcmF0b3JzKSYmTS5wdXNoKHcoayxfLE8pKSxSLmFjY2Vzc2liaWxpdHkmJk0ucHVzaChSLmFjY2Vzc2liaWxpdHkrXCIgXCIpLFIuZGVjbGFyZSYmTS5wdXNoKFwiZGVjbGFyZSBcIiksUi5zdGF0aWMmJk0ucHVzaChcInN0YXRpYyBcIiksKFIudHlwZT09PVwiVFNBYnN0cmFjdFByb3BlcnR5RGVmaW5pdGlvblwifHxSLmFic3RyYWN0KSYmTS5wdXNoKFwiYWJzdHJhY3QgXCIpLFIub3ZlcnJpZGUmJk0ucHVzaChcIm92ZXJyaWRlIFwiKSxSLnJlYWRvbmx5JiZNLnB1c2goXCJyZWFkb25seSBcIiksUi52YXJpYW5jZSYmTS5wdXNoKE8oXCJ2YXJpYW5jZVwiKSksUi50eXBlPT09XCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIiYmTS5wdXNoKFwiYWNjZXNzb3IgXCIpLE0ucHVzaCh2KGssXyxPKSxUKGspLGIoayksQShrLF8sTykpLFtCKGssXyxPLE0sXCIgPVwiLFwidmFsdWVcIiksSF19bi5leHBvcnRzPXtwcmludENsYXNzOkkscHJpbnRDbGFzc01ldGhvZDpGLHByaW50Q2xhc3NQcm9wZXJ0eTpTLHByaW50SGFyZGxpbmVBZnRlckhlcml0YWdlOkR9fX0pLGFvPVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L2ludGVyZmFjZS5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7aXNOb25FbXB0eUFycmF5OnR9PUdlKCkse2J1aWxkZXJzOntqb2luOnMsbGluZTppLGdyb3VwOnIsaW5kZW50OnUsaWZCcmVhazphfX09TGUoKSx7aGFzQ29tbWVudDpjLGlkZW50aXR5OmwsQ29tbWVudENoZWNrRmxhZ3M6Q309WGUoKSx7Z2V0VHlwZVBhcmFtZXRlcnNHcm91cElkOm19PVByKCkse3ByaW50VHlwZVNjcmlwdE1vZGlmaWVyczpnfT1vdCgpO2Z1bmN0aW9uIHAoZixoLE4pe2xldCBUPWYuZ2V0VmFsdWUoKSxBPVtdO1QuZGVjbGFyZSYmQS5wdXNoKFwiZGVjbGFyZSBcIiksVC50eXBlPT09XCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCImJkEucHVzaChULmFic3RyYWN0P1wiYWJzdHJhY3QgXCI6XCJcIixnKGYsaCxOKSksQS5wdXNoKFwiaW50ZXJmYWNlXCIpO2xldCBiPVtdLHY9W107VC50eXBlIT09XCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiJiZiLnB1c2goXCIgXCIsTihcImlkXCIpLE4oXCJ0eXBlUGFyYW1ldGVyc1wiKSk7bGV0IEI9VC50eXBlUGFyYW1ldGVycyYmIWMoVC50eXBlUGFyYW1ldGVycyxDLlRyYWlsaW5nfEMuTGluZSk7cmV0dXJuIHQoVC5leHRlbmRzKSYmdi5wdXNoKEI/YShcIiBcIixpLHtncm91cElkOm0oVC50eXBlUGFyYW1ldGVycyl9KTppLFwiZXh0ZW5kcyBcIiwoVC5leHRlbmRzLmxlbmd0aD09PTE/bDp1KShzKFtcIixcIixpXSxmLm1hcChOLFwiZXh0ZW5kc1wiKSkpKSxULmlkJiZjKFQuaWQsQy5UcmFpbGluZyl8fHQoVC5leHRlbmRzKT9CP0EucHVzaChyKFsuLi5iLHUodildKSk6QS5wdXNoKHIodShbLi4uYiwuLi52XSkpKTpBLnB1c2goLi4uYiwuLi52KSxBLnB1c2goXCIgXCIsTihcImJvZHlcIikpLHIoQSl9bi5leHBvcnRzPXtwcmludEludGVyZmFjZTpwfX19KSxpbz1aKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9tb2R1bGUuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2lzTm9uRW1wdHlBcnJheTp0fT1HZSgpLHtidWlsZGVyczp7c29mdGxpbmU6cyxncm91cDppLGluZGVudDpyLGpvaW46dSxsaW5lOmEsaWZCcmVhazpjLGhhcmRsaW5lOmx9fT1MZSgpLHtwcmludERhbmdsaW5nQ29tbWVudHM6Q309UWUoKSx7aGFzQ29tbWVudDptLENvbW1lbnRDaGVja0ZsYWdzOmcsc2hvdWxkUHJpbnRDb21tYTpwLG5lZWRzSGFyZGxpbmVBZnRlckRhbmdsaW5nQ29tbWVudDpmLGlzU3RyaW5nTGl0ZXJhbDpoLHJhd1RleHQ6Tn09WGUoKSx7bG9jU3RhcnQ6VCxoYXNTYW1lTG9jOkF9PW50KCkse2hhc0RlY29yYXRvcnNCZWZvcmVFeHBvcnQ6YixwcmludERlY29yYXRvcnNCZWZvcmVFeHBvcnQ6dn09VW4oKTtmdW5jdGlvbiBCKFMsayxfKXtsZXQgTz1TLmdldFZhbHVlKCksUj1rLnNlbWk/XCI7XCI6XCJcIixNPVtdLHtpbXBvcnRLaW5kOkh9PU87cmV0dXJuIE0ucHVzaChcImltcG9ydFwiKSxIJiZIIT09XCJ2YWx1ZVwiJiZNLnB1c2goXCIgXCIsSCksTS5wdXNoKGQoUyxrLF8pLEQoUyxrLF8pLG8oUyxrLF8pLFIpLE19ZnVuY3Rpb24gdyhTLGssXyl7bGV0IE89Uy5nZXRWYWx1ZSgpLFI9W107YihPKSYmUi5wdXNoKHYoUyxrLF8pKTtsZXR7dHlwZTpNLGV4cG9ydEtpbmQ6SCxkZWNsYXJhdGlvbjpQfT1PO3JldHVybiBSLnB1c2goXCJleHBvcnRcIiksKE8uZGVmYXVsdHx8TT09PVwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpJiZSLnB1c2goXCIgZGVmYXVsdFwiKSxtKE8sZy5EYW5nbGluZykmJihSLnB1c2goXCIgXCIsQyhTLGssITApKSxmKE8pJiZSLnB1c2gobCkpLFA/Ui5wdXNoKFwiIFwiLF8oXCJkZWNsYXJhdGlvblwiKSk6Ui5wdXNoKEg9PT1cInR5cGVcIj9cIiB0eXBlXCI6XCJcIixkKFMsayxfKSxEKFMsayxfKSxvKFMsayxfKSksRShPLGspJiZSLnB1c2goXCI7XCIpLFJ9ZnVuY3Rpb24gSShTLGssXyl7bGV0IE89Uy5nZXRWYWx1ZSgpLFI9ay5zZW1pP1wiO1wiOlwiXCIsTT1bXSx7ZXhwb3J0S2luZDpILGV4cG9ydGVkOlB9PU87cmV0dXJuIE0ucHVzaChcImV4cG9ydFwiKSxIPT09XCJ0eXBlXCImJk0ucHVzaChcIiB0eXBlXCIpLE0ucHVzaChcIiAqXCIpLFAmJk0ucHVzaChcIiBhcyBcIixfKFwiZXhwb3J0ZWRcIikpLE0ucHVzaChEKFMsayxfKSxvKFMsayxfKSxSKSxNfWZ1bmN0aW9uIEUoUyxrKXtpZighay5zZW1pKXJldHVybiExO2xldHt0eXBlOl8sZGVjbGFyYXRpb246T309UyxSPVMuZGVmYXVsdHx8Xz09PVwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCI7aWYoIU8pcmV0dXJuITA7bGV0e3R5cGU6TX09TztyZXR1cm4hIShSJiZNIT09XCJDbGFzc0RlY2xhcmF0aW9uXCImJk0hPT1cIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiYmTSE9PVwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiJiZNIT09XCJEZWNsYXJlQ2xhc3NcIiYmTSE9PVwiRGVjbGFyZUZ1bmN0aW9uXCImJk0hPT1cIlRTRGVjbGFyZUZ1bmN0aW9uXCImJk0hPT1cIkVudW1EZWNsYXJhdGlvblwiKX1mdW5jdGlvbiBEKFMsayxfKXtsZXQgTz1TLmdldFZhbHVlKCk7aWYoIU8uc291cmNlKXJldHVyblwiXCI7bGV0IFI9W107cmV0dXJuIHkoTyxrKXx8Ui5wdXNoKFwiIGZyb21cIiksUi5wdXNoKFwiIFwiLF8oXCJzb3VyY2VcIikpLFJ9ZnVuY3Rpb24gZChTLGssXyl7bGV0IE89Uy5nZXRWYWx1ZSgpO2lmKHkoTyxrKSlyZXR1cm5cIlwiO2xldCBSPVtcIiBcIl07aWYodChPLnNwZWNpZmllcnMpKXtsZXQgTT1bXSxIPVtdO1MuZWFjaCgoKT0+e2xldCBQPVMuZ2V0VmFsdWUoKS50eXBlO2lmKFA9PT1cIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwifHxQPT09XCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCJ8fFA9PT1cIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwifHxQPT09XCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpTS5wdXNoKF8oKSk7ZWxzZSBpZihQPT09XCJFeHBvcnRTcGVjaWZpZXJcInx8UD09PVwiSW1wb3J0U3BlY2lmaWVyXCIpSC5wdXNoKF8oKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNwZWNpZmllciB0eXBlIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShQKSkpfSxcInNwZWNpZmllcnNcIiksUi5wdXNoKHUoXCIsIFwiLE0pKSxILmxlbmd0aD4wJiYoTS5sZW5ndGg+MCYmUi5wdXNoKFwiLCBcIiksSC5sZW5ndGg+MXx8TS5sZW5ndGg+MHx8Ty5zcGVjaWZpZXJzLnNvbWUoRz0+bShHKSk/Ui5wdXNoKGkoW1wie1wiLHIoW2suYnJhY2tldFNwYWNpbmc/YTpzLHUoW1wiLFwiLGFdLEgpXSksYyhwKGspP1wiLFwiOlwiXCIpLGsuYnJhY2tldFNwYWNpbmc/YTpzLFwifVwiXSkpOlIucHVzaChbXCJ7XCIsay5icmFja2V0U3BhY2luZz9cIiBcIjpcIlwiLC4uLkgsay5icmFja2V0U3BhY2luZz9cIiBcIjpcIlwiLFwifVwiXSkpfWVsc2UgUi5wdXNoKFwie31cIik7cmV0dXJuIFJ9ZnVuY3Rpb24geShTLGspe2xldHt0eXBlOl8saW1wb3J0S2luZDpPLHNvdXJjZTpSLHNwZWNpZmllcnM6TX09UztyZXR1cm4gXyE9PVwiSW1wb3J0RGVjbGFyYXRpb25cInx8dChNKXx8Tz09PVwidHlwZVwiPyExOiEve1xccyp9Ly50ZXN0KGsub3JpZ2luYWxUZXh0LnNsaWNlKFQoUyksVChSKSkpfWZ1bmN0aW9uIG8oUyxrLF8pe2xldCBPPVMuZ2V0Tm9kZSgpO3JldHVybiB0KE8uYXNzZXJ0aW9ucyk/W1wiIGFzc2VydCB7XCIsay5icmFja2V0U3BhY2luZz9cIiBcIjpcIlwiLHUoXCIsIFwiLFMubWFwKF8sXCJhc3NlcnRpb25zXCIpKSxrLmJyYWNrZXRTcGFjaW5nP1wiIFwiOlwiXCIsXCJ9XCJdOlwiXCJ9ZnVuY3Rpb24geChTLGssXyl7bGV0IE89Uy5nZXROb2RlKCkse3R5cGU6Un09TyxNPVtdLEg9Uj09PVwiSW1wb3J0U3BlY2lmaWVyXCI/Ty5pbXBvcnRLaW5kOk8uZXhwb3J0S2luZDtIJiZIIT09XCJ2YWx1ZVwiJiZNLnB1c2goSCxcIiBcIik7bGV0IFA9Ui5zdGFydHNXaXRoKFwiSW1wb3J0XCIpLEc9UD9cImltcG9ydGVkXCI6XCJsb2NhbFwiLHJlPVA/XCJsb2NhbFwiOlwiZXhwb3J0ZWRcIiwkPU9bR10sVz1PW3JlXSxlZT1cIlwiLFU9XCJcIjtyZXR1cm4gUj09PVwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCJ8fFI9PT1cIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiP2VlPVwiKlwiOiQmJihlZT1fKEcpKSxXJiYhRihPKSYmKFU9XyhyZSkpLE0ucHVzaChlZSxlZSYmVT9cIiBhcyBcIjpcIlwiLFUpLE19ZnVuY3Rpb24gRihTKXtpZihTLnR5cGUhPT1cIkltcG9ydFNwZWNpZmllclwiJiZTLnR5cGUhPT1cIkV4cG9ydFNwZWNpZmllclwiKXJldHVybiExO2xldHtsb2NhbDprLFtTLnR5cGU9PT1cIkltcG9ydFNwZWNpZmllclwiP1wiaW1wb3J0ZWRcIjpcImV4cG9ydGVkXCJdOl99PVM7aWYoay50eXBlIT09Xy50eXBlfHwhQShrLF8pKXJldHVybiExO2lmKGgoaykpcmV0dXJuIGsudmFsdWU9PT1fLnZhbHVlJiZOKGspPT09TihfKTtzd2l0Y2goay50eXBlKXtjYXNlXCJJZGVudGlmaWVyXCI6cmV0dXJuIGsubmFtZT09PV8ubmFtZTtkZWZhdWx0OnJldHVybiExfX1uLmV4cG9ydHM9e3ByaW50SW1wb3J0RGVjbGFyYXRpb246QixwcmludEV4cG9ydERlY2xhcmF0aW9uOncscHJpbnRFeHBvcnRBbGxEZWNsYXJhdGlvbjpJLHByaW50TW9kdWxlU3BlY2lmaWVyOnh9fX0pLHpuPVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L29iamVjdC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7cHJpbnREYW5nbGluZ0NvbW1lbnRzOnR9PVFlKCkse2J1aWxkZXJzOntsaW5lOnMsc29mdGxpbmU6aSxncm91cDpyLGluZGVudDp1LGlmQnJlYWs6YSxoYXJkbGluZTpjfX09TGUoKSx7Z2V0TGFzdDpsLGhhc05ld2xpbmVJblJhbmdlOkMsaGFzTmV3bGluZTptLGlzTm9uRW1wdHlBcnJheTpnfT1HZSgpLHtzaG91bGRQcmludENvbW1hOnAsaGFzQ29tbWVudDpmLGdldENvbW1lbnRzOmgsQ29tbWVudENoZWNrRmxhZ3M6Tixpc05leHRMaW5lRW1wdHk6VH09WGUoKSx7bG9jU3RhcnQ6QSxsb2NFbmQ6Yn09bnQoKSx7cHJpbnRPcHRpb25hbFRva2VuOnYscHJpbnRUeXBlQW5ub3RhdGlvbjpCfT1vdCgpLHtzaG91bGRIdWdGdW5jdGlvblBhcmFtZXRlcnM6d309d3IoKSx7c2hvdWxkSHVnVHlwZTpJfT1fcigpLHtwcmludEhhcmRsaW5lQWZ0ZXJIZXJpdGFnZTpFfT1ZdCgpO2Z1bmN0aW9uIEQoZCx5LG8pe2xldCB4PXkuc2VtaT9cIjtcIjpcIlwiLEY9ZC5nZXRWYWx1ZSgpLFM7Ri50eXBlPT09XCJUU1R5cGVMaXRlcmFsXCI/Uz1cIm1lbWJlcnNcIjpGLnR5cGU9PT1cIlRTSW50ZXJmYWNlQm9keVwiP1M9XCJib2R5XCI6Uz1cInByb3BlcnRpZXNcIjtsZXQgaz1GLnR5cGU9PT1cIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIsXz1bU107ayYmXy5wdXNoKFwiaW5kZXhlcnNcIixcImNhbGxQcm9wZXJ0aWVzXCIsXCJpbnRlcm5hbFNsb3RzXCIpO2xldCBPPV8ubWFwKFY9PkZbVl1bMF0pLnNvcnQoKFYsb2UpPT5BKFYpLUEob2UpKVswXSxSPWQuZ2V0UGFyZW50Tm9kZSgwKSxNPWsmJlImJihSLnR5cGU9PT1cIkludGVyZmFjZURlY2xhcmF0aW9uXCJ8fFIudHlwZT09PVwiRGVjbGFyZUludGVyZmFjZVwifHxSLnR5cGU9PT1cIkRlY2xhcmVDbGFzc1wiKSYmZC5nZXROYW1lKCk9PT1cImJvZHlcIixIPUYudHlwZT09PVwiVFNJbnRlcmZhY2VCb2R5XCJ8fE18fEYudHlwZT09PVwiT2JqZWN0UGF0dGVyblwiJiZSLnR5cGUhPT1cIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiYmUi50eXBlIT09XCJGdW5jdGlvbkV4cHJlc3Npb25cIiYmUi50eXBlIT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiJiZSLnR5cGUhPT1cIk9iamVjdE1ldGhvZFwiJiZSLnR5cGUhPT1cIkNsYXNzTWV0aG9kXCImJlIudHlwZSE9PVwiQ2xhc3NQcml2YXRlTWV0aG9kXCImJlIudHlwZSE9PVwiQXNzaWdubWVudFBhdHRlcm5cIiYmUi50eXBlIT09XCJDYXRjaENsYXVzZVwiJiZGLnByb3BlcnRpZXMuc29tZShWPT5WLnZhbHVlJiYoVi52YWx1ZS50eXBlPT09XCJPYmplY3RQYXR0ZXJuXCJ8fFYudmFsdWUudHlwZT09PVwiQXJyYXlQYXR0ZXJuXCIpKXx8Ri50eXBlIT09XCJPYmplY3RQYXR0ZXJuXCImJk8mJkMoeS5vcmlnaW5hbFRleHQsQShGKSxBKE8pKSxQPU0/XCI7XCI6Ri50eXBlPT09XCJUU0ludGVyZmFjZUJvZHlcInx8Ri50eXBlPT09XCJUU1R5cGVMaXRlcmFsXCI/YSh4LFwiO1wiKTpcIixcIixHPUYudHlwZT09PVwiUmVjb3JkRXhwcmVzc2lvblwiP1wiI3tcIjpGLmV4YWN0P1wie3xcIjpcIntcIixyZT1GLmV4YWN0P1wifH1cIjpcIn1cIiwkPVtdO2ZvcihsZXQgViBvZiBfKWQuZWFjaChvZT0+e2xldCBLPW9lLmdldFZhbHVlKCk7JC5wdXNoKHtub2RlOksscHJpbnRlZDpvKCksbG9jOkEoSyl9KX0sVik7Xy5sZW5ndGg+MSYmJC5zb3J0KChWLG9lKT0+Vi5sb2Mtb2UubG9jKTtsZXQgVz1bXSxlZT0kLm1hcChWPT57bGV0IG9lPVsuLi5XLHIoVi5wcmludGVkKV07cmV0dXJuIFc9W1Asc10sKFYubm9kZS50eXBlPT09XCJUU1Byb3BlcnR5U2lnbmF0dXJlXCJ8fFYubm9kZS50eXBlPT09XCJUU01ldGhvZFNpZ25hdHVyZVwifHxWLm5vZGUudHlwZT09PVwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiKSYmZihWLm5vZGUsTi5QcmV0dGllcklnbm9yZSkmJlcuc2hpZnQoKSxUKFYubm9kZSx5KSYmVy5wdXNoKGMpLG9lfSk7aWYoRi5pbmV4YWN0KXtsZXQgVjtpZihmKEYsTi5EYW5nbGluZykpe2xldCBvZT1mKEYsTi5MaW5lKTtWPVt0KGQseSwhMCksb2V8fG0oeS5vcmlnaW5hbFRleHQsYihsKGgoRikpKSk/YzpzLFwiLi4uXCJdfWVsc2UgVj1bXCIuLi5cIl07ZWUucHVzaChbLi4uVywuLi5WXSl9bGV0IFU9bChGW1NdKSxuZT0hKEYuaW5leGFjdHx8VSYmVS50eXBlPT09XCJSZXN0RWxlbWVudFwifHxVJiYoVS50eXBlPT09XCJUU1Byb3BlcnR5U2lnbmF0dXJlXCJ8fFUudHlwZT09PVwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cInx8VS50eXBlPT09XCJUU01ldGhvZFNpZ25hdHVyZVwifHxVLnR5cGU9PT1cIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIikmJmYoVSxOLlByZXR0aWVySWdub3JlKSksc2U7aWYoZWUubGVuZ3RoPT09MCl7aWYoIWYoRixOLkRhbmdsaW5nKSlyZXR1cm5bRyxyZSxCKGQseSxvKV07c2U9cihbRyx0KGQseSksaSxyZSx2KGQpLEIoZCx5LG8pXSl9ZWxzZSBzZT1bTSYmZyhGLnByb3BlcnRpZXMpP0UoUik6XCJcIixHLHUoW3kuYnJhY2tldFNwYWNpbmc/czppLC4uLmVlXSksYShuZSYmKFAhPT1cIixcInx8cCh5KSk/UDpcIlwiKSx5LmJyYWNrZXRTcGFjaW5nP3M6aSxyZSx2KGQpLEIoZCx5LG8pXTtyZXR1cm4gZC5tYXRjaChWPT5WLnR5cGU9PT1cIk9iamVjdFBhdHRlcm5cIiYmIVYuZGVjb3JhdG9ycywoVixvZSxLKT0+dyhWKSYmKG9lPT09XCJwYXJhbXNcInx8b2U9PT1cInBhcmFtZXRlcnNcInx8b2U9PT1cInRoaXNcInx8b2U9PT1cInJlc3RcIikmJks9PT0wKXx8ZC5tYXRjaChJLChWLG9lKT0+b2U9PT1cInR5cGVBbm5vdGF0aW9uXCIsKFYsb2UpPT5vZT09PVwidHlwZUFubm90YXRpb25cIiwoVixvZSxLKT0+dyhWKSYmKG9lPT09XCJwYXJhbXNcInx8b2U9PT1cInBhcmFtZXRlcnNcInx8b2U9PT1cInRoaXNcInx8b2U9PT1cInJlc3RcIikmJks9PT0wKXx8IUgmJmQubWF0Y2goVj0+Vi50eXBlPT09XCJPYmplY3RQYXR0ZXJuXCIsVj0+Vi50eXBlPT09XCJBc3NpZ25tZW50RXhwcmVzc2lvblwifHxWLnR5cGU9PT1cIlZhcmlhYmxlRGVjbGFyYXRvclwiKT9zZTpyKHNlLHtzaG91bGRCcmVhazpIfSl9bi5leHBvcnRzPXtwcmludE9iamVjdDpEfX19KSx3bT1aKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9mbG93LmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PVV0KCkse3ByaW50RGFuZ2xpbmdDb21tZW50czpzfT1RZSgpLHtwcmludFN0cmluZzppLHByaW50TnVtYmVyOnJ9PUdlKCkse2J1aWxkZXJzOntoYXJkbGluZTp1LHNvZnRsaW5lOmEsZ3JvdXA6YyxpbmRlbnQ6bH19PUxlKCkse2dldFBhcmVudEV4cG9ydERlY2xhcmF0aW9uOkMsaXNGdW5jdGlvbk5vdGF0aW9uOm0saXNHZXR0ZXJPclNldHRlcjpnLHJhd1RleHQ6cCxzaG91bGRQcmludENvbW1hOmZ9PVhlKCkse2xvY1N0YXJ0OmgsbG9jRW5kOk59PW50KCkse3ByaW50Q2xhc3M6VH09WXQoKSx7cHJpbnRPcGFxdWVUeXBlOkEscHJpbnRUeXBlQWxpYXM6YixwcmludEludGVyc2VjdGlvblR5cGU6dixwcmludFVuaW9uVHlwZTpCLHByaW50RnVuY3Rpb25UeXBlOncscHJpbnRUdXBsZVR5cGU6SSxwcmludEluZGV4ZWRBY2Nlc3NUeXBlOkV9PV9yKCkse3ByaW50SW50ZXJmYWNlOkR9PWFvKCkse3ByaW50VHlwZVBhcmFtZXRlcjpkLHByaW50VHlwZVBhcmFtZXRlcnM6eX09UHIoKSx7cHJpbnRFeHBvcnREZWNsYXJhdGlvbjpvLHByaW50RXhwb3J0QWxsRGVjbGFyYXRpb246eH09aW8oKSx7cHJpbnRBcnJheUl0ZW1zOkZ9PXp0KCkse3ByaW50T2JqZWN0OlN9PXpuKCkse3ByaW50UHJvcGVydHlLZXk6a309S3QoKSx7cHJpbnRPcHRpb25hbFRva2VuOl8scHJpbnRUeXBlQW5ub3RhdGlvbjpPLHByaW50UmVzdFNwcmVhZDpSfT1vdCgpO2Z1bmN0aW9uIE0oUCxHLHJlKXtsZXQgJD1QLmdldFZhbHVlKCksVz1HLnNlbWk/XCI7XCI6XCJcIixlZT1bXTtzd2l0Y2goJC50eXBlKXtjYXNlXCJEZWNsYXJlQ2xhc3NcIjpyZXR1cm4gSChQLFQoUCxHLHJlKSk7Y2FzZVwiRGVjbGFyZUZ1bmN0aW9uXCI6cmV0dXJuIEgoUCxbXCJmdW5jdGlvbiBcIixyZShcImlkXCIpLCQucHJlZGljYXRlP1wiIFwiOlwiXCIscmUoXCJwcmVkaWNhdGVcIiksV10pO2Nhc2VcIkRlY2xhcmVNb2R1bGVcIjpyZXR1cm4gSChQLFtcIm1vZHVsZSBcIixyZShcImlkXCIpLFwiIFwiLHJlKFwiYm9keVwiKV0pO2Nhc2VcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCI6cmV0dXJuIEgoUCxbXCJtb2R1bGUuZXhwb3J0c1wiLFwiOiBcIixyZShcInR5cGVBbm5vdGF0aW9uXCIpLFddKTtjYXNlXCJEZWNsYXJlVmFyaWFibGVcIjpyZXR1cm4gSChQLFtcInZhciBcIixyZShcImlkXCIpLFddKTtjYXNlXCJEZWNsYXJlT3BhcXVlVHlwZVwiOnJldHVybiBIKFAsQShQLEcscmUpKTtjYXNlXCJEZWNsYXJlSW50ZXJmYWNlXCI6cmV0dXJuIEgoUCxEKFAsRyxyZSkpO2Nhc2VcIkRlY2xhcmVUeXBlQWxpYXNcIjpyZXR1cm4gSChQLGIoUCxHLHJlKSk7Y2FzZVwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCI6cmV0dXJuIEgoUCxvKFAsRyxyZSkpO2Nhc2VcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiOnJldHVybiBIKFAseChQLEcscmUpKTtjYXNlXCJPcGFxdWVUeXBlXCI6cmV0dXJuIEEoUCxHLHJlKTtjYXNlXCJUeXBlQWxpYXNcIjpyZXR1cm4gYihQLEcscmUpO2Nhc2VcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIHYoUCxHLHJlKTtjYXNlXCJVbmlvblR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIEIoUCxHLHJlKTtjYXNlXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIHcoUCxHLHJlKTtjYXNlXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIEkoUCxHLHJlKTtjYXNlXCJHZW5lcmljVHlwZUFubm90YXRpb25cIjpyZXR1cm5bcmUoXCJpZFwiKSx5KFAsRyxyZSxcInR5cGVQYXJhbWV0ZXJzXCIpXTtjYXNlXCJJbmRleGVkQWNjZXNzVHlwZVwiOmNhc2VcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIjpyZXR1cm4gRShQLEcscmUpO2Nhc2VcIlR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIHJlKFwidHlwZUFubm90YXRpb25cIik7Y2FzZVwiVHlwZVBhcmFtZXRlclwiOnJldHVybiBkKFAsRyxyZSk7Y2FzZVwiVHlwZW9mVHlwZUFubm90YXRpb25cIjpyZXR1cm5bXCJ0eXBlb2YgXCIscmUoXCJhcmd1bWVudFwiKV07Y2FzZVwiRXhpc3RzVHlwZUFubm90YXRpb25cIjpyZXR1cm5cIipcIjtjYXNlXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuXCJlbXB0eVwiO2Nhc2VcIk1peGVkVHlwZUFubm90YXRpb25cIjpyZXR1cm5cIm1peGVkXCI7Y2FzZVwiQXJyYXlUeXBlQW5ub3RhdGlvblwiOnJldHVybltyZShcImVsZW1lbnRUeXBlXCIpLFwiW11cIl07Y2FzZVwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiOnJldHVybiBTdHJpbmcoJC52YWx1ZSk7Y2FzZVwiRW51bURlY2xhcmF0aW9uXCI6cmV0dXJuW1wiZW51bSBcIixyZShcImlkXCIpLFwiIFwiLHJlKFwiYm9keVwiKV07Y2FzZVwiRW51bUJvb2xlYW5Cb2R5XCI6Y2FzZVwiRW51bU51bWJlckJvZHlcIjpjYXNlXCJFbnVtU3RyaW5nQm9keVwiOmNhc2VcIkVudW1TeW1ib2xCb2R5XCI6e2lmKCQudHlwZT09PVwiRW51bVN5bWJvbEJvZHlcInx8JC5leHBsaWNpdFR5cGUpe2xldCBVPW51bGw7c3dpdGNoKCQudHlwZSl7Y2FzZVwiRW51bUJvb2xlYW5Cb2R5XCI6VT1cImJvb2xlYW5cIjticmVhaztjYXNlXCJFbnVtTnVtYmVyQm9keVwiOlU9XCJudW1iZXJcIjticmVhaztjYXNlXCJFbnVtU3RyaW5nQm9keVwiOlU9XCJzdHJpbmdcIjticmVhaztjYXNlXCJFbnVtU3ltYm9sQm9keVwiOlU9XCJzeW1ib2xcIjticmVha31lZS5wdXNoKFwib2YgXCIsVSxcIiBcIil9aWYoJC5tZW1iZXJzLmxlbmd0aD09PTAmJiEkLmhhc1Vua25vd25NZW1iZXJzKWVlLnB1c2goYyhbXCJ7XCIscyhQLEcpLGEsXCJ9XCJdKSk7ZWxzZXtsZXQgVT0kLm1lbWJlcnMubGVuZ3RoPjA/W3UsRihQLEcsXCJtZW1iZXJzXCIscmUpLCQuaGFzVW5rbm93bk1lbWJlcnN8fGYoRyk/XCIsXCI6XCJcIl06W107ZWUucHVzaChjKFtcIntcIixsKFsuLi5VLC4uLiQuaGFzVW5rbm93bk1lbWJlcnM/W3UsXCIuLi5cIl06W11dKSxzKFAsRywhMCksdSxcIn1cIl0pKX1yZXR1cm4gZWV9Y2FzZVwiRW51bUJvb2xlYW5NZW1iZXJcIjpjYXNlXCJFbnVtTnVtYmVyTWVtYmVyXCI6Y2FzZVwiRW51bVN0cmluZ01lbWJlclwiOnJldHVybltyZShcImlkXCIpLFwiID0gXCIsdHlwZW9mICQuaW5pdD09XCJvYmplY3RcIj9yZShcImluaXRcIik6U3RyaW5nKCQuaW5pdCldO2Nhc2VcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIjpyZXR1cm4gcmUoXCJpZFwiKTtjYXNlXCJGdW5jdGlvblR5cGVQYXJhbVwiOntsZXQgVT0kLm5hbWU/cmUoXCJuYW1lXCIpOlAuZ2V0UGFyZW50Tm9kZSgpLnRoaXM9PT0kP1widGhpc1wiOlwiXCI7cmV0dXJuW1UsXyhQKSxVP1wiOiBcIjpcIlwiLHJlKFwidHlwZUFubm90YXRpb25cIildfWNhc2VcIkludGVyZmFjZURlY2xhcmF0aW9uXCI6Y2FzZVwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIjpyZXR1cm4gRChQLEcscmUpO2Nhc2VcIkNsYXNzSW1wbGVtZW50c1wiOmNhc2VcIkludGVyZmFjZUV4dGVuZHNcIjpyZXR1cm5bcmUoXCJpZFwiKSxyZShcInR5cGVQYXJhbWV0ZXJzXCIpXTtjYXNlXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuW1wiP1wiLHJlKFwidHlwZUFubm90YXRpb25cIildO2Nhc2VcIlZhcmlhbmNlXCI6e2xldHtraW5kOlV9PSQ7cmV0dXJuIHQub2soVT09PVwicGx1c1wifHxVPT09XCJtaW51c1wiKSxVPT09XCJwbHVzXCI/XCIrXCI6XCItXCJ9Y2FzZVwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiOnJldHVybiAkLnN0YXRpYyYmZWUucHVzaChcInN0YXRpYyBcIiksZWUucHVzaChyZShcInZhbHVlXCIpKSxlZTtjYXNlXCJPYmplY3RUeXBlSW5kZXhlclwiOnJldHVyblskLnN0YXRpYz9cInN0YXRpYyBcIjpcIlwiLCQudmFyaWFuY2U/cmUoXCJ2YXJpYW5jZVwiKTpcIlwiLFwiW1wiLHJlKFwiaWRcIiksJC5pZD9cIjogXCI6XCJcIixyZShcImtleVwiKSxcIl06IFwiLHJlKFwidmFsdWVcIildO2Nhc2VcIk9iamVjdFR5cGVQcm9wZXJ0eVwiOntsZXQgVT1cIlwiO3JldHVybiAkLnByb3RvP1U9XCJwcm90byBcIjokLnN0YXRpYyYmKFU9XCJzdGF0aWMgXCIpLFtVLGcoJCk/JC5raW5kK1wiIFwiOlwiXCIsJC52YXJpYW5jZT9yZShcInZhcmlhbmNlXCIpOlwiXCIsayhQLEcscmUpLF8oUCksbSgkKT9cIlwiOlwiOiBcIixyZShcInZhbHVlXCIpXX1jYXNlXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiOnJldHVybiBTKFAsRyxyZSk7Y2FzZVwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiOnJldHVyblskLnN0YXRpYz9cInN0YXRpYyBcIjpcIlwiLFwiW1tcIixyZShcImlkXCIpLFwiXV1cIixfKFApLCQubWV0aG9kP1wiXCI6XCI6IFwiLHJlKFwidmFsdWVcIildO2Nhc2VcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiOnJldHVybiBSKFAsRyxyZSk7Y2FzZVwiUXVhbGlmaWVkVHlwZW9mSWRlbnRpZmllclwiOmNhc2VcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCI6cmV0dXJuW3JlKFwicXVhbGlmaWNhdGlvblwiKSxcIi5cIixyZShcImlkXCIpXTtjYXNlXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIjpyZXR1cm4gaShwKCQpLEcpO2Nhc2VcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiOnQuc3RyaWN0RXF1YWwodHlwZW9mICQudmFsdWUsXCJudW1iZXJcIik7Y2FzZVwiQmlnSW50TGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuICQuZXh0cmE/cigkLmV4dHJhLnJhdyk6cigkLnJhdyk7Y2FzZVwiVHlwZUNhc3RFeHByZXNzaW9uXCI6cmV0dXJuW1wiKFwiLHJlKFwiZXhwcmVzc2lvblwiKSxPKFAsRyxyZSksXCIpXCJdO2Nhc2VcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiOmNhc2VcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCI6e2xldCBVPXkoUCxHLHJlLFwicGFyYW1zXCIpO2lmKEcucGFyc2VyPT09XCJmbG93XCIpe2xldCBuZT1oKCQpLHNlPU4oJCksVj1HLm9yaWdpbmFsVGV4dC5sYXN0SW5kZXhPZihcIi8qXCIsbmUpLG9lPUcub3JpZ2luYWxUZXh0LmluZGV4T2YoXCIqL1wiLHNlKTtpZihWIT09LTEmJm9lIT09LTEpe2xldCBLPUcub3JpZ2luYWxUZXh0LnNsaWNlKFYrMixvZSkudHJpbSgpO2lmKEsuc3RhcnRzV2l0aChcIjo6XCIpJiYhSy5pbmNsdWRlcyhcIi8qXCIpJiYhSy5pbmNsdWRlcyhcIiovXCIpKXJldHVybltcIi8qOjogXCIsVSxcIiAqL1wiXX19cmV0dXJuIFV9Y2FzZVwiSW5mZXJyZWRQcmVkaWNhdGVcIjpyZXR1cm5cIiVjaGVja3NcIjtjYXNlXCJEZWNsYXJlZFByZWRpY2F0ZVwiOnJldHVybltcIiVjaGVja3MoXCIscmUoXCJ2YWx1ZVwiKSxcIilcIl07Y2FzZVwiQW55VHlwZUFubm90YXRpb25cIjpyZXR1cm5cImFueVwiO2Nhc2VcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiOnJldHVyblwiYm9vbGVhblwiO2Nhc2VcIkJpZ0ludFR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuXCJiaWdpbnRcIjtjYXNlXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuXCJudWxsXCI7Y2FzZVwiTnVtYmVyVHlwZUFubm90YXRpb25cIjpyZXR1cm5cIm51bWJlclwiO2Nhc2VcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuXCJzeW1ib2xcIjtjYXNlXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiOnJldHVyblwic3RyaW5nXCI7Y2FzZVwiVm9pZFR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuXCJ2b2lkXCI7Y2FzZVwiVGhpc1R5cGVBbm5vdGF0aW9uXCI6cmV0dXJuXCJ0aGlzXCI7Y2FzZVwiTm9kZVwiOmNhc2VcIlByaW50YWJsZVwiOmNhc2VcIlNvdXJjZUxvY2F0aW9uXCI6Y2FzZVwiUG9zaXRpb25cIjpjYXNlXCJTdGF0ZW1lbnRcIjpjYXNlXCJGdW5jdGlvblwiOmNhc2VcIlBhdHRlcm5cIjpjYXNlXCJFeHByZXNzaW9uXCI6Y2FzZVwiRGVjbGFyYXRpb25cIjpjYXNlXCJTcGVjaWZpZXJcIjpjYXNlXCJOYW1lZFNwZWNpZmllclwiOmNhc2VcIkNvbW1lbnRcIjpjYXNlXCJNZW1iZXJUeXBlQW5ub3RhdGlvblwiOmNhc2VcIlR5cGVcIjp0aHJvdyBuZXcgRXJyb3IoXCJ1bnByaW50YWJsZSB0eXBlOiBcIitKU09OLnN0cmluZ2lmeSgkLnR5cGUpKX19ZnVuY3Rpb24gSChQLEcpe2xldCByZT1DKFApO3JldHVybiByZT8odC5zdHJpY3RFcXVhbChyZS50eXBlLFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpLEcpOltcImRlY2xhcmUgXCIsR119bi5leHBvcnRzPXtwcmludEZsb3c6TX19fSksX209Wih7XCJzcmMvbGFuZ3VhZ2UtanMvdXRpbHMvaXMtdHMta2V5d29yZC10eXBlLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO2Z1bmN0aW9uIHQocyl7bGV0e3R5cGU6aX09cztyZXR1cm4gaS5zdGFydHNXaXRoKFwiVFNcIikmJmkuZW5kc1dpdGgoXCJLZXl3b3JkXCIpfW4uZXhwb3J0cz10fX0pLG9vPVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L3Rlcm5hcnkuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2hhc05ld2xpbmVJblJhbmdlOnR9PUdlKCkse2lzSnN4Tm9kZTpzLGdldENvbW1lbnRzOmksaXNDYWxsRXhwcmVzc2lvbjpyLGlzTWVtYmVyRXhwcmVzc2lvbjp1fT1YZSgpLHtsb2NTdGFydDphLGxvY0VuZDpjfT1udCgpLGw9UHQoKSx7YnVpbGRlcnM6e2xpbmU6Qyxzb2Z0bGluZTptLGdyb3VwOmcsaW5kZW50OnAsYWxpZ246ZixpZkJyZWFrOmgsZGVkZW50Ok4sYnJlYWtQYXJlbnQ6VH19PUxlKCk7ZnVuY3Rpb24gQShJKXtsZXQgRT1bSV07Zm9yKGxldCBEPTA7RDxFLmxlbmd0aDtEKyspe2xldCBkPUVbRF07Zm9yKGxldCB5IG9mW1widGVzdFwiLFwiY29uc2VxdWVudFwiLFwiYWx0ZXJuYXRlXCJdKXtsZXQgbz1kW3ldO2lmKHMobykpcmV0dXJuITA7by50eXBlPT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiYmRS5wdXNoKG8pfX1yZXR1cm4hMX1mdW5jdGlvbiBiKEksRSxEKXtsZXQgZD1JLmdldFZhbHVlKCkseT1kLnR5cGU9PT1cIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLG89eT9cImFsdGVybmF0ZVwiOlwiZmFsc2VUeXBlXCIseD1JLmdldFBhcmVudE5vZGUoKSxGPXk/RChcInRlc3RcIik6W0QoXCJjaGVja1R5cGVcIiksXCIgXCIsXCJleHRlbmRzXCIsXCIgXCIsRChcImV4dGVuZHNUeXBlXCIpXTtyZXR1cm4geC50eXBlPT09ZC50eXBlJiZ4W29dPT09ZD9mKDIsRik6Rn12YXIgdj1uZXcgTWFwKFtbXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFwicmlnaHRcIl0sW1wiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJpbml0XCJdLFtcIlJldHVyblN0YXRlbWVudFwiLFwiYXJndW1lbnRcIl0sW1wiVGhyb3dTdGF0ZW1lbnRcIixcImFyZ3VtZW50XCJdLFtcIlVuYXJ5RXhwcmVzc2lvblwiLFwiYXJndW1lbnRcIl0sW1wiWWllbGRFeHByZXNzaW9uXCIsXCJhcmd1bWVudFwiXV0pO2Z1bmN0aW9uIEIoSSl7bGV0IEU9SS5nZXRWYWx1ZSgpO2lmKEUudHlwZSE9PVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpcmV0dXJuITE7bGV0IEQsZD1FO2ZvcihsZXQgeT0wOyFEO3krKyl7bGV0IG89SS5nZXRQYXJlbnROb2RlKHkpO2lmKHIobykmJm8uY2FsbGVlPT09ZHx8dShvKSYmby5vYmplY3Q9PT1kfHxvLnR5cGU9PT1cIlRTTm9uTnVsbEV4cHJlc3Npb25cIiYmby5leHByZXNzaW9uPT09ZCl7ZD1vO2NvbnRpbnVlfW8udHlwZT09PVwiTmV3RXhwcmVzc2lvblwiJiZvLmNhbGxlZT09PWR8fG8udHlwZT09PVwiVFNBc0V4cHJlc3Npb25cIiYmby5leHByZXNzaW9uPT09ZD8oRD1JLmdldFBhcmVudE5vZGUoeSsxKSxkPW8pOkQ9b31yZXR1cm4gZD09PUU/ITE6RFt2LmdldChELnR5cGUpXT09PWR9ZnVuY3Rpb24gdyhJLEUsRCl7bGV0IGQ9SS5nZXRWYWx1ZSgpLHk9ZC50eXBlPT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIixvPXk/XCJjb25zZXF1ZW50XCI6XCJ0cnVlVHlwZVwiLHg9eT9cImFsdGVybmF0ZVwiOlwiZmFsc2VUeXBlXCIsRj15P1tcInRlc3RcIl06W1wiY2hlY2tUeXBlXCIsXCJleHRlbmRzVHlwZVwiXSxTPWRbb10saz1kW3hdLF89W10sTz0hMSxSPUkuZ2V0UGFyZW50Tm9kZSgpLE09Ui50eXBlPT09ZC50eXBlJiZGLnNvbWUoSz0+UltLXT09PWQpLEg9Ui50eXBlPT09ZC50eXBlJiYhTSxQLEcscmU9MDtkbyBHPVB8fGQsUD1JLmdldFBhcmVudE5vZGUocmUpLHJlKys7d2hpbGUoUCYmUC50eXBlPT09ZC50eXBlJiZGLmV2ZXJ5KEs9PlBbS10hPT1HKSk7bGV0ICQ9UHx8UixXPUc7aWYoeSYmKHMoZFtGWzBdXSl8fHMoUyl8fHMoayl8fEEoVykpKXtPPSEwLEg9ITA7bGV0IEs9cT0+W2goXCIoXCIpLHAoW20scV0pLG0saChcIilcIildLEVlPXE9PnEudHlwZT09PVwiTnVsbExpdGVyYWxcInx8cS50eXBlPT09XCJMaXRlcmFsXCImJnEudmFsdWU9PT1udWxsfHxxLnR5cGU9PT1cIklkZW50aWZpZXJcIiYmcS5uYW1lPT09XCJ1bmRlZmluZWRcIjtfLnB1c2goXCIgPyBcIixFZShTKT9EKG8pOksoRChvKSksXCIgOiBcIixrLnR5cGU9PT1kLnR5cGV8fEVlKGspP0QoeCk6SyhEKHgpKSl9ZWxzZXtsZXQgSz1bQyxcIj8gXCIsUy50eXBlPT09ZC50eXBlP2goXCJcIixcIihcIik6XCJcIixmKDIsRChvKSksUy50eXBlPT09ZC50eXBlP2goXCJcIixcIilcIik6XCJcIixDLFwiOiBcIixrLnR5cGU9PT1kLnR5cGU/RCh4KTpmKDIsRCh4KSldO18ucHVzaChSLnR5cGUhPT1kLnR5cGV8fFJbeF09PT1kfHxNP0s6RS51c2VUYWJzP04ocChLKSk6ZihNYXRoLm1heCgwLEUudGFiV2lkdGgtMiksSykpfWxldCBVPVsuLi5GLm1hcChLPT5pKGRbS10pKSxpKFMpLGkoayldLmZsYXQoKS5zb21lKEs9PmwoSykmJnQoRS5vcmlnaW5hbFRleHQsYShLKSxjKEspKSksbmU9Sz0+Uj09PSQ/ZyhLLHtzaG91bGRCcmVhazpVfSk6VT9bSyxUXTpLLHNlPSFPJiYodShSKXx8Ui50eXBlPT09XCJOR1BpcGVFeHByZXNzaW9uXCImJlIubGVmdD09PWQpJiYhUi5jb21wdXRlZCxWPUIoSSksb2U9bmUoW2IoSSxFLEQpLEg/XzpwKF8pLHkmJnNlJiYhVj9tOlwiXCJdKTtyZXR1cm4gTXx8Vj9nKFtwKFttLG9lXSksbV0pOm9lfW4uZXhwb3J0cz17cHJpbnRUZXJuYXJ5Ond9fX0pLGNvPVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L3N0YXRlbWVudC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7YnVpbGRlcnM6e2hhcmRsaW5lOnR9fT1MZSgpLHM9a3QoKSx7Z2V0TGVmdFNpZGVQYXRoTmFtZTppLGhhc05ha2VkTGVmdFNpZGU6cixpc0pzeE5vZGU6dSxpc1RoZU9ubHlKc3hFbGVtZW50SW5NYXJrZG93bjphLGhhc0NvbW1lbnQ6YyxDb21tZW50Q2hlY2tGbGFnczpsLGlzTmV4dExpbmVFbXB0eTpDfT1YZSgpLHtzaG91bGRQcmludFBhcmFtc1dpdGhvdXRQYXJlbnM6bX09SXIoKTtmdW5jdGlvbiBnKHYsQix3LEkpe2xldCBFPXYuZ2V0VmFsdWUoKSxEPVtdLGQ9RS50eXBlPT09XCJDbGFzc0JvZHlcIix5PXAoRVtJXSk7cmV0dXJuIHYuZWFjaCgobyx4LEYpPT57bGV0IFM9by5nZXRWYWx1ZSgpO2lmKFMudHlwZT09PVwiRW1wdHlTdGF0ZW1lbnRcIilyZXR1cm47bGV0IGs9dygpOyFCLnNlbWkmJiFkJiYhYShCLG8pJiZmKG8sQik/YyhTLGwuTGVhZGluZyk/RC5wdXNoKHcoW10se25lZWRzU2VtaTohMH0pKTpELnB1c2goXCI7XCIsayk6RC5wdXNoKGspLCFCLnNlbWkmJmQmJkEoUykmJmIoUyxGW3grMV0pJiZELnB1c2goXCI7XCIpLFMhPT15JiYoRC5wdXNoKHQpLEMoUyxCKSYmRC5wdXNoKHQpKX0sSSksRH1mdW5jdGlvbiBwKHYpe2ZvcihsZXQgQj12Lmxlbmd0aC0xO0I+PTA7Qi0tKXtsZXQgdz12W0JdO2lmKHcudHlwZSE9PVwiRW1wdHlTdGF0ZW1lbnRcIilyZXR1cm4gd319ZnVuY3Rpb24gZih2LEIpe3JldHVybiB2LmdldE5vZGUoKS50eXBlIT09XCJFeHByZXNzaW9uU3RhdGVtZW50XCI/ITE6di5jYWxsKEk9PmgoSSxCKSxcImV4cHJlc3Npb25cIil9ZnVuY3Rpb24gaCh2LEIpe2xldCB3PXYuZ2V0VmFsdWUoKTtzd2l0Y2gody50eXBlKXtjYXNlXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOmNhc2VcIlR5cGVDYXN0RXhwcmVzc2lvblwiOmNhc2VcIkFycmF5RXhwcmVzc2lvblwiOmNhc2VcIkFycmF5UGF0dGVyblwiOmNhc2VcIlRlbXBsYXRlTGl0ZXJhbFwiOmNhc2VcIlRlbXBsYXRlRWxlbWVudFwiOmNhc2VcIlJlZ0V4cExpdGVyYWxcIjpyZXR1cm4hMDtjYXNlXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOntpZighbSh2LEIpKXJldHVybiEwO2JyZWFrfWNhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOntsZXR7cHJlZml4Okksb3BlcmF0b3I6RX09dztpZihJJiYoRT09PVwiK1wifHxFPT09XCItXCIpKXJldHVybiEwO2JyZWFrfWNhc2VcIkJpbmRFeHByZXNzaW9uXCI6e2lmKCF3Lm9iamVjdClyZXR1cm4hMDticmVha31jYXNlXCJMaXRlcmFsXCI6e2lmKHcucmVnZXgpcmV0dXJuITA7YnJlYWt9ZGVmYXVsdDppZih1KHcpKXJldHVybiEwfXJldHVybiBzKHYsQik/ITA6cih3KT92LmNhbGwoST0+aChJLEIpLC4uLmkodix3KSk6ITF9ZnVuY3Rpb24gTih2LEIsdyl7cmV0dXJuIGcodixCLHcsXCJib2R5XCIpfWZ1bmN0aW9uIFQodixCLHcpe3JldHVybiBnKHYsQix3LFwiY29uc2VxdWVudFwiKX12YXIgQT12PT57bGV0e3R5cGU6Qn09djtyZXR1cm4gQj09PVwiQ2xhc3NQcm9wZXJ0eVwifHxCPT09XCJQcm9wZXJ0eURlZmluaXRpb25cInx8Qj09PVwiQ2xhc3NQcml2YXRlUHJvcGVydHlcInx8Qj09PVwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCJ9O2Z1bmN0aW9uIGIodixCKXtsZXQgdz12LmtleSYmdi5rZXkubmFtZTtpZigodz09PVwic3RhdGljXCJ8fHc9PT1cImdldFwifHx3PT09XCJzZXRcIikmJiF2LnZhbHVlJiYhdi50eXBlQW5ub3RhdGlvbilyZXR1cm4hMDtpZighQnx8Qi5zdGF0aWN8fEIuYWNjZXNzaWJpbGl0eSlyZXR1cm4hMTtpZighQi5jb21wdXRlZCl7bGV0IEk9Qi5rZXkmJkIua2V5Lm5hbWU7aWYoST09PVwiaW5cInx8ST09PVwiaW5zdGFuY2VvZlwiKXJldHVybiEwfWlmKEEoQikmJkIudmFyaWFuY2UmJiFCLnN0YXRpYyYmIUIuZGVjbGFyZSlyZXR1cm4hMDtzd2l0Y2goQi50eXBlKXtjYXNlXCJDbGFzc1Byb3BlcnR5XCI6Y2FzZVwiUHJvcGVydHlEZWZpbml0aW9uXCI6Y2FzZVwiVFNBYnN0cmFjdFByb3BlcnR5RGVmaW5pdGlvblwiOnJldHVybiBCLmNvbXB1dGVkO2Nhc2VcIk1ldGhvZERlZmluaXRpb25cIjpjYXNlXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiOmNhc2VcIkNsYXNzTWV0aG9kXCI6Y2FzZVwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6e2lmKChCLnZhbHVlP0IudmFsdWUuYXN5bmM6Qi5hc3luYyl8fEIua2luZD09PVwiZ2V0XCJ8fEIua2luZD09PVwic2V0XCIpcmV0dXJuITE7bGV0IEU9Qi52YWx1ZT9CLnZhbHVlLmdlbmVyYXRvcjpCLmdlbmVyYXRvcjtyZXR1cm4hIShCLmNvbXB1dGVkfHxFKX1jYXNlXCJUU0luZGV4U2lnbmF0dXJlXCI6cmV0dXJuITB9cmV0dXJuITF9bi5leHBvcnRzPXtwcmludEJvZHk6TixwcmludFN3aXRjaENhc2VDb25zZXF1ZW50OlR9fX0pLGxvPVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L2Jsb2NrLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntwcmludERhbmdsaW5nQ29tbWVudHM6dH09UWUoKSx7aXNOb25FbXB0eUFycmF5OnN9PUdlKCkse2J1aWxkZXJzOntoYXJkbGluZTppLGluZGVudDpyfX09TGUoKSx7aGFzQ29tbWVudDp1LENvbW1lbnRDaGVja0ZsYWdzOmEsaXNOZXh0TGluZUVtcHR5OmN9PVhlKCkse3ByaW50SGFyZGxpbmVBZnRlckhlcml0YWdlOmx9PVl0KCkse3ByaW50Qm9keTpDfT1jbygpO2Z1bmN0aW9uIG0ocCxmLGgpe2xldCBOPXAuZ2V0VmFsdWUoKSxUPVtdO2lmKE4udHlwZT09PVwiU3RhdGljQmxvY2tcIiYmVC5wdXNoKFwic3RhdGljIFwiKSxOLnR5cGU9PT1cIkNsYXNzQm9keVwiJiZzKE4uYm9keSkpe2xldCBiPXAuZ2V0UGFyZW50Tm9kZSgpO1QucHVzaChsKGIpKX1ULnB1c2goXCJ7XCIpO2xldCBBPWcocCxmLGgpO2lmKEEpVC5wdXNoKHIoW2ksQV0pLGkpO2Vsc2V7bGV0IGI9cC5nZXRQYXJlbnROb2RlKCksdj1wLmdldFBhcmVudE5vZGUoMSk7Yi50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwifHxiLnR5cGU9PT1cIkZ1bmN0aW9uRXhwcmVzc2lvblwifHxiLnR5cGU9PT1cIkZ1bmN0aW9uRGVjbGFyYXRpb25cInx8Yi50eXBlPT09XCJPYmplY3RNZXRob2RcInx8Yi50eXBlPT09XCJDbGFzc01ldGhvZFwifHxiLnR5cGU9PT1cIkNsYXNzUHJpdmF0ZU1ldGhvZFwifHxiLnR5cGU9PT1cIkZvclN0YXRlbWVudFwifHxiLnR5cGU9PT1cIldoaWxlU3RhdGVtZW50XCJ8fGIudHlwZT09PVwiRG9XaGlsZVN0YXRlbWVudFwifHxiLnR5cGU9PT1cIkRvRXhwcmVzc2lvblwifHxiLnR5cGU9PT1cIkNhdGNoQ2xhdXNlXCImJiF2LmZpbmFsaXplcnx8Yi50eXBlPT09XCJUU01vZHVsZURlY2xhcmF0aW9uXCJ8fGIudHlwZT09PVwiVFNEZWNsYXJlRnVuY3Rpb25cInx8Ti50eXBlPT09XCJTdGF0aWNCbG9ja1wifHxOLnR5cGU9PT1cIkNsYXNzQm9keVwifHxULnB1c2goaSl9cmV0dXJuIFQucHVzaChcIn1cIiksVH1mdW5jdGlvbiBnKHAsZixoKXtsZXQgTj1wLmdldFZhbHVlKCksVD1zKE4uZGlyZWN0aXZlcyksQT1OLmJvZHkuc29tZShCPT5CLnR5cGUhPT1cIkVtcHR5U3RhdGVtZW50XCIpLGI9dShOLGEuRGFuZ2xpbmcpO2lmKCFUJiYhQSYmIWIpcmV0dXJuXCJcIjtsZXQgdj1bXTtpZihUJiZwLmVhY2goKEIsdyxJKT0+e3YucHVzaChoKCkpLCh3PEkubGVuZ3RoLTF8fEF8fGIpJiYodi5wdXNoKGkpLGMoQi5nZXRWYWx1ZSgpLGYpJiZ2LnB1c2goaSkpfSxcImRpcmVjdGl2ZXNcIiksQSYmdi5wdXNoKEMocCxmLGgpKSxiJiZ2LnB1c2godChwLGYsITApKSxOLnR5cGU9PT1cIlByb2dyYW1cIil7bGV0IEI9cC5nZXRQYXJlbnROb2RlKCk7KCFCfHxCLnR5cGUhPT1cIk1vZHVsZUV4cHJlc3Npb25cIikmJnYucHVzaChpKX1yZXR1cm4gdn1uLmV4cG9ydHM9e3ByaW50QmxvY2s6bSxwcmludEJsb2NrQm9keTpnfX19KSxQbT1aKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC90eXBlc2NyaXB0LmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntwcmludERhbmdsaW5nQ29tbWVudHM6dH09UWUoKSx7aGFzTmV3bGluZUluUmFuZ2U6c309R2UoKSx7YnVpbGRlcnM6e2pvaW46aSxsaW5lOnIsaGFyZGxpbmU6dSxzb2Z0bGluZTphLGdyb3VwOmMsaW5kZW50OmwsY29uZGl0aW9uYWxHcm91cDpDLGlmQnJlYWs6bX19PUxlKCkse2lzTGl0ZXJhbDpnLGdldFR5cGVTY3JpcHRNYXBwZWRUeXBlTW9kaWZpZXI6cCxzaG91bGRQcmludENvbW1hOmYsaXNDYWxsRXhwcmVzc2lvbjpoLGlzTWVtYmVyRXhwcmVzc2lvbjpOfT1YZSgpLFQ9X20oKSx7bG9jU3RhcnQ6QSxsb2NFbmQ6Yn09bnQoKSx7cHJpbnRPcHRpb25hbFRva2VuOnYscHJpbnRUeXBlU2NyaXB0TW9kaWZpZXJzOkJ9PW90KCkse3ByaW50VGVybmFyeTp3fT1vbygpLHtwcmludEZ1bmN0aW9uUGFyYW1ldGVyczpJLHNob3VsZEdyb3VwRnVuY3Rpb25QYXJhbWV0ZXJzOkV9PXdyKCkse3ByaW50VGVtcGxhdGVMaXRlcmFsOkR9PUl0KCkse3ByaW50QXJyYXlJdGVtczpkfT16dCgpLHtwcmludE9iamVjdDp5fT16bigpLHtwcmludENsYXNzUHJvcGVydHk6byxwcmludENsYXNzTWV0aG9kOnh9PVl0KCkse3ByaW50VHlwZVBhcmFtZXRlcjpGLHByaW50VHlwZVBhcmFtZXRlcnM6U309UHIoKSx7cHJpbnRQcm9wZXJ0eUtleTprfT1LdCgpLHtwcmludEZ1bmN0aW9uOl8scHJpbnRNZXRob2RJbnRlcm5hbDpPfT1JcigpLHtwcmludEludGVyZmFjZTpSfT1hbygpLHtwcmludEJsb2NrOk19PWxvKCkse3ByaW50VHlwZUFsaWFzOkgscHJpbnRJbnRlcnNlY3Rpb25UeXBlOlAscHJpbnRVbmlvblR5cGU6RyxwcmludEZ1bmN0aW9uVHlwZTpyZSxwcmludFR1cGxlVHlwZTokLHByaW50SW5kZXhlZEFjY2Vzc1R5cGU6V309X3IoKTtmdW5jdGlvbiBlZShVLG5lLHNlKXtsZXQgVj1VLmdldFZhbHVlKCk7aWYoIVYudHlwZS5zdGFydHNXaXRoKFwiVFNcIikpcmV0dXJuO2lmKFQoVikpcmV0dXJuIFYudHlwZS5zbGljZSgyLC03KS50b0xvd2VyQ2FzZSgpO2xldCBvZT1uZS5zZW1pP1wiO1wiOlwiXCIsSz1bXTtzd2l0Y2goVi50eXBlKXtjYXNlXCJUU1RoaXNUeXBlXCI6cmV0dXJuXCJ0aGlzXCI7Y2FzZVwiVFNUeXBlQXNzZXJ0aW9uXCI6e2xldCBFZT0hKFYuZXhwcmVzc2lvbi50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cInx8Vi5leHByZXNzaW9uLnR5cGU9PT1cIk9iamVjdEV4cHJlc3Npb25cIikscT1jKFtcIjxcIixsKFthLHNlKFwidHlwZUFubm90YXRpb25cIildKSxhLFwiPlwiXSksbGU9W20oXCIoXCIpLGwoW2Esc2UoXCJleHByZXNzaW9uXCIpXSksYSxtKFwiKVwiKV07cmV0dXJuIEVlP0MoW1txLHNlKFwiZXhwcmVzc2lvblwiKV0sW3EsYyhsZSx7c2hvdWxkQnJlYWs6ITB9KV0sW3Esc2UoXCJleHByZXNzaW9uXCIpXV0pOmMoW3Esc2UoXCJleHByZXNzaW9uXCIpXSl9Y2FzZVwiVFNEZWNsYXJlRnVuY3Rpb25cIjpyZXR1cm4gXyhVLHNlLG5lKTtjYXNlXCJUU0V4cG9ydEFzc2lnbm1lbnRcIjpyZXR1cm5bXCJleHBvcnQgPSBcIixzZShcImV4cHJlc3Npb25cIiksb2VdO2Nhc2VcIlRTTW9kdWxlQmxvY2tcIjpyZXR1cm4gTShVLG5lLHNlKTtjYXNlXCJUU0ludGVyZmFjZUJvZHlcIjpjYXNlXCJUU1R5cGVMaXRlcmFsXCI6cmV0dXJuIHkoVSxuZSxzZSk7Y2FzZVwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiOnJldHVybiBIKFUsbmUsc2UpO2Nhc2VcIlRTUXVhbGlmaWVkTmFtZVwiOnJldHVybiBpKFwiLlwiLFtzZShcImxlZnRcIiksc2UoXCJyaWdodFwiKV0pO2Nhc2VcIlRTQWJzdHJhY3RNZXRob2REZWZpbml0aW9uXCI6Y2FzZVwiVFNEZWNsYXJlTWV0aG9kXCI6cmV0dXJuIHgoVSxuZSxzZSk7Y2FzZVwiVFNBYnN0cmFjdFByb3BlcnR5RGVmaW5pdGlvblwiOnJldHVybiBvKFUsbmUsc2UpO2Nhc2VcIlRTSW50ZXJmYWNlSGVyaXRhZ2VcIjpjYXNlXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiOnJldHVybiBLLnB1c2goc2UoXCJleHByZXNzaW9uXCIpKSxWLnR5cGVQYXJhbWV0ZXJzJiZLLnB1c2goc2UoXCJ0eXBlUGFyYW1ldGVyc1wiKSksSztjYXNlXCJUU1RlbXBsYXRlTGl0ZXJhbFR5cGVcIjpyZXR1cm4gRChVLHNlLG5lKTtjYXNlXCJUU05hbWVkVHVwbGVNZW1iZXJcIjpyZXR1cm5bc2UoXCJsYWJlbFwiKSxWLm9wdGlvbmFsP1wiP1wiOlwiXCIsXCI6IFwiLHNlKFwiZWxlbWVudFR5cGVcIildO2Nhc2VcIlRTUmVzdFR5cGVcIjpyZXR1cm5bXCIuLi5cIixzZShcInR5cGVBbm5vdGF0aW9uXCIpXTtjYXNlXCJUU09wdGlvbmFsVHlwZVwiOnJldHVybltzZShcInR5cGVBbm5vdGF0aW9uXCIpLFwiP1wiXTtjYXNlXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCI6cmV0dXJuIFIoVSxuZSxzZSk7Y2FzZVwiVFNDbGFzc0ltcGxlbWVudHNcIjpyZXR1cm5bc2UoXCJleHByZXNzaW9uXCIpLHNlKFwidHlwZVBhcmFtZXRlcnNcIildO2Nhc2VcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCI6Y2FzZVwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiOnJldHVybiBTKFUsbmUsc2UsXCJwYXJhbXNcIik7Y2FzZVwiVFNUeXBlUGFyYW1ldGVyXCI6cmV0dXJuIEYoVSxuZSxzZSk7Y2FzZVwiVFNBc0V4cHJlc3Npb25cIjp7Sy5wdXNoKHNlKFwiZXhwcmVzc2lvblwiKSxcIiBhcyBcIixzZShcInR5cGVBbm5vdGF0aW9uXCIpKTtsZXQgRWU9VS5nZXRQYXJlbnROb2RlKCk7cmV0dXJuIGgoRWUpJiZFZS5jYWxsZWU9PT1WfHxOKEVlKSYmRWUub2JqZWN0PT09Vj9jKFtsKFthLC4uLktdKSxhXSk6S31jYXNlXCJUU0FycmF5VHlwZVwiOnJldHVybltzZShcImVsZW1lbnRUeXBlXCIpLFwiW11cIl07Y2FzZVwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiOnJldHVybiBWLnJlYWRvbmx5JiZLLnB1c2goXCJyZWFkb25seSBcIiksSy5wdXNoKGsoVSxuZSxzZSksdihVKSksVi50eXBlQW5ub3RhdGlvbiYmSy5wdXNoKFwiOiBcIixzZShcInR5cGVBbm5vdGF0aW9uXCIpKSxWLmluaXRpYWxpemVyJiZLLnB1c2goXCIgPSBcIixzZShcImluaXRpYWxpemVyXCIpKSxLO2Nhc2VcIlRTUGFyYW1ldGVyUHJvcGVydHlcIjpyZXR1cm4gVi5hY2Nlc3NpYmlsaXR5JiZLLnB1c2goVi5hY2Nlc3NpYmlsaXR5K1wiIFwiKSxWLmV4cG9ydCYmSy5wdXNoKFwiZXhwb3J0IFwiKSxWLnN0YXRpYyYmSy5wdXNoKFwic3RhdGljIFwiKSxWLm92ZXJyaWRlJiZLLnB1c2goXCJvdmVycmlkZSBcIiksVi5yZWFkb25seSYmSy5wdXNoKFwicmVhZG9ubHkgXCIpLEsucHVzaChzZShcInBhcmFtZXRlclwiKSksSztjYXNlXCJUU1R5cGVRdWVyeVwiOnJldHVybltcInR5cGVvZiBcIixzZShcImV4cHJOYW1lXCIpXTtjYXNlXCJUU0luZGV4U2lnbmF0dXJlXCI6e2xldCBFZT1VLmdldFBhcmVudE5vZGUoKSxxPVYucGFyYW1ldGVycy5sZW5ndGg+MT9tKGYobmUpP1wiLFwiOlwiXCIpOlwiXCIsbGU9YyhbbChbYSxpKFtcIiwgXCIsYV0sVS5tYXAoc2UsXCJwYXJhbWV0ZXJzXCIpKV0pLHEsYV0pO3JldHVybltWLmV4cG9ydD9cImV4cG9ydCBcIjpcIlwiLFYuYWNjZXNzaWJpbGl0eT9bVi5hY2Nlc3NpYmlsaXR5LFwiIFwiXTpcIlwiLFYuc3RhdGljP1wic3RhdGljIFwiOlwiXCIsVi5yZWFkb25seT9cInJlYWRvbmx5IFwiOlwiXCIsVi5kZWNsYXJlP1wiZGVjbGFyZSBcIjpcIlwiLFwiW1wiLFYucGFyYW1ldGVycz9sZTpcIlwiLFYudHlwZUFubm90YXRpb24/XCJdOiBcIjpcIl1cIixWLnR5cGVBbm5vdGF0aW9uP3NlKFwidHlwZUFubm90YXRpb25cIik6XCJcIixFZS50eXBlPT09XCJDbGFzc0JvZHlcIj9vZTpcIlwiXX1jYXNlXCJUU1R5cGVQcmVkaWNhdGVcIjpyZXR1cm5bVi5hc3NlcnRzP1wiYXNzZXJ0cyBcIjpcIlwiLHNlKFwicGFyYW1ldGVyTmFtZVwiKSxWLnR5cGVBbm5vdGF0aW9uP1tcIiBpcyBcIixzZShcInR5cGVBbm5vdGF0aW9uXCIpXTpcIlwiXTtjYXNlXCJUU05vbk51bGxFeHByZXNzaW9uXCI6cmV0dXJuW3NlKFwiZXhwcmVzc2lvblwiKSxcIiFcIl07Y2FzZVwiVFNJbXBvcnRUeXBlXCI6cmV0dXJuW1YuaXNUeXBlT2Y/XCJ0eXBlb2YgXCI6XCJcIixcImltcG9ydChcIixzZShWLnBhcmFtZXRlcj9cInBhcmFtZXRlclwiOlwiYXJndW1lbnRcIiksXCIpXCIsVi5xdWFsaWZpZXI/W1wiLlwiLHNlKFwicXVhbGlmaWVyXCIpXTpcIlwiLFMoVSxuZSxzZSxcInR5cGVQYXJhbWV0ZXJzXCIpXTtjYXNlXCJUU0xpdGVyYWxUeXBlXCI6cmV0dXJuIHNlKFwibGl0ZXJhbFwiKTtjYXNlXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCI6cmV0dXJuIFcoVSxuZSxzZSk7Y2FzZVwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiOmNhc2VcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCI6Y2FzZVwiVFNDb25zdHJ1Y3RvclR5cGVcIjp7aWYoVi50eXBlPT09XCJUU0NvbnN0cnVjdG9yVHlwZVwiJiZWLmFic3RyYWN0JiZLLnB1c2goXCJhYnN0cmFjdCBcIiksVi50eXBlIT09XCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiJiZLLnB1c2goXCJuZXcgXCIpLEsucHVzaChjKEkoVSxzZSxuZSwhMSwhMCkpKSxWLnJldHVyblR5cGV8fFYudHlwZUFubm90YXRpb24pe2xldCBFZT1WLnR5cGU9PT1cIlRTQ29uc3RydWN0b3JUeXBlXCI7Sy5wdXNoKEVlP1wiID0+IFwiOlwiOiBcIixzZShcInJldHVyblR5cGVcIiksc2UoXCJ0eXBlQW5ub3RhdGlvblwiKSl9cmV0dXJuIEt9Y2FzZVwiVFNUeXBlT3BlcmF0b3JcIjpyZXR1cm5bVi5vcGVyYXRvcixcIiBcIixzZShcInR5cGVBbm5vdGF0aW9uXCIpXTtjYXNlXCJUU01hcHBlZFR5cGVcIjp7bGV0IEVlPXMobmUub3JpZ2luYWxUZXh0LEEoViksYihWKSk7cmV0dXJuIGMoW1wie1wiLGwoW25lLmJyYWNrZXRTcGFjaW5nP3I6YSxWLnJlYWRvbmx5P1twKFYucmVhZG9ubHksXCJyZWFkb25seVwiKSxcIiBcIl06XCJcIixCKFUsbmUsc2UpLHNlKFwidHlwZVBhcmFtZXRlclwiKSxWLm9wdGlvbmFsP3AoVi5vcHRpb25hbCxcIj9cIik6XCJcIixWLnR5cGVBbm5vdGF0aW9uP1wiOiBcIjpcIlwiLHNlKFwidHlwZUFubm90YXRpb25cIiksbShvZSldKSx0KFUsbmUsITApLG5lLmJyYWNrZXRTcGFjaW5nP3I6YSxcIn1cIl0se3Nob3VsZEJyZWFrOkVlfSl9Y2FzZVwiVFNNZXRob2RTaWduYXR1cmVcIjp7bGV0IEVlPVYua2luZCYmVi5raW5kIT09XCJtZXRob2RcIj9cIlwiLmNvbmNhdChWLmtpbmQsXCIgXCIpOlwiXCI7Sy5wdXNoKFYuYWNjZXNzaWJpbGl0eT9bVi5hY2Nlc3NpYmlsaXR5LFwiIFwiXTpcIlwiLEVlLFYuZXhwb3J0P1wiZXhwb3J0IFwiOlwiXCIsVi5zdGF0aWM/XCJzdGF0aWMgXCI6XCJcIixWLnJlYWRvbmx5P1wicmVhZG9ubHkgXCI6XCJcIixWLmFic3RyYWN0P1wiYWJzdHJhY3QgXCI6XCJcIixWLmRlY2xhcmU/XCJkZWNsYXJlIFwiOlwiXCIsVi5jb21wdXRlZD9cIltcIjpcIlwiLHNlKFwia2V5XCIpLFYuY29tcHV0ZWQ/XCJdXCI6XCJcIix2KFUpKTtsZXQgcT1JKFUsc2UsbmUsITEsITApLGxlPVYucmV0dXJuVHlwZT9cInJldHVyblR5cGVcIjpcInR5cGVBbm5vdGF0aW9uXCIsdWU9VltsZV0sUT11ZT9zZShsZSk6XCJcIixkZT1FKFYsUSk7cmV0dXJuIEsucHVzaChkZT9jKHEpOnEpLHVlJiZLLnB1c2goXCI6IFwiLGMoUSkpLGMoSyl9Y2FzZVwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiOnJldHVybiBLLnB1c2goXCJleHBvcnQgYXMgbmFtZXNwYWNlIFwiLHNlKFwiaWRcIikpLG5lLnNlbWkmJksucHVzaChcIjtcIiksYyhLKTtjYXNlXCJUU0VudW1EZWNsYXJhdGlvblwiOnJldHVybiBWLmRlY2xhcmUmJksucHVzaChcImRlY2xhcmUgXCIpLFYubW9kaWZpZXJzJiZLLnB1c2goQihVLG5lLHNlKSksVi5jb25zdCYmSy5wdXNoKFwiY29uc3QgXCIpLEsucHVzaChcImVudW0gXCIsc2UoXCJpZFwiKSxcIiBcIiksVi5tZW1iZXJzLmxlbmd0aD09PTA/Sy5wdXNoKGMoW1wie1wiLHQoVSxuZSksYSxcIn1cIl0pKTpLLnB1c2goYyhbXCJ7XCIsbChbdSxkKFUsbmUsXCJtZW1iZXJzXCIsc2UpLGYobmUsXCJlczVcIik/XCIsXCI6XCJcIl0pLHQoVSxuZSwhMCksdSxcIn1cIl0pKSxLO2Nhc2VcIlRTRW51bU1lbWJlclwiOnJldHVybiBLLnB1c2goc2UoXCJpZFwiKSksVi5pbml0aWFsaXplciYmSy5wdXNoKFwiID0gXCIsc2UoXCJpbml0aWFsaXplclwiKSksSztjYXNlXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCI6cmV0dXJuIFYuaXNFeHBvcnQmJksucHVzaChcImV4cG9ydCBcIiksSy5wdXNoKFwiaW1wb3J0IFwiKSxWLmltcG9ydEtpbmQmJlYuaW1wb3J0S2luZCE9PVwidmFsdWVcIiYmSy5wdXNoKFYuaW1wb3J0S2luZCxcIiBcIiksSy5wdXNoKHNlKFwiaWRcIiksXCIgPSBcIixzZShcIm1vZHVsZVJlZmVyZW5jZVwiKSksbmUuc2VtaSYmSy5wdXNoKFwiO1wiKSxjKEspO2Nhc2VcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIjpyZXR1cm5bXCJyZXF1aXJlKFwiLHNlKFwiZXhwcmVzc2lvblwiKSxcIilcIl07Y2FzZVwiVFNNb2R1bGVEZWNsYXJhdGlvblwiOntsZXQgRWU9VS5nZXRQYXJlbnROb2RlKCkscT1nKFYuaWQpLGxlPUVlLnR5cGU9PT1cIlRTTW9kdWxlRGVjbGFyYXRpb25cIix1ZT1WLmJvZHkmJlYuYm9keS50eXBlPT09XCJUU01vZHVsZURlY2xhcmF0aW9uXCI7aWYobGUpSy5wdXNoKFwiLlwiKTtlbHNle1YuZGVjbGFyZSYmSy5wdXNoKFwiZGVjbGFyZSBcIiksSy5wdXNoKEIoVSxuZSxzZSkpO2xldCBRPW5lLm9yaWdpbmFsVGV4dC5zbGljZShBKFYpLEEoVi5pZCkpO1YuaWQudHlwZT09PVwiSWRlbnRpZmllclwiJiZWLmlkLm5hbWU9PT1cImdsb2JhbFwiJiYhL25hbWVzcGFjZXxtb2R1bGUvLnRlc3QoUSl8fEsucHVzaChxfHwvKD86XnxcXHMpbW9kdWxlKD86XFxzfCQpLy50ZXN0KFEpP1wibW9kdWxlIFwiOlwibmFtZXNwYWNlIFwiKX1yZXR1cm4gSy5wdXNoKHNlKFwiaWRcIikpLHVlP0sucHVzaChzZShcImJvZHlcIikpOlYuYm9keT9LLnB1c2goXCIgXCIsYyhzZShcImJvZHlcIikpKTpLLnB1c2gob2UpLEt9Y2FzZVwiVFNDb25kaXRpb25hbFR5cGVcIjpyZXR1cm4gdyhVLG5lLHNlKTtjYXNlXCJUU0luZmVyVHlwZVwiOnJldHVybltcImluZmVyXCIsXCIgXCIsc2UoXCJ0eXBlUGFyYW1ldGVyXCIpXTtjYXNlXCJUU0ludGVyc2VjdGlvblR5cGVcIjpyZXR1cm4gUChVLG5lLHNlKTtjYXNlXCJUU1VuaW9uVHlwZVwiOnJldHVybiBHKFUsbmUsc2UpO2Nhc2VcIlRTRnVuY3Rpb25UeXBlXCI6cmV0dXJuIHJlKFUsbmUsc2UpO2Nhc2VcIlRTVHVwbGVUeXBlXCI6cmV0dXJuICQoVSxuZSxzZSk7Y2FzZVwiVFNUeXBlUmVmZXJlbmNlXCI6cmV0dXJuW3NlKFwidHlwZU5hbWVcIiksUyhVLG5lLHNlLFwidHlwZVBhcmFtZXRlcnNcIildO2Nhc2VcIlRTVHlwZUFubm90YXRpb25cIjpyZXR1cm4gc2UoXCJ0eXBlQW5ub3RhdGlvblwiKTtjYXNlXCJUU0VtcHR5Qm9keUZ1bmN0aW9uRXhwcmVzc2lvblwiOnJldHVybiBPKFUsbmUsc2UpO2Nhc2VcIlRTSlNEb2NBbGxUeXBlXCI6cmV0dXJuXCIqXCI7Y2FzZVwiVFNKU0RvY1Vua25vd25UeXBlXCI6cmV0dXJuXCI/XCI7Y2FzZVwiVFNKU0RvY051bGxhYmxlVHlwZVwiOnJldHVybltcIj9cIixzZShcInR5cGVBbm5vdGF0aW9uXCIpXTtjYXNlXCJUU0pTRG9jTm9uTnVsbGFibGVUeXBlXCI6cmV0dXJuW1wiIVwiLHNlKFwidHlwZUFubm90YXRpb25cIildO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBUeXBlU2NyaXB0IG5vZGUgdHlwZTogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KFYudHlwZSksXCIuXCIpKX19bi5leHBvcnRzPXtwcmludFR5cGVzY3JpcHQ6ZWV9fX0pLEltPVooe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L2NvbW1lbnQuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2hhc05ld2xpbmU6dH09R2UoKSx7YnVpbGRlcnM6e2pvaW46cyxoYXJkbGluZTppfSx1dGlsczp7cmVwbGFjZVRleHRFbmRPZkxpbmU6cn19PUxlKCkse2lzTGluZUNvbW1lbnQ6dX09WGUoKSx7bG9jU3RhcnQ6YSxsb2NFbmQ6Y309bnQoKSxsPVB0KCk7ZnVuY3Rpb24gQyhwLGYpe2xldCBoPXAuZ2V0VmFsdWUoKTtpZih1KGgpKXJldHVybiBmLm9yaWdpbmFsVGV4dC5zbGljZShhKGgpLGMoaCkpLnRyaW1FbmQoKTtpZihsKGgpKXtpZihtKGgpKXtsZXQgQT1nKGgpO3JldHVybiBoLnRyYWlsaW5nJiYhdChmLm9yaWdpbmFsVGV4dCxhKGgpLHtiYWNrd2FyZHM6ITB9KT9baSxBXTpBfWxldCBOPWMoaCksVD1mLm9yaWdpbmFsVGV4dC5zbGljZShOLTMsTik9PT1cIiotL1wiO3JldHVybltcIi8qXCIscihoLnZhbHVlKSxUP1wiKi0vXCI6XCIqL1wiXX10aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBjb21tZW50OiBcIitKU09OLnN0cmluZ2lmeShoKSl9ZnVuY3Rpb24gbShwKXtsZXQgZj1cIipcIi5jb25jYXQocC52YWx1ZSxcIipcIikuc3BsaXQoYFxuYCk7cmV0dXJuIGYubGVuZ3RoPjEmJmYuZXZlcnkoaD0+aC50cmltKClbMF09PT1cIipcIil9ZnVuY3Rpb24gZyhwKXtsZXQgZj1wLnZhbHVlLnNwbGl0KGBcbmApO3JldHVybltcIi8qXCIscyhpLGYubWFwKChoLE4pPT5OPT09MD9oLnRyaW1FbmQoKTpcIiBcIisoTjxmLmxlbmd0aC0xP2gudHJpbSgpOmgudHJpbVN0YXJ0KCkpKSksXCIqL1wiXX1uLmV4cG9ydHM9e3ByaW50Q29tbWVudDpDfX19KSxrbT1aKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9saXRlcmFsLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntwcmludFN0cmluZzp0LHByaW50TnVtYmVyOnN9PUdlKCk7ZnVuY3Rpb24gaShhLGMpe2xldCBsPWEuZ2V0Tm9kZSgpO3N3aXRjaChsLnR5cGUpe2Nhc2VcIlJlZ0V4cExpdGVyYWxcIjpyZXR1cm4gdShsKTtjYXNlXCJCaWdJbnRMaXRlcmFsXCI6cmV0dXJuIHIobC5iaWdpbnR8fGwuZXh0cmEucmF3KTtjYXNlXCJOdW1lcmljTGl0ZXJhbFwiOnJldHVybiBzKGwuZXh0cmEucmF3KTtjYXNlXCJTdHJpbmdMaXRlcmFsXCI6cmV0dXJuIHQobC5leHRyYS5yYXcsYyk7Y2FzZVwiTnVsbExpdGVyYWxcIjpyZXR1cm5cIm51bGxcIjtjYXNlXCJCb29sZWFuTGl0ZXJhbFwiOnJldHVybiBTdHJpbmcobC52YWx1ZSk7Y2FzZVwiRGVjaW1hbExpdGVyYWxcIjpyZXR1cm4gcyhsLnZhbHVlKStcIm1cIjtjYXNlXCJMaXRlcmFsXCI6e2lmKGwucmVnZXgpcmV0dXJuIHUobC5yZWdleCk7aWYobC5iaWdpbnQpcmV0dXJuIHIobC5yYXcpO2lmKGwuZGVjaW1hbClyZXR1cm4gcyhsLmRlY2ltYWwpK1wibVwiO2xldHt2YWx1ZTpDfT1sO3JldHVybiB0eXBlb2YgQz09XCJudW1iZXJcIj9zKGwucmF3KTp0eXBlb2YgQz09XCJzdHJpbmdcIj90KGwucmF3LGMpOlN0cmluZyhDKX19fWZ1bmN0aW9uIHIoYSl7cmV0dXJuIGEudG9Mb3dlckNhc2UoKX1mdW5jdGlvbiB1KGEpe2xldHtwYXR0ZXJuOmMsZmxhZ3M6bH09YTtyZXR1cm4gbD1bLi4ubF0uc29ydCgpLmpvaW4oXCJcIiksXCIvXCIuY29uY2F0KGMsXCIvXCIpLmNvbmNhdChsKX1uLmV4cG9ydHM9e3ByaW50TGl0ZXJhbDppfX19KSxMbT1aKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludGVyLWVzdHJlZS5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7cHJpbnREYW5nbGluZ0NvbW1lbnRzOnR9PVFlKCkse2hhc05ld2xpbmU6c309R2UoKSx7YnVpbGRlcnM6e2pvaW46aSxsaW5lOnIsaGFyZGxpbmU6dSxzb2Z0bGluZTphLGdyb3VwOmMsaW5kZW50Omx9LHV0aWxzOntyZXBsYWNlVGV4dEVuZE9mTGluZTpDfX09TGUoKSxtPXltKCksZz1obSgpLHtpbnNlcnRQcmFnbWE6cH09ZW8oKSxmPXRvKCksaD1rdCgpLE49cm8oKSx7aGFzRmxvd1Nob3J0aGFuZEFubm90YXRpb25Db21tZW50OlQsaGFzQ29tbWVudDpBLENvbW1lbnRDaGVja0ZsYWdzOmIsaXNUaGVPbmx5SnN4RWxlbWVudEluTWFya2Rvd246dixpc0xpbmVDb21tZW50OkIsaXNOZXh0TGluZUVtcHR5OncsbmVlZHNIYXJkbGluZUFmdGVyRGFuZ2xpbmdDb21tZW50OkkscmF3VGV4dDpFLGhhc0lnbm9yZUNvbW1lbnQ6RCxpc0NhbGxFeHByZXNzaW9uOmQsaXNNZW1iZXJFeHByZXNzaW9uOnksbWFya2VyRm9ySWZXaXRob3V0QmxvY2tBbmRTYW1lTGluZUNvbW1lbnQ6b309WGUoKSx7bG9jU3RhcnQ6eCxsb2NFbmQ6Rn09bnQoKSxTPVB0KCkse3ByaW50SHRtbEJpbmRpbmc6ayxpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb246X309Ym0oKSx7cHJpbnRBbmd1bGFyOk99PVRtKCkse3ByaW50SnN4OlIsaGFzSnN4SWdub3JlQ29tbWVudDpNfT1CbSgpLHtwcmludEZsb3c6SH09d20oKSx7cHJpbnRUeXBlc2NyaXB0OlB9PVBtKCkse3ByaW50T3B0aW9uYWxUb2tlbjpHLHByaW50QmluZEV4cHJlc3Npb25DYWxsZWU6cmUscHJpbnRUeXBlQW5ub3RhdGlvbjokLGFkanVzdENsYXVzZTpXLHByaW50UmVzdFNwcmVhZDplZSxwcmludERlZmluaXRlVG9rZW46VX09b3QoKSx7cHJpbnRJbXBvcnREZWNsYXJhdGlvbjpuZSxwcmludEV4cG9ydERlY2xhcmF0aW9uOnNlLHByaW50RXhwb3J0QWxsRGVjbGFyYXRpb246VixwcmludE1vZHVsZVNwZWNpZmllcjpvZX09aW8oKSx7cHJpbnRUZXJuYXJ5Okt9PW9vKCkse3ByaW50VGVtcGxhdGVMaXRlcmFsOkVlfT1JdCgpLHtwcmludEFycmF5OnF9PXp0KCkse3ByaW50T2JqZWN0OmxlfT16bigpLHtwcmludENsYXNzOnVlLHByaW50Q2xhc3NNZXRob2Q6USxwcmludENsYXNzUHJvcGVydHk6ZGV9PVl0KCkse3ByaW50UHJvcGVydHk6Z2V9PUt0KCkse3ByaW50RnVuY3Rpb246dmUscHJpbnRBcnJvd0Z1bmN0aW9uOnhlLHByaW50TWV0aG9kOndlLHByaW50UmV0dXJuU3RhdGVtZW50OmZlLHByaW50VGhyb3dTdGF0ZW1lbnQ6cGV9PUlyKCkse3ByaW50Q2FsbEV4cHJlc3Npb246bWV9PXNvKCkse3ByaW50VmFyaWFibGVEZWNsYXJhdG9yOmNlLHByaW50QXNzaWdubWVudEV4cHJlc3Npb246aGV9PVh0KCkse3ByaW50QmluYXJ5aXNoRXhwcmVzc2lvbjpKfT1KbigpLHtwcmludFN3aXRjaENhc2VDb25zZXF1ZW50OnllfT1jbygpLHtwcmludE1lbWJlckV4cHJlc3Npb246WH09dW8oKSx7cHJpbnRCbG9jazpZLHByaW50QmxvY2tCb2R5OnRlfT1sbygpLHtwcmludENvbW1lbnQ6en09SW0oKSx7cHJpbnRMaXRlcmFsOmp9PWttKCkse3ByaW50RGVjb3JhdG9yczpDZX09VW4oKTtmdW5jdGlvbiBOZShUZSxfZSxGZSxLZSl7bGV0IFNlPWplKFRlLF9lLEZlLEtlKTtpZighU2UpcmV0dXJuXCJcIjtsZXQgemU9VGUuZ2V0VmFsdWUoKSx7dHlwZTpCZX09emU7aWYoQmU9PT1cIkNsYXNzTWV0aG9kXCJ8fEJlPT09XCJDbGFzc1ByaXZhdGVNZXRob2RcInx8QmU9PT1cIkNsYXNzUHJvcGVydHlcInx8QmU9PT1cIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwifHxCZT09PVwiUHJvcGVydHlEZWZpbml0aW9uXCJ8fEJlPT09XCJUU0Fic3RyYWN0UHJvcGVydHlEZWZpbml0aW9uXCJ8fEJlPT09XCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwifHxCZT09PVwiTWV0aG9kRGVmaW5pdGlvblwifHxCZT09PVwiVFNBYnN0cmFjdE1ldGhvZERlZmluaXRpb25cInx8QmU9PT1cIlRTRGVjbGFyZU1ldGhvZFwiKXJldHVybiBTZTtsZXQgSWU9W1NlXSxWZT1DZShUZSxfZSxGZSksQWU9emUudHlwZT09PVwiQ2xhc3NFeHByZXNzaW9uXCImJlZlO2lmKFZlJiYoSWU9Wy4uLlZlLFNlXSwhQWUpKXJldHVybiBjKEllKTtpZighaChUZSxfZSkpcmV0dXJuIEtlJiZLZS5uZWVkc1NlbWkmJkllLnVuc2hpZnQoXCI7XCIpLEllLmxlbmd0aD09PTEmJkllWzBdPT09U2U/U2U6SWU7aWYoQWUmJihJZT1bbChbciwuLi5JZV0pXSksSWUudW5zaGlmdChcIihcIiksS2UmJktlLm5lZWRzU2VtaSYmSWUudW5zaGlmdChcIjtcIiksVCh6ZSkpe2xldFtQZV09emUudHJhaWxpbmdDb21tZW50cztJZS5wdXNoKFwiIC8qXCIsUGUudmFsdWUudHJpbVN0YXJ0KCksXCIqL1wiKSxQZS5wcmludGVkPSEwfXJldHVybiBBZSYmSWUucHVzaChyKSxJZS5wdXNoKFwiKVwiKSxJZX1mdW5jdGlvbiBqZShUZSxfZSxGZSxLZSl7bGV0IFNlPVRlLmdldFZhbHVlKCksemU9X2Uuc2VtaT9cIjtcIjpcIlwiO2lmKCFTZSlyZXR1cm5cIlwiO2lmKHR5cGVvZiBTZT09XCJzdHJpbmdcIilyZXR1cm4gU2U7Zm9yKGxldCBJZSBvZltqLGssTyxSLEgsUF0pe2xldCBWZT1JZShUZSxfZSxGZSk7aWYodHlwZW9mIFZlPFwidVwiKXJldHVybiBWZX1sZXQgQmU9W107c3dpdGNoKFNlLnR5cGUpe2Nhc2VcIkpzRXhwcmVzc2lvblJvb3RcIjpyZXR1cm4gRmUoXCJub2RlXCIpO2Nhc2VcIkpzb25Sb290XCI6cmV0dXJuW0ZlKFwibm9kZVwiKSx1XTtjYXNlXCJGaWxlXCI6cmV0dXJuIFNlLnByb2dyYW0mJlNlLnByb2dyYW0uaW50ZXJwcmV0ZXImJkJlLnB1c2goRmUoW1wicHJvZ3JhbVwiLFwiaW50ZXJwcmV0ZXJcIl0pKSxCZS5wdXNoKEZlKFwicHJvZ3JhbVwiKSksQmU7Y2FzZVwiUHJvZ3JhbVwiOnJldHVybiB0ZShUZSxfZSxGZSk7Y2FzZVwiRW1wdHlTdGF0ZW1lbnRcIjpyZXR1cm5cIlwiO2Nhc2VcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjp7aWYoU2UuZGlyZWN0aXZlKXJldHVybltVZShTZS5leHByZXNzaW9uLF9lKSx6ZV07aWYoX2UucGFyc2VyPT09XCJfX3Z1ZV9ldmVudF9iaW5kaW5nXCIpe2xldCBWZT1UZS5nZXRQYXJlbnROb2RlKCk7aWYoVmUudHlwZT09PVwiUHJvZ3JhbVwiJiZWZS5ib2R5Lmxlbmd0aD09PTEmJlZlLmJvZHlbMF09PT1TZSlyZXR1cm5bRmUoXCJleHByZXNzaW9uXCIpLF8oU2UuZXhwcmVzc2lvbik/XCI7XCI6XCJcIl19bGV0IEllPXQoVGUsX2UsITAsVmU9PntsZXR7bWFya2VyOkFlfT1WZTtyZXR1cm4gQWU9PT1vfSk7cmV0dXJuW0ZlKFwiZXhwcmVzc2lvblwiKSx2KF9lLFRlKT9cIlwiOnplLEllP1tcIiBcIixJZV06XCJcIl19Y2FzZVwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpyZXR1cm4hQShTZS5leHByZXNzaW9uKSYmKFNlLmV4cHJlc3Npb24udHlwZT09PVwiT2JqZWN0RXhwcmVzc2lvblwifHxTZS5leHByZXNzaW9uLnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwiKT9bXCIoXCIsRmUoXCJleHByZXNzaW9uXCIpLFwiKVwiXTpjKFtcIihcIixsKFthLEZlKFwiZXhwcmVzc2lvblwiKV0pLGEsXCIpXCJdKTtjYXNlXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOnJldHVybiBoZShUZSxfZSxGZSk7Y2FzZVwiVmFyaWFibGVEZWNsYXJhdG9yXCI6cmV0dXJuIGNlKFRlLF9lLEZlKTtjYXNlXCJCaW5hcnlFeHByZXNzaW9uXCI6Y2FzZVwiTG9naWNhbEV4cHJlc3Npb25cIjpyZXR1cm4gSihUZSxfZSxGZSk7Y2FzZVwiQXNzaWdubWVudFBhdHRlcm5cIjpyZXR1cm5bRmUoXCJsZWZ0XCIpLFwiID0gXCIsRmUoXCJyaWdodFwiKV07Y2FzZVwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOnJldHVybiBYKFRlLF9lLEZlKTtjYXNlXCJNZXRhUHJvcGVydHlcIjpyZXR1cm5bRmUoXCJtZXRhXCIpLFwiLlwiLEZlKFwicHJvcGVydHlcIildO2Nhc2VcIkJpbmRFeHByZXNzaW9uXCI6cmV0dXJuIFNlLm9iamVjdCYmQmUucHVzaChGZShcIm9iamVjdFwiKSksQmUucHVzaChjKGwoW2EscmUoVGUsX2UsRmUpXSkpKSxCZTtjYXNlXCJJZGVudGlmaWVyXCI6cmV0dXJuW1NlLm5hbWUsRyhUZSksVShUZSksJChUZSxfZSxGZSldO2Nhc2VcIlY4SW50cmluc2ljSWRlbnRpZmllclwiOnJldHVybltcIiVcIixTZS5uYW1lXTtjYXNlXCJTcHJlYWRFbGVtZW50XCI6Y2FzZVwiU3ByZWFkRWxlbWVudFBhdHRlcm5cIjpjYXNlXCJTcHJlYWRQcm9wZXJ0eVwiOmNhc2VcIlNwcmVhZFByb3BlcnR5UGF0dGVyblwiOmNhc2VcIlJlc3RFbGVtZW50XCI6cmV0dXJuIGVlKFRlLF9lLEZlKTtjYXNlXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6Y2FzZVwiRnVuY3Rpb25FeHByZXNzaW9uXCI6cmV0dXJuIHZlKFRlLEZlLF9lLEtlKTtjYXNlXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOnJldHVybiB4ZShUZSxfZSxGZSxLZSk7Y2FzZVwiWWllbGRFeHByZXNzaW9uXCI6cmV0dXJuIEJlLnB1c2goXCJ5aWVsZFwiKSxTZS5kZWxlZ2F0ZSYmQmUucHVzaChcIipcIiksU2UuYXJndW1lbnQmJkJlLnB1c2goXCIgXCIsRmUoXCJhcmd1bWVudFwiKSksQmU7Y2FzZVwiQXdhaXRFeHByZXNzaW9uXCI6e2lmKEJlLnB1c2goXCJhd2FpdFwiKSxTZS5hcmd1bWVudCl7QmUucHVzaChcIiBcIixGZShcImFyZ3VtZW50XCIpKTtsZXQgSWU9VGUuZ2V0UGFyZW50Tm9kZSgpO2lmKGQoSWUpJiZJZS5jYWxsZWU9PT1TZXx8eShJZSkmJkllLm9iamVjdD09PVNlKXtCZT1bbChbYSwuLi5CZV0pLGFdO2xldCBWZT1UZS5maW5kQW5jZXN0b3IoQWU9PkFlLnR5cGU9PT1cIkF3YWl0RXhwcmVzc2lvblwifHxBZS50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwiKTtpZighVmV8fFZlLnR5cGUhPT1cIkF3YWl0RXhwcmVzc2lvblwiKXJldHVybiBjKEJlKX19cmV0dXJuIEJlfWNhc2VcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiOmNhc2VcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIjpyZXR1cm4gc2UoVGUsX2UsRmUpO2Nhc2VcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCI6cmV0dXJuIFYoVGUsX2UsRmUpO2Nhc2VcIkltcG9ydERlY2xhcmF0aW9uXCI6cmV0dXJuIG5lKFRlLF9lLEZlKTtjYXNlXCJJbXBvcnRTcGVjaWZpZXJcIjpjYXNlXCJFeHBvcnRTcGVjaWZpZXJcIjpjYXNlXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIjpjYXNlXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIjpjYXNlXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCI6Y2FzZVwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiOnJldHVybiBvZShUZSxfZSxGZSk7Y2FzZVwiSW1wb3J0QXR0cmlidXRlXCI6cmV0dXJuW0ZlKFwia2V5XCIpLFwiOiBcIixGZShcInZhbHVlXCIpXTtjYXNlXCJJbXBvcnRcIjpyZXR1cm5cImltcG9ydFwiO2Nhc2VcIkJsb2NrU3RhdGVtZW50XCI6Y2FzZVwiU3RhdGljQmxvY2tcIjpjYXNlXCJDbGFzc0JvZHlcIjpyZXR1cm4gWShUZSxfZSxGZSk7Y2FzZVwiVGhyb3dTdGF0ZW1lbnRcIjpyZXR1cm4gcGUoVGUsX2UsRmUpO2Nhc2VcIlJldHVyblN0YXRlbWVudFwiOnJldHVybiBmZShUZSxfZSxGZSk7Y2FzZVwiTmV3RXhwcmVzc2lvblwiOmNhc2VcIkltcG9ydEV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6Y2FzZVwiQ2FsbEV4cHJlc3Npb25cIjpyZXR1cm4gbWUoVGUsX2UsRmUpO2Nhc2VcIk9iamVjdEV4cHJlc3Npb25cIjpjYXNlXCJPYmplY3RQYXR0ZXJuXCI6Y2FzZVwiUmVjb3JkRXhwcmVzc2lvblwiOnJldHVybiBsZShUZSxfZSxGZSk7Y2FzZVwiT2JqZWN0UHJvcGVydHlcIjpjYXNlXCJQcm9wZXJ0eVwiOnJldHVybiBTZS5tZXRob2R8fFNlLmtpbmQ9PT1cImdldFwifHxTZS5raW5kPT09XCJzZXRcIj93ZShUZSxfZSxGZSk6Z2UoVGUsX2UsRmUpO2Nhc2VcIk9iamVjdE1ldGhvZFwiOnJldHVybiB3ZShUZSxfZSxGZSk7Y2FzZVwiRGVjb3JhdG9yXCI6cmV0dXJuW1wiQFwiLEZlKFwiZXhwcmVzc2lvblwiKV07Y2FzZVwiQXJyYXlFeHByZXNzaW9uXCI6Y2FzZVwiQXJyYXlQYXR0ZXJuXCI6Y2FzZVwiVHVwbGVFeHByZXNzaW9uXCI6cmV0dXJuIHEoVGUsX2UsRmUpO2Nhc2VcIlNlcXVlbmNlRXhwcmVzc2lvblwiOntsZXQgSWU9VGUuZ2V0UGFyZW50Tm9kZSgwKTtpZihJZS50eXBlPT09XCJFeHByZXNzaW9uU3RhdGVtZW50XCJ8fEllLnR5cGU9PT1cIkZvclN0YXRlbWVudFwiKXtsZXQgVmU9W107cmV0dXJuIFRlLmVhY2goKEFlLE9lKT0+e09lPT09MD9WZS5wdXNoKEZlKCkpOlZlLnB1c2goXCIsXCIsbChbcixGZSgpXSkpfSxcImV4cHJlc3Npb25zXCIpLGMoVmUpfXJldHVybiBjKGkoW1wiLFwiLHJdLFRlLm1hcChGZSxcImV4cHJlc3Npb25zXCIpKSl9Y2FzZVwiVGhpc0V4cHJlc3Npb25cIjpyZXR1cm5cInRoaXNcIjtjYXNlXCJTdXBlclwiOnJldHVyblwic3VwZXJcIjtjYXNlXCJEaXJlY3RpdmVcIjpyZXR1cm5bRmUoXCJ2YWx1ZVwiKSx6ZV07Y2FzZVwiRGlyZWN0aXZlTGl0ZXJhbFwiOnJldHVybiBVZShTZSxfZSk7Y2FzZVwiVW5hcnlFeHByZXNzaW9uXCI6cmV0dXJuIEJlLnB1c2goU2Uub3BlcmF0b3IpLC9bYS16XSQvLnRlc3QoU2Uub3BlcmF0b3IpJiZCZS5wdXNoKFwiIFwiKSxBKFNlLmFyZ3VtZW50KT9CZS5wdXNoKGMoW1wiKFwiLGwoW2EsRmUoXCJhcmd1bWVudFwiKV0pLGEsXCIpXCJdKSk6QmUucHVzaChGZShcImFyZ3VtZW50XCIpKSxCZTtjYXNlXCJVcGRhdGVFeHByZXNzaW9uXCI6cmV0dXJuIEJlLnB1c2goRmUoXCJhcmd1bWVudFwiKSxTZS5vcGVyYXRvciksU2UucHJlZml4JiZCZS5yZXZlcnNlKCksQmU7Y2FzZVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6cmV0dXJuIEsoVGUsX2UsRmUpO2Nhc2VcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjp7bGV0IEllPVRlLm1hcChGZSxcImRlY2xhcmF0aW9uc1wiKSxWZT1UZS5nZXRQYXJlbnROb2RlKCksQWU9VmUudHlwZT09PVwiRm9yU3RhdGVtZW50XCJ8fFZlLnR5cGU9PT1cIkZvckluU3RhdGVtZW50XCJ8fFZlLnR5cGU9PT1cIkZvck9mU3RhdGVtZW50XCIsT2U9U2UuZGVjbGFyYXRpb25zLnNvbWUoaWU9PmllLmluaXQpLFBlO3JldHVybiBJZS5sZW5ndGg9PT0xJiYhQShTZS5kZWNsYXJhdGlvbnNbMF0pP1BlPUllWzBdOkllLmxlbmd0aD4wJiYoUGU9bChJZVswXSkpLEJlPVtTZS5kZWNsYXJlP1wiZGVjbGFyZSBcIjpcIlwiLFNlLmtpbmQsUGU/W1wiIFwiLFBlXTpcIlwiLGwoSWUuc2xpY2UoMSkubWFwKGllPT5bXCIsXCIsT2UmJiFBZT91OnIsaWVdKSldLEFlJiZWZS5ib2R5IT09U2V8fEJlLnB1c2goemUpLGMoQmUpfWNhc2VcIldpdGhTdGF0ZW1lbnRcIjpyZXR1cm4gYyhbXCJ3aXRoIChcIixGZShcIm9iamVjdFwiKSxcIilcIixXKFNlLmJvZHksRmUoXCJib2R5XCIpKV0pO2Nhc2VcIklmU3RhdGVtZW50XCI6e2xldCBJZT1XKFNlLmNvbnNlcXVlbnQsRmUoXCJjb25zZXF1ZW50XCIpKSxWZT1jKFtcImlmIChcIixjKFtsKFthLEZlKFwidGVzdFwiKV0pLGFdKSxcIilcIixJZV0pO2lmKEJlLnB1c2goVmUpLFNlLmFsdGVybmF0ZSl7bGV0IEFlPUEoU2UuY29uc2VxdWVudCxiLlRyYWlsaW5nfGIuTGluZSl8fEkoU2UpLE9lPVNlLmNvbnNlcXVlbnQudHlwZT09PVwiQmxvY2tTdGF0ZW1lbnRcIiYmIUFlO0JlLnB1c2goT2U/XCIgXCI6dSksQShTZSxiLkRhbmdsaW5nKSYmQmUucHVzaCh0KFRlLF9lLCEwKSxBZT91OlwiIFwiKSxCZS5wdXNoKFwiZWxzZVwiLGMoVyhTZS5hbHRlcm5hdGUsRmUoXCJhbHRlcm5hdGVcIiksU2UuYWx0ZXJuYXRlLnR5cGU9PT1cIklmU3RhdGVtZW50XCIpKSl9cmV0dXJuIEJlfWNhc2VcIkZvclN0YXRlbWVudFwiOntsZXQgSWU9VyhTZS5ib2R5LEZlKFwiYm9keVwiKSksVmU9dChUZSxfZSwhMCksQWU9VmU/W1ZlLGFdOlwiXCI7cmV0dXJuIVNlLmluaXQmJiFTZS50ZXN0JiYhU2UudXBkYXRlP1tBZSxjKFtcImZvciAoOzspXCIsSWVdKV06W0FlLGMoW1wiZm9yIChcIixjKFtsKFthLEZlKFwiaW5pdFwiKSxcIjtcIixyLEZlKFwidGVzdFwiKSxcIjtcIixyLEZlKFwidXBkYXRlXCIpXSksYV0pLFwiKVwiLEllXSldfWNhc2VcIldoaWxlU3RhdGVtZW50XCI6cmV0dXJuIGMoW1wid2hpbGUgKFwiLGMoW2woW2EsRmUoXCJ0ZXN0XCIpXSksYV0pLFwiKVwiLFcoU2UuYm9keSxGZShcImJvZHlcIikpXSk7Y2FzZVwiRm9ySW5TdGF0ZW1lbnRcIjpyZXR1cm4gYyhbXCJmb3IgKFwiLEZlKFwibGVmdFwiKSxcIiBpbiBcIixGZShcInJpZ2h0XCIpLFwiKVwiLFcoU2UuYm9keSxGZShcImJvZHlcIikpXSk7Y2FzZVwiRm9yT2ZTdGF0ZW1lbnRcIjpyZXR1cm4gYyhbXCJmb3JcIixTZS5hd2FpdD9cIiBhd2FpdFwiOlwiXCIsXCIgKFwiLEZlKFwibGVmdFwiKSxcIiBvZiBcIixGZShcInJpZ2h0XCIpLFwiKVwiLFcoU2UuYm9keSxGZShcImJvZHlcIikpXSk7Y2FzZVwiRG9XaGlsZVN0YXRlbWVudFwiOntsZXQgSWU9VyhTZS5ib2R5LEZlKFwiYm9keVwiKSk7cmV0dXJuIEJlPVtjKFtcImRvXCIsSWVdKV0sU2UuYm9keS50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwiP0JlLnB1c2goXCIgXCIpOkJlLnB1c2godSksQmUucHVzaChcIndoaWxlIChcIixjKFtsKFthLEZlKFwidGVzdFwiKV0pLGFdKSxcIilcIix6ZSksQmV9Y2FzZVwiRG9FeHByZXNzaW9uXCI6cmV0dXJuW1NlLmFzeW5jP1wiYXN5bmMgXCI6XCJcIixcImRvIFwiLEZlKFwiYm9keVwiKV07Y2FzZVwiQnJlYWtTdGF0ZW1lbnRcIjpyZXR1cm4gQmUucHVzaChcImJyZWFrXCIpLFNlLmxhYmVsJiZCZS5wdXNoKFwiIFwiLEZlKFwibGFiZWxcIikpLEJlLnB1c2goemUpLEJlO2Nhc2VcIkNvbnRpbnVlU3RhdGVtZW50XCI6cmV0dXJuIEJlLnB1c2goXCJjb250aW51ZVwiKSxTZS5sYWJlbCYmQmUucHVzaChcIiBcIixGZShcImxhYmVsXCIpKSxCZS5wdXNoKHplKSxCZTtjYXNlXCJMYWJlbGVkU3RhdGVtZW50XCI6cmV0dXJuIFNlLmJvZHkudHlwZT09PVwiRW1wdHlTdGF0ZW1lbnRcIj9bRmUoXCJsYWJlbFwiKSxcIjo7XCJdOltGZShcImxhYmVsXCIpLFwiOiBcIixGZShcImJvZHlcIildO2Nhc2VcIlRyeVN0YXRlbWVudFwiOnJldHVybltcInRyeSBcIixGZShcImJsb2NrXCIpLFNlLmhhbmRsZXI/W1wiIFwiLEZlKFwiaGFuZGxlclwiKV06XCJcIixTZS5maW5hbGl6ZXI/W1wiIGZpbmFsbHkgXCIsRmUoXCJmaW5hbGl6ZXJcIildOlwiXCJdO2Nhc2VcIkNhdGNoQ2xhdXNlXCI6aWYoU2UucGFyYW0pe2xldCBJZT1BKFNlLnBhcmFtLEFlPT4hUyhBZSl8fEFlLmxlYWRpbmcmJnMoX2Uub3JpZ2luYWxUZXh0LEYoQWUpKXx8QWUudHJhaWxpbmcmJnMoX2Uub3JpZ2luYWxUZXh0LHgoQWUpLHtiYWNrd2FyZHM6ITB9KSksVmU9RmUoXCJwYXJhbVwiKTtyZXR1cm5bXCJjYXRjaCBcIixJZT9bXCIoXCIsbChbYSxWZV0pLGEsXCIpIFwiXTpbXCIoXCIsVmUsXCIpIFwiXSxGZShcImJvZHlcIildfXJldHVybltcImNhdGNoIFwiLEZlKFwiYm9keVwiKV07Y2FzZVwiU3dpdGNoU3RhdGVtZW50XCI6cmV0dXJuW2MoW1wic3dpdGNoIChcIixsKFthLEZlKFwiZGlzY3JpbWluYW50XCIpXSksYSxcIilcIl0pLFwiIHtcIixTZS5jYXNlcy5sZW5ndGg+MD9sKFt1LGkodSxUZS5tYXAoKEllLFZlLEFlKT0+e2xldCBPZT1JZS5nZXRWYWx1ZSgpO3JldHVybltGZSgpLFZlIT09QWUubGVuZ3RoLTEmJncoT2UsX2UpP3U6XCJcIl19LFwiY2FzZXNcIikpXSk6XCJcIix1LFwifVwiXTtjYXNlXCJTd2l0Y2hDYXNlXCI6e1NlLnRlc3Q/QmUucHVzaChcImNhc2UgXCIsRmUoXCJ0ZXN0XCIpLFwiOlwiKTpCZS5wdXNoKFwiZGVmYXVsdDpcIiksQShTZSxiLkRhbmdsaW5nKSYmQmUucHVzaChcIiBcIix0KFRlLF9lLCEwKSk7bGV0IEllPVNlLmNvbnNlcXVlbnQuZmlsdGVyKFZlPT5WZS50eXBlIT09XCJFbXB0eVN0YXRlbWVudFwiKTtpZihJZS5sZW5ndGg+MCl7bGV0IFZlPXllKFRlLF9lLEZlKTtCZS5wdXNoKEllLmxlbmd0aD09PTEmJkllWzBdLnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCI/W1wiIFwiLFZlXTpsKFt1LFZlXSkpfXJldHVybiBCZX1jYXNlXCJEZWJ1Z2dlclN0YXRlbWVudFwiOnJldHVybltcImRlYnVnZ2VyXCIsemVdO2Nhc2VcIkNsYXNzRGVjbGFyYXRpb25cIjpjYXNlXCJDbGFzc0V4cHJlc3Npb25cIjpyZXR1cm4gdWUoVGUsX2UsRmUpO2Nhc2VcIkNsYXNzTWV0aG9kXCI6Y2FzZVwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6Y2FzZVwiTWV0aG9kRGVmaW5pdGlvblwiOnJldHVybiBRKFRlLF9lLEZlKTtjYXNlXCJDbGFzc1Byb3BlcnR5XCI6Y2FzZVwiUHJvcGVydHlEZWZpbml0aW9uXCI6Y2FzZVwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIjpjYXNlXCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIjpyZXR1cm4gZGUoVGUsX2UsRmUpO2Nhc2VcIlRlbXBsYXRlRWxlbWVudFwiOnJldHVybiBDKFNlLnZhbHVlLnJhdyk7Y2FzZVwiVGVtcGxhdGVMaXRlcmFsXCI6cmV0dXJuIEVlKFRlLEZlLF9lKTtjYXNlXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpyZXR1cm5bRmUoXCJ0YWdcIiksRmUoXCJ0eXBlUGFyYW1ldGVyc1wiKSxGZShcInF1YXNpXCIpXTtjYXNlXCJQcml2YXRlSWRlbnRpZmllclwiOnJldHVybltcIiNcIixGZShcIm5hbWVcIildO2Nhc2VcIlByaXZhdGVOYW1lXCI6cmV0dXJuW1wiI1wiLEZlKFwiaWRcIildO2Nhc2VcIkludGVycHJldGVyRGlyZWN0aXZlXCI6cmV0dXJuIEJlLnB1c2goXCIjIVwiLFNlLnZhbHVlLHUpLHcoU2UsX2UpJiZCZS5wdXNoKHUpLEJlO2Nhc2VcIlRvcGljUmVmZXJlbmNlXCI6cmV0dXJuXCIlXCI7Y2FzZVwiQXJndW1lbnRQbGFjZWhvbGRlclwiOnJldHVyblwiP1wiO2Nhc2VcIk1vZHVsZUV4cHJlc3Npb25cIjp7QmUucHVzaChcIm1vZHVsZSB7XCIpO2xldCBJZT1GZShcImJvZHlcIik7cmV0dXJuIEllJiZCZS5wdXNoKGwoW3UsSWVdKSx1KSxCZS5wdXNoKFwifVwiKSxCZX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIrSlNPTi5zdHJpbmdpZnkoU2UudHlwZSkpfX1mdW5jdGlvbiBVZShUZSxfZSl7bGV0IEZlPUUoVGUpLEtlPUZlLnNsaWNlKDEsLTEpO2lmKEtlLmluY2x1ZGVzKCdcIicpfHxLZS5pbmNsdWRlcyhcIidcIikpcmV0dXJuIEZlO2xldCBTZT1fZS5zaW5nbGVRdW90ZT9cIidcIjonXCInO3JldHVybiBTZStLZStTZX1mdW5jdGlvbiB0dChUZSl7cmV0dXJuIFRlLnR5cGUmJiFTKFRlKSYmIUIoVGUpJiZUZS50eXBlIT09XCJFbXB0eVN0YXRlbWVudFwiJiZUZS50eXBlIT09XCJUZW1wbGF0ZUVsZW1lbnRcIiYmVGUudHlwZSE9PVwiSW1wb3J0XCImJlRlLnR5cGUhPT1cIlRTRW1wdHlCb2R5RnVuY3Rpb25FeHByZXNzaW9uXCJ9bi5leHBvcnRzPXtwcmVwcm9jZXNzOk4scHJpbnQ6TmUsZW1iZWQ6bSxpbnNlcnRQcmFnbWE6cCxtYXNzYWdlQXN0Tm9kZTpnLGhhc1ByZXR0aWVySWdub3JlKFRlKXtyZXR1cm4gRChUZSl8fE0oVGUpfSx3aWxsUHJpbnRPd25Db21tZW50czpmLndpbGxQcmludE93bkNvbW1lbnRzLGNhbkF0dGFjaENvbW1lbnQ6dHQscHJpbnRDb21tZW50OnosaXNCbG9ja0NvbW1lbnQ6UyxoYW5kbGVDb21tZW50czp7YXZvaWRBc3RNdXRhdGlvbjohMCxvd25MaW5lOmYuaGFuZGxlT3duTGluZUNvbW1lbnQsZW5kT2ZMaW5lOmYuaGFuZGxlRW5kT2ZMaW5lQ29tbWVudCxyZW1haW5pbmc6Zi5oYW5kbGVSZW1haW5pbmdDb21tZW50fSxnZXRDb21tZW50Q2hpbGROb2RlczpmLmdldENvbW1lbnRDaGlsZE5vZGVzfX19KSxPbT1aKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludGVyLWVzdHJlZS1qc29uLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntidWlsZGVyczp7aGFyZGxpbmU6dCxpbmRlbnQ6cyxqb2luOml9fT1MZSgpLHI9cm8oKTtmdW5jdGlvbiB1KGwsQyxtKXtsZXQgZz1sLmdldFZhbHVlKCk7c3dpdGNoKGcudHlwZSl7Y2FzZVwiSnNvblJvb3RcIjpyZXR1cm5bbShcIm5vZGVcIiksdF07Y2FzZVwiQXJyYXlFeHByZXNzaW9uXCI6e2lmKGcuZWxlbWVudHMubGVuZ3RoPT09MClyZXR1cm5cIltdXCI7bGV0IHA9bC5tYXAoKCk9PmwuZ2V0VmFsdWUoKT09PW51bGw/XCJudWxsXCI6bSgpLFwiZWxlbWVudHNcIik7cmV0dXJuW1wiW1wiLHMoW3QsaShbXCIsXCIsdF0scCldKSx0LFwiXVwiXX1jYXNlXCJPYmplY3RFeHByZXNzaW9uXCI6cmV0dXJuIGcucHJvcGVydGllcy5sZW5ndGg9PT0wP1wie31cIjpbXCJ7XCIscyhbdCxpKFtcIixcIix0XSxsLm1hcChtLFwicHJvcGVydGllc1wiKSldKSx0LFwifVwiXTtjYXNlXCJPYmplY3RQcm9wZXJ0eVwiOnJldHVyblttKFwia2V5XCIpLFwiOiBcIixtKFwidmFsdWVcIildO2Nhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOnJldHVybltnLm9wZXJhdG9yPT09XCIrXCI/XCJcIjpnLm9wZXJhdG9yLG0oXCJhcmd1bWVudFwiKV07Y2FzZVwiTnVsbExpdGVyYWxcIjpyZXR1cm5cIm51bGxcIjtjYXNlXCJCb29sZWFuTGl0ZXJhbFwiOnJldHVybiBnLnZhbHVlP1widHJ1ZVwiOlwiZmFsc2VcIjtjYXNlXCJTdHJpbmdMaXRlcmFsXCI6Y2FzZVwiTnVtZXJpY0xpdGVyYWxcIjpyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZy52YWx1ZSk7Y2FzZVwiSWRlbnRpZmllclwiOntsZXQgcD1sLmdldFBhcmVudE5vZGUoKTtyZXR1cm4gcCYmcC50eXBlPT09XCJPYmplY3RQcm9wZXJ0eVwiJiZwLmtleT09PWc/SlNPTi5zdHJpbmdpZnkoZy5uYW1lKTpnLm5hbWV9Y2FzZVwiVGVtcGxhdGVMaXRlcmFsXCI6cmV0dXJuIG0oW1wicXVhc2lzXCIsMF0pO2Nhc2VcIlRlbXBsYXRlRWxlbWVudFwiOnJldHVybiBKU09OLnN0cmluZ2lmeShnLnZhbHVlLmNvb2tlZCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiK0pTT04uc3RyaW5naWZ5KGcudHlwZSkpfX12YXIgYT1uZXcgU2V0KFtcInN0YXJ0XCIsXCJlbmRcIixcImV4dHJhXCIsXCJsb2NcIixcImNvbW1lbnRzXCIsXCJsZWFkaW5nQ29tbWVudHNcIixcInRyYWlsaW5nQ29tbWVudHNcIixcImlubmVyQ29tbWVudHNcIixcImVycm9yc1wiLFwicmFuZ2VcIixcInRva2Vuc1wiXSk7ZnVuY3Rpb24gYyhsLEMpe2xldHt0eXBlOm19PWw7aWYobT09PVwiT2JqZWN0UHJvcGVydHlcIiYmbC5rZXkudHlwZT09PVwiSWRlbnRpZmllclwiKXtDLmtleT17dHlwZTpcIlN0cmluZ0xpdGVyYWxcIix2YWx1ZTpsLmtleS5uYW1lfTtyZXR1cm59aWYobT09PVwiVW5hcnlFeHByZXNzaW9uXCImJmwub3BlcmF0b3I9PT1cIitcIilyZXR1cm4gQy5hcmd1bWVudDtpZihtPT09XCJBcnJheUV4cHJlc3Npb25cIil7Zm9yKGxldFtnLHBdb2YgbC5lbGVtZW50cy5lbnRyaWVzKCkpcD09PW51bGwmJkMuZWxlbWVudHMuc3BsaWNlKGcsMCx7dHlwZTpcIk51bGxMaXRlcmFsXCJ9KTtyZXR1cm59aWYobT09PVwiVGVtcGxhdGVMaXRlcmFsXCIpcmV0dXJue3R5cGU6XCJTdHJpbmdMaXRlcmFsXCIsdmFsdWU6bC5xdWFzaXNbMF0udmFsdWUuY29va2VkfX1jLmlnbm9yZWRQcm9wZXJ0aWVzPWEsbi5leHBvcnRzPXtwcmVwcm9jZXNzOnIscHJpbnQ6dSxtYXNzYWdlQXN0Tm9kZTpjfX19KSxMdD1aKHtcInNyYy9jb21tb24vY29tbW9uLW9wdGlvbnMuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9XCJDb21tb25cIjtuLmV4cG9ydHM9e2JyYWNrZXRTcGFjaW5nOntzaW5jZTpcIjAuMC4wXCIsY2F0ZWdvcnk6dCx0eXBlOlwiYm9vbGVhblwiLGRlZmF1bHQ6ITAsZGVzY3JpcHRpb246XCJQcmludCBzcGFjZXMgYmV0d2VlbiBicmFja2V0cy5cIixvcHBvc2l0ZURlc2NyaXB0aW9uOlwiRG8gbm90IHByaW50IHNwYWNlcyBiZXR3ZWVuIGJyYWNrZXRzLlwifSxzaW5nbGVRdW90ZTp7c2luY2U6XCIwLjAuMFwiLGNhdGVnb3J5OnQsdHlwZTpcImJvb2xlYW5cIixkZWZhdWx0OiExLGRlc2NyaXB0aW9uOlwiVXNlIHNpbmdsZSBxdW90ZXMgaW5zdGVhZCBvZiBkb3VibGUgcXVvdGVzLlwifSxwcm9zZVdyYXA6e3NpbmNlOlwiMS44LjJcIixjYXRlZ29yeTp0LHR5cGU6XCJjaG9pY2VcIixkZWZhdWx0Olt7c2luY2U6XCIxLjguMlwiLHZhbHVlOiEwfSx7c2luY2U6XCIxLjkuMFwiLHZhbHVlOlwicHJlc2VydmVcIn1dLGRlc2NyaXB0aW9uOlwiSG93IHRvIHdyYXAgcHJvc2UuXCIsY2hvaWNlczpbe3NpbmNlOlwiMS45LjBcIix2YWx1ZTpcImFsd2F5c1wiLGRlc2NyaXB0aW9uOlwiV3JhcCBwcm9zZSBpZiBpdCBleGNlZWRzIHRoZSBwcmludCB3aWR0aC5cIn0se3NpbmNlOlwiMS45LjBcIix2YWx1ZTpcIm5ldmVyXCIsZGVzY3JpcHRpb246XCJEbyBub3Qgd3JhcCBwcm9zZS5cIn0se3NpbmNlOlwiMS45LjBcIix2YWx1ZTpcInByZXNlcnZlXCIsZGVzY3JpcHRpb246XCJXcmFwIHByb3NlIGFzLWlzLlwifV19LGJyYWNrZXRTYW1lTGluZTp7c2luY2U6XCIyLjQuMFwiLGNhdGVnb3J5OnQsdHlwZTpcImJvb2xlYW5cIixkZWZhdWx0OiExLGRlc2NyaXB0aW9uOlwiUHV0ID4gb2Ygb3BlbmluZyB0YWdzIG9uIHRoZSBsYXN0IGxpbmUgaW5zdGVhZCBvZiBvbiBhIG5ldyBsaW5lLlwifSxzaW5nbGVBdHRyaWJ1dGVQZXJMaW5lOntzaW5jZTpcIjIuNi4wXCIsY2F0ZWdvcnk6dCx0eXBlOlwiYm9vbGVhblwiLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJFbmZvcmNlIHNpbmdsZSBhdHRyaWJ1dGUgcGVyIGxpbmUgaW4gSFRNTCwgVnVlIGFuZCBKU1guXCJ9fX19KSxqbT1aKHtcInNyYy9sYW5ndWFnZS1qcy9vcHRpb25zLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PUx0KCkscz1cIkphdmFTY3JpcHRcIjtuLmV4cG9ydHM9e2Fycm93UGFyZW5zOntzaW5jZTpcIjEuOS4wXCIsY2F0ZWdvcnk6cyx0eXBlOlwiY2hvaWNlXCIsZGVmYXVsdDpbe3NpbmNlOlwiMS45LjBcIix2YWx1ZTpcImF2b2lkXCJ9LHtzaW5jZTpcIjIuMC4wXCIsdmFsdWU6XCJhbHdheXNcIn1dLGRlc2NyaXB0aW9uOlwiSW5jbHVkZSBwYXJlbnRoZXNlcyBhcm91bmQgYSBzb2xlIGFycm93IGZ1bmN0aW9uIHBhcmFtZXRlci5cIixjaG9pY2VzOlt7dmFsdWU6XCJhbHdheXNcIixkZXNjcmlwdGlvbjpcIkFsd2F5cyBpbmNsdWRlIHBhcmVucy4gRXhhbXBsZTogYCh4KSA9PiB4YFwifSx7dmFsdWU6XCJhdm9pZFwiLGRlc2NyaXB0aW9uOlwiT21pdCBwYXJlbnMgd2hlbiBwb3NzaWJsZS4gRXhhbXBsZTogYHggPT4geGBcIn1dfSxicmFja2V0U2FtZUxpbmU6dC5icmFja2V0U2FtZUxpbmUsYnJhY2tldFNwYWNpbmc6dC5icmFja2V0U3BhY2luZyxqc3hCcmFja2V0U2FtZUxpbmU6e3NpbmNlOlwiMC4xNy4wXCIsY2F0ZWdvcnk6cyx0eXBlOlwiYm9vbGVhblwiLGRlc2NyaXB0aW9uOlwiUHV0ID4gb24gdGhlIGxhc3QgbGluZSBpbnN0ZWFkIG9mIGF0IGEgbmV3IGxpbmUuXCIsZGVwcmVjYXRlZDpcIjIuNC4wXCJ9LHNlbWk6e3NpbmNlOlwiMS4wLjBcIixjYXRlZ29yeTpzLHR5cGU6XCJib29sZWFuXCIsZGVmYXVsdDohMCxkZXNjcmlwdGlvbjpcIlByaW50IHNlbWljb2xvbnMuXCIsb3Bwb3NpdGVEZXNjcmlwdGlvbjpcIkRvIG5vdCBwcmludCBzZW1pY29sb25zLCBleGNlcHQgYXQgdGhlIGJlZ2lubmluZyBvZiBsaW5lcyB3aGljaCBtYXkgbmVlZCB0aGVtLlwifSxzaW5nbGVRdW90ZTp0LnNpbmdsZVF1b3RlLGpzeFNpbmdsZVF1b3RlOntzaW5jZTpcIjEuMTUuMFwiLGNhdGVnb3J5OnMsdHlwZTpcImJvb2xlYW5cIixkZWZhdWx0OiExLGRlc2NyaXB0aW9uOlwiVXNlIHNpbmdsZSBxdW90ZXMgaW4gSlNYLlwifSxxdW90ZVByb3BzOntzaW5jZTpcIjEuMTcuMFwiLGNhdGVnb3J5OnMsdHlwZTpcImNob2ljZVwiLGRlZmF1bHQ6XCJhcy1uZWVkZWRcIixkZXNjcmlwdGlvbjpcIkNoYW5nZSB3aGVuIHByb3BlcnRpZXMgaW4gb2JqZWN0cyBhcmUgcXVvdGVkLlwiLGNob2ljZXM6W3t2YWx1ZTpcImFzLW5lZWRlZFwiLGRlc2NyaXB0aW9uOlwiT25seSBhZGQgcXVvdGVzIGFyb3VuZCBvYmplY3QgcHJvcGVydGllcyB3aGVyZSByZXF1aXJlZC5cIn0se3ZhbHVlOlwiY29uc2lzdGVudFwiLGRlc2NyaXB0aW9uOlwiSWYgYXQgbGVhc3Qgb25lIHByb3BlcnR5IGluIGFuIG9iamVjdCByZXF1aXJlcyBxdW90ZXMsIHF1b3RlIGFsbCBwcm9wZXJ0aWVzLlwifSx7dmFsdWU6XCJwcmVzZXJ2ZVwiLGRlc2NyaXB0aW9uOlwiUmVzcGVjdCB0aGUgaW5wdXQgdXNlIG9mIHF1b3RlcyBpbiBvYmplY3QgcHJvcGVydGllcy5cIn1dfSx0cmFpbGluZ0NvbW1hOntzaW5jZTpcIjAuMC4wXCIsY2F0ZWdvcnk6cyx0eXBlOlwiY2hvaWNlXCIsZGVmYXVsdDpbe3NpbmNlOlwiMC4wLjBcIix2YWx1ZTohMX0se3NpbmNlOlwiMC4xOS4wXCIsdmFsdWU6XCJub25lXCJ9LHtzaW5jZTpcIjIuMC4wXCIsdmFsdWU6XCJlczVcIn1dLGRlc2NyaXB0aW9uOlwiUHJpbnQgdHJhaWxpbmcgY29tbWFzIHdoZXJldmVyIHBvc3NpYmxlIHdoZW4gbXVsdGktbGluZS5cIixjaG9pY2VzOlt7dmFsdWU6XCJlczVcIixkZXNjcmlwdGlvbjpcIlRyYWlsaW5nIGNvbW1hcyB3aGVyZSB2YWxpZCBpbiBFUzUgKG9iamVjdHMsIGFycmF5cywgZXRjLilcIn0se3ZhbHVlOlwibm9uZVwiLGRlc2NyaXB0aW9uOlwiTm8gdHJhaWxpbmcgY29tbWFzLlwifSx7dmFsdWU6XCJhbGxcIixkZXNjcmlwdGlvbjpcIlRyYWlsaW5nIGNvbW1hcyB3aGVyZXZlciBwb3NzaWJsZSAoaW5jbHVkaW5nIGZ1bmN0aW9uIGFyZ3VtZW50cykuXCJ9XX0sc2luZ2xlQXR0cmlidXRlUGVyTGluZTp0LnNpbmdsZUF0dHJpYnV0ZVBlckxpbmV9fX0pLHFtPVooe1wic3JjL2xhbmd1YWdlLWpzL3BhcnNlL3BhcnNlcnMuanNcIigpe2FlKCl9fSksRm49Wih7XCJub2RlX21vZHVsZXMvbGluZ3Vpc3QtbGFuZ3VhZ2VzL2RhdGEvSmF2YVNjcmlwdC5qc29uXCIoZSxuKXtuLmV4cG9ydHM9e25hbWU6XCJKYXZhU2NyaXB0XCIsdHlwZTpcInByb2dyYW1taW5nXCIsdG1TY29wZTpcInNvdXJjZS5qc1wiLGFjZU1vZGU6XCJqYXZhc2NyaXB0XCIsY29kZW1pcnJvck1vZGU6XCJqYXZhc2NyaXB0XCIsY29kZW1pcnJvck1pbWVUeXBlOlwidGV4dC9qYXZhc2NyaXB0XCIsY29sb3I6XCIjZjFlMDVhXCIsYWxpYXNlczpbXCJqc1wiLFwibm9kZVwiXSxleHRlbnNpb25zOltcIi5qc1wiLFwiLl9qc1wiLFwiLmJvbmVzXCIsXCIuY2pzXCIsXCIuZXNcIixcIi5lczZcIixcIi5mcmFnXCIsXCIuZ3NcIixcIi5qYWtlXCIsXCIuanNiXCIsXCIuanNjYWRcIixcIi5qc2ZsXCIsXCIuanNtXCIsXCIuanNzXCIsXCIuanN4XCIsXCIubWpzXCIsXCIubmpzXCIsXCIucGFjXCIsXCIuc2pzXCIsXCIuc3Nqc1wiLFwiLnhzanNcIixcIi54c2pzbGliXCJdLGZpbGVuYW1lczpbXCJKYWtlZmlsZVwiXSxpbnRlcnByZXRlcnM6W1wiY2hha3JhXCIsXCJkOFwiLFwiZ2pzXCIsXCJqc1wiLFwibm9kZVwiLFwibm9kZWpzXCIsXCJxanNcIixcInJoaW5vXCIsXCJ2OFwiLFwidjgtc2hlbGxcIl0sbGFuZ3VhZ2VJZDoxODN9fX0pLE1tPVooe1wibm9kZV9tb2R1bGVzL2xpbmd1aXN0LWxhbmd1YWdlcy9kYXRhL1R5cGVTY3JpcHQuanNvblwiKGUsbil7bi5leHBvcnRzPXtuYW1lOlwiVHlwZVNjcmlwdFwiLHR5cGU6XCJwcm9ncmFtbWluZ1wiLGNvbG9yOlwiIzJiNzQ4OVwiLGFsaWFzZXM6W1widHNcIl0saW50ZXJwcmV0ZXJzOltcImRlbm9cIixcInRzLW5vZGVcIl0sZXh0ZW5zaW9uczpbXCIudHNcIl0sdG1TY29wZTpcInNvdXJjZS50c1wiLGFjZU1vZGU6XCJ0eXBlc2NyaXB0XCIsY29kZW1pcnJvck1vZGU6XCJqYXZhc2NyaXB0XCIsY29kZW1pcnJvck1pbWVUeXBlOlwiYXBwbGljYXRpb24vdHlwZXNjcmlwdFwiLGxhbmd1YWdlSWQ6Mzc4fX19KSxSbT1aKHtcIm5vZGVfbW9kdWxlcy9saW5ndWlzdC1sYW5ndWFnZXMvZGF0YS9UU1guanNvblwiKGUsbil7bi5leHBvcnRzPXtuYW1lOlwiVFNYXCIsdHlwZTpcInByb2dyYW1taW5nXCIsZ3JvdXA6XCJUeXBlU2NyaXB0XCIsZXh0ZW5zaW9uczpbXCIudHN4XCJdLHRtU2NvcGU6XCJzb3VyY2UudHN4XCIsYWNlTW9kZTpcImphdmFzY3JpcHRcIixjb2RlbWlycm9yTW9kZTpcImpzeFwiLGNvZGVtaXJyb3JNaW1lVHlwZTpcInRleHQvanN4XCIsbGFuZ3VhZ2VJZDo5NDkwMTkyNH19fSksbWk9Wih7XCJub2RlX21vZHVsZXMvbGluZ3Vpc3QtbGFuZ3VhZ2VzL2RhdGEvSlNPTi5qc29uXCIoZSxuKXtuLmV4cG9ydHM9e25hbWU6XCJKU09OXCIsdHlwZTpcImRhdGFcIix0bVNjb3BlOlwic291cmNlLmpzb25cIixhY2VNb2RlOlwianNvblwiLGNvZGVtaXJyb3JNb2RlOlwiamF2YXNjcmlwdFwiLGNvZGVtaXJyb3JNaW1lVHlwZTpcImFwcGxpY2F0aW9uL2pzb25cIixleHRlbnNpb25zOltcIi5qc29uXCIsXCIuYXZzY1wiLFwiLmdlb2pzb25cIixcIi5nbHRmXCIsXCIuaGFyXCIsXCIuaWNlXCIsXCIuSlNPTi10bUxhbmd1YWdlXCIsXCIuanNvbmxcIixcIi5tY21ldGFcIixcIi50ZnN0YXRlXCIsXCIudGZzdGF0ZS5iYWNrdXBcIixcIi50b3BvanNvblwiLFwiLndlYmFwcFwiLFwiLndlYm1hbmlmZXN0XCIsXCIueXlcIixcIi55eXBcIl0sZmlsZW5hbWVzOltcIi5hcmNjb25maWdcIixcIi5odG1saGludHJjXCIsXCIuaW1nYm90Y29uZmlnXCIsXCIudGVybi1jb25maWdcIixcIi50ZXJuLXByb2plY3RcIixcIi53YXRjaG1hbmNvbmZpZ1wiLFwiUGlwZmlsZS5sb2NrXCIsXCJjb21wb3Nlci5sb2NrXCIsXCJtY21vZC5pbmZvXCJdLGxhbmd1YWdlSWQ6MTc0fX19KSxWbT1aKHtcIm5vZGVfbW9kdWxlcy9saW5ndWlzdC1sYW5ndWFnZXMvZGF0YS9KU09OIHdpdGggQ29tbWVudHMuanNvblwiKGUsbil7bi5leHBvcnRzPXtuYW1lOlwiSlNPTiB3aXRoIENvbW1lbnRzXCIsdHlwZTpcImRhdGFcIixncm91cDpcIkpTT05cIix0bVNjb3BlOlwic291cmNlLmpzXCIsYWNlTW9kZTpcImphdmFzY3JpcHRcIixjb2RlbWlycm9yTW9kZTpcImphdmFzY3JpcHRcIixjb2RlbWlycm9yTWltZVR5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIixhbGlhc2VzOltcImpzb25jXCJdLGV4dGVuc2lvbnM6W1wiLmpzb25jXCIsXCIuc3VibGltZS1idWlsZFwiLFwiLnN1YmxpbWUtY29tbWFuZHNcIixcIi5zdWJsaW1lLWNvbXBsZXRpb25zXCIsXCIuc3VibGltZS1rZXltYXBcIixcIi5zdWJsaW1lLW1hY3JvXCIsXCIuc3VibGltZS1tZW51XCIsXCIuc3VibGltZS1tb3VzZW1hcFwiLFwiLnN1YmxpbWUtcHJvamVjdFwiLFwiLnN1YmxpbWUtc2V0dGluZ3NcIixcIi5zdWJsaW1lLXRoZW1lXCIsXCIuc3VibGltZS13b3Jrc3BhY2VcIixcIi5zdWJsaW1lX21ldHJpY3NcIixcIi5zdWJsaW1lX3Nlc3Npb25cIl0sZmlsZW5hbWVzOltcIi5iYWJlbHJjXCIsXCIuZXNsaW50cmMuanNvblwiLFwiLmpzY3NyY1wiLFwiLmpzaGludHJjXCIsXCIuanNsaW50cmNcIixcImFwaS1leHRyYWN0b3IuanNvblwiLFwiZGV2Y29udGFpbmVyLmpzb25cIixcImpzY29uZmlnLmpzb25cIixcImxhbmd1YWdlLWNvbmZpZ3VyYXRpb24uanNvblwiLFwidHNjb25maWcuanNvblwiLFwidHNsaW50Lmpzb25cIl0sbGFuZ3VhZ2VJZDo0MjN9fX0pLFdtPVooe1wibm9kZV9tb2R1bGVzL2xpbmd1aXN0LWxhbmd1YWdlcy9kYXRhL0pTT041Lmpzb25cIihlLG4pe24uZXhwb3J0cz17bmFtZTpcIkpTT041XCIsdHlwZTpcImRhdGFcIixleHRlbnNpb25zOltcIi5qc29uNVwiXSx0bVNjb3BlOlwic291cmNlLmpzXCIsYWNlTW9kZTpcImphdmFzY3JpcHRcIixjb2RlbWlycm9yTW9kZTpcImphdmFzY3JpcHRcIixjb2RlbWlycm9yTWltZVR5cGU6XCJhcHBsaWNhdGlvbi9qc29uXCIsbGFuZ3VhZ2VJZDoxNzV9fX0pLCRtPVooe1wic3JjL2xhbmd1YWdlLWpzL2luZGV4LmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PWJ0KCkscz1MbSgpLGk9T20oKSxyPWptKCksdT1xbSgpLGE9W3QoRm4oKSxsPT4oe3NpbmNlOlwiMC4wLjBcIixwYXJzZXJzOltcImJhYmVsXCIsXCJhY29yblwiLFwiZXNwcmVlXCIsXCJtZXJpeWFoXCIsXCJiYWJlbC1mbG93XCIsXCJiYWJlbC10c1wiLFwiZmxvd1wiLFwidHlwZXNjcmlwdFwiXSx2c2NvZGVMYW5ndWFnZUlkczpbXCJqYXZhc2NyaXB0XCIsXCJtb25nb1wiXSxpbnRlcnByZXRlcnM6Wy4uLmwuaW50ZXJwcmV0ZXJzLFwienhcIl0sZXh0ZW5zaW9uczpbLi4ubC5leHRlbnNpb25zLmZpbHRlcihDPT5DIT09XCIuanN4XCIpLFwiLnd4c1wiXX0pKSx0KEZuKCksKCk9Pih7bmFtZTpcIkZsb3dcIixzaW5jZTpcIjAuMC4wXCIscGFyc2VyczpbXCJmbG93XCIsXCJiYWJlbC1mbG93XCJdLHZzY29kZUxhbmd1YWdlSWRzOltcImphdmFzY3JpcHRcIl0sYWxpYXNlczpbXSxmaWxlbmFtZXM6W10sZXh0ZW5zaW9uczpbXCIuanMuZmxvd1wiXX0pKSx0KEZuKCksKCk9Pih7bmFtZTpcIkpTWFwiLHNpbmNlOlwiMC4wLjBcIixwYXJzZXJzOltcImJhYmVsXCIsXCJiYWJlbC1mbG93XCIsXCJiYWJlbC10c1wiLFwiZmxvd1wiLFwidHlwZXNjcmlwdFwiLFwiZXNwcmVlXCIsXCJtZXJpeWFoXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcImphdmFzY3JpcHRyZWFjdFwiXSxhbGlhc2VzOnZvaWQgMCxmaWxlbmFtZXM6dm9pZCAwLGV4dGVuc2lvbnM6W1wiLmpzeFwiXSxncm91cDpcIkphdmFTY3JpcHRcIixpbnRlcnByZXRlcnM6dm9pZCAwLHRtU2NvcGU6XCJzb3VyY2UuanMuanN4XCIsYWNlTW9kZTpcImphdmFzY3JpcHRcIixjb2RlbWlycm9yTW9kZTpcImpzeFwiLGNvZGVtaXJyb3JNaW1lVHlwZTpcInRleHQvanN4XCIsY29sb3I6dm9pZCAwfSkpLHQoTW0oKSxsPT4oe3NpbmNlOlwiMS40LjBcIixwYXJzZXJzOltcInR5cGVzY3JpcHRcIixcImJhYmVsLXRzXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcInR5cGVzY3JpcHRcIl0sZXh0ZW5zaW9uczpbLi4ubC5leHRlbnNpb25zLFwiLm10c1wiLFwiLmN0c1wiXX0pKSx0KFJtKCksKCk9Pih7c2luY2U6XCIxLjQuMFwiLHBhcnNlcnM6W1widHlwZXNjcmlwdFwiLFwiYmFiZWwtdHNcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1widHlwZXNjcmlwdHJlYWN0XCJdfSkpLHQobWkoKSwoKT0+KHtuYW1lOlwiSlNPTi5zdHJpbmdpZnlcIixzaW5jZTpcIjEuMTMuMFwiLHBhcnNlcnM6W1wianNvbi1zdHJpbmdpZnlcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wianNvblwiXSxleHRlbnNpb25zOltdLGZpbGVuYW1lczpbXCJwYWNrYWdlLmpzb25cIixcInBhY2thZ2UtbG9jay5qc29uXCIsXCJjb21wb3Nlci5qc29uXCJdfSkpLHQobWkoKSxsPT4oe3NpbmNlOlwiMS41LjBcIixwYXJzZXJzOltcImpzb25cIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wianNvblwiXSxleHRlbnNpb25zOmwuZXh0ZW5zaW9ucy5maWx0ZXIoQz0+QyE9PVwiLmpzb25sXCIpfSkpLHQoVm0oKSxsPT4oe3NpbmNlOlwiMS41LjBcIixwYXJzZXJzOltcImpzb25cIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wianNvbmNcIl0sZmlsZW5hbWVzOlsuLi5sLmZpbGVuYW1lcyxcIi5lc2xpbnRyY1wiLFwiLnN3Y3JjXCJdfSkpLHQoV20oKSwoKT0+KHtzaW5jZTpcIjEuMTMuMFwiLHBhcnNlcnM6W1wianNvbjVcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wianNvbjVcIl19KSldLGM9e2VzdHJlZTpzLFwiZXN0cmVlLWpzb25cIjppfTtuLmV4cG9ydHM9e2xhbmd1YWdlczphLG9wdGlvbnM6cixwcmludGVyczpjLHBhcnNlcnM6dX19fSksSG09Wih7XCJzcmMvbGFuZ3VhZ2UtY3NzL2NsZWFuLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3Zhcntpc0Zyb250TWF0dGVyTm9kZTp0fT1HZSgpLHM9c3QoKSxpPW5ldyBTZXQoW1wicmF3XCIsXCJyYXdzXCIsXCJzb3VyY2VJbmRleFwiLFwic291cmNlXCIsXCJiZWZvcmVcIixcImFmdGVyXCIsXCJ0cmFpbGluZ0NvbW1hXCJdKTtmdW5jdGlvbiByKGEsYyxsKXtpZih0KGEpJiZhLmxhbmc9PT1cInlhbWxcIiYmZGVsZXRlIGMudmFsdWUsYS50eXBlPT09XCJjc3MtY29tbWVudFwiJiZsLnR5cGU9PT1cImNzcy1yb290XCImJmwubm9kZXMubGVuZ3RoPjAmJigobC5ub2Rlc1swXT09PWF8fHQobC5ub2Rlc1swXSkmJmwubm9kZXNbMV09PT1hKSYmKGRlbGV0ZSBjLnRleHQsL15cXCpcXHMqQCg/OmZvcm1hdHxwcmV0dGllcilcXHMqJC8udGVzdChhLnRleHQpKXx8bC50eXBlPT09XCJjc3Mtcm9vdFwiJiZzKGwubm9kZXMpPT09YSkpcmV0dXJuIG51bGw7aWYoYS50eXBlPT09XCJ2YWx1ZS1yb290XCImJmRlbGV0ZSBjLnRleHQsKGEudHlwZT09PVwibWVkaWEtcXVlcnlcInx8YS50eXBlPT09XCJtZWRpYS1xdWVyeS1saXN0XCJ8fGEudHlwZT09PVwibWVkaWEtZmVhdHVyZS1leHByZXNzaW9uXCIpJiZkZWxldGUgYy52YWx1ZSxhLnR5cGU9PT1cImNzcy1ydWxlXCImJmRlbGV0ZSBjLnBhcmFtcyxhLnR5cGU9PT1cInNlbGVjdG9yLWNvbWJpbmF0b3JcIiYmKGMudmFsdWU9Yy52YWx1ZS5yZXBsYWNlKC9cXHMrL2csXCIgXCIpKSxhLnR5cGU9PT1cIm1lZGlhLWZlYXR1cmVcIiYmKGMudmFsdWU9Yy52YWx1ZS5yZXBsYWNlKC8gL2csXCJcIikpLChhLnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmKGEuaXNDb2xvciYmYS5pc0hleHx8W1wiaW5pdGlhbFwiLFwiaW5oZXJpdFwiLFwidW5zZXRcIixcInJldmVydFwiXS5pbmNsdWRlcyhjLnZhbHVlLnJlcGxhY2UoKS50b0xvd2VyQ2FzZSgpKSl8fGEudHlwZT09PVwibWVkaWEtZmVhdHVyZVwifHxhLnR5cGU9PT1cInNlbGVjdG9yLXJvb3QtaW52YWxpZFwifHxhLnR5cGU9PT1cInNlbGVjdG9yLXBzZXVkb1wiKSYmKGMudmFsdWU9Yy52YWx1ZS50b0xvd2VyQ2FzZSgpKSxhLnR5cGU9PT1cImNzcy1kZWNsXCImJihjLnByb3A9Yy5wcm9wLnRvTG93ZXJDYXNlKCkpLChhLnR5cGU9PT1cImNzcy1hdHJ1bGVcInx8YS50eXBlPT09XCJjc3MtaW1wb3J0XCIpJiYoYy5uYW1lPWMubmFtZS50b0xvd2VyQ2FzZSgpKSxhLnR5cGU9PT1cInZhbHVlLW51bWJlclwiJiYoYy51bml0PWMudW5pdC50b0xvd2VyQ2FzZSgpKSwoYS50eXBlPT09XCJtZWRpYS1mZWF0dXJlXCJ8fGEudHlwZT09PVwibWVkaWEta2V5d29yZFwifHxhLnR5cGU9PT1cIm1lZGlhLXR5cGVcInx8YS50eXBlPT09XCJtZWRpYS11bmtub3duXCJ8fGEudHlwZT09PVwibWVkaWEtdXJsXCJ8fGEudHlwZT09PVwibWVkaWEtdmFsdWVcInx8YS50eXBlPT09XCJzZWxlY3Rvci1hdHRyaWJ1dGVcInx8YS50eXBlPT09XCJzZWxlY3Rvci1zdHJpbmdcInx8YS50eXBlPT09XCJzZWxlY3Rvci1jbGFzc1wifHxhLnR5cGU9PT1cInNlbGVjdG9yLWNvbWJpbmF0b3JcInx8YS50eXBlPT09XCJ2YWx1ZS1zdHJpbmdcIikmJmMudmFsdWUmJihjLnZhbHVlPXUoYy52YWx1ZSkpLGEudHlwZT09PVwic2VsZWN0b3ItYXR0cmlidXRlXCImJihjLmF0dHJpYnV0ZT1jLmF0dHJpYnV0ZS50cmltKCksYy5uYW1lc3BhY2UmJnR5cGVvZiBjLm5hbWVzcGFjZT09XCJzdHJpbmdcIiYmKGMubmFtZXNwYWNlPWMubmFtZXNwYWNlLnRyaW0oKSxjLm5hbWVzcGFjZS5sZW5ndGg9PT0wJiYoYy5uYW1lc3BhY2U9ITApKSxjLnZhbHVlJiYoYy52YWx1ZT1jLnZhbHVlLnRyaW0oKS5yZXBsYWNlKC9eW1wiJ118W1wiJ10kL2csXCJcIiksZGVsZXRlIGMucXVvdGVkKSksKGEudHlwZT09PVwibWVkaWEtdmFsdWVcInx8YS50eXBlPT09XCJtZWRpYS10eXBlXCJ8fGEudHlwZT09PVwidmFsdWUtbnVtYmVyXCJ8fGEudHlwZT09PVwic2VsZWN0b3Itcm9vdC1pbnZhbGlkXCJ8fGEudHlwZT09PVwic2VsZWN0b3ItY2xhc3NcInx8YS50eXBlPT09XCJzZWxlY3Rvci1jb21iaW5hdG9yXCJ8fGEudHlwZT09PVwic2VsZWN0b3ItdGFnXCIpJiZjLnZhbHVlJiYoYy52YWx1ZT1jLnZhbHVlLnJlcGxhY2UoLyhbXFxkKy5FZS1dKykoW0EtWmEtel0qKS9nLChDLG0sZyk9PntsZXQgcD1OdW1iZXIobSk7cmV0dXJuIE51bWJlci5pc05hTihwKT9DOnArZy50b0xvd2VyQ2FzZSgpfSkpLGEudHlwZT09PVwic2VsZWN0b3ItdGFnXCIpe2xldCBDPWEudmFsdWUudG9Mb3dlckNhc2UoKTtbXCJmcm9tXCIsXCJ0b1wiXS5pbmNsdWRlcyhDKSYmKGMudmFsdWU9Qyl9aWYoYS50eXBlPT09XCJjc3MtYXRydWxlXCImJmEubmFtZS50b0xvd2VyQ2FzZSgpPT09XCJzdXBwb3J0c1wiJiZkZWxldGUgYy52YWx1ZSxhLnR5cGU9PT1cInNlbGVjdG9yLXVua25vd25cIiYmZGVsZXRlIGMudmFsdWUsYS50eXBlPT09XCJ2YWx1ZS1jb21tYV9ncm91cFwiKXtsZXQgQz1hLmdyb3Vwcy5maW5kSW5kZXgobT0+bS50eXBlPT09XCJ2YWx1ZS1udW1iZXJcIiYmbS51bml0PT09XCIuLi5cIik7QyE9PS0xJiYoYy5ncm91cHNbQ10udW5pdD1cIlwiLGMuZ3JvdXBzLnNwbGljZShDKzEsMCx7dHlwZTpcInZhbHVlLXdvcmRcIix2YWx1ZTpcIi4uLlwiLGlzQ29sb3I6ITEsaXNIZXg6ITF9KSl9fXIuaWdub3JlZFByb3BlcnRpZXM9aTtmdW5jdGlvbiB1KGEpe3JldHVybiBhLnJlcGxhY2UoLycvZywnXCInKS5yZXBsYWNlKC9cXFxcKFteXFxkQS1GYS1mXSkvZyxcIiQxXCIpfW4uZXhwb3J0cz1yfX0pLFhuPVooe1wic3JjL3V0aWxzL2Zyb250LW1hdHRlci9wcmludC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7YnVpbGRlcnM6e2hhcmRsaW5lOnQsbWFya0FzUm9vdDpzfX09TGUoKTtmdW5jdGlvbiBpKHIsdSl7aWYoci5sYW5nPT09XCJ5YW1sXCIpe2xldCBhPXIudmFsdWUudHJpbSgpLGM9YT91KGEse3BhcnNlcjpcInlhbWxcIn0se3N0cmlwVHJhaWxpbmdIYXJkbGluZTohMH0pOlwiXCI7cmV0dXJuIHMoW3Iuc3RhcnREZWxpbWl0ZXIsdCxjLGM/dDpcIlwiLHIuZW5kRGVsaW1pdGVyXSl9fW4uZXhwb3J0cz1pfX0pLEdtPVooe1wic3JjL2xhbmd1YWdlLWNzcy9lbWJlZC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7YnVpbGRlcnM6e2hhcmRsaW5lOnR9fT1MZSgpLHM9WG4oKTtmdW5jdGlvbiBpKHIsdSxhKXtsZXQgYz1yLmdldFZhbHVlKCk7aWYoYy50eXBlPT09XCJmcm9udC1tYXR0ZXJcIil7bGV0IGw9cyhjLGEpO3JldHVybiBsP1tsLHRdOlwiXCJ9fW4uZXhwb3J0cz1pfX0pLHBvPVooe1wic3JjL3V0aWxzL2Zyb250LW1hdHRlci9wYXJzZS5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD1uZXcgUmVnRXhwKFwiXig/PHN0YXJ0RGVsaW1pdGVyPi17M318XFxcXCt7M30pKD88bGFuZ3VhZ2U+W15cXFxcbl0qKVxcXFxuKD86fCg/PHZhbHVlPi4qPylcXFxcbikoPzxlbmREZWxpbWl0ZXI+XFxcXGs8c3RhcnREZWxpbWl0ZXI+fFxcXFwuezN9KVteXFxcXFNcXFxcbl0qKD86XFxcXG58JClcIixcInNcIik7ZnVuY3Rpb24gcyhpKXtsZXQgcj1pLm1hdGNoKHQpO2lmKCFyKXJldHVybntjb250ZW50Oml9O2xldHtzdGFydERlbGltaXRlcjp1LGxhbmd1YWdlOmEsdmFsdWU6Yz1cIlwiLGVuZERlbGltaXRlcjpsfT1yLmdyb3VwcyxDPWEudHJpbSgpfHxcInlhbWxcIjtpZih1PT09XCIrKytcIiYmKEM9XCJ0b21sXCIpLEMhPT1cInlhbWxcIiYmdSE9PWwpcmV0dXJue2NvbnRlbnQ6aX07bGV0W21dPXI7cmV0dXJue2Zyb250TWF0dGVyOnt0eXBlOlwiZnJvbnQtbWF0dGVyXCIsbGFuZzpDLHZhbHVlOmMsc3RhcnREZWxpbWl0ZXI6dSxlbmREZWxpbWl0ZXI6bCxyYXc6bS5yZXBsYWNlKC9cXG4kLyxcIlwiKX0sY29udGVudDptLnJlcGxhY2UoL1teXFxuXS9nLFwiIFwiKStpLnNsaWNlKG0ubGVuZ3RoKX19bi5leHBvcnRzPXN9fSksSm09Wih7XCJzcmMvbGFuZ3VhZ2UtY3NzL3ByYWdtYS5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD1lbygpLHM9cG8oKTtmdW5jdGlvbiBpKHUpe3JldHVybiB0Lmhhc1ByYWdtYShzKHUpLmNvbnRlbnQpfWZ1bmN0aW9uIHIodSl7bGV0e2Zyb250TWF0dGVyOmEsY29udGVudDpjfT1zKHUpO3JldHVybihhP2EucmF3K2BcblxuYDpcIlwiKSt0Lmluc2VydFByYWdtYShjKX1uLmV4cG9ydHM9e2hhc1ByYWdtYTppLGluc2VydFByYWdtYTpyfX19KSxVbT1aKHtcInNyYy9sYW5ndWFnZS1jc3MvdXRpbHMvaW5kZXguanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9bmV3IFNldChbXCJyZWRcIixcImdyZWVuXCIsXCJibHVlXCIsXCJhbHBoYVwiLFwiYVwiLFwicmdiXCIsXCJodWVcIixcImhcIixcInNhdHVyYXRpb25cIixcInNcIixcImxpZ2h0bmVzc1wiLFwibFwiLFwid2hpdGVuZXNzXCIsXCJ3XCIsXCJibGFja25lc3NcIixcImJcIixcInRpbnRcIixcInNoYWRlXCIsXCJibGVuZFwiLFwiYmxlbmRhXCIsXCJjb250cmFzdFwiLFwiaHNsXCIsXCJoc2xhXCIsXCJod2JcIixcImh3YmFcIl0pO2Z1bmN0aW9uIHMocSxsZSl7bGV0IHVlPUFycmF5LmlzQXJyYXkobGUpP2xlOltsZV0sUT0tMSxkZTtmb3IoO2RlPXEuZ2V0UGFyZW50Tm9kZSgrK1EpOylpZih1ZS5pbmNsdWRlcyhkZS50eXBlKSlyZXR1cm4gUTtyZXR1cm4tMX1mdW5jdGlvbiBpKHEsbGUpe2xldCB1ZT1zKHEsbGUpO3JldHVybiB1ZT09PS0xP251bGw6cS5nZXRQYXJlbnROb2RlKHVlKX1mdW5jdGlvbiByKHEpe2xldCBsZT1pKHEsXCJjc3MtZGVjbFwiKTtyZXR1cm4gbGUmJmxlLnByb3AmJmxlLnByb3AudG9Mb3dlckNhc2UoKX1mdW5jdGlvbiB1KHEpe3JldHVybltcImluaXRpYWxcIixcImluaGVyaXRcIixcInVuc2V0XCIsXCJyZXZlcnRcIl0uaW5jbHVkZXMocS50b0xvd2VyQ2FzZSgpKX1mdW5jdGlvbiBhKHEsbGUpe2xldCB1ZT1pKHEsXCJjc3MtYXRydWxlXCIpO3JldHVybiB1ZSYmdWUubmFtZSYmdWUubmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwia2V5ZnJhbWVzXCIpJiZbXCJmcm9tXCIsXCJ0b1wiXS5pbmNsdWRlcyhsZS50b0xvd2VyQ2FzZSgpKX1mdW5jdGlvbiBjKHEpe3JldHVybiBxLmluY2x1ZGVzKFwiJFwiKXx8cS5pbmNsdWRlcyhcIkBcIil8fHEuaW5jbHVkZXMoXCIjXCIpfHxxLnN0YXJ0c1dpdGgoXCIlXCIpfHxxLnN0YXJ0c1dpdGgoXCItLVwiKXx8cS5zdGFydHNXaXRoKFwiOi0tXCIpfHxxLmluY2x1ZGVzKFwiKFwiKSYmcS5pbmNsdWRlcyhcIilcIik/cTpxLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gbChxLGxlKXtsZXQgdWU9aShxLFwidmFsdWUtZnVuY1wiKTtyZXR1cm4gdWUmJnVlLnZhbHVlJiZ1ZS52YWx1ZS50b0xvd2VyQ2FzZSgpPT09bGV9ZnVuY3Rpb24gQyhxKXtsZXQgbGU9aShxLFwiY3NzLXJ1bGVcIik7cmV0dXJuIGxlJiZsZS5yYXdzJiZsZS5yYXdzLnNlbGVjdG9yJiYobGUucmF3cy5zZWxlY3Rvci5zdGFydHNXaXRoKFwiOmltcG9ydFwiKXx8bGUucmF3cy5zZWxlY3Rvci5zdGFydHNXaXRoKFwiOmV4cG9ydFwiKSl9ZnVuY3Rpb24gbShxLGxlKXtsZXQgdWU9QXJyYXkuaXNBcnJheShsZSk/bGU6W2xlXSxRPWkocSxcImNzcy1hdHJ1bGVcIik7cmV0dXJuIFEmJnVlLmluY2x1ZGVzKFEubmFtZS50b0xvd2VyQ2FzZSgpKX1mdW5jdGlvbiBnKHEpe2xldCBsZT1xLmdldFZhbHVlKCksdWU9aShxLFwiY3NzLWF0cnVsZVwiKTtyZXR1cm4gdWUmJnVlLm5hbWU9PT1cImltcG9ydFwiJiZsZS5ncm91cHNbMF0udmFsdWU9PT1cInVybFwiJiZsZS5ncm91cHMubGVuZ3RoPT09Mn1mdW5jdGlvbiBwKHEpe3JldHVybiBxLnR5cGU9PT1cInZhbHVlLWZ1bmNcIiYmcS52YWx1ZS50b0xvd2VyQ2FzZSgpPT09XCJ1cmxcIn1mdW5jdGlvbiBmKHEsbGUpe2xldCB1ZT1xLmdldFBhcmVudE5vZGUoKTtpZighdWUpcmV0dXJuITE7bGV0e25vZGVzOlF9PXVlO3JldHVybiBRJiZRLmluZGV4T2YobGUpPT09US5sZW5ndGgtMX1mdW5jdGlvbiBoKHEpe3JldHVybiBxLnNlbGVjdG9yP3R5cGVvZiBxLnNlbGVjdG9yPT1cInN0cmluZ1wiJiYvXkAuKzouKiQvLnRlc3QocS5zZWxlY3Rvcil8fHEuc2VsZWN0b3IudmFsdWUmJi9eQC4rOi4qJC8udGVzdChxLnNlbGVjdG9yLnZhbHVlKTohMX1mdW5jdGlvbiBOKHEpe3JldHVybiBxLnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmW1wiZnJvbVwiLFwidGhyb3VnaFwiLFwiZW5kXCJdLmluY2x1ZGVzKHEudmFsdWUpfWZ1bmN0aW9uIFQocSl7cmV0dXJuIHEudHlwZT09PVwidmFsdWUtd29yZFwiJiZbXCJhbmRcIixcIm9yXCIsXCJub3RcIl0uaW5jbHVkZXMocS52YWx1ZSl9ZnVuY3Rpb24gQShxKXtyZXR1cm4gcS50eXBlPT09XCJ2YWx1ZS13b3JkXCImJnEudmFsdWU9PT1cImluXCJ9ZnVuY3Rpb24gYihxKXtyZXR1cm4gcS50eXBlPT09XCJ2YWx1ZS1vcGVyYXRvclwiJiZxLnZhbHVlPT09XCIqXCJ9ZnVuY3Rpb24gdihxKXtyZXR1cm4gcS50eXBlPT09XCJ2YWx1ZS1vcGVyYXRvclwiJiZxLnZhbHVlPT09XCIvXCJ9ZnVuY3Rpb24gQihxKXtyZXR1cm4gcS50eXBlPT09XCJ2YWx1ZS1vcGVyYXRvclwiJiZxLnZhbHVlPT09XCIrXCJ9ZnVuY3Rpb24gdyhxKXtyZXR1cm4gcS50eXBlPT09XCJ2YWx1ZS1vcGVyYXRvclwiJiZxLnZhbHVlPT09XCItXCJ9ZnVuY3Rpb24gSShxKXtyZXR1cm4gcS50eXBlPT09XCJ2YWx1ZS1vcGVyYXRvclwiJiZxLnZhbHVlPT09XCIlXCJ9ZnVuY3Rpb24gRShxKXtyZXR1cm4gYihxKXx8dihxKXx8QihxKXx8dyhxKXx8SShxKX1mdW5jdGlvbiBEKHEpe3JldHVybiBxLnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmW1wiPT1cIixcIiE9XCJdLmluY2x1ZGVzKHEudmFsdWUpfWZ1bmN0aW9uIGQocSl7cmV0dXJuIHEudHlwZT09PVwidmFsdWUtd29yZFwiJiZbXCI8XCIsXCI+XCIsXCI8PVwiLFwiPj1cIl0uaW5jbHVkZXMocS52YWx1ZSl9ZnVuY3Rpb24geShxKXtyZXR1cm4gcS50eXBlPT09XCJjc3MtYXRydWxlXCImJltcImlmXCIsXCJlbHNlXCIsXCJmb3JcIixcImVhY2hcIixcIndoaWxlXCJdLmluY2x1ZGVzKHEubmFtZSl9ZnVuY3Rpb24gbyhxKXtyZXR1cm4gcS5yYXdzJiZxLnJhd3MucGFyYW1zJiYvXlxcKFxccypcXCkkLy50ZXN0KHEucmF3cy5wYXJhbXMpfWZ1bmN0aW9uIHgocSl7cmV0dXJuIHEubmFtZS5zdGFydHNXaXRoKFwicHJldHRpZXItcGxhY2Vob2xkZXJcIil9ZnVuY3Rpb24gRihxKXtyZXR1cm4gcS5wcm9wLnN0YXJ0c1dpdGgoXCJAcHJldHRpZXItcGxhY2Vob2xkZXJcIil9ZnVuY3Rpb24gUyhxLGxlKXtyZXR1cm4gcS52YWx1ZT09PVwiJCRcIiYmcS50eXBlPT09XCJ2YWx1ZS1mdW5jXCImJmxlJiZsZS50eXBlPT09XCJ2YWx1ZS13b3JkXCImJiFsZS5yYXdzLmJlZm9yZX1mdW5jdGlvbiBrKHEpe3JldHVybiBxLnZhbHVlJiZxLnZhbHVlLnR5cGU9PT1cInZhbHVlLXJvb3RcIiYmcS52YWx1ZS5ncm91cCYmcS52YWx1ZS5ncm91cC50eXBlPT09XCJ2YWx1ZS12YWx1ZVwiJiZxLnByb3AudG9Mb3dlckNhc2UoKT09PVwiY29tcG9zZXNcIn1mdW5jdGlvbiBfKHEpe3JldHVybiBxLnZhbHVlJiZxLnZhbHVlLmdyb3VwJiZxLnZhbHVlLmdyb3VwLmdyb3VwJiZxLnZhbHVlLmdyb3VwLmdyb3VwLnR5cGU9PT1cInZhbHVlLXBhcmVuX2dyb3VwXCImJnEudmFsdWUuZ3JvdXAuZ3JvdXAub3BlbiE9PW51bGwmJnEudmFsdWUuZ3JvdXAuZ3JvdXAuY2xvc2UhPT1udWxsfWZ1bmN0aW9uIE8ocSl7cmV0dXJuIHEucmF3cyYmcS5yYXdzLmJlZm9yZT09PVwiXCJ9ZnVuY3Rpb24gUihxKXtyZXR1cm4gcS50eXBlPT09XCJ2YWx1ZS1jb21tYV9ncm91cFwiJiZxLmdyb3VwcyYmcS5ncm91cHNbMV0mJnEuZ3JvdXBzWzFdLnR5cGU9PT1cInZhbHVlLWNvbG9uXCJ9ZnVuY3Rpb24gTShxKXtyZXR1cm4gcS50eXBlPT09XCJ2YWx1ZS1wYXJlbl9ncm91cFwiJiZxLmdyb3VwcyYmcS5ncm91cHNbMF0mJlIocS5ncm91cHNbMF0pfWZ1bmN0aW9uIEgocSl7bGV0IGxlPXEuZ2V0VmFsdWUoKTtpZihsZS5ncm91cHMubGVuZ3RoPT09MClyZXR1cm4hMTtsZXQgdWU9cS5nZXRQYXJlbnROb2RlKDEpO2lmKCFNKGxlKSYmISh1ZSYmTSh1ZSkpKXJldHVybiExO2xldCBRPWkocSxcImNzcy1kZWNsXCIpO3JldHVybiEhKFEmJlEucHJvcCYmUS5wcm9wLnN0YXJ0c1dpdGgoXCIkXCIpfHxNKHVlKXx8dWUudHlwZT09PVwidmFsdWUtZnVuY1wiKX1mdW5jdGlvbiBQKHEpe3JldHVybiBxLnR5cGU9PT1cInZhbHVlLWNvbW1lbnRcIiYmcS5pbmxpbmV9ZnVuY3Rpb24gRyhxKXtyZXR1cm4gcS50eXBlPT09XCJ2YWx1ZS13b3JkXCImJnEudmFsdWU9PT1cIiNcIn1mdW5jdGlvbiByZShxKXtyZXR1cm4gcS50eXBlPT09XCJ2YWx1ZS13b3JkXCImJnEudmFsdWU9PT1cIntcIn1mdW5jdGlvbiAkKHEpe3JldHVybiBxLnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmcS52YWx1ZT09PVwifVwifWZ1bmN0aW9uIFcocSl7cmV0dXJuW1widmFsdWUtd29yZFwiLFwidmFsdWUtYXR3b3JkXCJdLmluY2x1ZGVzKHEudHlwZSl9ZnVuY3Rpb24gZWUocSl7cmV0dXJuIHEmJnEudHlwZT09PVwidmFsdWUtY29sb25cIn1mdW5jdGlvbiBVKHEsbGUpe2lmKCFSKGxlKSlyZXR1cm4hMTtsZXR7Z3JvdXBzOnVlfT1sZSxRPXVlLmluZGV4T2YocSk7cmV0dXJuIFE9PT0tMT8hMTplZSh1ZVtRKzFdKX1mdW5jdGlvbiBuZShxKXtyZXR1cm4gcS52YWx1ZSYmW1wibm90XCIsXCJhbmRcIixcIm9yXCJdLmluY2x1ZGVzKHEudmFsdWUudG9Mb3dlckNhc2UoKSl9ZnVuY3Rpb24gc2UocSl7cmV0dXJuIHEudHlwZSE9PVwidmFsdWUtZnVuY1wiPyExOnQuaGFzKHEudmFsdWUudG9Mb3dlckNhc2UoKSl9ZnVuY3Rpb24gVihxKXtyZXR1cm4vXFwvXFwvLy50ZXN0KHEuc3BsaXQoL1tcXG5cXHJdLykucG9wKCkpfWZ1bmN0aW9uIG9lKHEpe3JldHVybiBxJiZxLnR5cGU9PT1cInZhbHVlLWF0d29yZFwiJiZxLnZhbHVlLnN0YXJ0c1dpdGgoXCJwcmV0dGllci1wbGFjZWhvbGRlci1cIil9ZnVuY3Rpb24gSyhxLGxlKXtpZighcS5vcGVufHxxLm9wZW4udmFsdWUhPT1cIihcInx8IXEuY2xvc2V8fHEuY2xvc2UudmFsdWUhPT1cIilcInx8cS5ncm91cHMuc29tZSh1ZT0+dWUudHlwZSE9PVwidmFsdWUtY29tbWFfZ3JvdXBcIikpcmV0dXJuITE7aWYobGUudHlwZT09PVwidmFsdWUtY29tbWFfZ3JvdXBcIil7bGV0IHVlPWxlLmdyb3Vwcy5pbmRleE9mKHEpLTEsUT1sZS5ncm91cHNbdWVdO2lmKFEmJlEudHlwZT09PVwidmFsdWUtd29yZFwiJiZRLnZhbHVlPT09XCJ3aXRoXCIpcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gRWUocSl7cmV0dXJuIHEudHlwZT09PVwidmFsdWUtcGFyZW5fZ3JvdXBcIiYmcS5vcGVuJiZxLm9wZW4udmFsdWU9PT1cIihcIiYmcS5jbG9zZSYmcS5jbG9zZS52YWx1ZT09PVwiKVwifW4uZXhwb3J0cz17Z2V0QW5jZXN0b3JDb3VudGVyOnMsZ2V0QW5jZXN0b3JOb2RlOmksZ2V0UHJvcE9mRGVjbE5vZGU6cixtYXliZVRvTG93ZXJDYXNlOmMsaW5zaWRlVmFsdWVGdW5jdGlvbk5vZGU6bCxpbnNpZGVJQ1NTUnVsZU5vZGU6QyxpbnNpZGVBdFJ1bGVOb2RlOm0saW5zaWRlVVJMRnVuY3Rpb25JbkltcG9ydEF0UnVsZU5vZGU6Zyxpc0tleWZyYW1lQXRSdWxlS2V5d29yZHM6YSxpc1dpZGVLZXl3b3Jkczp1LGlzTGFzdE5vZGU6Zixpc1NDU1NDb250cm9sRGlyZWN0aXZlTm9kZTp5LGlzRGV0YWNoZWRSdWxlc2V0RGVjbGFyYXRpb25Ob2RlOmgsaXNSZWxhdGlvbmFsT3BlcmF0b3JOb2RlOmQsaXNFcXVhbGl0eU9wZXJhdG9yTm9kZTpELGlzTXVsdGlwbGljYXRpb25Ob2RlOmIsaXNEaXZpc2lvbk5vZGU6dixpc0FkZGl0aW9uTm9kZTpCLGlzU3VidHJhY3Rpb25Ob2RlOncsaXNNb2R1bG9Ob2RlOkksaXNNYXRoT3BlcmF0b3JOb2RlOkUsaXNFYWNoS2V5d29yZE5vZGU6QSxpc0ZvcktleXdvcmROb2RlOk4saXNVUkxGdW5jdGlvbk5vZGU6cCxpc0lmRWxzZUtleXdvcmROb2RlOlQsaGFzQ29tcG9zZXNOb2RlOmssaGFzUGFyZW5zQXJvdW5kTm9kZTpfLGhhc0VtcHR5UmF3QmVmb3JlOk8saXNEZXRhY2hlZFJ1bGVzZXRDYWxsTm9kZTpvLGlzVGVtcGxhdGVQbGFjZWhvbGRlck5vZGU6eCxpc1RlbXBsYXRlUHJvcE5vZGU6Rixpc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlOlMsaXNLZXlWYWx1ZVBhaXJOb2RlOlIsaXNLZXlWYWx1ZVBhaXJJblBhcmVuR3JvdXBOb2RlOk0saXNLZXlJblZhbHVlUGFpck5vZGU6VSxpc1NDU1NNYXBJdGVtTm9kZTpILGlzSW5saW5lVmFsdWVDb21tZW50Tm9kZTpQLGlzSGFzaE5vZGU6Ryxpc0xlZnRDdXJseUJyYWNlTm9kZTpyZSxpc1JpZ2h0Q3VybHlCcmFjZU5vZGU6JCxpc1dvcmROb2RlOlcsaXNDb2xvbk5vZGU6ZWUsaXNNZWRpYUFuZFN1cHBvcnRzS2V5d29yZHM6bmUsaXNDb2xvckFkanVzdGVyRnVuY05vZGU6c2UsbGFzdExpbmVIYXNJbmxpbmVDb21tZW50OlYsaXNBdFdvcmRQbGFjZWhvbGRlck5vZGU6b2UsaXNDb25maWd1cmF0aW9uTm9kZTpLLGlzUGFyZW5Hcm91cE5vZGU6RWV9fX0pLHptPVooe1wic3JjL3V0aWxzL2xpbmUtY29sdW1uLXRvLWluZGV4LmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpLG4uZXhwb3J0cz1mdW5jdGlvbih0LHMpe2xldCBpPTA7Zm9yKGxldCByPTA7cjx0LmxpbmUtMTsrK3IpaT1zLmluZGV4T2YoYFxuYCxpKSsxO3JldHVybiBpK3QuY29sdW1ufX19KSxYbT1aKHtcInNyYy9sYW5ndWFnZS1jc3MvbG9jLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3Zhcntza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmU6dH09VHIoKSxzPXN0KCksaT16bSgpO2Z1bmN0aW9uIHIocCxmKXtyZXR1cm4gdHlwZW9mIHAuc291cmNlSW5kZXg9PVwibnVtYmVyXCI/cC5zb3VyY2VJbmRleDpwLnNvdXJjZT9pKHAuc291cmNlLnN0YXJ0LGYpLTE6bnVsbH1mdW5jdGlvbiB1KHAsZil7aWYocC50eXBlPT09XCJjc3MtY29tbWVudFwiJiZwLmlubGluZSlyZXR1cm4gdChmLHAuc291cmNlLnN0YXJ0T2Zmc2V0KTtsZXQgaD1wLm5vZGVzJiZzKHAubm9kZXMpO3JldHVybiBoJiZwLnNvdXJjZSYmIXAuc291cmNlLmVuZCYmKHA9aCkscC5zb3VyY2UmJnAuc291cmNlLmVuZD9pKHAuc291cmNlLmVuZCxmKTpudWxsfWZ1bmN0aW9uIGEocCxmKXtwLnNvdXJjZSYmKHAuc291cmNlLnN0YXJ0T2Zmc2V0PXIocCxmKSxwLnNvdXJjZS5lbmRPZmZzZXQ9dShwLGYpKTtmb3IobGV0IGggaW4gcCl7bGV0IE49cFtoXTtoPT09XCJzb3VyY2VcInx8IU58fHR5cGVvZiBOIT1cIm9iamVjdFwifHwoTi50eXBlPT09XCJ2YWx1ZS1yb290XCJ8fE4udHlwZT09PVwidmFsdWUtdW5rbm93blwiP2MoTixsKHApLE4udGV4dHx8Ti52YWx1ZSk6YShOLGYpKX19ZnVuY3Rpb24gYyhwLGYsaCl7cC5zb3VyY2UmJihwLnNvdXJjZS5zdGFydE9mZnNldD1yKHAsaCkrZixwLnNvdXJjZS5lbmRPZmZzZXQ9dShwLGgpK2YpO2ZvcihsZXQgTiBpbiBwKXtsZXQgVD1wW05dO049PT1cInNvdXJjZVwifHwhVHx8dHlwZW9mIFQhPVwib2JqZWN0XCJ8fGMoVCxmLGgpfX1mdW5jdGlvbiBsKHApe2xldCBmPXAuc291cmNlLnN0YXJ0T2Zmc2V0O3JldHVybiB0eXBlb2YgcC5wcm9wPT1cInN0cmluZ1wiJiYoZis9cC5wcm9wLmxlbmd0aCkscC50eXBlPT09XCJjc3MtYXRydWxlXCImJnR5cGVvZiBwLm5hbWU9PVwic3RyaW5nXCImJihmKz0xK3AubmFtZS5sZW5ndGgrcC5yYXdzLmFmdGVyTmFtZS5tYXRjaCgvXlxccyo6P1xccyovKVswXS5sZW5ndGgpLHAudHlwZSE9PVwiY3NzLWF0cnVsZVwiJiZwLnJhd3MmJnR5cGVvZiBwLnJhd3MuYmV0d2Vlbj09XCJzdHJpbmdcIiYmKGYrPXAucmF3cy5iZXR3ZWVuLmxlbmd0aCksZn1mdW5jdGlvbiBDKHApe2xldCBmPVwiaW5pdGlhbFwiLGg9XCJpbml0aWFsXCIsTixUPSExLEE9W107Zm9yKGxldCBiPTA7YjxwLmxlbmd0aDtiKyspe2xldCB2PXBbYl07c3dpdGNoKGYpe2Nhc2VcImluaXRpYWxcIjppZih2PT09XCInXCIpe2Y9XCJzaW5nbGUtcXVvdGVzXCI7Y29udGludWV9aWYodj09PSdcIicpe2Y9XCJkb3VibGUtcXVvdGVzXCI7Y29udGludWV9aWYoKHY9PT1cInVcInx8dj09PVwiVVwiKSYmcC5zbGljZShiLGIrNCkudG9Mb3dlckNhc2UoKT09PVwidXJsKFwiKXtmPVwidXJsXCIsYis9Mztjb250aW51ZX1pZih2PT09XCIqXCImJnBbYi0xXT09PVwiL1wiKXtmPVwiY29tbWVudC1ibG9ja1wiO2NvbnRpbnVlfWlmKHY9PT1cIi9cIiYmcFtiLTFdPT09XCIvXCIpe2Y9XCJjb21tZW50LWlubGluZVwiLE49Yi0xO2NvbnRpbnVlfWNvbnRpbnVlO2Nhc2VcInNpbmdsZS1xdW90ZXNcIjppZih2PT09XCInXCImJnBbYi0xXSE9PVwiXFxcXFwiJiYoZj1oLGg9XCJpbml0aWFsXCIpLHY9PT1gXG5gfHx2PT09XCJcXHJcIilyZXR1cm4gcDtjb250aW51ZTtjYXNlXCJkb3VibGUtcXVvdGVzXCI6aWYodj09PSdcIicmJnBbYi0xXSE9PVwiXFxcXFwiJiYoZj1oLGg9XCJpbml0aWFsXCIpLHY9PT1gXG5gfHx2PT09XCJcXHJcIilyZXR1cm4gcDtjb250aW51ZTtjYXNlXCJ1cmxcIjppZih2PT09XCIpXCImJihmPVwiaW5pdGlhbFwiKSx2PT09YFxuYHx8dj09PVwiXFxyXCIpcmV0dXJuIHA7aWYodj09PVwiJ1wiKXtmPVwic2luZ2xlLXF1b3Rlc1wiLGg9XCJ1cmxcIjtjb250aW51ZX1pZih2PT09J1wiJyl7Zj1cImRvdWJsZS1xdW90ZXNcIixoPVwidXJsXCI7Y29udGludWV9Y29udGludWU7Y2FzZVwiY29tbWVudC1ibG9ja1wiOnY9PT1cIi9cIiYmcFtiLTFdPT09XCIqXCImJihmPVwiaW5pdGlhbFwiKTtjb250aW51ZTtjYXNlXCJjb21tZW50LWlubGluZVwiOih2PT09J1wiJ3x8dj09PVwiJ1wifHx2PT09XCIqXCIpJiYoVD0hMCksKHY9PT1gXG5gfHx2PT09XCJcXHJcIikmJihUJiZBLnB1c2goW04sYl0pLGY9XCJpbml0aWFsXCIsVD0hMSk7Y29udGludWV9fWZvcihsZXRbYix2XW9mIEEpcD1wLnNsaWNlKDAsYikrcC5zbGljZShiLHYpLnJlcGxhY2UoL1tcIicqXS9nLFwiIFwiKStwLnNsaWNlKHYpO3JldHVybiBwfWZ1bmN0aW9uIG0ocCl7cmV0dXJuIHAuc291cmNlLnN0YXJ0T2Zmc2V0fWZ1bmN0aW9uIGcocCl7cmV0dXJuIHAuc291cmNlLmVuZE9mZnNldH1uLmV4cG9ydHM9e2xvY1N0YXJ0Om0sbG9jRW5kOmcsY2FsY3VsYXRlTG9jOmEscmVwbGFjZVF1b3Rlc0luSW5saW5lQ29tbWVudHM6Q319fSksS209Wih7XCJzcmMvbGFuZ3VhZ2UtY3NzL3V0aWxzL2lzLWxlc3MtcGFyc2VyLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO2Z1bmN0aW9uIHQocyl7cmV0dXJuIHMucGFyc2VyPT09XCJjc3NcInx8cy5wYXJzZXI9PT1cImxlc3NcIn1uLmV4cG9ydHM9dH19KSxZbT1aKHtcInNyYy9sYW5ndWFnZS1jc3MvdXRpbHMvaXMtc2Nzcy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KHMsaSl7cmV0dXJuIHM9PT1cImxlc3NcInx8cz09PVwic2Nzc1wiP3M9PT1cInNjc3NcIjovKD86XFx3XFxzKjpcXHMqW146fV0rfCMpe3xAaW1wb3J0W15cXG5dKyg/OnVybHwsKS8udGVzdChpKX1uLmV4cG9ydHM9dH19KSxRbT1aKHtcInNyYy9sYW5ndWFnZS1jc3MvdXRpbHMvY3NzLXVuaXRzLmV2YWx1YXRlLmpzXCIoZSxuKXtuLmV4cG9ydHM9e2VtOlwiZW1cIixyZW06XCJyZW1cIixleDpcImV4XCIscmV4OlwicmV4XCIsY2FwOlwiY2FwXCIscmNhcDpcInJjYXBcIixjaDpcImNoXCIscmNoOlwicmNoXCIsaWM6XCJpY1wiLHJpYzpcInJpY1wiLGxoOlwibGhcIixybGg6XCJybGhcIix2dzpcInZ3XCIsdmg6XCJ2aFwiLHZpOlwidmlcIix2YjpcInZiXCIsdm1pbjpcInZtaW5cIix2bWF4Olwidm1heFwiLGNtOlwiY21cIixtbTpcIm1tXCIscTpcIlFcIixpbjpcImluXCIscHQ6XCJwdFwiLHBjOlwicGNcIixweDpcInB4XCIsZGVnOlwiZGVnXCIsZ3JhZDpcImdyYWRcIixyYWQ6XCJyYWRcIix0dXJuOlwidHVyblwiLHM6XCJzXCIsbXM6XCJtc1wiLGh6OlwiSHpcIixraHo6XCJrSHpcIixkcGk6XCJkcGlcIixkcGNtOlwiZHBjbVwiLGRwcHg6XCJkcHB4XCIseDpcInhcIn19fSksWm09Wih7XCJzcmMvbGFuZ3VhZ2UtY3NzL3V0aWxzL3ByaW50LXVuaXQuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9UW0oKTtmdW5jdGlvbiBzKGkpe2xldCByPWkudG9Mb3dlckNhc2UoKTtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscik/dFtyXTppfW4uZXhwb3J0cz1zfX0pLGVkPVooe1wic3JjL2xhbmd1YWdlLWNzcy9wcmludGVyLXBvc3Rjc3MuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9c3QoKSx7cHJpbnROdW1iZXI6cyxwcmludFN0cmluZzppLGhhc05ld2xpbmU6cixpc0Zyb250TWF0dGVyTm9kZTp1LGlzTmV4dExpbmVFbXB0eTphLGlzTm9uRW1wdHlBcnJheTpjfT1HZSgpLHtidWlsZGVyczp7am9pbjpsLGxpbmU6QyxoYXJkbGluZTptLHNvZnRsaW5lOmcsZ3JvdXA6cCxmaWxsOmYsaW5kZW50OmgsZGVkZW50Ok4saWZCcmVhazpULGJyZWFrUGFyZW50OkF9LHV0aWxzOntyZW1vdmVMaW5lczpiLGdldERvY1BhcnRzOnZ9fT1MZSgpLEI9SG0oKSx3PUdtKCkse2luc2VydFByYWdtYTpJfT1KbSgpLHtnZXRBbmNlc3Rvck5vZGU6RSxnZXRQcm9wT2ZEZWNsTm9kZTpELG1heWJlVG9Mb3dlckNhc2U6ZCxpbnNpZGVWYWx1ZUZ1bmN0aW9uTm9kZTp5LGluc2lkZUlDU1NSdWxlTm9kZTpvLGluc2lkZUF0UnVsZU5vZGU6eCxpbnNpZGVVUkxGdW5jdGlvbkluSW1wb3J0QXRSdWxlTm9kZTpGLGlzS2V5ZnJhbWVBdFJ1bGVLZXl3b3JkczpTLGlzV2lkZUtleXdvcmRzOmssaXNMYXN0Tm9kZTpfLGlzU0NTU0NvbnRyb2xEaXJlY3RpdmVOb2RlOk8saXNEZXRhY2hlZFJ1bGVzZXREZWNsYXJhdGlvbk5vZGU6Uixpc1JlbGF0aW9uYWxPcGVyYXRvck5vZGU6TSxpc0VxdWFsaXR5T3BlcmF0b3JOb2RlOkgsaXNNdWx0aXBsaWNhdGlvbk5vZGU6UCxpc0RpdmlzaW9uTm9kZTpHLGlzQWRkaXRpb25Ob2RlOnJlLGlzU3VidHJhY3Rpb25Ob2RlOiQsaXNNYXRoT3BlcmF0b3JOb2RlOlcsaXNFYWNoS2V5d29yZE5vZGU6ZWUsaXNGb3JLZXl3b3JkTm9kZTpVLGlzVVJMRnVuY3Rpb25Ob2RlOm5lLGlzSWZFbHNlS2V5d29yZE5vZGU6c2UsaGFzQ29tcG9zZXNOb2RlOlYsaGFzUGFyZW5zQXJvdW5kTm9kZTpvZSxoYXNFbXB0eVJhd0JlZm9yZTpLLGlzS2V5VmFsdWVQYWlyTm9kZTpFZSxpc0tleUluVmFsdWVQYWlyTm9kZTpxLGlzRGV0YWNoZWRSdWxlc2V0Q2FsbE5vZGU6bGUsaXNUZW1wbGF0ZVBsYWNlaG9sZGVyTm9kZTp1ZSxpc1RlbXBsYXRlUHJvcE5vZGU6USxpc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlOmRlLGlzU0NTU01hcEl0ZW1Ob2RlOmdlLGlzSW5saW5lVmFsdWVDb21tZW50Tm9kZTp2ZSxpc0hhc2hOb2RlOnhlLGlzTGVmdEN1cmx5QnJhY2VOb2RlOndlLGlzUmlnaHRDdXJseUJyYWNlTm9kZTpmZSxpc1dvcmROb2RlOnBlLGlzQ29sb25Ob2RlOm1lLGlzTWVkaWFBbmRTdXBwb3J0c0tleXdvcmRzOmNlLGlzQ29sb3JBZGp1c3RlckZ1bmNOb2RlOmhlLGxhc3RMaW5lSGFzSW5saW5lQ29tbWVudDpKLGlzQXRXb3JkUGxhY2Vob2xkZXJOb2RlOnllLGlzQ29uZmlndXJhdGlvbk5vZGU6WCxpc1BhcmVuR3JvdXBOb2RlOll9PVVtKCkse2xvY1N0YXJ0OnRlLGxvY0VuZDp6fT1YbSgpLGo9S20oKSxDZT1ZbSgpLE5lPVptKCk7ZnVuY3Rpb24gamUoQWUpe3JldHVybiBBZS50cmFpbGluZ0NvbW1hPT09XCJlczVcInx8QWUudHJhaWxpbmdDb21tYT09PVwiYWxsXCJ9ZnVuY3Rpb24gVWUoQWUsT2UsUGUpe2xldCBpZT1BZS5nZXRWYWx1ZSgpO2lmKCFpZSlyZXR1cm5cIlwiO2lmKHR5cGVvZiBpZT09XCJzdHJpbmdcIilyZXR1cm4gaWU7c3dpdGNoKGllLnR5cGUpe2Nhc2VcImZyb250LW1hdHRlclwiOnJldHVybltpZS5yYXcsbV07Y2FzZVwiY3NzLXJvb3RcIjp7bGV0IE1lPXR0KEFlLE9lLFBlKSxxZT1pZS5yYXdzLmFmdGVyLnRyaW0oKTtyZXR1cm5bTWUscWU/XCIgXCIuY29uY2F0KHFlKTpcIlwiLHYoTWUpLmxlbmd0aD4wP206XCJcIl19Y2FzZVwiY3NzLWNvbW1lbnRcIjp7bGV0IE1lPWllLmlubGluZXx8aWUucmF3cy5pbmxpbmUscWU9T2Uub3JpZ2luYWxUZXh0LnNsaWNlKHRlKGllKSx6KGllKSk7cmV0dXJuIE1lP3FlLnRyaW1FbmQoKTpxZX1jYXNlXCJjc3MtcnVsZVwiOnJldHVybltQZShcInNlbGVjdG9yXCIpLGllLmltcG9ydGFudD9cIiAhaW1wb3J0YW50XCI6XCJcIixpZS5ub2Rlcz9baWUuc2VsZWN0b3ImJmllLnNlbGVjdG9yLnR5cGU9PT1cInNlbGVjdG9yLXVua25vd25cIiYmSihpZS5zZWxlY3Rvci52YWx1ZSk/QzpcIiBcIixcIntcIixpZS5ub2Rlcy5sZW5ndGg+MD9oKFttLHR0KEFlLE9lLFBlKV0pOlwiXCIsbSxcIn1cIixSKGllKT9cIjtcIjpcIlwiXTpcIjtcIl07Y2FzZVwiY3NzLWRlY2xcIjp7bGV0IE1lPUFlLmdldFBhcmVudE5vZGUoKSx7YmV0d2VlbjpxZX09aWUucmF3cyxKZT1xZS50cmltKCkscnQ9SmU9PT1cIjpcIixaZT1WKGllKT9iKFBlKFwidmFsdWVcIikpOlBlKFwidmFsdWVcIik7cmV0dXJuIXJ0JiZKKEplKSYmKFplPWgoW20sTihaZSldKSksW2llLnJhd3MuYmVmb3JlLnJlcGxhY2UoL1tcXHM7XS9nLFwiXCIpLG8oQWUpP2llLnByb3A6ZChpZS5wcm9wKSxKZS5zdGFydHNXaXRoKFwiLy9cIik/XCIgXCI6XCJcIixKZSxpZS5leHRlbmQ/XCJcIjpcIiBcIixqKE9lKSYmaWUuZXh0ZW5kJiZpZS5zZWxlY3Rvcj9bXCJleHRlbmQoXCIsUGUoXCJzZWxlY3RvclwiKSxcIilcIl06XCJcIixaZSxpZS5yYXdzLmltcG9ydGFudD9pZS5yYXdzLmltcG9ydGFudC5yZXBsYWNlKC9cXHMqIVxccyppbXBvcnRhbnQvaSxcIiAhaW1wb3J0YW50XCIpOmllLmltcG9ydGFudD9cIiAhaW1wb3J0YW50XCI6XCJcIixpZS5yYXdzLnNjc3NEZWZhdWx0P2llLnJhd3Muc2Nzc0RlZmF1bHQucmVwbGFjZSgvXFxzKiFkZWZhdWx0L2ksXCIgIWRlZmF1bHRcIik6aWUuc2Nzc0RlZmF1bHQ/XCIgIWRlZmF1bHRcIjpcIlwiLGllLnJhd3Muc2Nzc0dsb2JhbD9pZS5yYXdzLnNjc3NHbG9iYWwucmVwbGFjZSgvXFxzKiFnbG9iYWwvaSxcIiAhZ2xvYmFsXCIpOmllLnNjc3NHbG9iYWw/XCIgIWdsb2JhbFwiOlwiXCIsaWUubm9kZXM/W1wiIHtcIixoKFtnLHR0KEFlLE9lLFBlKV0pLGcsXCJ9XCJdOlEoaWUpJiYhTWUucmF3cy5zZW1pY29sb24mJk9lLm9yaWdpbmFsVGV4dFt6KGllKS0xXSE9PVwiO1wiP1wiXCI6T2UuX19pc0hUTUxTdHlsZUF0dHJpYnV0ZSYmXyhBZSxpZSk/VChcIjtcIik6XCI7XCJdfWNhc2VcImNzcy1hdHJ1bGVcIjp7bGV0IE1lPUFlLmdldFBhcmVudE5vZGUoKSxxZT11ZShpZSkmJiFNZS5yYXdzLnNlbWljb2xvbiYmT2Uub3JpZ2luYWxUZXh0W3ooaWUpLTFdIT09XCI7XCI7aWYoaihPZSkpe2lmKGllLm1peGluKXJldHVybltQZShcInNlbGVjdG9yXCIpLGllLmltcG9ydGFudD9cIiAhaW1wb3J0YW50XCI6XCJcIixxZT9cIlwiOlwiO1wiXTtpZihpZS5mdW5jdGlvbilyZXR1cm5baWUubmFtZSxQZShcInBhcmFtc1wiKSxxZT9cIlwiOlwiO1wiXTtpZihpZS52YXJpYWJsZSlyZXR1cm5bXCJAXCIsaWUubmFtZSxcIjogXCIsaWUudmFsdWU/UGUoXCJ2YWx1ZVwiKTpcIlwiLGllLnJhd3MuYmV0d2Vlbi50cmltKCk/aWUucmF3cy5iZXR3ZWVuLnRyaW0oKStcIiBcIjpcIlwiLGllLm5vZGVzP1tcIntcIixoKFtpZS5ub2Rlcy5sZW5ndGg+MD9nOlwiXCIsdHQoQWUsT2UsUGUpXSksZyxcIn1cIl06XCJcIixxZT9cIlwiOlwiO1wiXX1yZXR1cm5bXCJAXCIsbGUoaWUpfHxpZS5uYW1lLmVuZHNXaXRoKFwiOlwiKT9pZS5uYW1lOmQoaWUubmFtZSksaWUucGFyYW1zP1tsZShpZSk/XCJcIjp1ZShpZSk/aWUucmF3cy5hZnRlck5hbWU9PT1cIlwiP1wiXCI6aWUubmFtZS5lbmRzV2l0aChcIjpcIik/XCIgXCI6L15cXHMqXFxuXFxzKlxcbi8udGVzdChpZS5yYXdzLmFmdGVyTmFtZSk/W20sbV06L15cXHMqXFxuLy50ZXN0KGllLnJhd3MuYWZ0ZXJOYW1lKT9tOlwiIFwiOlwiIFwiLFBlKFwicGFyYW1zXCIpXTpcIlwiLGllLnNlbGVjdG9yP2goW1wiIFwiLFBlKFwic2VsZWN0b3JcIildKTpcIlwiLGllLnZhbHVlP3AoW1wiIFwiLFBlKFwidmFsdWVcIiksTyhpZSk/b2UoaWUpP1wiIFwiOkM6XCJcIl0pOmllLm5hbWU9PT1cImVsc2VcIj9cIiBcIjpcIlwiLGllLm5vZGVzP1tPKGllKT9cIlwiOmllLnNlbGVjdG9yJiYhaWUuc2VsZWN0b3Iubm9kZXMmJnR5cGVvZiBpZS5zZWxlY3Rvci52YWx1ZT09XCJzdHJpbmdcIiYmSihpZS5zZWxlY3Rvci52YWx1ZSl8fCFpZS5zZWxlY3RvciYmdHlwZW9mIGllLnBhcmFtcz09XCJzdHJpbmdcIiYmSihpZS5wYXJhbXMpP0M6XCIgXCIsXCJ7XCIsaChbaWUubm9kZXMubGVuZ3RoPjA/ZzpcIlwiLHR0KEFlLE9lLFBlKV0pLGcsXCJ9XCJdOnFlP1wiXCI6XCI7XCJdfWNhc2VcIm1lZGlhLXF1ZXJ5LWxpc3RcIjp7bGV0IE1lPVtdO3JldHVybiBBZS5lYWNoKHFlPT57bGV0IEplPXFlLmdldFZhbHVlKCk7SmUudHlwZT09PVwibWVkaWEtcXVlcnlcIiYmSmUudmFsdWU9PT1cIlwifHxNZS5wdXNoKFBlKCkpfSxcIm5vZGVzXCIpLHAoaChsKEMsTWUpKSl9Y2FzZVwibWVkaWEtcXVlcnlcIjpyZXR1cm5bbChcIiBcIixBZS5tYXAoUGUsXCJub2Rlc1wiKSksXyhBZSxpZSk/XCJcIjpcIixcIl07Y2FzZVwibWVkaWEtdHlwZVwiOnJldHVybiBJZSh6ZShpZS52YWx1ZSxPZSkpO2Nhc2VcIm1lZGlhLWZlYXR1cmUtZXhwcmVzc2lvblwiOnJldHVybiBpZS5ub2Rlcz9bXCIoXCIsLi4uQWUubWFwKFBlLFwibm9kZXNcIiksXCIpXCJdOmllLnZhbHVlO2Nhc2VcIm1lZGlhLWZlYXR1cmVcIjpyZXR1cm4gZCh6ZShpZS52YWx1ZS5yZXBsYWNlKC8gKy9nLFwiIFwiKSxPZSkpO2Nhc2VcIm1lZGlhLWNvbG9uXCI6cmV0dXJuW2llLnZhbHVlLFwiIFwiXTtjYXNlXCJtZWRpYS12YWx1ZVwiOnJldHVybiBJZSh6ZShpZS52YWx1ZSxPZSkpO2Nhc2VcIm1lZGlhLWtleXdvcmRcIjpyZXR1cm4gemUoaWUudmFsdWUsT2UpO2Nhc2VcIm1lZGlhLXVybFwiOnJldHVybiB6ZShpZS52YWx1ZS5yZXBsYWNlKC9edXJsXFwoXFxzKy9naSxcInVybChcIikucmVwbGFjZSgvXFxzK1xcKSQvZyxcIilcIiksT2UpO2Nhc2VcIm1lZGlhLXVua25vd25cIjpyZXR1cm4gaWUudmFsdWU7Y2FzZVwic2VsZWN0b3Itcm9vdFwiOnJldHVybiBwKFt4KEFlLFwiY3VzdG9tLXNlbGVjdG9yXCIpP1tFKEFlLFwiY3NzLWF0cnVsZVwiKS5jdXN0b21TZWxlY3RvcixDXTpcIlwiLGwoW1wiLFwiLHgoQWUsW1wiZXh0ZW5kXCIsXCJjdXN0b20tc2VsZWN0b3JcIixcIm5lc3RcIl0pP0M6bV0sQWUubWFwKFBlLFwibm9kZXNcIikpXSk7Y2FzZVwic2VsZWN0b3Itc2VsZWN0b3JcIjpyZXR1cm4gcChoKEFlLm1hcChQZSxcIm5vZGVzXCIpKSk7Y2FzZVwic2VsZWN0b3ItY29tbWVudFwiOnJldHVybiBpZS52YWx1ZTtjYXNlXCJzZWxlY3Rvci1zdHJpbmdcIjpyZXR1cm4gemUoaWUudmFsdWUsT2UpO2Nhc2VcInNlbGVjdG9yLXRhZ1wiOntsZXQgTWU9QWUuZ2V0UGFyZW50Tm9kZSgpLHFlPU1lJiZNZS5ub2Rlcy5pbmRleE9mKGllKSxKZT1xZSYmTWUubm9kZXNbcWUtMV07cmV0dXJuW2llLm5hbWVzcGFjZT9baWUubmFtZXNwYWNlPT09ITA/XCJcIjppZS5uYW1lc3BhY2UudHJpbSgpLFwifFwiXTpcIlwiLEplLnR5cGU9PT1cInNlbGVjdG9yLW5lc3RpbmdcIj9pZS52YWx1ZTpJZShTKEFlLGllLnZhbHVlKT9pZS52YWx1ZS50b0xvd2VyQ2FzZSgpOmllLnZhbHVlKV19Y2FzZVwic2VsZWN0b3ItaWRcIjpyZXR1cm5bXCIjXCIsaWUudmFsdWVdO2Nhc2VcInNlbGVjdG9yLWNsYXNzXCI6cmV0dXJuW1wiLlwiLEllKHplKGllLnZhbHVlLE9lKSldO2Nhc2VcInNlbGVjdG9yLWF0dHJpYnV0ZVwiOnJldHVybltcIltcIixpZS5uYW1lc3BhY2U/W2llLm5hbWVzcGFjZT09PSEwP1wiXCI6aWUubmFtZXNwYWNlLnRyaW0oKSxcInxcIl06XCJcIixpZS5hdHRyaWJ1dGUudHJpbSgpLGllLm9wZXJhdG9yP2llLm9wZXJhdG9yOlwiXCIsaWUudmFsdWU/QmUoemUoaWUudmFsdWUudHJpbSgpLE9lKSxPZSk6XCJcIixpZS5pbnNlbnNpdGl2ZT9cIiBpXCI6XCJcIixcIl1cIl07Y2FzZVwic2VsZWN0b3ItY29tYmluYXRvclwiOntpZihpZS52YWx1ZT09PVwiK1wifHxpZS52YWx1ZT09PVwiPlwifHxpZS52YWx1ZT09PVwiflwifHxpZS52YWx1ZT09PVwiPj4+XCIpe2xldCBKZT1BZS5nZXRQYXJlbnROb2RlKCk7cmV0dXJuW0plLnR5cGU9PT1cInNlbGVjdG9yLXNlbGVjdG9yXCImJkplLm5vZGVzWzBdPT09aWU/XCJcIjpDLGllLnZhbHVlLF8oQWUsaWUpP1wiXCI6XCIgXCJdfWxldCBNZT1pZS52YWx1ZS50cmltKCkuc3RhcnRzV2l0aChcIihcIik/QzpcIlwiLHFlPUllKHplKGllLnZhbHVlLnRyaW0oKSxPZSkpfHxDO3JldHVybltNZSxxZV19Y2FzZVwic2VsZWN0b3ItdW5pdmVyc2FsXCI6cmV0dXJuW2llLm5hbWVzcGFjZT9baWUubmFtZXNwYWNlPT09ITA/XCJcIjppZS5uYW1lc3BhY2UudHJpbSgpLFwifFwiXTpcIlwiLGllLnZhbHVlXTtjYXNlXCJzZWxlY3Rvci1wc2V1ZG9cIjpyZXR1cm5bZChpZS52YWx1ZSksYyhpZS5ub2Rlcyk/W1wiKFwiLGwoXCIsIFwiLEFlLm1hcChQZSxcIm5vZGVzXCIpKSxcIilcIl06XCJcIl07Y2FzZVwic2VsZWN0b3ItbmVzdGluZ1wiOnJldHVybiBpZS52YWx1ZTtjYXNlXCJzZWxlY3Rvci11bmtub3duXCI6e2xldCBNZT1FKEFlLFwiY3NzLXJ1bGVcIik7aWYoTWUmJk1lLmlzU0NTU05lc3RlclByb3BlcnR5KXJldHVybiBJZSh6ZShkKGllLnZhbHVlKSxPZSkpO2xldCBxZT1BZS5nZXRQYXJlbnROb2RlKCk7aWYocWUucmF3cyYmcWUucmF3cy5zZWxlY3Rvcil7bGV0IHJ0PXRlKHFlKSxaZT1ydCtxZS5yYXdzLnNlbGVjdG9yLmxlbmd0aDtyZXR1cm4gT2Uub3JpZ2luYWxUZXh0LnNsaWNlKHJ0LFplKS50cmltKCl9bGV0IEplPUFlLmdldFBhcmVudE5vZGUoMSk7aWYocWUudHlwZT09PVwidmFsdWUtcGFyZW5fZ3JvdXBcIiYmSmUmJkplLnR5cGU9PT1cInZhbHVlLWZ1bmNcIiYmSmUudmFsdWU9PT1cInNlbGVjdG9yXCIpe2xldCBydD16KHFlLm9wZW4pKzEsWmU9dGUocWUuY2xvc2UpLGN0PU9lLm9yaWdpbmFsVGV4dC5zbGljZShydCxaZSkudHJpbSgpO3JldHVybiBKKGN0KT9bQSxjdF06Y3R9cmV0dXJuIGllLnZhbHVlfWNhc2VcInZhbHVlLXZhbHVlXCI6Y2FzZVwidmFsdWUtcm9vdFwiOnJldHVybiBQZShcImdyb3VwXCIpO2Nhc2VcInZhbHVlLWNvbW1lbnRcIjpyZXR1cm4gT2Uub3JpZ2luYWxUZXh0LnNsaWNlKHRlKGllKSx6KGllKSk7Y2FzZVwidmFsdWUtY29tbWFfZ3JvdXBcIjp7bGV0IE1lPUFlLmdldFBhcmVudE5vZGUoKSxxZT1BZS5nZXRQYXJlbnROb2RlKDEpLEplPUQoQWUpLHJ0PUplJiZNZS50eXBlPT09XCJ2YWx1ZS12YWx1ZVwiJiYoSmU9PT1cImdyaWRcInx8SmUuc3RhcnRzV2l0aChcImdyaWQtdGVtcGxhdGVcIikpLFplPUUoQWUsXCJjc3MtYXRydWxlXCIpLGN0PVplJiZPKFplKSxxdD1pZS5ncm91cHMuc29tZSh1dD0+dmUodXQpKSxMPUFlLm1hcChQZSxcImdyb3Vwc1wiKSxEZT1bXSxrZT15KEFlLFwidXJsXCIpLFdlPSExLCRlPSExO2ZvcihsZXQgdXQ9MDt1dDxpZS5ncm91cHMubGVuZ3RoOysrdXQpe0RlLnB1c2goTFt1dF0pO2xldCBldD1pZS5ncm91cHNbdXQtMV0sUmU9aWUuZ3JvdXBzW3V0XSxIZT1pZS5ncm91cHNbdXQrMV0sWnQ9aWUuZ3JvdXBzW3V0KzJdO2lmKGtlKXsoSGUmJnJlKEhlKXx8cmUoUmUpKSYmRGUucHVzaChcIiBcIik7Y29udGludWV9aWYoeChBZSxcImZvcndhcmRcIikmJlJlLnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmUmUudmFsdWUmJmV0IT09dm9pZCAwJiZldC50eXBlPT09XCJ2YWx1ZS13b3JkXCImJmV0LnZhbHVlPT09XCJhc1wiJiZIZS50eXBlPT09XCJ2YWx1ZS1vcGVyYXRvclwiJiZIZS52YWx1ZT09PVwiKlwifHwhSGV8fFJlLnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmUmUudmFsdWUuZW5kc1dpdGgoXCItXCIpJiZ5ZShIZSkpY29udGludWU7bGV0IGhvPVJlLnR5cGU9PT1cInZhbHVlLXN0cmluZ1wiJiZSZS52YWx1ZS5zdGFydHNXaXRoKFwiI3tcIiksQ289V2UmJkhlLnR5cGU9PT1cInZhbHVlLXN0cmluZ1wiJiZIZS52YWx1ZS5lbmRzV2l0aChcIn1cIik7aWYoaG98fENvKXtXZT0hV2U7Y29udGludWV9aWYoV2V8fG1lKFJlKXx8bWUoSGUpfHxSZS50eXBlPT09XCJ2YWx1ZS1hdHdvcmRcIiYmUmUudmFsdWU9PT1cIlwifHxSZS52YWx1ZT09PVwiflwifHxSZS52YWx1ZSYmUmUudmFsdWUuaW5jbHVkZXMoXCJcXFxcXCIpJiZIZSYmSGUudHlwZSE9PVwidmFsdWUtY29tbWVudFwifHxldCYmZXQudmFsdWUmJmV0LnZhbHVlLmluZGV4T2YoXCJcXFxcXCIpPT09ZXQudmFsdWUubGVuZ3RoLTEmJlJlLnR5cGU9PT1cInZhbHVlLW9wZXJhdG9yXCImJlJlLnZhbHVlPT09XCIvXCJ8fFJlLnZhbHVlPT09XCJcXFxcXCJ8fGRlKFJlLEhlKXx8eGUoUmUpfHx3ZShSZSl8fGZlKEhlKXx8d2UoSGUpJiZLKEhlKXx8ZmUoUmUpJiZLKEhlKXx8UmUudmFsdWU9PT1cIi0tXCImJnhlKEhlKSljb250aW51ZTtsZXQgUW49VyhSZSksWm49VyhIZSk7aWYoKFFuJiZ4ZShIZSl8fFpuJiZmZShSZSkpJiZLKEhlKXx8IWV0JiZHKFJlKXx8eShBZSxcImNhbGNcIikmJihyZShSZSl8fHJlKEhlKXx8JChSZSl8fCQoSGUpKSYmSyhIZSkpY29udGludWU7bGV0IEVvPShyZShSZSl8fCQoUmUpKSYmdXQ9PT0wJiYoSGUudHlwZT09PVwidmFsdWUtbnVtYmVyXCJ8fEhlLmlzSGV4KSYmcWUmJmhlKHFlKSYmIUsoSGUpLGV1PVp0JiZadC50eXBlPT09XCJ2YWx1ZS1mdW5jXCJ8fFp0JiZwZShadCl8fFJlLnR5cGU9PT1cInZhbHVlLWZ1bmNcInx8cGUoUmUpLHR1PUhlLnR5cGU9PT1cInZhbHVlLWZ1bmNcInx8cGUoSGUpfHxldCYmZXQudHlwZT09PVwidmFsdWUtZnVuY1wifHxldCYmcGUoZXQpO2lmKCEoIShQKEhlKXx8UChSZSkpJiYheShBZSxcImNhbGNcIikmJiFFbyYmKEcoSGUpJiYhZXV8fEcoUmUpJiYhdHV8fHJlKEhlKSYmIWV1fHxyZShSZSkmJiF0dXx8JChIZSl8fCQoUmUpKSYmKEsoSGUpfHxRbiYmKCFldHx8ZXQmJlcoZXQpKSkpKXtpZih2ZShSZSkpe2lmKE1lLnR5cGU9PT1cInZhbHVlLXBhcmVuX2dyb3VwXCIpe0RlLnB1c2goTihtKSk7Y29udGludWV9RGUucHVzaChtKTtjb250aW51ZX1pZihjdCYmKEgoSGUpfHxNKEhlKXx8c2UoSGUpfHxlZShSZSl8fFUoUmUpKSl7RGUucHVzaChcIiBcIik7Y29udGludWV9aWYoWmUmJlplLm5hbWUudG9Mb3dlckNhc2UoKT09PVwibmFtZXNwYWNlXCIpe0RlLnB1c2goXCIgXCIpO2NvbnRpbnVlfWlmKHJ0KXtSZS5zb3VyY2UmJkhlLnNvdXJjZSYmUmUuc291cmNlLnN0YXJ0LmxpbmUhPT1IZS5zb3VyY2Uuc3RhcnQubGluZT8oRGUucHVzaChtKSwkZT0hMCk6RGUucHVzaChcIiBcIik7Y29udGludWV9aWYoWm4pe0RlLnB1c2goXCIgXCIpO2NvbnRpbnVlfWlmKCEoSGUmJkhlLnZhbHVlPT09XCIuLi5cIikmJiEoeWUoUmUpJiZ5ZShIZSkmJnooUmUpPT09dGUoSGUpKSl7aWYoeWUoUmUpJiZZKEhlKSYmeihSZSk9PT10ZShIZS5vcGVuKSl7RGUucHVzaChnKTtjb250aW51ZX1pZihSZS52YWx1ZT09PVwid2l0aFwiJiZZKEhlKSl7RGUucHVzaChcIiBcIik7Y29udGludWV9RGUucHVzaChDKX19fXJldHVybiBxdCYmRGUucHVzaChBKSwkZSYmRGUudW5zaGlmdChtKSxjdD9wKGgoRGUpKTpGKEFlKT9wKGYoRGUpKTpwKGgoZihEZSkpKX1jYXNlXCJ2YWx1ZS1wYXJlbl9ncm91cFwiOntsZXQgTWU9QWUuZ2V0UGFyZW50Tm9kZSgpO2lmKE1lJiZuZShNZSkmJihpZS5ncm91cHMubGVuZ3RoPT09MXx8aWUuZ3JvdXBzLmxlbmd0aD4wJiZpZS5ncm91cHNbMF0udHlwZT09PVwidmFsdWUtY29tbWFfZ3JvdXBcIiYmaWUuZ3JvdXBzWzBdLmdyb3Vwcy5sZW5ndGg+MCYmaWUuZ3JvdXBzWzBdLmdyb3Vwc1swXS50eXBlPT09XCJ2YWx1ZS13b3JkXCImJmllLmdyb3Vwc1swXS5ncm91cHNbMF0udmFsdWUuc3RhcnRzV2l0aChcImRhdGE6XCIpKSlyZXR1cm5baWUub3Blbj9QZShcIm9wZW5cIik6XCJcIixsKFwiLFwiLEFlLm1hcChQZSxcImdyb3Vwc1wiKSksaWUuY2xvc2U/UGUoXCJjbG9zZVwiKTpcIlwiXTtpZighaWUub3Blbil7bGV0IGtlPUFlLm1hcChQZSxcImdyb3Vwc1wiKSxXZT1bXTtmb3IobGV0ICRlPTA7JGU8a2UubGVuZ3RoOyRlKyspJGUhPT0wJiZXZS5wdXNoKFtcIixcIixDXSksV2UucHVzaChrZVskZV0pO3JldHVybiBwKGgoZihXZSkpKX1sZXQgcWU9Z2UoQWUpLEplPXQoaWUuZ3JvdXBzKSxydD1KZSYmSmUudHlwZT09PVwidmFsdWUtY29tbWVudFwiLFplPXEoaWUsTWUpLGN0PVgoaWUsTWUpLHF0PWN0fHxxZSYmIVplLEw9Y3R8fFplLERlPXAoW2llLm9wZW4/UGUoXCJvcGVuXCIpOlwiXCIsaChbZyxsKFtDXSxBZS5tYXAoKGtlLFdlKT0+e2xldCAkZT1rZS5nZXRWYWx1ZSgpLHV0PVdlPT09aWUuZ3JvdXBzLmxlbmd0aC0xLGV0PVtQZSgpLHV0P1wiXCI6XCIsXCJdO2lmKEVlKCRlKSYmJGUudHlwZT09PVwidmFsdWUtY29tbWFfZ3JvdXBcIiYmJGUuZ3JvdXBzJiYkZS5ncm91cHNbMF0udHlwZSE9PVwidmFsdWUtcGFyZW5fZ3JvdXBcIiYmJGUuZ3JvdXBzWzJdJiYkZS5ncm91cHNbMl0udHlwZT09PVwidmFsdWUtcGFyZW5fZ3JvdXBcIil7bGV0IFJlPXYoZXRbMF0uY29udGVudHMuY29udGVudHMpO3JldHVybiBSZVsxXT1wKFJlWzFdKSxwKE4oZXQpKX1pZighdXQmJiRlLnR5cGU9PT1cInZhbHVlLWNvbW1hX2dyb3VwXCImJmMoJGUuZ3JvdXBzKSl7bGV0IFJlPXQoJGUuZ3JvdXBzKTtSZS5zb3VyY2UmJmEoT2Uub3JpZ2luYWxUZXh0LFJlLHopJiZldC5wdXNoKG0pfXJldHVybiBldH0sXCJncm91cHNcIikpXSksVCghcnQmJkNlKE9lLnBhcnNlcixPZS5vcmlnaW5hbFRleHQpJiZxZSYmamUoT2UpP1wiLFwiOlwiXCIpLGcsaWUuY2xvc2U/UGUoXCJjbG9zZVwiKTpcIlwiXSx7c2hvdWxkQnJlYWs6cXR9KTtyZXR1cm4gTD9OKERlKTpEZX1jYXNlXCJ2YWx1ZS1mdW5jXCI6cmV0dXJuW2llLnZhbHVlLHgoQWUsXCJzdXBwb3J0c1wiKSYmY2UoaWUpP1wiIFwiOlwiXCIsUGUoXCJncm91cFwiKV07Y2FzZVwidmFsdWUtcGFyZW5cIjpyZXR1cm4gaWUudmFsdWU7Y2FzZVwidmFsdWUtbnVtYmVyXCI6cmV0dXJuW1ZlKGllLnZhbHVlKSxOZShpZS51bml0KV07Y2FzZVwidmFsdWUtb3BlcmF0b3JcIjpyZXR1cm4gaWUudmFsdWU7Y2FzZVwidmFsdWUtd29yZFwiOnJldHVybiBpZS5pc0NvbG9yJiZpZS5pc0hleHx8ayhpZS52YWx1ZSk/aWUudmFsdWUudG9Mb3dlckNhc2UoKTppZS52YWx1ZTtjYXNlXCJ2YWx1ZS1jb2xvblwiOntsZXQgTWU9QWUuZ2V0UGFyZW50Tm9kZSgpLHFlPU1lJiZNZS5ncm91cHMuaW5kZXhPZihpZSksSmU9cWUmJk1lLmdyb3Vwc1txZS0xXTtyZXR1cm5baWUudmFsdWUsSmUmJnR5cGVvZiBKZS52YWx1ZT09XCJzdHJpbmdcIiYmdChKZS52YWx1ZSk9PT1cIlxcXFxcInx8eShBZSxcInVybFwiKT9cIlwiOkNdfWNhc2VcInZhbHVlLWNvbW1hXCI6cmV0dXJuW2llLnZhbHVlLFwiIFwiXTtjYXNlXCJ2YWx1ZS1zdHJpbmdcIjpyZXR1cm4gaShpZS5yYXdzLnF1b3RlK2llLnZhbHVlK2llLnJhd3MucXVvdGUsT2UpO2Nhc2VcInZhbHVlLWF0d29yZFwiOnJldHVybltcIkBcIixpZS52YWx1ZV07Y2FzZVwidmFsdWUtdW5pY29kZS1yYW5nZVwiOnJldHVybiBpZS52YWx1ZTtjYXNlXCJ2YWx1ZS11bmtub3duXCI6cmV0dXJuIGllLnZhbHVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwb3N0Y3NzIHR5cGUgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGllLnR5cGUpKSl9fWZ1bmN0aW9uIHR0KEFlLE9lLFBlKXtsZXQgaWU9W107cmV0dXJuIEFlLmVhY2goKE1lLHFlLEplKT0+e2xldCBydD1KZVtxZS0xXTtpZihydCYmcnQudHlwZT09PVwiY3NzLWNvbW1lbnRcIiYmcnQudGV4dC50cmltKCk9PT1cInByZXR0aWVyLWlnbm9yZVwiKXtsZXQgWmU9TWUuZ2V0VmFsdWUoKTtpZS5wdXNoKE9lLm9yaWdpbmFsVGV4dC5zbGljZSh0ZShaZSkseihaZSkpKX1lbHNlIGllLnB1c2goUGUoKSk7cWUhPT1KZS5sZW5ndGgtMSYmKEplW3FlKzFdLnR5cGU9PT1cImNzcy1jb21tZW50XCImJiFyKE9lLm9yaWdpbmFsVGV4dCx0ZShKZVtxZSsxXSkse2JhY2t3YXJkczohMH0pJiYhdShKZVtxZV0pfHxKZVtxZSsxXS50eXBlPT09XCJjc3MtYXRydWxlXCImJkplW3FlKzFdLm5hbWU9PT1cImVsc2VcIiYmSmVbcWVdLnR5cGUhPT1cImNzcy1jb21tZW50XCI/aWUucHVzaChcIiBcIik6KGllLnB1c2goT2UuX19pc0hUTUxTdHlsZUF0dHJpYnV0ZT9DOm0pLGEoT2Uub3JpZ2luYWxUZXh0LE1lLmdldFZhbHVlKCkseikmJiF1KEplW3FlXSkmJmllLnB1c2gobSkpKX0sXCJub2Rlc1wiKSxpZX12YXIgVGU9LyhbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqXFwxL2dzLF9lPS8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbRWVdWystXT9cXGQrKT8vZyxGZT0vW0EtWmEtel0rL2csS2U9L1skQF0/W0EtWl9hLXpcXHUwMDgwLVxcdUZGRkZdW1xcd1xcdTAwODAtXFx1RkZGRi1dKi9nLFNlPW5ldyBSZWdFeHAoVGUuc291cmNlK1wifChcIi5jb25jYXQoS2Uuc291cmNlLFwiKT8oXCIpLmNvbmNhdChfZS5zb3VyY2UsXCIpKFwiKS5jb25jYXQoRmUuc291cmNlLFwiKT9cIiksXCJnXCIpO2Z1bmN0aW9uIHplKEFlLE9lKXtyZXR1cm4gQWUucmVwbGFjZShUZSxQZT0+aShQZSxPZSkpfWZ1bmN0aW9uIEJlKEFlLE9lKXtsZXQgUGU9T2Uuc2luZ2xlUXVvdGU/XCInXCI6J1wiJztyZXR1cm4gQWUuaW5jbHVkZXMoJ1wiJyl8fEFlLmluY2x1ZGVzKFwiJ1wiKT9BZTpQZStBZStQZX1mdW5jdGlvbiBJZShBZSl7cmV0dXJuIEFlLnJlcGxhY2UoU2UsKE9lLFBlLGllLE1lLHFlKT0+IWllJiZNZT9WZShNZSkrZChxZXx8XCJcIik6T2UpfWZ1bmN0aW9uIFZlKEFlKXtyZXR1cm4gcyhBZSkucmVwbGFjZSgvXFwuMCg/PSR8ZSkvLFwiXCIpfW4uZXhwb3J0cz17cHJpbnQ6VWUsZW1iZWQ6dyxpbnNlcnRQcmFnbWE6SSxtYXNzYWdlQXN0Tm9kZTpCfX19KSx0ZD1aKHtcInNyYy9sYW5ndWFnZS1jc3Mvb3B0aW9ucy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD1MdCgpO24uZXhwb3J0cz17c2luZ2xlUXVvdGU6dC5zaW5nbGVRdW90ZX19fSkscmQ9Wih7XCJzcmMvbGFuZ3VhZ2UtY3NzL3BhcnNlcnMuanNcIigpe2FlKCl9fSksbmQ9Wih7XCJub2RlX21vZHVsZXMvbGluZ3Vpc3QtbGFuZ3VhZ2VzL2RhdGEvQ1NTLmpzb25cIihlLG4pe24uZXhwb3J0cz17bmFtZTpcIkNTU1wiLHR5cGU6XCJtYXJrdXBcIix0bVNjb3BlOlwic291cmNlLmNzc1wiLGFjZU1vZGU6XCJjc3NcIixjb2RlbWlycm9yTW9kZTpcImNzc1wiLGNvZGVtaXJyb3JNaW1lVHlwZTpcInRleHQvY3NzXCIsY29sb3I6XCIjNTYzZDdjXCIsZXh0ZW5zaW9uczpbXCIuY3NzXCJdLGxhbmd1YWdlSWQ6NTB9fX0pLHVkPVooe1wibm9kZV9tb2R1bGVzL2xpbmd1aXN0LWxhbmd1YWdlcy9kYXRhL1Bvc3RDU1MuanNvblwiKGUsbil7bi5leHBvcnRzPXtuYW1lOlwiUG9zdENTU1wiLHR5cGU6XCJtYXJrdXBcIix0bVNjb3BlOlwic291cmNlLnBvc3Rjc3NcIixncm91cDpcIkNTU1wiLGV4dGVuc2lvbnM6W1wiLnBjc3NcIixcIi5wb3N0Y3NzXCJdLGFjZU1vZGU6XCJ0ZXh0XCIsbGFuZ3VhZ2VJZDoyNjI3NjQ0Mzd9fX0pLHNkPVooe1wibm9kZV9tb2R1bGVzL2xpbmd1aXN0LWxhbmd1YWdlcy9kYXRhL0xlc3MuanNvblwiKGUsbil7bi5leHBvcnRzPXtuYW1lOlwiTGVzc1wiLHR5cGU6XCJtYXJrdXBcIixjb2xvcjpcIiMxZDM2NWRcIixleHRlbnNpb25zOltcIi5sZXNzXCJdLHRtU2NvcGU6XCJzb3VyY2UuY3NzLmxlc3NcIixhY2VNb2RlOlwibGVzc1wiLGNvZGVtaXJyb3JNb2RlOlwiY3NzXCIsY29kZW1pcnJvck1pbWVUeXBlOlwidGV4dC9jc3NcIixsYW5ndWFnZUlkOjE5OH19fSksYWQ9Wih7XCJub2RlX21vZHVsZXMvbGluZ3Vpc3QtbGFuZ3VhZ2VzL2RhdGEvU0NTUy5qc29uXCIoZSxuKXtuLmV4cG9ydHM9e25hbWU6XCJTQ1NTXCIsdHlwZTpcIm1hcmt1cFwiLGNvbG9yOlwiI2M2NTM4Y1wiLHRtU2NvcGU6XCJzb3VyY2UuY3NzLnNjc3NcIixhY2VNb2RlOlwic2Nzc1wiLGNvZGVtaXJyb3JNb2RlOlwiY3NzXCIsY29kZW1pcnJvck1pbWVUeXBlOlwidGV4dC94LXNjc3NcIixleHRlbnNpb25zOltcIi5zY3NzXCJdLGxhbmd1YWdlSWQ6MzI5fX19KSxpZD1aKHtcInNyYy9sYW5ndWFnZS1jc3MvaW5kZXguanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9YnQoKSxzPWVkKCksaT10ZCgpLHI9cmQoKSx1PVt0KG5kKCksYz0+KHtzaW5jZTpcIjEuNC4wXCIscGFyc2VyczpbXCJjc3NcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wiY3NzXCJdLGV4dGVuc2lvbnM6Wy4uLmMuZXh0ZW5zaW9ucyxcIi53eHNzXCJdfSkpLHQodWQoKSwoKT0+KHtzaW5jZTpcIjEuNC4wXCIscGFyc2VyczpbXCJjc3NcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wicG9zdGNzc1wiXX0pKSx0KHNkKCksKCk9Pih7c2luY2U6XCIxLjQuMFwiLHBhcnNlcnM6W1wibGVzc1wiXSx2c2NvZGVMYW5ndWFnZUlkczpbXCJsZXNzXCJdfSkpLHQoYWQoKSwoKT0+KHtzaW5jZTpcIjEuNC4wXCIscGFyc2VyczpbXCJzY3NzXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcInNjc3NcIl19KSldLGE9e3Bvc3Rjc3M6c307bi5leHBvcnRzPXtsYW5ndWFnZXM6dSxvcHRpb25zOmkscHJpbnRlcnM6YSxwYXJzZXJzOnJ9fX0pLG9kPVooe1wic3JjL2xhbmd1YWdlLWhhbmRsZWJhcnMvbG9jLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO2Z1bmN0aW9uIHQoaSl7cmV0dXJuIGkubG9jLnN0YXJ0Lm9mZnNldH1mdW5jdGlvbiBzKGkpe3JldHVybiBpLmxvYy5lbmQub2Zmc2V0fW4uZXhwb3J0cz17bG9jU3RhcnQ6dCxsb2NFbmQ6c319fSksY2Q9Wih7XCJzcmMvbGFuZ3VhZ2UtaGFuZGxlYmFycy9jbGVhbi5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KHMsaSl7aWYocy50eXBlPT09XCJUZXh0Tm9kZVwiKXtsZXQgcj1zLmNoYXJzLnRyaW0oKTtpZighcilyZXR1cm4gbnVsbDtpLmNoYXJzPXIucmVwbGFjZSgvW1xcdFxcblxcZlxcciBdKy9nLFwiIFwiKX1zLnR5cGU9PT1cIkF0dHJOb2RlXCImJnMubmFtZS50b0xvd2VyQ2FzZSgpPT09XCJjbGFzc1wiJiZkZWxldGUgaS52YWx1ZX10Lmlnbm9yZWRQcm9wZXJ0aWVzPW5ldyBTZXQoW1wibG9jXCIsXCJzZWxmQ2xvc2luZ1wiXSksbi5leHBvcnRzPXR9fSksbGQ9Wih7XCJ2ZW5kb3JzL2h0bWwtdm9pZC1lbGVtZW50cy5qc29uXCIoZSxuKXtuLmV4cG9ydHM9e2h0bWxWb2lkRWxlbWVudHM6W1wiYXJlYVwiLFwiYmFzZVwiLFwiYmFzZWZvbnRcIixcImJnc291bmRcIixcImJyXCIsXCJjb2xcIixcImNvbW1hbmRcIixcImVtYmVkXCIsXCJmcmFtZVwiLFwiaHJcIixcImltYWdlXCIsXCJpbWdcIixcImlucHV0XCIsXCJpc2luZGV4XCIsXCJrZXlnZW5cIixcImxpbmtcIixcIm1lbnVpdGVtXCIsXCJtZXRhXCIsXCJuZXh0aWRcIixcInBhcmFtXCIsXCJzb3VyY2VcIixcInRyYWNrXCIsXCJ3YnJcIl19fX0pLHBkPVooe1wic3JjL2xhbmd1YWdlLWhhbmRsZWJhcnMvdXRpbHMuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2h0bWxWb2lkRWxlbWVudHM6dH09bGQoKSxzPXN0KCk7ZnVuY3Rpb24gaShiKXtsZXQgdj1iLmdldFZhbHVlKCksQj1iLmdldFBhcmVudE5vZGUoMCk7cmV0dXJuISEobShiLFtcIkVsZW1lbnROb2RlXCJdKSYmcyhCLmNoaWxkcmVuKT09PXZ8fG0oYixbXCJCbG9ja1wiXSkmJnMoQi5ib2R5KT09PXYpfWZ1bmN0aW9uIHIoYil7cmV0dXJuIGIudG9VcHBlckNhc2UoKT09PWJ9ZnVuY3Rpb24gdShiKXtyZXR1cm4gQyhiLFtcIkVsZW1lbnROb2RlXCJdKSYmdHlwZW9mIGIudGFnPT1cInN0cmluZ1wiJiZiLnRhZ1swXSE9PVwiOlwiJiYocihiLnRhZ1swXSl8fGIudGFnLmluY2x1ZGVzKFwiLlwiKSl9dmFyIGE9bmV3IFNldCh0KTtmdW5jdGlvbiBjKGIpe3JldHVybiB1KGIpJiZiLmNoaWxkcmVuLmV2ZXJ5KHY9PmwodikpfHxhLmhhcyhiLnRhZyl9ZnVuY3Rpb24gbChiKXtyZXR1cm4gQyhiLFtcIlRleHROb2RlXCJdKSYmIS9cXFMvLnRlc3QoYi5jaGFycyl9ZnVuY3Rpb24gQyhiLHYpe3JldHVybiBiJiZ2LmluY2x1ZGVzKGIudHlwZSl9ZnVuY3Rpb24gbShiLHYpe2xldCBCPWIuZ2V0UGFyZW50Tm9kZSgwKTtyZXR1cm4gQyhCLHYpfWZ1bmN0aW9uIGcoYix2KXtsZXQgQj1oKGIpO3JldHVybiBDKEIsdil9ZnVuY3Rpb24gcChiLHYpe2xldCBCPU4oYik7cmV0dXJuIEMoQix2KX1mdW5jdGlvbiBmKGIsdil7bGV0IEI9Yi5nZXRWYWx1ZSgpLHc9Yi5nZXRQYXJlbnROb2RlKDApfHx7fSxJPXcuY2hpbGRyZW58fHcuYm9keXx8dy5wYXJ0c3x8W10sRT1JLmluZGV4T2YoQik7cmV0dXJuIEUhPT0tMSYmSVtFK3ZdfWZ1bmN0aW9uIGgoYil7bGV0IHY9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOjE7cmV0dXJuIGYoYiwtdil9ZnVuY3Rpb24gTihiKXtyZXR1cm4gZihiLDEpfWZ1bmN0aW9uIFQoYil7cmV0dXJuIEMoYixbXCJNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnRcIl0pJiZ0eXBlb2YgYi52YWx1ZT09XCJzdHJpbmdcIiYmYi52YWx1ZS50cmltKCk9PT1cInByZXR0aWVyLWlnbm9yZVwifWZ1bmN0aW9uIEEoYil7bGV0IHY9Yi5nZXRWYWx1ZSgpLEI9aChiLDIpO3JldHVybiBUKHYpfHxUKEIpfW4uZXhwb3J0cz17Z2V0TmV4dE5vZGU6TixnZXRQcmV2aW91c05vZGU6aCxoYXNQcmV0dGllcklnbm9yZTpBLGlzTGFzdE5vZGVPZlNpYmxpbmdzOmksaXNOZXh0Tm9kZU9mU29tZVR5cGU6cCxpc05vZGVPZlNvbWVUeXBlOkMsaXNQYXJlbnRPZlNvbWVUeXBlOm0saXNQcmV2aW91c05vZGVPZlNvbWVUeXBlOmcsaXNWb2lkOmMsaXNXaGl0ZXNwYWNlTm9kZTpsfX19KSxmZD1aKHtcInNyYy9sYW5ndWFnZS1oYW5kbGViYXJzL3ByaW50ZXItZ2xpbW1lci5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7YnVpbGRlcnM6e2RlZGVudDp0LGZpbGw6cyxncm91cDppLGhhcmRsaW5lOnIsaWZCcmVhazp1LGluZGVudDphLGpvaW46YyxsaW5lOmwsc29mdGxpbmU6Q30sdXRpbHM6e2dldERvY1BhcnRzOm0scmVwbGFjZVRleHRFbmRPZkxpbmU6Z319PUxlKCkse2dldFByZWZlcnJlZFF1b3RlOnAsaXNOb25FbXB0eUFycmF5OmZ9PUdlKCkse2xvY1N0YXJ0OmgsbG9jRW5kOk59PW9kKCksVD1jZCgpLHtnZXROZXh0Tm9kZTpBLGdldFByZXZpb3VzTm9kZTpiLGhhc1ByZXR0aWVySWdub3JlOnYsaXNMYXN0Tm9kZU9mU2libGluZ3M6Qixpc05leHROb2RlT2ZTb21lVHlwZTp3LGlzTm9kZU9mU29tZVR5cGU6SSxpc1BhcmVudE9mU29tZVR5cGU6RSxpc1ByZXZpb3VzTm9kZU9mU29tZVR5cGU6RCxpc1ZvaWQ6ZCxpc1doaXRlc3BhY2VOb2RlOnl9PXBkKCksbz0yO2Z1bmN0aW9uIHgoSix5ZSxYKXtsZXQgWT1KLmdldFZhbHVlKCk7aWYoIVkpcmV0dXJuXCJcIjtpZih2KEopKXJldHVybiB5ZS5vcmlnaW5hbFRleHQuc2xpY2UoaChZKSxOKFkpKTtsZXQgdGU9eWUuc2luZ2xlUXVvdGU/XCInXCI6J1wiJztzd2l0Y2goWS50eXBlKXtjYXNlXCJCbG9ja1wiOmNhc2VcIlByb2dyYW1cIjpjYXNlXCJUZW1wbGF0ZVwiOnJldHVybiBpKEoubWFwKFgsXCJib2R5XCIpKTtjYXNlXCJFbGVtZW50Tm9kZVwiOntsZXQgej1pKFMoSixYKSksaj15ZS5odG1sV2hpdGVzcGFjZVNlbnNpdGl2aXR5PT09XCJpZ25vcmVcIiYmdyhKLFtcIkVsZW1lbnROb2RlXCJdKT9DOlwiXCI7aWYoZChZKSlyZXR1cm5beixqXTtsZXQgQ2U9W1wiPC9cIixZLnRhZyxcIj5cIl07cmV0dXJuIFkuY2hpbGRyZW4ubGVuZ3RoPT09MD9beixhKENlKSxqXTp5ZS5odG1sV2hpdGVzcGFjZVNlbnNpdGl2aXR5PT09XCJpZ25vcmVcIj9beixhKGsoSix5ZSxYKSkscixhKENlKSxqXTpbeixhKGkoayhKLHllLFgpKSksYShDZSksal19Y2FzZVwiQmxvY2tTdGF0ZW1lbnRcIjp7bGV0IHo9Si5nZXRQYXJlbnROb2RlKDEpO3JldHVybiB6JiZ6LmludmVyc2UmJnouaW52ZXJzZS5ib2R5Lmxlbmd0aD09PTEmJnouaW52ZXJzZS5ib2R5WzBdPT09WSYmei5pbnZlcnNlLmJvZHlbMF0ucGF0aC5wYXJ0c1swXT09PVwiaWZcIj9bVShKLFgpLEsoSixYLHllKSxFZShKLFgseWUpXTpbVyhKLFgpLGkoW0soSixYLHllKSxFZShKLFgseWUpLG5lKEosWCx5ZSldKV19Y2FzZVwiRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50XCI6cmV0dXJuIGkoW1wie3tcIixwZShKLFgpLFwifX1cIl0pO2Nhc2VcIk11c3RhY2hlU3RhdGVtZW50XCI6cmV0dXJuIGkoW08oWSkscGUoSixYKSxSKFkpXSk7Y2FzZVwiU3ViRXhwcmVzc2lvblwiOnJldHVybiBpKFtcIihcIixmZShKLFgpLEMsXCIpXCJdKTtjYXNlXCJBdHRyTm9kZVwiOntsZXQgej1ZLnZhbHVlLnR5cGU9PT1cIlRleHROb2RlXCI7aWYoeiYmWS52YWx1ZS5jaGFycz09PVwiXCImJmgoWS52YWx1ZSk9PT1OKFkudmFsdWUpKXJldHVybiBZLm5hbWU7bGV0IENlPXo/cChZLnZhbHVlLmNoYXJzLHRlKS5xdW90ZTpZLnZhbHVlLnR5cGU9PT1cIkNvbmNhdFN0YXRlbWVudFwiP3AoWS52YWx1ZS5wYXJ0cy5maWx0ZXIoamU9PmplLnR5cGU9PT1cIlRleHROb2RlXCIpLm1hcChqZT0+amUuY2hhcnMpLmpvaW4oXCJcIiksdGUpLnF1b3RlOlwiXCIsTmU9WChcInZhbHVlXCIpO3JldHVybltZLm5hbWUsXCI9XCIsQ2UsWS5uYW1lPT09XCJjbGFzc1wiJiZDZT9pKGEoTmUpKTpOZSxDZV19Y2FzZVwiQ29uY2F0U3RhdGVtZW50XCI6cmV0dXJuIEoubWFwKFgsXCJwYXJ0c1wiKTtjYXNlXCJIYXNoXCI6cmV0dXJuIGMobCxKLm1hcChYLFwicGFpcnNcIikpO2Nhc2VcIkhhc2hQYWlyXCI6cmV0dXJuW1kua2V5LFwiPVwiLFgoXCJ2YWx1ZVwiKV07Y2FzZVwiVGV4dE5vZGVcIjp7bGV0IHo9WS5jaGFycy5yZXBsYWNlKC97ey9nLFwiXFxcXHt7XCIpLGo9dWUoSik7aWYoail7aWYoaj09PVwiY2xhc3NcIil7bGV0IFNlPXoudHJpbSgpLnNwbGl0KC9cXHMrLykuam9pbihcIiBcIiksemU9ITEsQmU9ITE7cmV0dXJuIEUoSixbXCJDb25jYXRTdGF0ZW1lbnRcIl0pJiYoRChKLFtcIk11c3RhY2hlU3RhdGVtZW50XCJdKSYmL15cXHMvLnRlc3QoeikmJih6ZT0hMCksdyhKLFtcIk11c3RhY2hlU3RhdGVtZW50XCJdKSYmL1xccyQvLnRlc3QoeikmJlNlIT09XCJcIiYmKEJlPSEwKSksW3plP2w6XCJcIixTZSxCZT9sOlwiXCJdfXJldHVybiBnKHopfWxldCBOZT0vXltcXHRcXG5cXGZcXHIgXSokLy50ZXN0KHopLGplPSFiKEopLFVlPSFBKEopO2lmKHllLmh0bWxXaGl0ZXNwYWNlU2Vuc2l0aXZpdHkhPT1cImlnbm9yZVwiKXtsZXQgU2U9L15bXFx0XFxuXFxmXFxyIF0qLyx6ZT0vW1xcdFxcblxcZlxcciBdKiQvLEJlPVVlJiZFKEosW1wiVGVtcGxhdGVcIl0pLEllPWplJiZFKEosW1wiVGVtcGxhdGVcIl0pO2lmKE5lKXtpZihJZXx8QmUpcmV0dXJuXCJcIjtsZXQgaWU9W2xdLE1lPVEoeik7cmV0dXJuIE1lJiYoaWU9dmUoTWUpKSxCKEopJiYoaWU9aWUubWFwKHFlPT50KHFlKSkpLGllfWxldFtWZV09ei5tYXRjaChTZSksW0FlXT16Lm1hdGNoKHplKSxPZT1bXTtpZihWZSl7T2U9W2xdO2xldCBpZT1RKFZlKTtpZSYmKE9lPXZlKGllKSksej16LnJlcGxhY2UoU2UsXCJcIil9bGV0IFBlPVtdO2lmKEFlKXtpZighQmUpe1BlPVtsXTtsZXQgaWU9UShBZSk7aWUmJihQZT12ZShpZSkpLEIoSikmJihQZT1QZS5tYXAoTWU9PnQoTWUpKSl9ej16LnJlcGxhY2UoemUsXCJcIil9cmV0dXJuWy4uLk9lLHMocSh6KSksLi4uUGVdfWxldCB0dD1RKHopLFRlPWRlKHopLF9lPWdlKHopO2lmKChqZXx8VWUpJiZOZSYmRShKLFtcIkJsb2NrXCIsXCJFbGVtZW50Tm9kZVwiLFwiVGVtcGxhdGVcIl0pKXJldHVyblwiXCI7TmUmJnR0PyhUZT1NYXRoLm1pbih0dCxvKSxfZT0wKToodyhKLFtcIkJsb2NrU3RhdGVtZW50XCIsXCJFbGVtZW50Tm9kZVwiXSkmJihfZT1NYXRoLm1heChfZSwxKSksRChKLFtcIkJsb2NrU3RhdGVtZW50XCIsXCJFbGVtZW50Tm9kZVwiXSkmJihUZT1NYXRoLm1heChUZSwxKSkpO2xldCBGZT1cIlwiLEtlPVwiXCI7cmV0dXJuIF9lPT09MCYmdyhKLFtcIk11c3RhY2hlU3RhdGVtZW50XCJdKSYmKEtlPVwiIFwiKSxUZT09PTAmJkQoSixbXCJNdXN0YWNoZVN0YXRlbWVudFwiXSkmJihGZT1cIiBcIiksamUmJihUZT0wLEZlPVwiXCIpLFVlJiYoX2U9MCxLZT1cIlwiKSx6PXoucmVwbGFjZSgvXltcXHRcXG5cXGZcXHIgXSsvZyxGZSkucmVwbGFjZSgvW1xcdFxcblxcZlxcciBdKyQvLEtlKSxbLi4udmUoVGUpLHMocSh6KSksLi4udmUoX2UpXX1jYXNlXCJNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnRcIjp7bGV0IHo9aChZKSxqPU4oWSksQ2U9eWUub3JpZ2luYWxUZXh0LmNoYXJBdCh6KzIpPT09XCJ+XCIsTmU9eWUub3JpZ2luYWxUZXh0LmNoYXJBdChqLTMpPT09XCJ+XCIsamU9WS52YWx1ZS5pbmNsdWRlcyhcIn19XCIpP1wiLS1cIjpcIlwiO3JldHVybltcInt7XCIsQ2U/XCJ+XCI6XCJcIixcIiFcIixqZSxZLnZhbHVlLGplLE5lP1wiflwiOlwiXCIsXCJ9fVwiXX1jYXNlXCJQYXRoRXhwcmVzc2lvblwiOnJldHVybiBZLm9yaWdpbmFsO2Nhc2VcIkJvb2xlYW5MaXRlcmFsXCI6cmV0dXJuIFN0cmluZyhZLnZhbHVlKTtjYXNlXCJDb21tZW50U3RhdGVtZW50XCI6cmV0dXJuW1wiPCEtLVwiLFkudmFsdWUsXCItLT5cIl07Y2FzZVwiU3RyaW5nTGl0ZXJhbFwiOntpZih3ZShKKSl7bGV0IHo9eWUuc2luZ2xlUXVvdGU/J1wiJzpcIidcIjtyZXR1cm4geGUoWS52YWx1ZSx6KX1yZXR1cm4geGUoWS52YWx1ZSx0ZSl9Y2FzZVwiTnVtYmVyTGl0ZXJhbFwiOnJldHVybiBTdHJpbmcoWS52YWx1ZSk7Y2FzZVwiVW5kZWZpbmVkTGl0ZXJhbFwiOnJldHVyblwidW5kZWZpbmVkXCI7Y2FzZVwiTnVsbExpdGVyYWxcIjpyZXR1cm5cIm51bGxcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVua25vd24gZ2xpbW1lciB0eXBlOiBcIitKU09OLnN0cmluZ2lmeShZLnR5cGUpKX19ZnVuY3Rpb24gRihKLHllKXtyZXR1cm4gaChKKS1oKHllKX1mdW5jdGlvbiBTKEoseWUpe2xldCBYPUouZ2V0VmFsdWUoKSxZPVtcImF0dHJpYnV0ZXNcIixcIm1vZGlmaWVyc1wiLFwiY29tbWVudHNcIl0uZmlsdGVyKHo9PmYoWFt6XSkpLHRlPVkuZmxhdE1hcCh6PT5YW3pdKS5zb3J0KEYpO2ZvcihsZXQgeiBvZiBZKUouZWFjaChqPT57bGV0IENlPXRlLmluZGV4T2Yoai5nZXRWYWx1ZSgpKTt0ZS5zcGxpY2UoQ2UsMSxbbCx5ZSgpXSl9LHopO3JldHVybiBmKFguYmxvY2tQYXJhbXMpJiZ0ZS5wdXNoKGwsaGUoWCkpLFtcIjxcIixYLnRhZyxhKHRlKSxfKFgpXX1mdW5jdGlvbiBrKEoseWUsWCl7bGV0IHRlPUouZ2V0VmFsdWUoKS5jaGlsZHJlbi5ldmVyeSh6PT55KHopKTtyZXR1cm4geWUuaHRtbFdoaXRlc3BhY2VTZW5zaXRpdml0eT09PVwiaWdub3JlXCImJnRlP1wiXCI6Si5tYXAoKHosaik9PntsZXQgQ2U9WCgpO3JldHVybiBqPT09MCYmeWUuaHRtbFdoaXRlc3BhY2VTZW5zaXRpdml0eT09PVwiaWdub3JlXCI/W0MsQ2VdOkNlfSxcImNoaWxkcmVuXCIpfWZ1bmN0aW9uIF8oSil7cmV0dXJuIGQoSik/dShbQyxcIi8+XCJdLFtcIiAvPlwiLENdKTp1KFtDLFwiPlwiXSxcIj5cIil9ZnVuY3Rpb24gTyhKKXtsZXQgeWU9Si5lc2NhcGVkPT09ITE/XCJ7e3tcIjpcInt7XCIsWD1KLnN0cmlwJiZKLnN0cmlwLm9wZW4/XCJ+XCI6XCJcIjtyZXR1cm5beWUsWF19ZnVuY3Rpb24gUihKKXtsZXQgeWU9Si5lc2NhcGVkPT09ITE/XCJ9fX1cIjpcIn19XCI7cmV0dXJuW0ouc3RyaXAmJkouc3RyaXAuY2xvc2U/XCJ+XCI6XCJcIix5ZV19ZnVuY3Rpb24gTShKKXtsZXQgeWU9TyhKKSxYPUoub3BlblN0cmlwLm9wZW4/XCJ+XCI6XCJcIjtyZXR1cm5beWUsWCxcIiNcIl19ZnVuY3Rpb24gSChKKXtsZXQgeWU9UihKKTtyZXR1cm5bSi5vcGVuU3RyaXAuY2xvc2U/XCJ+XCI6XCJcIix5ZV19ZnVuY3Rpb24gUChKKXtsZXQgeWU9TyhKKSxYPUouY2xvc2VTdHJpcC5vcGVuP1wiflwiOlwiXCI7cmV0dXJuW3llLFgsXCIvXCJdfWZ1bmN0aW9uIEcoSil7bGV0IHllPVIoSik7cmV0dXJuW0ouY2xvc2VTdHJpcC5jbG9zZT9cIn5cIjpcIlwiLHllXX1mdW5jdGlvbiByZShKKXtsZXQgeWU9TyhKKSxYPUouaW52ZXJzZVN0cmlwLm9wZW4/XCJ+XCI6XCJcIjtyZXR1cm5beWUsWF19ZnVuY3Rpb24gJChKKXtsZXQgeWU9UihKKTtyZXR1cm5bSi5pbnZlcnNlU3RyaXAuY2xvc2U/XCJ+XCI6XCJcIix5ZV19ZnVuY3Rpb24gVyhKLHllKXtsZXQgWD1KLmdldFZhbHVlKCksWT1NKFgpLHRlPUgoWCksej1bbWUoSix5ZSldLGo9Y2UoSix5ZSk7aWYoaiYmei5wdXNoKGwsaiksZihYLnByb2dyYW0uYmxvY2tQYXJhbXMpKXtsZXQgQ2U9aGUoWC5wcm9ncmFtKTt6LnB1c2gobCxDZSl9cmV0dXJuIGkoW1ksYSh6KSxDLHRlXSl9ZnVuY3Rpb24gZWUoSix5ZSl7cmV0dXJuW3llLmh0bWxXaGl0ZXNwYWNlU2Vuc2l0aXZpdHk9PT1cImlnbm9yZVwiP3I6XCJcIixyZShKKSxcImVsc2VcIiwkKEopXX1mdW5jdGlvbiBVKEoseWUpe2xldCBYPUouZ2V0UGFyZW50Tm9kZSgxKTtyZXR1cm5bcmUoWCksXCJlbHNlIGlmIFwiLGNlKEoseWUpLCQoWCldfWZ1bmN0aW9uIG5lKEoseWUsWCl7bGV0IFk9Si5nZXRWYWx1ZSgpO3JldHVybiBYLmh0bWxXaGl0ZXNwYWNlU2Vuc2l0aXZpdHk9PT1cImlnbm9yZVwiP1tzZShZKT9DOnIsUChZKSx5ZShcInBhdGhcIiksRyhZKV06W1AoWSkseWUoXCJwYXRoXCIpLEcoWSldfWZ1bmN0aW9uIHNlKEope3JldHVybiBJKEosW1wiQmxvY2tTdGF0ZW1lbnRcIl0pJiZKLnByb2dyYW0uYm9keS5ldmVyeSh5ZT0+eSh5ZSkpfWZ1bmN0aW9uIFYoSil7cmV0dXJuIG9lKEopJiZKLmludmVyc2UuYm9keS5sZW5ndGg9PT0xJiZJKEouaW52ZXJzZS5ib2R5WzBdLFtcIkJsb2NrU3RhdGVtZW50XCJdKSYmSi5pbnZlcnNlLmJvZHlbMF0ucGF0aC5wYXJ0c1swXT09PVwiaWZcIn1mdW5jdGlvbiBvZShKKXtyZXR1cm4gSShKLFtcIkJsb2NrU3RhdGVtZW50XCJdKSYmSi5pbnZlcnNlfWZ1bmN0aW9uIEsoSix5ZSxYKXtsZXQgWT1KLmdldFZhbHVlKCk7aWYoc2UoWSkpcmV0dXJuXCJcIjtsZXQgdGU9eWUoXCJwcm9ncmFtXCIpO3JldHVybiBYLmh0bWxXaGl0ZXNwYWNlU2Vuc2l0aXZpdHk9PT1cImlnbm9yZVwiP2EoW3IsdGVdKTphKHRlKX1mdW5jdGlvbiBFZShKLHllLFgpe2xldCBZPUouZ2V0VmFsdWUoKSx0ZT15ZShcImludmVyc2VcIiksej1YLmh0bWxXaGl0ZXNwYWNlU2Vuc2l0aXZpdHk9PT1cImlnbm9yZVwiP1tyLHRlXTp0ZTtyZXR1cm4gVihZKT96Om9lKFkpP1tlZShZLFgpLGEoeildOlwiXCJ9ZnVuY3Rpb24gcShKKXtyZXR1cm4gbShjKGwsbGUoSikpKX1mdW5jdGlvbiBsZShKKXtyZXR1cm4gSi5zcGxpdCgvW1xcdFxcblxcZlxcciBdKy8pfWZ1bmN0aW9uIHVlKEope2ZvcihsZXQgeWU9MDt5ZTwyO3llKyspe2xldCBYPUouZ2V0UGFyZW50Tm9kZSh5ZSk7aWYoWCYmWC50eXBlPT09XCJBdHRyTm9kZVwiKXJldHVybiBYLm5hbWUudG9Mb3dlckNhc2UoKX19ZnVuY3Rpb24gUShKKXtyZXR1cm4gSj10eXBlb2YgSj09XCJzdHJpbmdcIj9KOlwiXCIsSi5zcGxpdChgXG5gKS5sZW5ndGgtMX1mdW5jdGlvbiBkZShKKXtKPXR5cGVvZiBKPT1cInN0cmluZ1wiP0o6XCJcIjtsZXQgeWU9KEoubWF0Y2goL14oW15cXFNcXG5cXHJdKltcXG5cXHJdKSsvZyl8fFtdKVswXXx8XCJcIjtyZXR1cm4gUSh5ZSl9ZnVuY3Rpb24gZ2UoSil7Sj10eXBlb2YgSj09XCJzdHJpbmdcIj9KOlwiXCI7bGV0IHllPShKLm1hdGNoKC8oW1xcblxccl1bXlxcU1xcblxccl0qKSskL2cpfHxbXSlbMF18fFwiXCI7cmV0dXJuIFEoeWUpfWZ1bmN0aW9uIHZlKCl7bGV0IEo9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT12b2lkIDA/YXJndW1lbnRzWzBdOjA7cmV0dXJuIEFycmF5LmZyb20oe2xlbmd0aDpNYXRoLm1pbihKLG8pfSkuZmlsbChyKX1mdW5jdGlvbiB4ZShKLHllKXtsZXR7cXVvdGU6WCxyZWdleDpZfT1wKEoseWUpO3JldHVybltYLEoucmVwbGFjZShZLFwiXFxcXFwiLmNvbmNhdChYKSksWF19ZnVuY3Rpb24gd2UoSil7bGV0IHllPTAsWD1KLmdldFBhcmVudE5vZGUoeWUpO2Zvcig7WCYmSShYLFtcIlN1YkV4cHJlc3Npb25cIl0pOyl5ZSsrLFg9Si5nZXRQYXJlbnROb2RlKHllKTtyZXR1cm4hIShYJiZJKEouZ2V0UGFyZW50Tm9kZSh5ZSsxKSxbXCJDb25jYXRTdGF0ZW1lbnRcIl0pJiZJKEouZ2V0UGFyZW50Tm9kZSh5ZSsyKSxbXCJBdHRyTm9kZVwiXSkpfWZ1bmN0aW9uIGZlKEoseWUpe2xldCBYPW1lKEoseWUpLFk9Y2UoSix5ZSk7cmV0dXJuIFk/YShbWCxsLGkoWSldKTpYfWZ1bmN0aW9uIHBlKEoseWUpe2xldCBYPW1lKEoseWUpLFk9Y2UoSix5ZSk7cmV0dXJuIFk/W2EoW1gsbCxZXSksQ106WH1mdW5jdGlvbiBtZShKLHllKXtyZXR1cm4geWUoXCJwYXRoXCIpfWZ1bmN0aW9uIGNlKEoseWUpe2xldCBYPUouZ2V0VmFsdWUoKSxZPVtdO2lmKFgucGFyYW1zLmxlbmd0aD4wKXtsZXQgdGU9Si5tYXAoeWUsXCJwYXJhbXNcIik7WS5wdXNoKC4uLnRlKX1pZihYLmhhc2gmJlguaGFzaC5wYWlycy5sZW5ndGg+MCl7bGV0IHRlPXllKFwiaGFzaFwiKTtZLnB1c2godGUpfXJldHVybiBZLmxlbmd0aD09PTA/XCJcIjpjKGwsWSl9ZnVuY3Rpb24gaGUoSil7cmV0dXJuW1wiYXMgfFwiLEouYmxvY2tQYXJhbXMuam9pbihcIiBcIiksXCJ8XCJdfW4uZXhwb3J0cz17cHJpbnQ6eCxtYXNzYWdlQXN0Tm9kZTpUfX19KSxEZD1aKHtcInNyYy9sYW5ndWFnZS1oYW5kbGViYXJzL3BhcnNlcnMuanNcIigpe2FlKCl9fSksbWQ9Wih7XCJub2RlX21vZHVsZXMvbGluZ3Vpc3QtbGFuZ3VhZ2VzL2RhdGEvSGFuZGxlYmFycy5qc29uXCIoZSxuKXtuLmV4cG9ydHM9e25hbWU6XCJIYW5kbGViYXJzXCIsdHlwZTpcIm1hcmt1cFwiLGNvbG9yOlwiI2Y3OTMxZVwiLGFsaWFzZXM6W1wiaGJzXCIsXCJodG1sYmFyc1wiXSxleHRlbnNpb25zOltcIi5oYW5kbGViYXJzXCIsXCIuaGJzXCJdLHRtU2NvcGU6XCJ0ZXh0Lmh0bWwuaGFuZGxlYmFyc1wiLGFjZU1vZGU6XCJoYW5kbGViYXJzXCIsbGFuZ3VhZ2VJZDoxNTV9fX0pLGRkPVooe1wic3JjL2xhbmd1YWdlLWhhbmRsZWJhcnMvaW5kZXguanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9YnQoKSxzPWZkKCksaT1EZCgpLHI9W3QobWQoKSwoKT0+KHtzaW5jZTpcIjIuMy4wXCIscGFyc2VyczpbXCJnbGltbWVyXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcImhhbmRsZWJhcnNcIl19KSldLHU9e2dsaW1tZXI6c307bi5leHBvcnRzPXtsYW5ndWFnZXM6cixwcmludGVyczp1LHBhcnNlcnM6aX19fSksZ2Q9Wih7XCJzcmMvbGFuZ3VhZ2UtZ3JhcGhxbC9wcmFnbWEuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7ZnVuY3Rpb24gdChpKXtyZXR1cm4vXlxccyojW15cXFNcXG5dKkAoPzpmb3JtYXR8cHJldHRpZXIpXFxzKig/OlxcbnwkKS8udGVzdChpKX1mdW5jdGlvbiBzKGkpe3JldHVybmAjIEBmb3JtYXRcblxuYCtpfW4uZXhwb3J0cz17aGFzUHJhZ21hOnQsaW5zZXJ0UHJhZ21hOnN9fX0pLHlkPVooe1wic3JjL2xhbmd1YWdlLWdyYXBocWwvbG9jLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO2Z1bmN0aW9uIHQoaSl7cmV0dXJuIHR5cGVvZiBpLnN0YXJ0PT1cIm51bWJlclwiP2kuc3RhcnQ6aS5sb2MmJmkubG9jLnN0YXJ0fWZ1bmN0aW9uIHMoaSl7cmV0dXJuIHR5cGVvZiBpLmVuZD09XCJudW1iZXJcIj9pLmVuZDppLmxvYyYmaS5sb2MuZW5kfW4uZXhwb3J0cz17bG9jU3RhcnQ6dCxsb2NFbmQ6c319fSksaGQ9Wih7XCJzcmMvbGFuZ3VhZ2UtZ3JhcGhxbC9wcmludGVyLWdyYXBocWwuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2J1aWxkZXJzOntqb2luOnQsaGFyZGxpbmU6cyxsaW5lOmksc29mdGxpbmU6cixncm91cDp1LGluZGVudDphLGlmQnJlYWs6Y319PUxlKCkse2lzTmV4dExpbmVFbXB0eTpsLGlzTm9uRW1wdHlBcnJheTpDfT1HZSgpLHtpbnNlcnRQcmFnbWE6bX09Z2QoKSx7bG9jU3RhcnQ6Zyxsb2NFbmQ6cH09eWQoKTtmdW5jdGlvbiBmKHcsSSxFKXtsZXQgRD13LmdldFZhbHVlKCk7aWYoIUQpcmV0dXJuXCJcIjtpZih0eXBlb2YgRD09XCJzdHJpbmdcIilyZXR1cm4gRDtzd2l0Y2goRC5raW5kKXtjYXNlXCJEb2N1bWVudFwiOntsZXQgZD1bXTtyZXR1cm4gdy5lYWNoKCh5LG8seCk9PntkLnB1c2goRSgpKSxvIT09eC5sZW5ndGgtMSYmKGQucHVzaChzKSxsKEkub3JpZ2luYWxUZXh0LHkuZ2V0VmFsdWUoKSxwKSYmZC5wdXNoKHMpKX0sXCJkZWZpbml0aW9uc1wiKSxbLi4uZCxzXX1jYXNlXCJPcGVyYXRpb25EZWZpbml0aW9uXCI6e2xldCBkPUkub3JpZ2luYWxUZXh0W2coRCldIT09XCJ7XCIseT1Cb29sZWFuKEQubmFtZSk7cmV0dXJuW2Q/RC5vcGVyYXRpb246XCJcIixkJiZ5P1tcIiBcIixFKFwibmFtZVwiKV06XCJcIixkJiYheSYmQyhELnZhcmlhYmxlRGVmaW5pdGlvbnMpP1wiIFwiOlwiXCIsQyhELnZhcmlhYmxlRGVmaW5pdGlvbnMpP3UoW1wiKFwiLGEoW3IsdChbYyhcIlwiLFwiLCBcIikscl0sdy5tYXAoRSxcInZhcmlhYmxlRGVmaW5pdGlvbnNcIikpXSkscixcIilcIl0pOlwiXCIsaCh3LEUsRCksRC5zZWxlY3Rpb25TZXQ/IWQmJiF5P1wiXCI6XCIgXCI6XCJcIixFKFwic2VsZWN0aW9uU2V0XCIpXX1jYXNlXCJGcmFnbWVudERlZmluaXRpb25cIjpyZXR1cm5bXCJmcmFnbWVudCBcIixFKFwibmFtZVwiKSxDKEQudmFyaWFibGVEZWZpbml0aW9ucyk/dShbXCIoXCIsYShbcix0KFtjKFwiXCIsXCIsIFwiKSxyXSx3Lm1hcChFLFwidmFyaWFibGVEZWZpbml0aW9uc1wiKSldKSxyLFwiKVwiXSk6XCJcIixcIiBvbiBcIixFKFwidHlwZUNvbmRpdGlvblwiKSxoKHcsRSxEKSxcIiBcIixFKFwic2VsZWN0aW9uU2V0XCIpXTtjYXNlXCJTZWxlY3Rpb25TZXRcIjpyZXR1cm5bXCJ7XCIsYShbcyx0KHMsTih3LEksRSxcInNlbGVjdGlvbnNcIikpXSkscyxcIn1cIl07Y2FzZVwiRmllbGRcIjpyZXR1cm4gdShbRC5hbGlhcz9bRShcImFsaWFzXCIpLFwiOiBcIl06XCJcIixFKFwibmFtZVwiKSxELmFyZ3VtZW50cy5sZW5ndGg+MD91KFtcIihcIixhKFtyLHQoW2MoXCJcIixcIiwgXCIpLHJdLE4odyxJLEUsXCJhcmd1bWVudHNcIikpXSkscixcIilcIl0pOlwiXCIsaCh3LEUsRCksRC5zZWxlY3Rpb25TZXQ/XCIgXCI6XCJcIixFKFwic2VsZWN0aW9uU2V0XCIpXSk7Y2FzZVwiTmFtZVwiOnJldHVybiBELnZhbHVlO2Nhc2VcIlN0cmluZ1ZhbHVlXCI6cmV0dXJuIEQuYmxvY2s/WydcIlwiXCInLHMsdChzLEQudmFsdWUucmVwbGFjZSgvXCJcIlwiL2csXCJcXFxcJCZcIikuc3BsaXQoYFxuYCkpLHMsJ1wiXCJcIiddOlsnXCInLEQudmFsdWUucmVwbGFjZSgvW1wiXFxcXF0vZyxcIlxcXFwkJlwiKS5yZXBsYWNlKC9cXG4vZyxcIlxcXFxuXCIpLCdcIiddO2Nhc2VcIkludFZhbHVlXCI6Y2FzZVwiRmxvYXRWYWx1ZVwiOmNhc2VcIkVudW1WYWx1ZVwiOnJldHVybiBELnZhbHVlO2Nhc2VcIkJvb2xlYW5WYWx1ZVwiOnJldHVybiBELnZhbHVlP1widHJ1ZVwiOlwiZmFsc2VcIjtjYXNlXCJOdWxsVmFsdWVcIjpyZXR1cm5cIm51bGxcIjtjYXNlXCJWYXJpYWJsZVwiOnJldHVybltcIiRcIixFKFwibmFtZVwiKV07Y2FzZVwiTGlzdFZhbHVlXCI6cmV0dXJuIHUoW1wiW1wiLGEoW3IsdChbYyhcIlwiLFwiLCBcIikscl0sdy5tYXAoRSxcInZhbHVlc1wiKSldKSxyLFwiXVwiXSk7Y2FzZVwiT2JqZWN0VmFsdWVcIjpyZXR1cm4gdShbXCJ7XCIsSS5icmFja2V0U3BhY2luZyYmRC5maWVsZHMubGVuZ3RoPjA/XCIgXCI6XCJcIixhKFtyLHQoW2MoXCJcIixcIiwgXCIpLHJdLHcubWFwKEUsXCJmaWVsZHNcIikpXSkscixjKFwiXCIsSS5icmFja2V0U3BhY2luZyYmRC5maWVsZHMubGVuZ3RoPjA/XCIgXCI6XCJcIiksXCJ9XCJdKTtjYXNlXCJPYmplY3RGaWVsZFwiOmNhc2VcIkFyZ3VtZW50XCI6cmV0dXJuW0UoXCJuYW1lXCIpLFwiOiBcIixFKFwidmFsdWVcIildO2Nhc2VcIkRpcmVjdGl2ZVwiOnJldHVybltcIkBcIixFKFwibmFtZVwiKSxELmFyZ3VtZW50cy5sZW5ndGg+MD91KFtcIihcIixhKFtyLHQoW2MoXCJcIixcIiwgXCIpLHJdLE4odyxJLEUsXCJhcmd1bWVudHNcIikpXSkscixcIilcIl0pOlwiXCJdO2Nhc2VcIk5hbWVkVHlwZVwiOnJldHVybiBFKFwibmFtZVwiKTtjYXNlXCJWYXJpYWJsZURlZmluaXRpb25cIjpyZXR1cm5bRShcInZhcmlhYmxlXCIpLFwiOiBcIixFKFwidHlwZVwiKSxELmRlZmF1bHRWYWx1ZT9bXCIgPSBcIixFKFwiZGVmYXVsdFZhbHVlXCIpXTpcIlwiLGgodyxFLEQpXTtjYXNlXCJPYmplY3RUeXBlRXh0ZW5zaW9uXCI6Y2FzZVwiT2JqZWN0VHlwZURlZmluaXRpb25cIjpyZXR1cm5bRShcImRlc2NyaXB0aW9uXCIpLEQuZGVzY3JpcHRpb24/czpcIlwiLEQua2luZD09PVwiT2JqZWN0VHlwZUV4dGVuc2lvblwiP1wiZXh0ZW5kIFwiOlwiXCIsXCJ0eXBlIFwiLEUoXCJuYW1lXCIpLEQuaW50ZXJmYWNlcy5sZW5ndGg+MD9bXCIgaW1wbGVtZW50cyBcIiwuLi5iKHcsSSxFKV06XCJcIixoKHcsRSxEKSxELmZpZWxkcy5sZW5ndGg+MD9bXCIge1wiLGEoW3MsdChzLE4odyxJLEUsXCJmaWVsZHNcIikpXSkscyxcIn1cIl06XCJcIl07Y2FzZVwiRmllbGREZWZpbml0aW9uXCI6cmV0dXJuW0UoXCJkZXNjcmlwdGlvblwiKSxELmRlc2NyaXB0aW9uP3M6XCJcIixFKFwibmFtZVwiKSxELmFyZ3VtZW50cy5sZW5ndGg+MD91KFtcIihcIixhKFtyLHQoW2MoXCJcIixcIiwgXCIpLHJdLE4odyxJLEUsXCJhcmd1bWVudHNcIikpXSkscixcIilcIl0pOlwiXCIsXCI6IFwiLEUoXCJ0eXBlXCIpLGgodyxFLEQpXTtjYXNlXCJEaXJlY3RpdmVEZWZpbml0aW9uXCI6cmV0dXJuW0UoXCJkZXNjcmlwdGlvblwiKSxELmRlc2NyaXB0aW9uP3M6XCJcIixcImRpcmVjdGl2ZSBcIixcIkBcIixFKFwibmFtZVwiKSxELmFyZ3VtZW50cy5sZW5ndGg+MD91KFtcIihcIixhKFtyLHQoW2MoXCJcIixcIiwgXCIpLHJdLE4odyxJLEUsXCJhcmd1bWVudHNcIikpXSkscixcIilcIl0pOlwiXCIsRC5yZXBlYXRhYmxlP1wiIHJlcGVhdGFibGVcIjpcIlwiLFwiIG9uIFwiLHQoXCIgfCBcIix3Lm1hcChFLFwibG9jYXRpb25zXCIpKV07Y2FzZVwiRW51bVR5cGVFeHRlbnNpb25cIjpjYXNlXCJFbnVtVHlwZURlZmluaXRpb25cIjpyZXR1cm5bRShcImRlc2NyaXB0aW9uXCIpLEQuZGVzY3JpcHRpb24/czpcIlwiLEQua2luZD09PVwiRW51bVR5cGVFeHRlbnNpb25cIj9cImV4dGVuZCBcIjpcIlwiLFwiZW51bSBcIixFKFwibmFtZVwiKSxoKHcsRSxEKSxELnZhbHVlcy5sZW5ndGg+MD9bXCIge1wiLGEoW3MsdChzLE4odyxJLEUsXCJ2YWx1ZXNcIikpXSkscyxcIn1cIl06XCJcIl07Y2FzZVwiRW51bVZhbHVlRGVmaW5pdGlvblwiOnJldHVybltFKFwiZGVzY3JpcHRpb25cIiksRC5kZXNjcmlwdGlvbj9zOlwiXCIsRShcIm5hbWVcIiksaCh3LEUsRCldO2Nhc2VcIklucHV0VmFsdWVEZWZpbml0aW9uXCI6cmV0dXJuW0UoXCJkZXNjcmlwdGlvblwiKSxELmRlc2NyaXB0aW9uP0QuZGVzY3JpcHRpb24uYmxvY2s/czppOlwiXCIsRShcIm5hbWVcIiksXCI6IFwiLEUoXCJ0eXBlXCIpLEQuZGVmYXVsdFZhbHVlP1tcIiA9IFwiLEUoXCJkZWZhdWx0VmFsdWVcIildOlwiXCIsaCh3LEUsRCldO2Nhc2VcIklucHV0T2JqZWN0VHlwZUV4dGVuc2lvblwiOmNhc2VcIklucHV0T2JqZWN0VHlwZURlZmluaXRpb25cIjpyZXR1cm5bRShcImRlc2NyaXB0aW9uXCIpLEQuZGVzY3JpcHRpb24/czpcIlwiLEQua2luZD09PVwiSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uXCI/XCJleHRlbmQgXCI6XCJcIixcImlucHV0IFwiLEUoXCJuYW1lXCIpLGgodyxFLEQpLEQuZmllbGRzLmxlbmd0aD4wP1tcIiB7XCIsYShbcyx0KHMsTih3LEksRSxcImZpZWxkc1wiKSldKSxzLFwifVwiXTpcIlwiXTtjYXNlXCJTY2hlbWFEZWZpbml0aW9uXCI6cmV0dXJuW0UoXCJkZXNjcmlwdGlvblwiKSxELmRlc2NyaXB0aW9uP3M6XCJcIixcInNjaGVtYVwiLGgodyxFLEQpLFwiIHtcIixELm9wZXJhdGlvblR5cGVzLmxlbmd0aD4wP2EoW3MsdChzLE4odyxJLEUsXCJvcGVyYXRpb25UeXBlc1wiKSldKTpcIlwiLHMsXCJ9XCJdO2Nhc2VcIk9wZXJhdGlvblR5cGVEZWZpbml0aW9uXCI6cmV0dXJuW0UoXCJvcGVyYXRpb25cIiksXCI6IFwiLEUoXCJ0eXBlXCIpXTtjYXNlXCJJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uXCI6Y2FzZVwiSW50ZXJmYWNlVHlwZURlZmluaXRpb25cIjpyZXR1cm5bRShcImRlc2NyaXB0aW9uXCIpLEQuZGVzY3JpcHRpb24/czpcIlwiLEQua2luZD09PVwiSW50ZXJmYWNlVHlwZUV4dGVuc2lvblwiP1wiZXh0ZW5kIFwiOlwiXCIsXCJpbnRlcmZhY2UgXCIsRShcIm5hbWVcIiksRC5pbnRlcmZhY2VzLmxlbmd0aD4wP1tcIiBpbXBsZW1lbnRzIFwiLC4uLmIodyxJLEUpXTpcIlwiLGgodyxFLEQpLEQuZmllbGRzLmxlbmd0aD4wP1tcIiB7XCIsYShbcyx0KHMsTih3LEksRSxcImZpZWxkc1wiKSldKSxzLFwifVwiXTpcIlwiXTtjYXNlXCJGcmFnbWVudFNwcmVhZFwiOnJldHVybltcIi4uLlwiLEUoXCJuYW1lXCIpLGgodyxFLEQpXTtjYXNlXCJJbmxpbmVGcmFnbWVudFwiOnJldHVybltcIi4uLlwiLEQudHlwZUNvbmRpdGlvbj9bXCIgb24gXCIsRShcInR5cGVDb25kaXRpb25cIildOlwiXCIsaCh3LEUsRCksXCIgXCIsRShcInNlbGVjdGlvblNldFwiKV07Y2FzZVwiVW5pb25UeXBlRXh0ZW5zaW9uXCI6Y2FzZVwiVW5pb25UeXBlRGVmaW5pdGlvblwiOnJldHVybiB1KFtFKFwiZGVzY3JpcHRpb25cIiksRC5kZXNjcmlwdGlvbj9zOlwiXCIsdShbRC5raW5kPT09XCJVbmlvblR5cGVFeHRlbnNpb25cIj9cImV4dGVuZCBcIjpcIlwiLFwidW5pb24gXCIsRShcIm5hbWVcIiksaCh3LEUsRCksRC50eXBlcy5sZW5ndGg+MD9bXCIgPVwiLGMoXCJcIixcIiBcIiksYShbYyhbaSxcIiAgXCJdKSx0KFtpLFwifCBcIl0sdy5tYXAoRSxcInR5cGVzXCIpKV0pXTpcIlwiXSldKTtjYXNlXCJTY2FsYXJUeXBlRXh0ZW5zaW9uXCI6Y2FzZVwiU2NhbGFyVHlwZURlZmluaXRpb25cIjpyZXR1cm5bRShcImRlc2NyaXB0aW9uXCIpLEQuZGVzY3JpcHRpb24/czpcIlwiLEQua2luZD09PVwiU2NhbGFyVHlwZUV4dGVuc2lvblwiP1wiZXh0ZW5kIFwiOlwiXCIsXCJzY2FsYXIgXCIsRShcIm5hbWVcIiksaCh3LEUsRCldO2Nhc2VcIk5vbk51bGxUeXBlXCI6cmV0dXJuW0UoXCJ0eXBlXCIpLFwiIVwiXTtjYXNlXCJMaXN0VHlwZVwiOnJldHVybltcIltcIixFKFwidHlwZVwiKSxcIl1cIl07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGdyYXBocWwgdHlwZTogXCIrSlNPTi5zdHJpbmdpZnkoRC5raW5kKSl9fWZ1bmN0aW9uIGgodyxJLEUpe2lmKEUuZGlyZWN0aXZlcy5sZW5ndGg9PT0wKXJldHVyblwiXCI7bGV0IEQ9dChpLHcubWFwKEksXCJkaXJlY3RpdmVzXCIpKTtyZXR1cm4gRS5raW5kPT09XCJGcmFnbWVudERlZmluaXRpb25cInx8RS5raW5kPT09XCJPcGVyYXRpb25EZWZpbml0aW9uXCI/dShbaSxEXSk6W1wiIFwiLHUoYShbcixEXSkpXX1mdW5jdGlvbiBOKHcsSSxFLEQpe3JldHVybiB3Lm1hcCgoZCx5LG8pPT57bGV0IHg9RSgpO3JldHVybiB5PG8ubGVuZ3RoLTEmJmwoSS5vcmlnaW5hbFRleHQsZC5nZXRWYWx1ZSgpLHApP1t4LHNdOnh9LEQpfWZ1bmN0aW9uIFQodyl7cmV0dXJuIHcua2luZCYmdy5raW5kIT09XCJDb21tZW50XCJ9ZnVuY3Rpb24gQSh3KXtsZXQgST13LmdldFZhbHVlKCk7aWYoSS5raW5kPT09XCJDb21tZW50XCIpcmV0dXJuXCIjXCIrSS52YWx1ZS50cmltRW5kKCk7dGhyb3cgbmV3IEVycm9yKFwiTm90IGEgY29tbWVudDogXCIrSlNPTi5zdHJpbmdpZnkoSSkpfWZ1bmN0aW9uIGIodyxJLEUpe2xldCBEPXcuZ2V0Tm9kZSgpLGQ9W10se2ludGVyZmFjZXM6eX09RCxvPXcubWFwKHg9PkUoeCksXCJpbnRlcmZhY2VzXCIpO2ZvcihsZXQgeD0wO3g8eS5sZW5ndGg7eCsrKXtsZXQgRj15W3hdO2QucHVzaChvW3hdKTtsZXQgUz15W3grMV07aWYoUyl7bGV0IGs9SS5vcmlnaW5hbFRleHQuc2xpY2UoRi5sb2MuZW5kLFMubG9jLnN0YXJ0KSxfPWsuaW5jbHVkZXMoXCIjXCIpLE89ay5yZXBsYWNlKC8jLiovZyxcIlwiKS50cmltKCk7ZC5wdXNoKE89PT1cIixcIj9cIixcIjpcIiAmXCIsXz9pOlwiIFwiKX19cmV0dXJuIGR9ZnVuY3Rpb24gdigpe312Lmlnbm9yZWRQcm9wZXJ0aWVzPW5ldyBTZXQoW1wibG9jXCIsXCJjb21tZW50c1wiXSk7ZnVuY3Rpb24gQih3KXtsZXQgST13LmdldFZhbHVlKCk7cmV0dXJuIEkmJkFycmF5LmlzQXJyYXkoSS5jb21tZW50cykmJkkuY29tbWVudHMuc29tZShFPT5FLnZhbHVlLnRyaW0oKT09PVwicHJldHRpZXItaWdub3JlXCIpfW4uZXhwb3J0cz17cHJpbnQ6ZixtYXNzYWdlQXN0Tm9kZTp2LGhhc1ByZXR0aWVySWdub3JlOkIsaW5zZXJ0UHJhZ21hOm0scHJpbnRDb21tZW50OkEsY2FuQXR0YWNoQ29tbWVudDpUfX19KSxDZD1aKHtcInNyYy9sYW5ndWFnZS1ncmFwaHFsL29wdGlvbnMuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9THQoKTtuLmV4cG9ydHM9e2JyYWNrZXRTcGFjaW5nOnQuYnJhY2tldFNwYWNpbmd9fX0pLEVkPVooe1wic3JjL2xhbmd1YWdlLWdyYXBocWwvcGFyc2Vycy5qc1wiKCl7YWUoKX19KSx2ZD1aKHtcIm5vZGVfbW9kdWxlcy9saW5ndWlzdC1sYW5ndWFnZXMvZGF0YS9HcmFwaFFMLmpzb25cIihlLG4pe24uZXhwb3J0cz17bmFtZTpcIkdyYXBoUUxcIix0eXBlOlwiZGF0YVwiLGNvbG9yOlwiI2UxMDA5OFwiLGV4dGVuc2lvbnM6W1wiLmdyYXBocWxcIixcIi5ncWxcIixcIi5ncmFwaHFsc1wiXSx0bVNjb3BlOlwic291cmNlLmdyYXBocWxcIixhY2VNb2RlOlwidGV4dFwiLGxhbmd1YWdlSWQ6MTM5fX19KSxGZD1aKHtcInNyYy9sYW5ndWFnZS1ncmFwaHFsL2luZGV4LmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PWJ0KCkscz1oZCgpLGk9Q2QoKSxyPUVkKCksdT1bdCh2ZCgpLCgpPT4oe3NpbmNlOlwiMS41LjBcIixwYXJzZXJzOltcImdyYXBocWxcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wiZ3JhcGhxbFwiXX0pKV0sYT17Z3JhcGhxbDpzfTtuLmV4cG9ydHM9e2xhbmd1YWdlczp1LG9wdGlvbnM6aSxwcmludGVyczphLHBhcnNlcnM6cn19fSksZm89Wih7XCJzcmMvbGFuZ3VhZ2UtbWFya2Rvd24vbG9jLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO2Z1bmN0aW9uIHQoaSl7cmV0dXJuIGkucG9zaXRpb24uc3RhcnQub2Zmc2V0fWZ1bmN0aW9uIHMoaSl7cmV0dXJuIGkucG9zaXRpb24uZW5kLm9mZnNldH1uLmV4cG9ydHM9e2xvY1N0YXJ0OnQsbG9jRW5kOnN9fX0pLEFkPVooe1wic3JjL2xhbmd1YWdlLW1hcmtkb3duL2NvbnN0YW50cy5ldmFsdWF0ZS5qc1wiKGUsbil7bi5leHBvcnRzPXtjamtQYXR0ZXJuOlwiKD86W1xcXFx1MDJlYS1cXFxcdTAyZWJcXFxcdTExMDAtXFxcXHUxMWZmXFxcXHUyZTgwLVxcXFx1MmU5OVxcXFx1MmU5Yi1cXFxcdTJlZjNcXFxcdTJmMDAtXFxcXHUyZmQ1XFxcXHUyZmYwLVxcXFx1MzAzZlxcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwOTktXFxcXHUzMDlmXFxcXHUzMGExLVxcXFx1MzBmYVxcXFx1MzBmYy1cXFxcdTMwZmZcXFxcdTMxMDUtXFxcXHUzMTJmXFxcXHUzMTMxLVxcXFx1MzE4ZVxcXFx1MzE5MC1cXFxcdTMxOTFcXFxcdTMxOTYtXFxcXHUzMWJhXFxcXHUzMWMwLVxcXFx1MzFlM1xcXFx1MzFmMC1cXFxcdTMyMWVcXFxcdTMyMmEtXFxcXHUzMjQ3XFxcXHUzMjYwLVxcXFx1MzI3ZVxcXFx1MzI4YS1cXFxcdTMyYjBcXFxcdTMyYzAtXFxcXHUzMmNiXFxcXHUzMmQwLVxcXFx1MzM3MFxcXFx1MzM3Yi1cXFxcdTMzN2ZcXFxcdTMzZTAtXFxcXHUzM2ZlXFxcXHUzNDAwLVxcXFx1NGRiNVxcXFx1NGUwMC1cXFxcdTlmZWZcXFxcdWE5NjAtXFxcXHVhOTdjXFxcXHVhYzAwLVxcXFx1ZDdhM1xcXFx1ZDdiMC1cXFxcdWQ3YzZcXFxcdWQ3Y2ItXFxcXHVkN2ZiXFxcXHVmOTAwLVxcXFx1ZmE2ZFxcXFx1ZmE3MC1cXFxcdWZhZDlcXFxcdWZlMTAtXFxcXHVmZTFmXFxcXHVmZTMwLVxcXFx1ZmU2ZlxcXFx1ZmYwMC1cXFxcdWZmZWZdfFtcXFxcdWQ4NDAtXFxcXHVkODY4XFxcXHVkODZhLVxcXFx1ZDg2Y1xcXFx1ZDg2Zi1cXFxcdWQ4NzJcXFxcdWQ4NzQtXFxcXHVkODc5XVtcXFxcdWRjMDAtXFxcXHVkZmZmXXxcXFxcdWQ4MmNbXFxcXHVkYzAwLVxcXFx1ZGQxZVxcXFx1ZGQ1MC1cXFxcdWRkNTJcXFxcdWRkNjQtXFxcXHVkZDY3XXxcXFxcdWQ4M2NbXFxcXHVkZTAwXFxcXHVkZTUwLVxcXFx1ZGU1MV18XFxcXHVkODY5W1xcXFx1ZGMwMC1cXFxcdWRlZDZcXFxcdWRmMDAtXFxcXHVkZmZmXXxcXFxcdWQ4NmRbXFxcXHVkYzAwLVxcXFx1ZGYzNFxcXFx1ZGY0MC1cXFxcdWRmZmZdfFxcXFx1ZDg2ZVtcXFxcdWRjMDAtXFxcXHVkYzFkXFxcXHVkYzIwLVxcXFx1ZGZmZl18XFxcXHVkODczW1xcXFx1ZGMwMC1cXFxcdWRlYTFcXFxcdWRlYjAtXFxcXHVkZmZmXXxcXFxcdWQ4N2FbXFxcXHVkYzAwLVxcXFx1ZGZlMF18XFxcXHVkODdlW1xcXFx1ZGMwMC1cXFxcdWRlMWRdKSg/OltcXFxcdWZlMDAtXFxcXHVmZTBmXXxcXFxcdWRiNDBbXFxcXHVkZDAwLVxcXFx1ZGRlZl0pP1wiLGtQYXR0ZXJuOlwiW1xcXFx1MTEwMC1cXFxcdTExZmZcXFxcdTMwMDEtXFxcXHUzMDAzXFxcXHUzMDA4LVxcXFx1MzAxMVxcXFx1MzAxMy1cXFxcdTMwMWZcXFxcdTMwMmUtXFxcXHUzMDMwXFxcXHUzMDM3XFxcXHUzMGZiXFxcXHUzMTMxLVxcXFx1MzE4ZVxcXFx1MzIwMC1cXFxcdTMyMWVcXFxcdTMyNjAtXFxcXHUzMjdlXFxcXHVhOTYwLVxcXFx1YTk3Y1xcXFx1YWMwMC1cXFxcdWQ3YTNcXFxcdWQ3YjAtXFxcXHVkN2M2XFxcXHVkN2NiLVxcXFx1ZDdmYlxcXFx1ZmU0NS1cXFxcdWZlNDZcXFxcdWZmNjEtXFxcXHVmZjY1XFxcXHVmZmEwLVxcXFx1ZmZiZVxcXFx1ZmZjMi1cXFxcdWZmYzdcXFxcdWZmY2EtXFxcXHVmZmNmXFxcXHVmZmQyLVxcXFx1ZmZkN1xcXFx1ZmZkYS1cXFxcdWZmZGNdXCIscHVuY3R1YXRpb25QYXR0ZXJuOlwiW1xcXFx1MDAyMS1cXFxcdTAwMmZcXFxcdTAwM2EtXFxcXHUwMDQwXFxcXHUwMDViLVxcXFx1MDA2MFxcXFx1MDA3Yi1cXFxcdTAwN2VcXFxcdTAwYTFcXFxcdTAwYTdcXFxcdTAwYWJcXFxcdTAwYjYtXFxcXHUwMGI3XFxcXHUwMGJiXFxcXHUwMGJmXFxcXHUwMzdlXFxcXHUwMzg3XFxcXHUwNTVhLVxcXFx1MDU1ZlxcXFx1MDU4OS1cXFxcdTA1OGFcXFxcdTA1YmVcXFxcdTA1YzBcXFxcdTA1YzNcXFxcdTA1YzZcXFxcdTA1ZjMtXFxcXHUwNWY0XFxcXHUwNjA5LVxcXFx1MDYwYVxcXFx1MDYwYy1cXFxcdTA2MGRcXFxcdTA2MWJcXFxcdTA2MWUtXFxcXHUwNjFmXFxcXHUwNjZhLVxcXFx1MDY2ZFxcXFx1MDZkNFxcXFx1MDcwMC1cXFxcdTA3MGRcXFxcdTA3ZjctXFxcXHUwN2Y5XFxcXHUwODMwLVxcXFx1MDgzZVxcXFx1MDg1ZVxcXFx1MDk2NC1cXFxcdTA5NjVcXFxcdTA5NzBcXFxcdTA5ZmRcXFxcdTBhNzZcXFxcdTBhZjBcXFxcdTBjNzdcXFxcdTBjODRcXFxcdTBkZjRcXFxcdTBlNGZcXFxcdTBlNWEtXFxcXHUwZTViXFxcXHUwZjA0LVxcXFx1MGYxMlxcXFx1MGYxNFxcXFx1MGYzYS1cXFxcdTBmM2RcXFxcdTBmODVcXFxcdTBmZDAtXFxcXHUwZmQ0XFxcXHUwZmQ5LVxcXFx1MGZkYVxcXFx1MTA0YS1cXFxcdTEwNGZcXFxcdTEwZmJcXFxcdTEzNjAtXFxcXHUxMzY4XFxcXHUxNDAwXFxcXHUxNjZlXFxcXHUxNjliLVxcXFx1MTY5Y1xcXFx1MTZlYi1cXFxcdTE2ZWRcXFxcdTE3MzUtXFxcXHUxNzM2XFxcXHUxN2Q0LVxcXFx1MTdkNlxcXFx1MTdkOC1cXFxcdTE3ZGFcXFxcdTE4MDAtXFxcXHUxODBhXFxcXHUxOTQ0LVxcXFx1MTk0NVxcXFx1MWExZS1cXFxcdTFhMWZcXFxcdTFhYTAtXFxcXHUxYWE2XFxcXHUxYWE4LVxcXFx1MWFhZFxcXFx1MWI1YS1cXFxcdTFiNjBcXFxcdTFiZmMtXFxcXHUxYmZmXFxcXHUxYzNiLVxcXFx1MWMzZlxcXFx1MWM3ZS1cXFxcdTFjN2ZcXFxcdTFjYzAtXFxcXHUxY2M3XFxcXHUxY2QzXFxcXHUyMDEwLVxcXFx1MjAyN1xcXFx1MjAzMC1cXFxcdTIwNDNcXFxcdTIwNDUtXFxcXHUyMDUxXFxcXHUyMDUzLVxcXFx1MjA1ZVxcXFx1MjA3ZC1cXFxcdTIwN2VcXFxcdTIwOGQtXFxcXHUyMDhlXFxcXHUyMzA4LVxcXFx1MjMwYlxcXFx1MjMyOS1cXFxcdTIzMmFcXFxcdTI3NjgtXFxcXHUyNzc1XFxcXHUyN2M1LVxcXFx1MjdjNlxcXFx1MjdlNi1cXFxcdTI3ZWZcXFxcdTI5ODMtXFxcXHUyOTk4XFxcXHUyOWQ4LVxcXFx1MjlkYlxcXFx1MjlmYy1cXFxcdTI5ZmRcXFxcdTJjZjktXFxcXHUyY2ZjXFxcXHUyY2ZlLVxcXFx1MmNmZlxcXFx1MmQ3MFxcXFx1MmUwMC1cXFxcdTJlMmVcXFxcdTJlMzAtXFxcXHUyZTRmXFxcXHUzMDAxLVxcXFx1MzAwM1xcXFx1MzAwOC1cXFxcdTMwMTFcXFxcdTMwMTQtXFxcXHUzMDFmXFxcXHUzMDMwXFxcXHUzMDNkXFxcXHUzMGEwXFxcXHUzMGZiXFxcXHVhNGZlLVxcXFx1YTRmZlxcXFx1YTYwZC1cXFxcdWE2MGZcXFxcdWE2NzNcXFxcdWE2N2VcXFxcdWE2ZjItXFxcXHVhNmY3XFxcXHVhODc0LVxcXFx1YTg3N1xcXFx1YThjZS1cXFxcdWE4Y2ZcXFxcdWE4ZjgtXFxcXHVhOGZhXFxcXHVhOGZjXFxcXHVhOTJlLVxcXFx1YTkyZlxcXFx1YTk1ZlxcXFx1YTljMS1cXFxcdWE5Y2RcXFxcdWE5ZGUtXFxcXHVhOWRmXFxcXHVhYTVjLVxcXFx1YWE1ZlxcXFx1YWFkZS1cXFxcdWFhZGZcXFxcdWFhZjAtXFxcXHVhYWYxXFxcXHVhYmViXFxcXHVmZDNlLVxcXFx1ZmQzZlxcXFx1ZmUxMC1cXFxcdWZlMTlcXFxcdWZlMzAtXFxcXHVmZTUyXFxcXHVmZTU0LVxcXFx1ZmU2MVxcXFx1ZmU2M1xcXFx1ZmU2OFxcXFx1ZmU2YS1cXFxcdWZlNmJcXFxcdWZmMDEtXFxcXHVmZjAzXFxcXHVmZjA1LVxcXFx1ZmYwYVxcXFx1ZmYwYy1cXFxcdWZmMGZcXFxcdWZmMWEtXFxcXHVmZjFiXFxcXHVmZjFmLVxcXFx1ZmYyMFxcXFx1ZmYzYi1cXFxcdWZmM2RcXFxcdWZmM2ZcXFxcdWZmNWJcXFxcdWZmNWRcXFxcdWZmNWYtXFxcXHVmZjY1XXxcXFxcdWQ4MDBbXFxcXHVkZDAwLVxcXFx1ZGQwMlxcXFx1ZGY5ZlxcXFx1ZGZkMF18XFxcXHVkODAxW1xcXFx1ZGQ2Zl18XFxcXHVkODAyW1xcXFx1ZGM1N1xcXFx1ZGQxZlxcXFx1ZGQzZlxcXFx1ZGU1MC1cXFxcdWRlNThcXFxcdWRlN2ZcXFxcdWRlZjAtXFxcXHVkZWY2XFxcXHVkZjM5LVxcXFx1ZGYzZlxcXFx1ZGY5OS1cXFxcdWRmOWNdfFxcXFx1ZDgwM1tcXFxcdWRmNTUtXFxcXHVkZjU5XXxcXFxcdWQ4MDRbXFxcXHVkYzQ3LVxcXFx1ZGM0ZFxcXFx1ZGNiYi1cXFxcdWRjYmNcXFxcdWRjYmUtXFxcXHVkY2MxXFxcXHVkZDQwLVxcXFx1ZGQ0M1xcXFx1ZGQ3NC1cXFxcdWRkNzVcXFxcdWRkYzUtXFxcXHVkZGM4XFxcXHVkZGNkXFxcXHVkZGRiXFxcXHVkZGRkLVxcXFx1ZGRkZlxcXFx1ZGUzOC1cXFxcdWRlM2RcXFxcdWRlYTldfFxcXFx1ZDgwNVtcXFxcdWRjNGItXFxcXHVkYzRmXFxcXHVkYzViXFxcXHVkYzVkXFxcXHVkY2M2XFxcXHVkZGMxLVxcXFx1ZGRkN1xcXFx1ZGU0MS1cXFxcdWRlNDNcXFxcdWRlNjAtXFxcXHVkZTZjXFxcXHVkZjNjLVxcXFx1ZGYzZV18XFxcXHVkODA2W1xcXFx1ZGMzYlxcXFx1ZGRlMlxcXFx1ZGUzZi1cXFxcdWRlNDZcXFxcdWRlOWEtXFxcXHVkZTljXFxcXHVkZTllLVxcXFx1ZGVhMl18XFxcXHVkODA3W1xcXFx1ZGM0MS1cXFxcdWRjNDVcXFxcdWRjNzAtXFxcXHVkYzcxXFxcXHVkZWY3LVxcXFx1ZGVmOFxcXFx1ZGZmZl18XFxcXHVkODA5W1xcXFx1ZGM3MC1cXFxcdWRjNzRdfFxcXFx1ZDgxYVtcXFxcdWRlNmUtXFxcXHVkZTZmXFxcXHVkZWY1XFxcXHVkZjM3LVxcXFx1ZGYzYlxcXFx1ZGY0NF18XFxcXHVkODFiW1xcXFx1ZGU5Ny1cXFxcdWRlOWFcXFxcdWRmZTJdfFxcXFx1ZDgyZltcXFxcdWRjOWZdfFxcXFx1ZDgzNltcXFxcdWRlODctXFxcXHVkZThiXXxcXFxcdWQ4M2FbXFxcXHVkZDVlLVxcXFx1ZGQ1Zl1cIn19fSksS249Wih7XCJzcmMvbGFuZ3VhZ2UtbWFya2Rvd24vdXRpbHMuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2dldExhc3Q6dH09R2UoKSx7bG9jU3RhcnQ6cyxsb2NFbmQ6aX09Zm8oKSx7Y2prUGF0dGVybjpyLGtQYXR0ZXJuOnUscHVuY3R1YXRpb25QYXR0ZXJuOmF9PUFkKCksYz1bXCJsaXF1aWROb2RlXCIsXCJpbmxpbmVDb2RlXCIsXCJlbXBoYXNpc1wiLFwiZXNDb21tZW50XCIsXCJzdHJvbmdcIixcImRlbGV0ZVwiLFwid2lraUxpbmtcIixcImxpbmtcIixcImxpbmtSZWZlcmVuY2VcIixcImltYWdlXCIsXCJpbWFnZVJlZmVyZW5jZVwiLFwiZm9vdG5vdGVcIixcImZvb3Rub3RlUmVmZXJlbmNlXCIsXCJzZW50ZW5jZVwiLFwid2hpdGVzcGFjZVwiLFwid29yZFwiLFwiYnJlYWtcIixcImlubGluZU1hdGhcIl0sbD1bLi4uYyxcInRhYmxlQ2VsbFwiLFwicGFyYWdyYXBoXCIsXCJoZWFkaW5nXCJdLEM9bmV3IFJlZ0V4cCh1KSxtPW5ldyBSZWdFeHAoYSk7ZnVuY3Rpb24gZyhBLGIpe2xldCB2PVwibm9uLWNqa1wiLEI9XCJjai1sZXR0ZXJcIix3PVwiay1sZXR0ZXJcIixJPVwiY2prLXB1bmN0dWF0aW9uXCIsRT1bXSxEPShiLnByb3NlV3JhcD09PVwicHJlc2VydmVcIj9BOkEucmVwbGFjZShuZXcgUmVnRXhwKFwiKFwiLmNvbmNhdChyLGApXG4oYCkuY29uY2F0KHIsXCIpXCIpLFwiZ1wiKSxcIiQxJDJcIikpLnNwbGl0KC8oW1xcdFxcbiBdKykvKTtmb3IobGV0W3ksb11vZiBELmVudHJpZXMoKSl7aWYoeSUyPT09MSl7RS5wdXNoKHt0eXBlOlwid2hpdGVzcGFjZVwiLHZhbHVlOi9cXG4vLnRlc3Qobyk/YFxuYDpcIiBcIn0pO2NvbnRpbnVlfWlmKCh5PT09MHx8eT09PUQubGVuZ3RoLTEpJiZvPT09XCJcIiljb250aW51ZTtsZXQgeD1vLnNwbGl0KG5ldyBSZWdFeHAoXCIoXCIuY29uY2F0KHIsXCIpXCIpKSk7Zm9yKGxldFtGLFNdb2YgeC5lbnRyaWVzKCkpaWYoISgoRj09PTB8fEY9PT14Lmxlbmd0aC0xKSYmUz09PVwiXCIpKXtpZihGJTI9PT0wKXtTIT09XCJcIiYmZCh7dHlwZTpcIndvcmRcIix2YWx1ZTpTLGtpbmQ6dixoYXNMZWFkaW5nUHVuY3R1YXRpb246bS50ZXN0KFNbMF0pLGhhc1RyYWlsaW5nUHVuY3R1YXRpb246bS50ZXN0KHQoUykpfSk7Y29udGludWV9ZChtLnRlc3QoUyk/e3R5cGU6XCJ3b3JkXCIsdmFsdWU6UyxraW5kOkksaGFzTGVhZGluZ1B1bmN0dWF0aW9uOiEwLGhhc1RyYWlsaW5nUHVuY3R1YXRpb246ITB9Ont0eXBlOlwid29yZFwiLHZhbHVlOlMsa2luZDpDLnRlc3QoUyk/dzpCLGhhc0xlYWRpbmdQdW5jdHVhdGlvbjohMSxoYXNUcmFpbGluZ1B1bmN0dWF0aW9uOiExfSl9fXJldHVybiBFO2Z1bmN0aW9uIGQoeSl7bGV0IG89dChFKTtvJiZvLnR5cGU9PT1cIndvcmRcIiYmKG8ua2luZD09PXYmJnkua2luZD09PUImJiFvLmhhc1RyYWlsaW5nUHVuY3R1YXRpb258fG8ua2luZD09PUImJnkua2luZD09PXYmJiF5Lmhhc0xlYWRpbmdQdW5jdHVhdGlvbj9FLnB1c2goe3R5cGU6XCJ3aGl0ZXNwYWNlXCIsdmFsdWU6XCIgXCJ9KToheCh2LEkpJiYhW28udmFsdWUseS52YWx1ZV0uc29tZShGPT4vXFx1MzAwMC8udGVzdChGKSkmJkUucHVzaCh7dHlwZTpcIndoaXRlc3BhY2VcIix2YWx1ZTpcIlwifSkpLEUucHVzaCh5KTtmdW5jdGlvbiB4KEYsUyl7cmV0dXJuIG8ua2luZD09PUYmJnkua2luZD09PVN8fG8ua2luZD09PVMmJnkua2luZD09PUZ9fX1mdW5jdGlvbiBwKEEsYil7bGV0Wyx2LEIsd109Yi5zbGljZShBLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCxBLnBvc2l0aW9uLmVuZC5vZmZzZXQpLm1hdGNoKC9eXFxzKihcXGQrKShcXC58XFwpKShcXHMqKS8pO3JldHVybntudW1iZXJUZXh0OnYsbWFya2VyOkIsbGVhZGluZ1NwYWNlczp3fX1mdW5jdGlvbiBmKEEsYil7aWYoIUEub3JkZXJlZHx8QS5jaGlsZHJlbi5sZW5ndGg8MilyZXR1cm4hMTtsZXQgdj1OdW1iZXIocChBLmNoaWxkcmVuWzBdLGIub3JpZ2luYWxUZXh0KS5udW1iZXJUZXh0KSxCPU51bWJlcihwKEEuY2hpbGRyZW5bMV0sYi5vcmlnaW5hbFRleHQpLm51bWJlclRleHQpO2lmKHY9PT0wJiZBLmNoaWxkcmVuLmxlbmd0aD4yKXtsZXQgdz1OdW1iZXIocChBLmNoaWxkcmVuWzJdLGIub3JpZ2luYWxUZXh0KS5udW1iZXJUZXh0KTtyZXR1cm4gQj09PTEmJnc9PT0xfXJldHVybiBCPT09MX1mdW5jdGlvbiBoKEEsYil7bGV0e3ZhbHVlOnZ9PUE7cmV0dXJuIEEucG9zaXRpb24uZW5kLm9mZnNldD09PWIubGVuZ3RoJiZ2LmVuZHNXaXRoKGBcbmApJiZiLmVuZHNXaXRoKGBcbmApP3Yuc2xpY2UoMCwtMSk6dn1mdW5jdGlvbiBOKEEsYil7cmV0dXJuIGZ1bmN0aW9uIHYoQix3LEkpe2xldCBFPU9iamVjdC5hc3NpZ24oe30sYihCLHcsSSkpO3JldHVybiBFLmNoaWxkcmVuJiYoRS5jaGlsZHJlbj1FLmNoaWxkcmVuLm1hcCgoRCxkKT0+dihELGQsW0UsLi4uSV0pKSksRX0oQSxudWxsLFtdKX1mdW5jdGlvbiBUKEEpe2lmKCFBfHxBLnR5cGUhPT1cImxpbmtcInx8QS5jaGlsZHJlbi5sZW5ndGghPT0xKXJldHVybiExO2xldCBiPUEuY2hpbGRyZW5bMF07cmV0dXJuIGImJnMoQSk9PT1zKGIpJiZpKEEpPT09aShiKX1uLmV4cG9ydHM9e21hcEFzdDpOLHNwbGl0VGV4dDpnLHB1bmN0dWF0aW9uUGF0dGVybjphLGdldEZlbmNlZENvZGVCbG9ja1ZhbHVlOmgsZ2V0T3JkZXJlZExpc3RJdGVtSW5mbzpwLGhhc0dpdERpZmZGcmllbmRseU9yZGVyZWRMaXN0OmYsSU5MSU5FX05PREVfVFlQRVM6YyxJTkxJTkVfTk9ERV9XUkFQUEVSX1RZUEVTOmwsaXNBdXRvbGluazpUfX19KSxTZD1aKHtcInNyYy9sYW5ndWFnZS1tYXJrZG93bi9lbWJlZC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7aW5mZXJQYXJzZXJCeUxhbmd1YWdlOnQsZ2V0TWF4Q29udGludW91c0NvdW50OnN9PUdlKCkse2J1aWxkZXJzOntoYXJkbGluZTppLG1hcmtBc1Jvb3Q6cn0sdXRpbHM6e3JlcGxhY2VFbmRPZkxpbmU6dX19PUxlKCksYT1YbigpLHtnZXRGZW5jZWRDb2RlQmxvY2tWYWx1ZTpjfT1LbigpO2Z1bmN0aW9uIGwoQyxtLGcscCl7bGV0IGY9Qy5nZXRWYWx1ZSgpO2lmKGYudHlwZT09PVwiY29kZVwiJiZmLmxhbmchPT1udWxsKXtsZXQgaD10KGYubGFuZyxwKTtpZihoKXtsZXQgTj1wLl9faW5Kc1RlbXBsYXRlP1wiflwiOlwiYFwiLFQ9Ti5yZXBlYXQoTWF0aC5tYXgoMyxzKGYudmFsdWUsTikrMSkpLEE9e3BhcnNlcjpofTtmLmxhbmc9PT1cInRzeFwiJiYoQS5maWxlcGF0aD1cImR1bW15LnRzeFwiKTtsZXQgYj1nKGMoZixwLm9yaWdpbmFsVGV4dCksQSx7c3RyaXBUcmFpbGluZ0hhcmRsaW5lOiEwfSk7cmV0dXJuIHIoW1QsZi5sYW5nLGYubWV0YT9cIiBcIitmLm1ldGE6XCJcIixpLHUoYiksaSxUXSl9fXN3aXRjaChmLnR5cGUpe2Nhc2VcImZyb250LW1hdHRlclwiOnJldHVybiBhKGYsZyk7Y2FzZVwiaW1wb3J0RXhwb3J0XCI6cmV0dXJuW2coZi52YWx1ZSx7cGFyc2VyOlwiYmFiZWxcIn0se3N0cmlwVHJhaWxpbmdIYXJkbGluZTohMH0pLGldO2Nhc2VcImpzeFwiOnJldHVybiBnKFwiPCQ+XCIuY29uY2F0KGYudmFsdWUsXCI8LyQ+XCIpLHtwYXJzZXI6XCJfX2pzX2V4cHJlc3Npb25cIixyb290TWFya2VyOlwibWR4XCJ9LHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6ITB9KX1yZXR1cm4gbnVsbH1uLmV4cG9ydHM9bH19KSxEbz1aKHtcInNyYy9sYW5ndWFnZS1tYXJrZG93bi9wcmFnbWEuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9cG8oKSxzPVtcImZvcm1hdFwiLFwicHJldHRpZXJcIl07ZnVuY3Rpb24gaShyKXtsZXQgdT1cIkAoXCIuY29uY2F0KHMuam9pbihcInxcIiksXCIpXCIpLGE9bmV3IFJlZ0V4cChbXCI8IS0tXFxcXHMqXCIuY29uY2F0KHUsXCJcXFxccyotLT5cIiksXCJ7XFxcXHMqXFxcXC9cXFxcKlxcXFxzKlwiLmNvbmNhdCh1LFwiXFxcXHMqXFxcXCpcXFxcL1xcXFxzKn1cIiksYDwhLS0uKlxccj9cbltcXFxcc1xcXFxTXSooXnxcbilbXlxcXFxTXG5dKmAuY29uY2F0KHUsYFteXFxcXFNcbl0qKCR8XG4pW1xcXFxzXFxcXFNdKlxuLiotLT5gKV0uam9pbihcInxcIiksXCJtXCIpLGM9ci5tYXRjaChhKTtyZXR1cm4gYyYmYy5pbmRleD09PTB9bi5leHBvcnRzPXtzdGFydFdpdGhQcmFnbWE6aSxoYXNQcmFnbWE6cj0+aSh0KHIpLmNvbnRlbnQudHJpbVN0YXJ0KCkpLGluc2VydFByYWdtYTpyPT57bGV0IHU9dChyKSxhPVwiPCEtLSBAXCIuY29uY2F0KHNbMF0sXCIgLS0+XCIpO3JldHVybiB1LmZyb250TWF0dGVyP1wiXCIuY29uY2F0KHUuZnJvbnRNYXR0ZXIucmF3LGBcblxuYCkuY29uY2F0KGEsYFxuXG5gKS5jb25jYXQodS5jb250ZW50KTpcIlwiLmNvbmNhdChhLGBcblxuYCkuY29uY2F0KHUuY29udGVudCl9fX19KSx4ZD1aKHtcInNyYy9sYW5ndWFnZS1tYXJrZG93bi9wcmludC1wcmVwcm9jZXNzLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PXN0KCkse2dldE9yZGVyZWRMaXN0SXRlbUluZm86cyxtYXBBc3Q6aSxzcGxpdFRleHQ6cn09S24oKSx1PS9eLiQvc3U7ZnVuY3Rpb24gYShULEEpe3JldHVybiBUPUMoVCxBKSxUPXAoVCksVD1sKFQpLFQ9aChULEEpLFQ9TihULEEpLFQ9ZihULEEpLFQ9YyhUKSxUPW0oVCksVH1mdW5jdGlvbiBjKFQpe3JldHVybiBpKFQsQT0+QS50eXBlIT09XCJpbXBvcnRcIiYmQS50eXBlIT09XCJleHBvcnRcIj9BOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxBKSx7fSx7dHlwZTpcImltcG9ydEV4cG9ydFwifSkpfWZ1bmN0aW9uIGwoVCl7cmV0dXJuIGkoVCxBPT5BLnR5cGUhPT1cImlubGluZUNvZGVcIj9BOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxBKSx7fSx7dmFsdWU6QS52YWx1ZS5yZXBsYWNlKC9cXHMrL2csXCIgXCIpfSkpfWZ1bmN0aW9uIEMoVCxBKXtyZXR1cm4gaShULGI9PmIudHlwZSE9PVwidGV4dFwifHxiLnZhbHVlPT09XCIqXCJ8fGIudmFsdWU9PT1cIl9cInx8IXUudGVzdChiLnZhbHVlKXx8Yi5wb3NpdGlvbi5lbmQub2Zmc2V0LWIucG9zaXRpb24uc3RhcnQub2Zmc2V0PT09Yi52YWx1ZS5sZW5ndGg/YjpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYikse30se3ZhbHVlOkEub3JpZ2luYWxUZXh0LnNsaWNlKGIucG9zaXRpb24uc3RhcnQub2Zmc2V0LGIucG9zaXRpb24uZW5kLm9mZnNldCl9KSl9ZnVuY3Rpb24gbShUKXtyZXR1cm4gZyhULChBLGIpPT5BLnR5cGU9PT1cImltcG9ydEV4cG9ydFwiJiZiLnR5cGU9PT1cImltcG9ydEV4cG9ydFwiLChBLGIpPT4oe3R5cGU6XCJpbXBvcnRFeHBvcnRcIix2YWx1ZTpBLnZhbHVlK2BcblxuYCtiLnZhbHVlLHBvc2l0aW9uOntzdGFydDpBLnBvc2l0aW9uLnN0YXJ0LGVuZDpiLnBvc2l0aW9uLmVuZH19KSl9ZnVuY3Rpb24gZyhULEEsYil7cmV0dXJuIGkoVCx2PT57aWYoIXYuY2hpbGRyZW4pcmV0dXJuIHY7bGV0IEI9di5jaGlsZHJlbi5yZWR1Y2UoKHcsSSk9PntsZXQgRT10KHcpO3JldHVybiBFJiZBKEUsSSk/dy5zcGxpY2UoLTEsMSxiKEUsSSkpOncucHVzaChJKSx3fSxbXSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx2KSx7fSx7Y2hpbGRyZW46Qn0pfSl9ZnVuY3Rpb24gcChUKXtyZXR1cm4gZyhULChBLGIpPT5BLnR5cGU9PT1cInRleHRcIiYmYi50eXBlPT09XCJ0ZXh0XCIsKEEsYik9Pih7dHlwZTpcInRleHRcIix2YWx1ZTpBLnZhbHVlK2IudmFsdWUscG9zaXRpb246e3N0YXJ0OkEucG9zaXRpb24uc3RhcnQsZW5kOmIucG9zaXRpb24uZW5kfX0pKX1mdW5jdGlvbiBmKFQsQSl7cmV0dXJuIGkoVCwoYix2LEIpPT57bGV0W3ddPUI7aWYoYi50eXBlIT09XCJ0ZXh0XCIpcmV0dXJuIGI7bGV0e3ZhbHVlOkl9PWI7cmV0dXJuIHcudHlwZT09PVwicGFyYWdyYXBoXCImJih2PT09MCYmKEk9SS50cmltU3RhcnQoKSksdj09PXcuY2hpbGRyZW4ubGVuZ3RoLTEmJihJPUkudHJpbUVuZCgpKSkse3R5cGU6XCJzZW50ZW5jZVwiLHBvc2l0aW9uOmIucG9zaXRpb24sY2hpbGRyZW46cihJLEEpfX0pfWZ1bmN0aW9uIGgoVCxBKXtyZXR1cm4gaShULChiLHYsQik9PntpZihiLnR5cGU9PT1cImNvZGVcIil7bGV0IHc9L15cXG4/KD86IHs0LH18XFx0KS8udGVzdChBLm9yaWdpbmFsVGV4dC5zbGljZShiLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCxiLnBvc2l0aW9uLmVuZC5vZmZzZXQpKTtpZihiLmlzSW5kZW50ZWQ9dyx3KWZvcihsZXQgST0wO0k8Qi5sZW5ndGg7SSsrKXtsZXQgRT1CW0ldO2lmKEUuaGFzSW5kZW50ZWRDb2RlYmxvY2spYnJlYWs7RS50eXBlPT09XCJsaXN0XCImJihFLmhhc0luZGVudGVkQ29kZWJsb2NrPSEwKX19cmV0dXJuIGJ9KX1mdW5jdGlvbiBOKFQsQSl7cmV0dXJuIGkoVCwoQix3LEkpPT57aWYoQi50eXBlPT09XCJsaXN0XCImJkIuY2hpbGRyZW4ubGVuZ3RoPjApe2ZvcihsZXQgRT0wO0U8SS5sZW5ndGg7RSsrKXtsZXQgRD1JW0VdO2lmKEQudHlwZT09PVwibGlzdFwiJiYhRC5pc0FsaWduZWQpcmV0dXJuIEIuaXNBbGlnbmVkPSExLEJ9Qi5pc0FsaWduZWQ9dihCKX1yZXR1cm4gQn0pO2Z1bmN0aW9uIGIoQil7cmV0dXJuIEIuY2hpbGRyZW4ubGVuZ3RoPT09MD8tMTpCLmNoaWxkcmVuWzBdLnBvc2l0aW9uLnN0YXJ0LmNvbHVtbi0xfWZ1bmN0aW9uIHYoQil7aWYoIUIub3JkZXJlZClyZXR1cm4hMDtsZXRbdyxJXT1CLmNoaWxkcmVuO2lmKHModyxBLm9yaWdpbmFsVGV4dCkubGVhZGluZ1NwYWNlcy5sZW5ndGg+MSlyZXR1cm4hMDtsZXQgRD1iKHcpO2lmKEQ9PT0tMSlyZXR1cm4hMTtpZihCLmNoaWxkcmVuLmxlbmd0aD09PTEpcmV0dXJuIEQlQS50YWJXaWR0aD09PTA7bGV0IGQ9YihJKTtyZXR1cm4gRCE9PWQ/ITE6RCVBLnRhYldpZHRoPT09MD8hMDpzKEksQS5vcmlnaW5hbFRleHQpLmxlYWRpbmdTcGFjZXMubGVuZ3RoPjF9fW4uZXhwb3J0cz1hfX0pLGJkPVooe1wic3JjL2xhbmd1YWdlLW1hcmtkb3duL2NsZWFuLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3Zhcntpc0Zyb250TWF0dGVyTm9kZTp0fT1HZSgpLHtzdGFydFdpdGhQcmFnbWE6c309RG8oKSxpPW5ldyBTZXQoW1wicG9zaXRpb25cIixcInJhd1wiXSk7ZnVuY3Rpb24gcih1LGEsYyl7aWYoKHUudHlwZT09PVwiZnJvbnQtbWF0dGVyXCJ8fHUudHlwZT09PVwiY29kZVwifHx1LnR5cGU9PT1cInlhbWxcInx8dS50eXBlPT09XCJpbXBvcnRcInx8dS50eXBlPT09XCJleHBvcnRcInx8dS50eXBlPT09XCJqc3hcIikmJmRlbGV0ZSBhLnZhbHVlLHUudHlwZT09PVwibGlzdFwiJiZkZWxldGUgYS5pc0FsaWduZWQsKHUudHlwZT09PVwibGlzdFwifHx1LnR5cGU9PT1cImxpc3RJdGVtXCIpJiYoZGVsZXRlIGEuc3ByZWFkLGRlbGV0ZSBhLmxvb3NlKSx1LnR5cGU9PT1cInRleHRcInx8KHUudHlwZT09PVwiaW5saW5lQ29kZVwiJiYoYS52YWx1ZT11LnZhbHVlLnJlcGxhY2UoL1tcXHRcXG4gXSsvZyxcIiBcIikpLHUudHlwZT09PVwid2lraUxpbmtcIiYmKGEudmFsdWU9dS52YWx1ZS50cmltKCkucmVwbGFjZSgvW1xcdFxcbl0rL2csXCIgXCIpKSwodS50eXBlPT09XCJkZWZpbml0aW9uXCJ8fHUudHlwZT09PVwibGlua1JlZmVyZW5jZVwiKSYmKGEubGFiZWw9dS5sYWJlbC50cmltKCkucmVwbGFjZSgvW1xcdFxcbiBdKy9nLFwiIFwiKS50b0xvd2VyQ2FzZSgpKSwodS50eXBlPT09XCJkZWZpbml0aW9uXCJ8fHUudHlwZT09PVwibGlua1wifHx1LnR5cGU9PT1cImltYWdlXCIpJiZ1LnRpdGxlJiYoYS50aXRsZT11LnRpdGxlLnJlcGxhY2UoL1xcXFwoW1wiJyldKS9nLFwiJDFcIikpLGMmJmMudHlwZT09PVwicm9vdFwiJiZjLmNoaWxkcmVuLmxlbmd0aD4wJiYoYy5jaGlsZHJlblswXT09PXV8fHQoYy5jaGlsZHJlblswXSkmJmMuY2hpbGRyZW5bMV09PT11KSYmdS50eXBlPT09XCJodG1sXCImJnModS52YWx1ZSkpKXJldHVybiBudWxsfXIuaWdub3JlZFByb3BlcnRpZXM9aSxuLmV4cG9ydHM9cn19KSxUZD1aKHtcInNyYy9sYW5ndWFnZS1tYXJrZG93bi9wcmludGVyLW1hcmtkb3duLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntnZXRMYXN0OnQsZ2V0TWluTm90UHJlc2VudENvbnRpbnVvdXNDb3VudDpzLGdldE1heENvbnRpbnVvdXNDb3VudDppLGdldFN0cmluZ1dpZHRoOnIsaXNOb25FbXB0eUFycmF5OnV9PUdlKCkse2J1aWxkZXJzOnticmVha1BhcmVudDphLGpvaW46YyxsaW5lOmwsbGl0ZXJhbGxpbmU6QyxtYXJrQXNSb290Om0saGFyZGxpbmU6Zyxzb2Z0bGluZTpwLGlmQnJlYWs6ZixmaWxsOmgsYWxpZ246TixpbmRlbnQ6VCxncm91cDpBLGhhcmRsaW5lV2l0aG91dEJyZWFrUGFyZW50OmJ9LHV0aWxzOntub3JtYWxpemVEb2M6dixyZXBsYWNlVGV4dEVuZE9mTGluZTpCfSxwcmludGVyOntwcmludERvY1RvU3RyaW5nOnd9fT1MZSgpLEk9U2QoKSx7aW5zZXJ0UHJhZ21hOkV9PURvKCkse2xvY1N0YXJ0OkQsbG9jRW5kOmR9PWZvKCkseT14ZCgpLG89YmQoKSx7Z2V0RmVuY2VkQ29kZUJsb2NrVmFsdWU6eCxoYXNHaXREaWZmRnJpZW5kbHlPcmRlcmVkTGlzdDpGLHNwbGl0VGV4dDpTLHB1bmN0dWF0aW9uUGF0dGVybjprLElOTElORV9OT0RFX1RZUEVTOl8sSU5MSU5FX05PREVfV1JBUFBFUl9UWVBFUzpPLGlzQXV0b2xpbms6Un09S24oKSxNPW5ldyBTZXQoW1wiaW1wb3J0RXhwb3J0XCJdKSxIPVtcImhlYWRpbmdcIixcInRhYmxlQ2VsbFwiLFwibGlua1wiLFwid2lraUxpbmtcIl0sUD1uZXcgU2V0KFtcImxpc3RJdGVtXCIsXCJkZWZpbml0aW9uXCIsXCJmb290bm90ZURlZmluaXRpb25cIl0pO2Z1bmN0aW9uIEcoZmUscGUsbWUpe2xldCBjZT1mZS5nZXRWYWx1ZSgpO2lmKGRlKGZlKSlyZXR1cm4gUyhwZS5vcmlnaW5hbFRleHQuc2xpY2UoY2UucG9zaXRpb24uc3RhcnQub2Zmc2V0LGNlLnBvc2l0aW9uLmVuZC5vZmZzZXQpLHBlKS5tYXAoaGU9PmhlLnR5cGU9PT1cIndvcmRcIj9oZS52YWx1ZTpoZS52YWx1ZT09PVwiXCI/XCJcIjpzZShmZSxoZS52YWx1ZSxwZSkpO3N3aXRjaChjZS50eXBlKXtjYXNlXCJmcm9udC1tYXR0ZXJcIjpyZXR1cm4gcGUub3JpZ2luYWxUZXh0LnNsaWNlKGNlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCxjZS5wb3NpdGlvbi5lbmQub2Zmc2V0KTtjYXNlXCJyb290XCI6cmV0dXJuIGNlLmNoaWxkcmVuLmxlbmd0aD09PTA/XCJcIjpbdihvZShmZSxwZSxtZSkpLE0uaGFzKEVlKGNlKS50eXBlKT9cIlwiOmddO2Nhc2VcInBhcmFncmFwaFwiOnJldHVybiBLKGZlLHBlLG1lLHtwb3N0cHJvY2Vzc29yOmh9KTtjYXNlXCJzZW50ZW5jZVwiOnJldHVybiBLKGZlLHBlLG1lKTtjYXNlXCJ3b3JkXCI6e2xldCBoZT1jZS52YWx1ZS5yZXBsYWNlKC9cXCovZyxcIlxcXFwkJlwiKS5yZXBsYWNlKG5ldyBSZWdFeHAoW1wiKF58XCIuY29uY2F0KGssXCIpKF8rKVwiKSxcIihfKykoXCIuY29uY2F0KGssXCJ8JClcIildLmpvaW4oXCJ8XCIpLFwiZ1wiKSwoWCxZLHRlLHosaik9Pih0ZT9cIlwiLmNvbmNhdChZKS5jb25jYXQodGUpOlwiXCIuY29uY2F0KHopLmNvbmNhdChqKSkucmVwbGFjZSgvXy9nLFwiXFxcXF9cIikpLEo9KFgsWSx0ZSk9PlgudHlwZT09PVwic2VudGVuY2VcIiYmdGU9PT0wLHllPShYLFksdGUpPT5SKFguY2hpbGRyZW5bdGUtMV0pO3JldHVybiBoZSE9PWNlLnZhbHVlJiYoZmUubWF0Y2godm9pZCAwLEoseWUpfHxmZS5tYXRjaCh2b2lkIDAsSiwoWCxZLHRlKT0+WC50eXBlPT09XCJlbXBoYXNpc1wiJiZ0ZT09PTAseWUpKSYmKGhlPWhlLnJlcGxhY2UoL14oXFxcXD9bKl9dKSsvLFg9PlgucmVwbGFjZSgvXFxcXC9nLFwiXCIpKSksaGV9Y2FzZVwid2hpdGVzcGFjZVwiOntsZXQgaGU9ZmUuZ2V0UGFyZW50Tm9kZSgpLEo9aGUuY2hpbGRyZW4uaW5kZXhPZihjZSkseWU9aGUuY2hpbGRyZW5bSisxXSxYPXllJiYvXj58Xig/OlsqKy1dfCN7MSw2fXxcXGQrWykuXSkkLy50ZXN0KHllLnZhbHVlKT9cIm5ldmVyXCI6cGUucHJvc2VXcmFwO3JldHVybiBzZShmZSxjZS52YWx1ZSx7cHJvc2VXcmFwOlh9KX1jYXNlXCJlbXBoYXNpc1wiOntsZXQgaGU7aWYoUihjZS5jaGlsZHJlblswXSkpaGU9cGUub3JpZ2luYWxUZXh0W2NlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldF07ZWxzZXtsZXQgSj1mZS5nZXRQYXJlbnROb2RlKCkseWU9Si5jaGlsZHJlbi5pbmRleE9mKGNlKSxYPUouY2hpbGRyZW5beWUtMV0sWT1KLmNoaWxkcmVuW3llKzFdO2hlPVgmJlgudHlwZT09PVwic2VudGVuY2VcIiYmWC5jaGlsZHJlbi5sZW5ndGg+MCYmdChYLmNoaWxkcmVuKS50eXBlPT09XCJ3b3JkXCImJiF0KFguY2hpbGRyZW4pLmhhc1RyYWlsaW5nUHVuY3R1YXRpb258fFkmJlkudHlwZT09PVwic2VudGVuY2VcIiYmWS5jaGlsZHJlbi5sZW5ndGg+MCYmWS5jaGlsZHJlblswXS50eXBlPT09XCJ3b3JkXCImJiFZLmNoaWxkcmVuWzBdLmhhc0xlYWRpbmdQdW5jdHVhdGlvbnx8bmUoZmUsXCJlbXBoYXNpc1wiKT9cIipcIjpcIl9cIn1yZXR1cm5baGUsSyhmZSxwZSxtZSksaGVdfWNhc2VcInN0cm9uZ1wiOnJldHVybltcIioqXCIsSyhmZSxwZSxtZSksXCIqKlwiXTtjYXNlXCJkZWxldGVcIjpyZXR1cm5bXCJ+flwiLEsoZmUscGUsbWUpLFwifn5cIl07Y2FzZVwiaW5saW5lQ29kZVwiOntsZXQgaGU9cyhjZS52YWx1ZSxcImBcIiksSj1cImBcIi5yZXBlYXQoaGV8fDEpLHllPWhlJiYhL15cXHMvLnRlc3QoY2UudmFsdWUpP1wiIFwiOlwiXCI7cmV0dXJuW0oseWUsY2UudmFsdWUseWUsSl19Y2FzZVwid2lraUxpbmtcIjp7bGV0IGhlPVwiXCI7cmV0dXJuIHBlLnByb3NlV3JhcD09PVwicHJlc2VydmVcIj9oZT1jZS52YWx1ZTpoZT1jZS52YWx1ZS5yZXBsYWNlKC9bXFx0XFxuXSsvZyxcIiBcIiksW1wiW1tcIixoZSxcIl1dXCJdfWNhc2VcImxpbmtcIjpzd2l0Y2gocGUub3JpZ2luYWxUZXh0W2NlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldF0pe2Nhc2VcIjxcIjp7bGV0IGhlPVwibWFpbHRvOlwiLEo9Y2UudXJsLnN0YXJ0c1dpdGgoaGUpJiZwZS5vcmlnaW5hbFRleHQuc2xpY2UoY2UucG9zaXRpb24uc3RhcnQub2Zmc2V0KzEsY2UucG9zaXRpb24uc3RhcnQub2Zmc2V0KzEraGUubGVuZ3RoKSE9PWhlP2NlLnVybC5zbGljZShoZS5sZW5ndGgpOmNlLnVybDtyZXR1cm5bXCI8XCIsSixcIj5cIl19Y2FzZVwiW1wiOnJldHVybltcIltcIixLKGZlLHBlLG1lKSxcIl0oXCIsZ2UoY2UudXJsLFwiKVwiKSx2ZShjZS50aXRsZSxwZSksXCIpXCJdO2RlZmF1bHQ6cmV0dXJuIHBlLm9yaWdpbmFsVGV4dC5zbGljZShjZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsY2UucG9zaXRpb24uZW5kLm9mZnNldCl9Y2FzZVwiaW1hZ2VcIjpyZXR1cm5bXCIhW1wiLGNlLmFsdHx8XCJcIixcIl0oXCIsZ2UoY2UudXJsLFwiKVwiKSx2ZShjZS50aXRsZSxwZSksXCIpXCJdO2Nhc2VcImJsb2NrcXVvdGVcIjpyZXR1cm5bXCI+IFwiLE4oXCI+IFwiLEsoZmUscGUsbWUpKV07Y2FzZVwiaGVhZGluZ1wiOnJldHVybltcIiNcIi5yZXBlYXQoY2UuZGVwdGgpK1wiIFwiLEsoZmUscGUsbWUpXTtjYXNlXCJjb2RlXCI6e2lmKGNlLmlzSW5kZW50ZWQpe2xldCB5ZT1cIiBcIi5yZXBlYXQoNCk7cmV0dXJuIE4oeWUsW3llLC4uLkIoY2UudmFsdWUsZyldKX1sZXQgaGU9cGUuX19pbkpzVGVtcGxhdGU/XCJ+XCI6XCJgXCIsSj1oZS5yZXBlYXQoTWF0aC5tYXgoMyxpKGNlLnZhbHVlLGhlKSsxKSk7cmV0dXJuW0osY2UubGFuZ3x8XCJcIixjZS5tZXRhP1wiIFwiK2NlLm1ldGE6XCJcIixnLC4uLkIoeChjZSxwZS5vcmlnaW5hbFRleHQpLGcpLGcsSl19Y2FzZVwiaHRtbFwiOntsZXQgaGU9ZmUuZ2V0UGFyZW50Tm9kZSgpLEo9aGUudHlwZT09PVwicm9vdFwiJiZ0KGhlLmNoaWxkcmVuKT09PWNlP2NlLnZhbHVlLnRyaW1FbmQoKTpjZS52YWx1ZSx5ZT0vXjwhLS0uKi0tPiQvcy50ZXN0KEopO3JldHVybiBCKEoseWU/ZzptKEMpKX1jYXNlXCJsaXN0XCI6e2xldCBoZT1XKGNlLGZlLmdldFBhcmVudE5vZGUoKSksSj1GKGNlLHBlKTtyZXR1cm4gSyhmZSxwZSxtZSx7cHJvY2Vzc29yOih5ZSxYKT0+e2xldCBZPXooKSx0ZT15ZS5nZXRWYWx1ZSgpO2lmKHRlLmNoaWxkcmVuLmxlbmd0aD09PTImJnRlLmNoaWxkcmVuWzFdLnR5cGU9PT1cImh0bWxcIiYmdGUuY2hpbGRyZW5bMF0ucG9zaXRpb24uc3RhcnQuY29sdW1uIT09dGUuY2hpbGRyZW5bMV0ucG9zaXRpb24uc3RhcnQuY29sdW1uKXJldHVybltZLHJlKHllLHBlLG1lLFkpXTtyZXR1cm5bWSxOKFwiIFwiLnJlcGVhdChZLmxlbmd0aCkscmUoeWUscGUsbWUsWSkpXTtmdW5jdGlvbiB6KCl7bGV0IGo9Y2Uub3JkZXJlZD8oWD09PTA/Y2Uuc3RhcnQ6Sj8xOmNlLnN0YXJ0K1gpKyhoZSUyPT09MD9cIi4gXCI6XCIpIFwiKTpoZSUyPT09MD9cIi0gXCI6XCIqIFwiO3JldHVybiBjZS5pc0FsaWduZWR8fGNlLmhhc0luZGVudGVkQ29kZWJsb2NrPyQoaixwZSk6an19fSl9Y2FzZVwidGhlbWF0aWNCcmVha1wiOntsZXQgaGU9VShmZSxcImxpc3RcIik7cmV0dXJuIGhlPT09LTE/XCItLS1cIjpXKGZlLmdldFBhcmVudE5vZGUoaGUpLGZlLmdldFBhcmVudE5vZGUoaGUrMSkpJTI9PT0wP1wiKioqXCI6XCItLS1cIn1jYXNlXCJsaW5rUmVmZXJlbmNlXCI6cmV0dXJuW1wiW1wiLEsoZmUscGUsbWUpLFwiXVwiLGNlLnJlZmVyZW5jZVR5cGU9PT1cImZ1bGxcIj9bXCJbXCIsY2UuaWRlbnRpZmllcixcIl1cIl06Y2UucmVmZXJlbmNlVHlwZT09PVwiY29sbGFwc2VkXCI/XCJbXVwiOlwiXCJdO2Nhc2VcImltYWdlUmVmZXJlbmNlXCI6c3dpdGNoKGNlLnJlZmVyZW5jZVR5cGUpe2Nhc2VcImZ1bGxcIjpyZXR1cm5bXCIhW1wiLGNlLmFsdHx8XCJcIixcIl1bXCIsY2UuaWRlbnRpZmllcixcIl1cIl07ZGVmYXVsdDpyZXR1cm5bXCIhW1wiLGNlLmFsdCxcIl1cIixjZS5yZWZlcmVuY2VUeXBlPT09XCJjb2xsYXBzZWRcIj9cIltdXCI6XCJcIl19Y2FzZVwiZGVmaW5pdGlvblwiOntsZXQgaGU9cGUucHJvc2VXcmFwPT09XCJhbHdheXNcIj9sOlwiIFwiO3JldHVybiBBKFtcIltcIixjZS5pZGVudGlmaWVyLFwiXTpcIixUKFtoZSxnZShjZS51cmwpLGNlLnRpdGxlPT09bnVsbD9cIlwiOltoZSx2ZShjZS50aXRsZSxwZSwhMSldXSldKX1jYXNlXCJmb290bm90ZVwiOnJldHVybltcIlteXCIsSyhmZSxwZSxtZSksXCJdXCJdO2Nhc2VcImZvb3Rub3RlUmVmZXJlbmNlXCI6cmV0dXJuW1wiW15cIixjZS5pZGVudGlmaWVyLFwiXVwiXTtjYXNlXCJmb290bm90ZURlZmluaXRpb25cIjp7bGV0IGhlPWZlLmdldFBhcmVudE5vZGUoKS5jaGlsZHJlbltmZS5nZXROYW1lKCkrMV0sSj1jZS5jaGlsZHJlbi5sZW5ndGg9PT0xJiZjZS5jaGlsZHJlblswXS50eXBlPT09XCJwYXJhZ3JhcGhcIiYmKHBlLnByb3NlV3JhcD09PVwibmV2ZXJcInx8cGUucHJvc2VXcmFwPT09XCJwcmVzZXJ2ZVwiJiZjZS5jaGlsZHJlblswXS5wb3NpdGlvbi5zdGFydC5saW5lPT09Y2UuY2hpbGRyZW5bMF0ucG9zaXRpb24uZW5kLmxpbmUpO3JldHVybltcIlteXCIsY2UuaWRlbnRpZmllcixcIl06IFwiLEo/SyhmZSxwZSxtZSk6QShbTihcIiBcIi5yZXBlYXQoNCksSyhmZSxwZSxtZSx7cHJvY2Vzc29yOih5ZSxYKT0+WD09PTA/QShbcCxtZSgpXSk6bWUoKX0pKSxoZSYmaGUudHlwZT09PVwiZm9vdG5vdGVEZWZpbml0aW9uXCI/cDpcIlwiXSldfWNhc2VcInRhYmxlXCI6cmV0dXJuIFYoZmUscGUsbWUpO2Nhc2VcInRhYmxlQ2VsbFwiOnJldHVybiBLKGZlLHBlLG1lKTtjYXNlXCJicmVha1wiOnJldHVybi9cXHMvLnRlc3QocGUub3JpZ2luYWxUZXh0W2NlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldF0pP1tcIiAgXCIsbShDKV06W1wiXFxcXFwiLGddO2Nhc2VcImxpcXVpZE5vZGVcIjpyZXR1cm4gQihjZS52YWx1ZSxnKTtjYXNlXCJpbXBvcnRFeHBvcnRcIjpyZXR1cm5bY2UudmFsdWUsZ107Y2FzZVwiZXNDb21tZW50XCI6cmV0dXJuW1wiey8qIFwiLGNlLnZhbHVlLFwiICovfVwiXTtjYXNlXCJqc3hcIjpyZXR1cm4gY2UudmFsdWU7Y2FzZVwibWF0aFwiOnJldHVybltcIiQkXCIsZyxjZS52YWx1ZT9bLi4uQihjZS52YWx1ZSxnKSxnXTpcIlwiLFwiJCRcIl07Y2FzZVwiaW5saW5lTWF0aFwiOnJldHVybiBwZS5vcmlnaW5hbFRleHQuc2xpY2UoRChjZSksZChjZSkpO2Nhc2VcInRhYmxlUm93XCI6Y2FzZVwibGlzdEl0ZW1cIjpkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVua25vd24gbWFya2Rvd24gdHlwZSBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoY2UudHlwZSkpKX19ZnVuY3Rpb24gcmUoZmUscGUsbWUsY2Upe2xldCBoZT1mZS5nZXRWYWx1ZSgpLEo9aGUuY2hlY2tlZD09PW51bGw/XCJcIjpoZS5jaGVja2VkP1wiW3hdIFwiOlwiWyBdIFwiO3JldHVybltKLEsoZmUscGUsbWUse3Byb2Nlc3NvcjooeWUsWCk9PntpZihYPT09MCYmeWUuZ2V0VmFsdWUoKS50eXBlIT09XCJsaXN0XCIpcmV0dXJuIE4oXCIgXCIucmVwZWF0KEoubGVuZ3RoKSxtZSgpKTtsZXQgWT1cIiBcIi5yZXBlYXQoeGUocGUudGFiV2lkdGgtY2UubGVuZ3RoLDAsMykpO3JldHVybltZLE4oWSxtZSgpKV19fSldfWZ1bmN0aW9uICQoZmUscGUpe2xldCBtZT1jZSgpO3JldHVybiBmZStcIiBcIi5yZXBlYXQobWU+PTQ/MDptZSk7ZnVuY3Rpb24gY2UoKXtsZXQgaGU9ZmUubGVuZ3RoJXBlLnRhYldpZHRoO3JldHVybiBoZT09PTA/MDpwZS50YWJXaWR0aC1oZX19ZnVuY3Rpb24gVyhmZSxwZSl7cmV0dXJuIGVlKGZlLHBlLG1lPT5tZS5vcmRlcmVkPT09ZmUub3JkZXJlZCl9ZnVuY3Rpb24gZWUoZmUscGUsbWUpe2xldCBjZT0tMTtmb3IobGV0IGhlIG9mIHBlLmNoaWxkcmVuKWlmKGhlLnR5cGU9PT1mZS50eXBlJiZtZShoZSk/Y2UrKzpjZT0tMSxoZT09PWZlKXJldHVybiBjZX1mdW5jdGlvbiBVKGZlLHBlKXtsZXQgbWU9QXJyYXkuaXNBcnJheShwZSk/cGU6W3BlXSxjZT0tMSxoZTtmb3IoO2hlPWZlLmdldFBhcmVudE5vZGUoKytjZSk7KWlmKG1lLmluY2x1ZGVzKGhlLnR5cGUpKXJldHVybiBjZTtyZXR1cm4tMX1mdW5jdGlvbiBuZShmZSxwZSl7bGV0IG1lPVUoZmUscGUpO3JldHVybiBtZT09PS0xP251bGw6ZmUuZ2V0UGFyZW50Tm9kZShtZSl9ZnVuY3Rpb24gc2UoZmUscGUsbWUpe2lmKG1lLnByb3NlV3JhcD09PVwicHJlc2VydmVcIiYmcGU9PT1gXG5gKXJldHVybiBnO2xldCBjZT1tZS5wcm9zZVdyYXA9PT1cImFsd2F5c1wiJiYhbmUoZmUsSCk7cmV0dXJuIHBlIT09XCJcIj9jZT9sOlwiIFwiOmNlP3A6XCJcIn1mdW5jdGlvbiBWKGZlLHBlLG1lKXtsZXQgY2U9ZmUuZ2V0VmFsdWUoKSxoZT1bXSxKPWZlLm1hcChqPT5qLm1hcCgoQ2UsTmUpPT57bGV0IGplPXcobWUoKSxwZSkuZm9ybWF0dGVkLFVlPXIoamUpO3JldHVybiBoZVtOZV09TWF0aC5tYXgoaGVbTmVdfHwzLFVlKSx7dGV4dDpqZSx3aWR0aDpVZX19LFwiY2hpbGRyZW5cIiksXCJjaGlsZHJlblwiKSx5ZT1ZKCExKTtpZihwZS5wcm9zZVdyYXAhPT1cIm5ldmVyXCIpcmV0dXJuW2EseWVdO2xldCBYPVkoITApO3JldHVyblthLEEoZihYLHllKSldO2Z1bmN0aW9uIFkoail7bGV0IENlPVt6KEpbMF0saiksdGUoaildO3JldHVybiBKLmxlbmd0aD4xJiZDZS5wdXNoKGMoYixKLnNsaWNlKDEpLm1hcChOZT0+eihOZSxqKSkpKSxjKGIsQ2UpfWZ1bmN0aW9uIHRlKGope2xldCBDZT1oZS5tYXAoKE5lLGplKT0+e2xldCBVZT1jZS5hbGlnbltqZV0sdHQ9VWU9PT1cImNlbnRlclwifHxVZT09PVwibGVmdFwiP1wiOlwiOlwiLVwiLFRlPVVlPT09XCJjZW50ZXJcInx8VWU9PT1cInJpZ2h0XCI/XCI6XCI6XCItXCIsX2U9aj9cIi1cIjpcIi1cIi5yZXBlYXQoTmUtMik7cmV0dXJuXCJcIi5jb25jYXQodHQpLmNvbmNhdChfZSkuY29uY2F0KFRlKX0pO3JldHVyblwifCBcIi5jb25jYXQoQ2Uuam9pbihcIiB8IFwiKSxcIiB8XCIpfWZ1bmN0aW9uIHooaixDZSl7bGV0IE5lPWoubWFwKChqZSxVZSk9PntsZXR7dGV4dDp0dCx3aWR0aDpUZX09amU7aWYoQ2UpcmV0dXJuIHR0O2xldCBfZT1oZVtVZV0tVGUsRmU9Y2UuYWxpZ25bVWVdLEtlPTA7RmU9PT1cInJpZ2h0XCI/S2U9X2U6RmU9PT1cImNlbnRlclwiJiYoS2U9TWF0aC5mbG9vcihfZS8yKSk7bGV0IFNlPV9lLUtlO3JldHVyblwiXCIuY29uY2F0KFwiIFwiLnJlcGVhdChLZSkpLmNvbmNhdCh0dCkuY29uY2F0KFwiIFwiLnJlcGVhdChTZSkpfSk7cmV0dXJuXCJ8IFwiLmNvbmNhdChOZS5qb2luKFwiIHwgXCIpLFwiIHxcIil9fWZ1bmN0aW9uIG9lKGZlLHBlLG1lKXtsZXQgY2U9W10saGU9bnVsbCx7Y2hpbGRyZW46Sn09ZmUuZ2V0VmFsdWUoKTtmb3IobGV0W3llLFhdb2YgSi5lbnRyaWVzKCkpc3dpdGNoKHEoWCkpe2Nhc2VcInN0YXJ0XCI6aGU9PT1udWxsJiYoaGU9e2luZGV4OnllLG9mZnNldDpYLnBvc2l0aW9uLmVuZC5vZmZzZXR9KTticmVhaztjYXNlXCJlbmRcIjpoZSE9PW51bGwmJihjZS5wdXNoKHtzdGFydDpoZSxlbmQ6e2luZGV4OnllLG9mZnNldDpYLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldH19KSxoZT1udWxsKTticmVhaztkZWZhdWx0OmJyZWFrfXJldHVybiBLKGZlLHBlLG1lLHtwcm9jZXNzb3I6KHllLFgpPT57aWYoY2UubGVuZ3RoPjApe2xldCBZPWNlWzBdO2lmKFg9PT1ZLnN0YXJ0LmluZGV4KXJldHVybltKW1kuc3RhcnQuaW5kZXhdLnZhbHVlLHBlLm9yaWdpbmFsVGV4dC5zbGljZShZLnN0YXJ0Lm9mZnNldCxZLmVuZC5vZmZzZXQpLEpbWS5lbmQuaW5kZXhdLnZhbHVlXTtpZihZLnN0YXJ0LmluZGV4PFgmJlg8WS5lbmQuaW5kZXgpcmV0dXJuITE7aWYoWD09PVkuZW5kLmluZGV4KXJldHVybiBjZS5zaGlmdCgpLCExfXJldHVybiBtZSgpfX0pfWZ1bmN0aW9uIEsoZmUscGUsbWUpe2xldCBjZT1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXZvaWQgMD9hcmd1bWVudHNbM106e30se3Bvc3Rwcm9jZXNzb3I6aGV9PWNlLEo9Y2UucHJvY2Vzc29yfHwoKCk9Pm1lKCkpLHllPWZlLmdldFZhbHVlKCksWD1bXSxZO3JldHVybiBmZS5lYWNoKCh0ZSx6KT0+e2xldCBqPXRlLmdldFZhbHVlKCksQ2U9Sih0ZSx6KTtpZihDZSE9PSExKXtsZXQgTmU9e3BhcnRzOlgscHJldk5vZGU6WSxwYXJlbnROb2RlOnllLG9wdGlvbnM6cGV9O2xlKGosTmUpJiYoWC5wdXNoKGcpLFkmJk0uaGFzKFkudHlwZSl8fCh1ZShqLE5lKXx8UShqLE5lKSkmJlgucHVzaChnKSxRKGosTmUpJiZYLnB1c2goZykpLFgucHVzaChDZSksWT1qfX0sXCJjaGlsZHJlblwiKSxoZT9oZShYKTpYfWZ1bmN0aW9uIEVlKGZlKXtsZXQgcGU9ZmU7Zm9yKDt1KHBlLmNoaWxkcmVuKTspcGU9dChwZS5jaGlsZHJlbik7cmV0dXJuIHBlfWZ1bmN0aW9uIHEoZmUpe2xldCBwZTtpZihmZS50eXBlPT09XCJodG1sXCIpcGU9ZmUudmFsdWUubWF0Y2goL148IS0tXFxzKnByZXR0aWVyLWlnbm9yZSg/Oi0oc3RhcnR8ZW5kKSk/XFxzKi0tPiQvKTtlbHNle2xldCBtZTtmZS50eXBlPT09XCJlc0NvbW1lbnRcIj9tZT1mZTpmZS50eXBlPT09XCJwYXJhZ3JhcGhcIiYmZmUuY2hpbGRyZW4ubGVuZ3RoPT09MSYmZmUuY2hpbGRyZW5bMF0udHlwZT09PVwiZXNDb21tZW50XCImJihtZT1mZS5jaGlsZHJlblswXSksbWUmJihwZT1tZS52YWx1ZS5tYXRjaCgvXnByZXR0aWVyLWlnbm9yZSg/Oi0oc3RhcnR8ZW5kKSk/JC8pKX1yZXR1cm4gcGU/cGVbMV0/cGVbMV06XCJuZXh0XCI6ITF9ZnVuY3Rpb24gbGUoZmUscGUpe2xldCBtZT1wZS5wYXJ0cy5sZW5ndGg9PT0wLGNlPV8uaW5jbHVkZXMoZmUudHlwZSksaGU9ZmUudHlwZT09PVwiaHRtbFwiJiZPLmluY2x1ZGVzKHBlLnBhcmVudE5vZGUudHlwZSk7cmV0dXJuIW1lJiYhY2UmJiFoZX1mdW5jdGlvbiB1ZShmZSxwZSl7bGV0IGNlPShwZS5wcmV2Tm9kZSYmcGUucHJldk5vZGUudHlwZSk9PT1mZS50eXBlJiZQLmhhcyhmZS50eXBlKSxoZT1wZS5wYXJlbnROb2RlLnR5cGU9PT1cImxpc3RJdGVtXCImJiFwZS5wYXJlbnROb2RlLmxvb3NlLEo9cGUucHJldk5vZGUmJnBlLnByZXZOb2RlLnR5cGU9PT1cImxpc3RJdGVtXCImJnBlLnByZXZOb2RlLmxvb3NlLHllPXEocGUucHJldk5vZGUpPT09XCJuZXh0XCIsWD1mZS50eXBlPT09XCJodG1sXCImJnBlLnByZXZOb2RlJiZwZS5wcmV2Tm9kZS50eXBlPT09XCJodG1sXCImJnBlLnByZXZOb2RlLnBvc2l0aW9uLmVuZC5saW5lKzE9PT1mZS5wb3NpdGlvbi5zdGFydC5saW5lLFk9ZmUudHlwZT09PVwiaHRtbFwiJiZwZS5wYXJlbnROb2RlLnR5cGU9PT1cImxpc3RJdGVtXCImJnBlLnByZXZOb2RlJiZwZS5wcmV2Tm9kZS50eXBlPT09XCJwYXJhZ3JhcGhcIiYmcGUucHJldk5vZGUucG9zaXRpb24uZW5kLmxpbmUrMT09PWZlLnBvc2l0aW9uLnN0YXJ0LmxpbmU7cmV0dXJuIEp8fCEoY2V8fGhlfHx5ZXx8WHx8WSl9ZnVuY3Rpb24gUShmZSxwZSl7bGV0IG1lPXBlLnByZXZOb2RlJiZwZS5wcmV2Tm9kZS50eXBlPT09XCJsaXN0XCIsY2U9ZmUudHlwZT09PVwiY29kZVwiJiZmZS5pc0luZGVudGVkO3JldHVybiBtZSYmY2V9ZnVuY3Rpb24gZGUoZmUpe2xldCBwZT1uZShmZSxbXCJsaW5rUmVmZXJlbmNlXCIsXCJpbWFnZVJlZmVyZW5jZVwiXSk7cmV0dXJuIHBlJiYocGUudHlwZSE9PVwibGlua1JlZmVyZW5jZVwifHxwZS5yZWZlcmVuY2VUeXBlIT09XCJmdWxsXCIpfWZ1bmN0aW9uIGdlKGZlKXtsZXQgcGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOltdLG1lPVtcIiBcIiwuLi5BcnJheS5pc0FycmF5KHBlKT9wZTpbcGVdXTtyZXR1cm4gbmV3IFJlZ0V4cChtZS5tYXAoY2U9PlwiXFxcXFwiLmNvbmNhdChjZSkpLmpvaW4oXCJ8XCIpKS50ZXN0KGZlKT9cIjxcIi5jb25jYXQoZmUsXCI+XCIpOmZlfWZ1bmN0aW9uIHZlKGZlLHBlKXtsZXQgbWU9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOiEwO2lmKCFmZSlyZXR1cm5cIlwiO2lmKG1lKXJldHVyblwiIFwiK3ZlKGZlLHBlLCExKTtpZihmZT1mZS5yZXBsYWNlKC9cXFxcKFtcIicpXSkvZyxcIiQxXCIpLGZlLmluY2x1ZGVzKCdcIicpJiZmZS5pbmNsdWRlcyhcIidcIikmJiFmZS5pbmNsdWRlcyhcIilcIikpcmV0dXJuXCIoXCIuY29uY2F0KGZlLFwiKVwiKTtsZXQgY2U9ZmUuc3BsaXQoXCInXCIpLmxlbmd0aC0xLGhlPWZlLnNwbGl0KCdcIicpLmxlbmd0aC0xLEo9Y2U+aGU/J1wiJzpoZT5jZXx8cGUuc2luZ2xlUXVvdGU/XCInXCI6J1wiJztyZXR1cm4gZmU9ZmUucmVwbGFjZSgvXFxcXC8sXCJcXFxcXFxcXFwiKSxmZT1mZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoXCIuY29uY2F0KEosXCIpXCIpLFwiZ1wiKSxcIlxcXFwkMVwiKSxcIlwiLmNvbmNhdChKKS5jb25jYXQoZmUpLmNvbmNhdChKKX1mdW5jdGlvbiB4ZShmZSxwZSxtZSl7cmV0dXJuIGZlPHBlP3BlOmZlPm1lP21lOmZlfWZ1bmN0aW9uIHdlKGZlKXtsZXQgcGU9TnVtYmVyKGZlLmdldE5hbWUoKSk7aWYocGU9PT0wKXJldHVybiExO2xldCBtZT1mZS5nZXRQYXJlbnROb2RlKCkuY2hpbGRyZW5bcGUtMV07cmV0dXJuIHEobWUpPT09XCJuZXh0XCJ9bi5leHBvcnRzPXtwcmVwcm9jZXNzOnkscHJpbnQ6RyxlbWJlZDpJLG1hc3NhZ2VBc3ROb2RlOm8saGFzUHJldHRpZXJJZ25vcmU6d2UsaW5zZXJ0UHJhZ21hOkV9fX0pLEJkPVooe1wic3JjL2xhbmd1YWdlLW1hcmtkb3duL29wdGlvbnMuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9THQoKTtuLmV4cG9ydHM9e3Byb3NlV3JhcDp0LnByb3NlV3JhcCxzaW5nbGVRdW90ZTp0LnNpbmdsZVF1b3RlfX19KSxOZD1aKHtcInNyYy9sYW5ndWFnZS1tYXJrZG93bi9wYXJzZXJzLmpzXCIoKXthZSgpfX0pLGRpPVooe1wibm9kZV9tb2R1bGVzL2xpbmd1aXN0LWxhbmd1YWdlcy9kYXRhL01hcmtkb3duLmpzb25cIihlLG4pe24uZXhwb3J0cz17bmFtZTpcIk1hcmtkb3duXCIsdHlwZTpcInByb3NlXCIsY29sb3I6XCIjMDgzZmExXCIsYWxpYXNlczpbXCJwYW5kb2NcIl0sYWNlTW9kZTpcIm1hcmtkb3duXCIsY29kZW1pcnJvck1vZGU6XCJnZm1cIixjb2RlbWlycm9yTWltZVR5cGU6XCJ0ZXh0L3gtZ2ZtXCIsd3JhcDohMCxleHRlbnNpb25zOltcIi5tZFwiLFwiLm1hcmtkb3duXCIsXCIubWRvd25cIixcIi5tZHduXCIsXCIubWR4XCIsXCIubWtkXCIsXCIubWtkblwiLFwiLm1rZG93blwiLFwiLnJvbm5cIixcIi5zY2RcIixcIi53b3JrYm9va1wiXSxmaWxlbmFtZXM6W1wiY29udGVudHMubHJcIl0sdG1TY29wZTpcInNvdXJjZS5nZm1cIixsYW5ndWFnZUlkOjIyMn19fSksd2Q9Wih7XCJzcmMvbGFuZ3VhZ2UtbWFya2Rvd24vaW5kZXguanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9YnQoKSxzPVRkKCksaT1CZCgpLHI9TmQoKSx1PVt0KGRpKCksYz0+KHtzaW5jZTpcIjEuOC4wXCIscGFyc2VyczpbXCJtYXJrZG93blwiXSx2c2NvZGVMYW5ndWFnZUlkczpbXCJtYXJrZG93blwiXSxmaWxlbmFtZXM6Wy4uLmMuZmlsZW5hbWVzLFwiUkVBRE1FXCJdLGV4dGVuc2lvbnM6Yy5leHRlbnNpb25zLmZpbHRlcihsPT5sIT09XCIubWR4XCIpfSkpLHQoZGkoKSwoKT0+KHtuYW1lOlwiTURYXCIsc2luY2U6XCIxLjE1LjBcIixwYXJzZXJzOltcIm1keFwiXSx2c2NvZGVMYW5ndWFnZUlkczpbXCJtZHhcIl0sZmlsZW5hbWVzOltdLGV4dGVuc2lvbnM6W1wiLm1keFwiXX0pKV0sYT17bWRhc3Q6c307bi5leHBvcnRzPXtsYW5ndWFnZXM6dSxvcHRpb25zOmkscHJpbnRlcnM6YSxwYXJzZXJzOnJ9fX0pLF9kPVooe1wic3JjL2xhbmd1YWdlLWh0bWwvY2xlYW4uanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2lzRnJvbnRNYXR0ZXJOb2RlOnR9PUdlKCkscz1uZXcgU2V0KFtcInNvdXJjZVNwYW5cIixcInN0YXJ0U291cmNlU3BhblwiLFwiZW5kU291cmNlU3BhblwiLFwibmFtZVNwYW5cIixcInZhbHVlU3BhblwiLFwicGFyZW50XCJdKTtmdW5jdGlvbiBpKHIsdSl7aWYoci50eXBlPT09XCJ0ZXh0XCJ8fHIudHlwZT09PVwiY29tbWVudFwifHx0KHIpfHxyLnR5cGU9PT1cInlhbWxcInx8ci50eXBlPT09XCJ0b21sXCIpcmV0dXJuIG51bGw7ci50eXBlPT09XCJhdHRyaWJ1dGVcIiYmZGVsZXRlIHUudmFsdWUsci50eXBlPT09XCJkb2NUeXBlXCImJmRlbGV0ZSB1LnZhbHVlfWkuaWdub3JlZFByb3BlcnRpZXM9cyxuLmV4cG9ydHM9aX19KSxQZD1aKHtcInNyYy9sYW5ndWFnZS1odG1sL2NvbnN0YW50cy5ldmFsdWF0ZS5qc1wiKGUsbil7bi5leHBvcnRzPXtDU1NfRElTUExBWV9UQUdTOnthcmVhOlwibm9uZVwiLGJhc2U6XCJub25lXCIsYmFzZWZvbnQ6XCJub25lXCIsZGF0YWxpc3Q6XCJub25lXCIsaGVhZDpcIm5vbmVcIixsaW5rOlwibm9uZVwiLG1ldGE6XCJub25lXCIsbm9lbWJlZDpcIm5vbmVcIixub2ZyYW1lczpcIm5vbmVcIixwYXJhbTpcImJsb2NrXCIscnA6XCJub25lXCIsc2NyaXB0OlwiYmxvY2tcIixzb3VyY2U6XCJibG9ja1wiLHN0eWxlOlwibm9uZVwiLHRlbXBsYXRlOlwiaW5saW5lXCIsdHJhY2s6XCJibG9ja1wiLHRpdGxlOlwibm9uZVwiLGh0bWw6XCJibG9ja1wiLGJvZHk6XCJibG9ja1wiLGFkZHJlc3M6XCJibG9ja1wiLGJsb2NrcXVvdGU6XCJibG9ja1wiLGNlbnRlcjpcImJsb2NrXCIsZGl2OlwiYmxvY2tcIixmaWd1cmU6XCJibG9ja1wiLGZpZ2NhcHRpb246XCJibG9ja1wiLGZvb3RlcjpcImJsb2NrXCIsZm9ybTpcImJsb2NrXCIsaGVhZGVyOlwiYmxvY2tcIixocjpcImJsb2NrXCIsbGVnZW5kOlwiYmxvY2tcIixsaXN0aW5nOlwiYmxvY2tcIixtYWluOlwiYmxvY2tcIixwOlwiYmxvY2tcIixwbGFpbnRleHQ6XCJibG9ja1wiLHByZTpcImJsb2NrXCIseG1wOlwiYmxvY2tcIixzbG90OlwiY29udGVudHNcIixydWJ5OlwicnVieVwiLHJ0OlwicnVieS10ZXh0XCIsYXJ0aWNsZTpcImJsb2NrXCIsYXNpZGU6XCJibG9ja1wiLGgxOlwiYmxvY2tcIixoMjpcImJsb2NrXCIsaDM6XCJibG9ja1wiLGg0OlwiYmxvY2tcIixoNTpcImJsb2NrXCIsaDY6XCJibG9ja1wiLGhncm91cDpcImJsb2NrXCIsbmF2OlwiYmxvY2tcIixzZWN0aW9uOlwiYmxvY2tcIixkaXI6XCJibG9ja1wiLGRkOlwiYmxvY2tcIixkbDpcImJsb2NrXCIsZHQ6XCJibG9ja1wiLG9sOlwiYmxvY2tcIix1bDpcImJsb2NrXCIsbGk6XCJsaXN0LWl0ZW1cIix0YWJsZTpcInRhYmxlXCIsY2FwdGlvbjpcInRhYmxlLWNhcHRpb25cIixjb2xncm91cDpcInRhYmxlLWNvbHVtbi1ncm91cFwiLGNvbDpcInRhYmxlLWNvbHVtblwiLHRoZWFkOlwidGFibGUtaGVhZGVyLWdyb3VwXCIsdGJvZHk6XCJ0YWJsZS1yb3ctZ3JvdXBcIix0Zm9vdDpcInRhYmxlLWZvb3Rlci1ncm91cFwiLHRyOlwidGFibGUtcm93XCIsdGQ6XCJ0YWJsZS1jZWxsXCIsdGg6XCJ0YWJsZS1jZWxsXCIsZmllbGRzZXQ6XCJibG9ja1wiLGJ1dHRvbjpcImlubGluZS1ibG9ja1wiLGRldGFpbHM6XCJibG9ja1wiLHN1bW1hcnk6XCJibG9ja1wiLGRpYWxvZzpcImJsb2NrXCIsbWV0ZXI6XCJpbmxpbmUtYmxvY2tcIixwcm9ncmVzczpcImlubGluZS1ibG9ja1wiLG9iamVjdDpcImlubGluZS1ibG9ja1wiLHZpZGVvOlwiaW5saW5lLWJsb2NrXCIsYXVkaW86XCJpbmxpbmUtYmxvY2tcIixzZWxlY3Q6XCJpbmxpbmUtYmxvY2tcIixvcHRpb246XCJibG9ja1wiLG9wdGdyb3VwOlwiYmxvY2tcIn0sQ1NTX0RJU1BMQVlfREVGQVVMVDpcImlubGluZVwiLENTU19XSElURV9TUEFDRV9UQUdTOntsaXN0aW5nOlwicHJlXCIscGxhaW50ZXh0OlwicHJlXCIscHJlOlwicHJlXCIseG1wOlwicHJlXCIsbm9icjpcIm5vd3JhcFwiLHRhYmxlOlwiaW5pdGlhbFwiLHRleHRhcmVhOlwicHJlLXdyYXBcIn0sQ1NTX1dISVRFX1NQQUNFX0RFRkFVTFQ6XCJub3JtYWxcIn19fSksSWQ9Wih7XCJzcmMvbGFuZ3VhZ2UtaHRtbC91dGlscy9pcy11bmtub3duLW5hbWVzcGFjZS5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KHMpe3JldHVybiBzLnR5cGU9PT1cImVsZW1lbnRcIiYmIXMuaGFzRXhwbGljaXROYW1lc3BhY2UmJiFbXCJodG1sXCIsXCJzdmdcIl0uaW5jbHVkZXMocy5uYW1lc3BhY2UpfW4uZXhwb3J0cz10fX0pLE90PVooe1wic3JjL2xhbmd1YWdlLWh0bWwvdXRpbHMvaW5kZXguanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2luZmVyUGFyc2VyQnlMYW5ndWFnZTp0LGlzRnJvbnRNYXR0ZXJOb2RlOnN9PUdlKCkse2J1aWxkZXJzOntsaW5lOmksaGFyZGxpbmU6cixqb2luOnV9LHV0aWxzOntnZXREb2NQYXJ0czphLHJlcGxhY2VUZXh0RW5kT2ZMaW5lOmN9fT1MZSgpLHtDU1NfRElTUExBWV9UQUdTOmwsQ1NTX0RJU1BMQVlfREVGQVVMVDpDLENTU19XSElURV9TUEFDRV9UQUdTOm0sQ1NTX1dISVRFX1NQQUNFX0RFRkFVTFQ6Z309UGQoKSxwPUlkKCksZj1uZXcgU2V0KFtcIlx0XCIsYFxuYCxcIlxcZlwiLFwiXFxyXCIsXCIgXCJdKSxoPWo9PmoucmVwbGFjZSgvXltcXHRcXG5cXGZcXHIgXSsvLFwiXCIpLE49aj0+ai5yZXBsYWNlKC9bXFx0XFxuXFxmXFxyIF0rJC8sXCJcIiksVD1qPT5oKE4oaikpLEE9aj0+ai5yZXBsYWNlKC9eW1xcdFxcZlxcciBdKlxcbi9nLFwiXCIpLGI9aj0+QShOKGopKSx2PWo9Pmouc3BsaXQoL1tcXHRcXG5cXGZcXHIgXSsvKSxCPWo9PmoubWF0Y2goL15bXFx0XFxuXFxmXFxyIF0qLylbMF0sdz1qPT57bGV0WyxDZSxOZSxqZV09ai5tYXRjaCgvXihbXFx0XFxuXFxmXFxyIF0qKSguKj8pKFtcXHRcXG5cXGZcXHIgXSopJC9zKTtyZXR1cm57bGVhZGluZ1doaXRlc3BhY2U6Q2UsdHJhaWxpbmdXaGl0ZXNwYWNlOmplLHRleHQ6TmV9fSxJPWo9Pi9bXFx0XFxuXFxmXFxyIF0vLnRlc3Qoaik7ZnVuY3Rpb24gRShqLENlKXtyZXR1cm4hIShqLnR5cGU9PT1cImllQ29uZGl0aW9uYWxDb21tZW50XCImJmoubGFzdENoaWxkJiYhai5sYXN0Q2hpbGQuaXNTZWxmQ2xvc2luZyYmIWoubGFzdENoaWxkLmVuZFNvdXJjZVNwYW58fGoudHlwZT09PVwiaWVDb25kaXRpb25hbENvbW1lbnRcIiYmIWouY29tcGxldGV8fGRlKGopJiZqLmNoaWxkcmVuLnNvbWUoTmU9Pk5lLnR5cGUhPT1cInRleHRcIiYmTmUudHlwZSE9PVwiaW50ZXJwb2xhdGlvblwiKXx8WChqLENlKSYmIW8oaikmJmoudHlwZSE9PVwiaW50ZXJwb2xhdGlvblwiKX1mdW5jdGlvbiBEKGope3JldHVybiBqLnR5cGU9PT1cImF0dHJpYnV0ZVwifHwhai5wYXJlbnR8fCFqLnByZXY/ITE6ZChqLnByZXYpfWZ1bmN0aW9uIGQoail7cmV0dXJuIGoudHlwZT09PVwiY29tbWVudFwiJiZqLnZhbHVlLnRyaW0oKT09PVwicHJldHRpZXItaWdub3JlXCJ9ZnVuY3Rpb24geShqKXtyZXR1cm4gai50eXBlPT09XCJ0ZXh0XCJ8fGoudHlwZT09PVwiY29tbWVudFwifWZ1bmN0aW9uIG8oail7cmV0dXJuIGoudHlwZT09PVwiZWxlbWVudFwiJiYoai5mdWxsTmFtZT09PVwic2NyaXB0XCJ8fGouZnVsbE5hbWU9PT1cInN0eWxlXCJ8fGouZnVsbE5hbWU9PT1cInN2ZzpzdHlsZVwifHxwKGopJiYoai5uYW1lPT09XCJzY3JpcHRcInx8ai5uYW1lPT09XCJzdHlsZVwiKSl9ZnVuY3Rpb24geChqKXtyZXR1cm4gai5jaGlsZHJlbiYmIW8oail9ZnVuY3Rpb24gRihqKXtyZXR1cm4gbyhqKXx8ai50eXBlPT09XCJpbnRlcnBvbGF0aW9uXCJ8fFMoail9ZnVuY3Rpb24gUyhqKXtyZXR1cm4gd2Uoaikuc3RhcnRzV2l0aChcInByZVwiKX1mdW5jdGlvbiBrKGosQ2Upe2xldCBOZT1qZSgpO2lmKE5lJiYhai5wcmV2JiZqLnBhcmVudCYmai5wYXJlbnQudGFnRGVmaW5pdGlvbiYmai5wYXJlbnQudGFnRGVmaW5pdGlvbi5pZ25vcmVGaXJzdExmKXJldHVybiBqLnR5cGU9PT1cImludGVycG9sYXRpb25cIjtyZXR1cm4gTmU7ZnVuY3Rpb24gamUoKXtyZXR1cm4gcyhqKT8hMTooai50eXBlPT09XCJ0ZXh0XCJ8fGoudHlwZT09PVwiaW50ZXJwb2xhdGlvblwiKSYmai5wcmV2JiYoai5wcmV2LnR5cGU9PT1cInRleHRcInx8ai5wcmV2LnR5cGU9PT1cImludGVycG9sYXRpb25cIik/ITA6IWoucGFyZW50fHxqLnBhcmVudC5jc3NEaXNwbGF5PT09XCJub25lXCI/ITE6ZGUoai5wYXJlbnQpPyEwOiEoIWoucHJldiYmKGoucGFyZW50LnR5cGU9PT1cInJvb3RcInx8ZGUoaikmJmoucGFyZW50fHxvKGoucGFyZW50KXx8SihqLnBhcmVudCxDZSl8fCFFZShqLnBhcmVudC5jc3NEaXNwbGF5KSl8fGoucHJldiYmIXVlKGoucHJldi5jc3NEaXNwbGF5KSl9fWZ1bmN0aW9uIF8oaixDZSl7cmV0dXJuIHMoaik/ITE6KGoudHlwZT09PVwidGV4dFwifHxqLnR5cGU9PT1cImludGVycG9sYXRpb25cIikmJmoubmV4dCYmKGoubmV4dC50eXBlPT09XCJ0ZXh0XCJ8fGoubmV4dC50eXBlPT09XCJpbnRlcnBvbGF0aW9uXCIpPyEwOiFqLnBhcmVudHx8ai5wYXJlbnQuY3NzRGlzcGxheT09PVwibm9uZVwiPyExOmRlKGoucGFyZW50KT8hMDohKCFqLm5leHQmJihqLnBhcmVudC50eXBlPT09XCJyb290XCJ8fGRlKGopJiZqLnBhcmVudHx8byhqLnBhcmVudCl8fEooai5wYXJlbnQsQ2UpfHwhcShqLnBhcmVudC5jc3NEaXNwbGF5KSl8fGoubmV4dCYmIWxlKGoubmV4dC5jc3NEaXNwbGF5KSl9ZnVuY3Rpb24gTyhqKXtyZXR1cm4gUShqLmNzc0Rpc3BsYXkpJiYhbyhqKX1mdW5jdGlvbiBSKGope3JldHVybiBzKGopfHxqLm5leHQmJmouc291cmNlU3Bhbi5lbmQmJmouc291cmNlU3Bhbi5lbmQubGluZSsxPGoubmV4dC5zb3VyY2VTcGFuLnN0YXJ0LmxpbmV9ZnVuY3Rpb24gTShqKXtyZXR1cm4gSChqKXx8ai50eXBlPT09XCJlbGVtZW50XCImJmouY2hpbGRyZW4ubGVuZ3RoPjAmJihbXCJib2R5XCIsXCJzY3JpcHRcIixcInN0eWxlXCJdLmluY2x1ZGVzKGoubmFtZSl8fGouY2hpbGRyZW4uc29tZShDZT0+bmUoQ2UpKSl8fGouZmlyc3RDaGlsZCYmai5maXJzdENoaWxkPT09ai5sYXN0Q2hpbGQmJmouZmlyc3RDaGlsZC50eXBlIT09XCJ0ZXh0XCImJiQoai5maXJzdENoaWxkKSYmKCFqLmxhc3RDaGlsZC5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmV8fFcoai5sYXN0Q2hpbGQpKX1mdW5jdGlvbiBIKGope3JldHVybiBqLnR5cGU9PT1cImVsZW1lbnRcIiYmai5jaGlsZHJlbi5sZW5ndGg+MCYmKFtcImh0bWxcIixcImhlYWRcIixcInVsXCIsXCJvbFwiLFwic2VsZWN0XCJdLmluY2x1ZGVzKGoubmFtZSl8fGouY3NzRGlzcGxheS5zdGFydHNXaXRoKFwidGFibGVcIikmJmouY3NzRGlzcGxheSE9PVwidGFibGUtY2VsbFwiKX1mdW5jdGlvbiBQKGope3JldHVybiBlZShqKXx8ai5wcmV2JiZHKGoucHJldil8fHJlKGopfWZ1bmN0aW9uIEcoail7cmV0dXJuIGVlKGopfHxqLnR5cGU9PT1cImVsZW1lbnRcIiYmai5mdWxsTmFtZT09PVwiYnJcInx8cmUoail9ZnVuY3Rpb24gcmUoail7cmV0dXJuICQoaikmJlcoail9ZnVuY3Rpb24gJChqKXtyZXR1cm4gai5oYXNMZWFkaW5nU3BhY2VzJiYoai5wcmV2P2oucHJldi5zb3VyY2VTcGFuLmVuZC5saW5lPGouc291cmNlU3Bhbi5zdGFydC5saW5lOmoucGFyZW50LnR5cGU9PT1cInJvb3RcInx8ai5wYXJlbnQuc3RhcnRTb3VyY2VTcGFuLmVuZC5saW5lPGouc291cmNlU3Bhbi5zdGFydC5saW5lKX1mdW5jdGlvbiBXKGope3JldHVybiBqLmhhc1RyYWlsaW5nU3BhY2VzJiYoai5uZXh0P2oubmV4dC5zb3VyY2VTcGFuLnN0YXJ0LmxpbmU+ai5zb3VyY2VTcGFuLmVuZC5saW5lOmoucGFyZW50LnR5cGU9PT1cInJvb3RcInx8ai5wYXJlbnQuZW5kU291cmNlU3BhbiYmai5wYXJlbnQuZW5kU291cmNlU3Bhbi5zdGFydC5saW5lPmouc291cmNlU3Bhbi5lbmQubGluZSl9ZnVuY3Rpb24gZWUoail7c3dpdGNoKGoudHlwZSl7Y2FzZVwiaWVDb25kaXRpb25hbENvbW1lbnRcIjpjYXNlXCJjb21tZW50XCI6Y2FzZVwiZGlyZWN0aXZlXCI6cmV0dXJuITA7Y2FzZVwiZWxlbWVudFwiOnJldHVybltcInNjcmlwdFwiLFwic2VsZWN0XCJdLmluY2x1ZGVzKGoubmFtZSl9cmV0dXJuITF9ZnVuY3Rpb24gVShqKXtyZXR1cm4gai5sYXN0Q2hpbGQ/VShqLmxhc3RDaGlsZCk6an1mdW5jdGlvbiBuZShqKXtyZXR1cm4gai5jaGlsZHJlbiYmai5jaGlsZHJlbi5zb21lKENlPT5DZS50eXBlIT09XCJ0ZXh0XCIpfWZ1bmN0aW9uIHNlKGope2xldHt0eXBlOkNlLGxhbmc6TmV9PWouYXR0ck1hcDtpZihDZT09PVwibW9kdWxlXCJ8fENlPT09XCJ0ZXh0L2phdmFzY3JpcHRcInx8Q2U9PT1cInRleHQvYmFiZWxcInx8Q2U9PT1cImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcInx8TmU9PT1cImpzeFwiKXJldHVyblwiYmFiZWxcIjtpZihDZT09PVwiYXBwbGljYXRpb24veC10eXBlc2NyaXB0XCJ8fE5lPT09XCJ0c1wifHxOZT09PVwidHN4XCIpcmV0dXJuXCJ0eXBlc2NyaXB0XCI7aWYoQ2U9PT1cInRleHQvbWFya2Rvd25cIilyZXR1cm5cIm1hcmtkb3duXCI7aWYoQ2U9PT1cInRleHQvaHRtbFwiKXJldHVyblwiaHRtbFwiO2lmKENlJiYoQ2UuZW5kc1dpdGgoXCJqc29uXCIpfHxDZS5lbmRzV2l0aChcImltcG9ydG1hcFwiKSkpcmV0dXJuXCJqc29uXCI7aWYoQ2U9PT1cInRleHQveC1oYW5kbGViYXJzLXRlbXBsYXRlXCIpcmV0dXJuXCJnbGltbWVyXCJ9ZnVuY3Rpb24gVihqKXtsZXR7bGFuZzpDZX09ai5hdHRyTWFwO2lmKCFDZXx8Q2U9PT1cInBvc3Rjc3NcInx8Q2U9PT1cImNzc1wiKXJldHVyblwiY3NzXCI7aWYoQ2U9PT1cInNjc3NcIilyZXR1cm5cInNjc3NcIjtpZihDZT09PVwibGVzc1wiKXJldHVyblwibGVzc1wifWZ1bmN0aW9uIG9lKGosQ2Upe2lmKGoubmFtZT09PVwic2NyaXB0XCImJiFqLmF0dHJNYXAuc3JjKXJldHVybiFqLmF0dHJNYXAubGFuZyYmIWouYXR0ck1hcC50eXBlP1wiYmFiZWxcIjpzZShqKTtpZihqLm5hbWU9PT1cInN0eWxlXCIpcmV0dXJuIFYoaik7aWYoQ2UmJlgoaixDZSkpcmV0dXJuIHNlKGopfHwhKFwic3JjXCJpbiBqLmF0dHJNYXApJiZ0KGouYXR0ck1hcC5sYW5nLENlKX1mdW5jdGlvbiBLKGope3JldHVybiBqPT09XCJibG9ja1wifHxqPT09XCJsaXN0LWl0ZW1cInx8ai5zdGFydHNXaXRoKFwidGFibGVcIil9ZnVuY3Rpb24gRWUoail7cmV0dXJuIUsoaikmJmohPT1cImlubGluZS1ibG9ja1wifWZ1bmN0aW9uIHEoail7cmV0dXJuIUsoaikmJmohPT1cImlubGluZS1ibG9ja1wifWZ1bmN0aW9uIGxlKGope3JldHVybiFLKGopfWZ1bmN0aW9uIHVlKGope3JldHVybiFLKGopfWZ1bmN0aW9uIFEoail7cmV0dXJuIUsoaikmJmohPT1cImlubGluZS1ibG9ja1wifWZ1bmN0aW9uIGRlKGope3JldHVybiB3ZShqKS5zdGFydHNXaXRoKFwicHJlXCIpfWZ1bmN0aW9uIGdlKGosQ2Upe2xldCBOZT0wO2ZvcihsZXQgamU9ai5zdGFjay5sZW5ndGgtMTtqZT49MDtqZS0tKXtsZXQgVWU9ai5zdGFja1tqZV07VWUmJnR5cGVvZiBVZT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoVWUpJiZDZShVZSkmJk5lKyt9cmV0dXJuIE5lfWZ1bmN0aW9uIHZlKGosQ2Upe2xldCBOZT1qO2Zvcig7TmU7KXtpZihDZShOZSkpcmV0dXJuITA7TmU9TmUucGFyZW50fXJldHVybiExfWZ1bmN0aW9uIHhlKGosQ2Upe2lmKGoucHJldiYmai5wcmV2LnR5cGU9PT1cImNvbW1lbnRcIil7bGV0IGplPWoucHJldi52YWx1ZS5tYXRjaCgvXlxccypkaXNwbGF5OlxccyooW2Etel0rKVxccyokLyk7aWYoamUpcmV0dXJuIGplWzFdfWxldCBOZT0hMTtpZihqLnR5cGU9PT1cImVsZW1lbnRcIiYmai5uYW1lc3BhY2U9PT1cInN2Z1wiKWlmKHZlKGosamU9PmplLmZ1bGxOYW1lPT09XCJzdmc6Zm9yZWlnbk9iamVjdFwiKSlOZT0hMDtlbHNlIHJldHVybiBqLm5hbWU9PT1cInN2Z1wiP1wiaW5saW5lLWJsb2NrXCI6XCJibG9ja1wiO3N3aXRjaChDZS5odG1sV2hpdGVzcGFjZVNlbnNpdGl2aXR5KXtjYXNlXCJzdHJpY3RcIjpyZXR1cm5cImlubGluZVwiO2Nhc2VcImlnbm9yZVwiOnJldHVyblwiYmxvY2tcIjtkZWZhdWx0OnJldHVybiBDZS5wYXJzZXI9PT1cInZ1ZVwiJiZqLnBhcmVudCYmai5wYXJlbnQudHlwZT09PVwicm9vdFwiP1wiYmxvY2tcIjpqLnR5cGU9PT1cImVsZW1lbnRcIiYmKCFqLm5hbWVzcGFjZXx8TmV8fHAoaikpJiZsW2oubmFtZV18fEN9fWZ1bmN0aW9uIHdlKGope3JldHVybiBqLnR5cGU9PT1cImVsZW1lbnRcIiYmKCFqLm5hbWVzcGFjZXx8cChqKSkmJm1bai5uYW1lXXx8Z31mdW5jdGlvbiBmZShqKXtsZXQgQ2U9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO2ZvcihsZXQgTmUgb2Ygai5zcGxpdChgXG5gKSl7aWYoTmUubGVuZ3RoPT09MCljb250aW51ZTtpZighZi5oYXMoTmVbMF0pKXJldHVybiAwO2xldCBqZT1CKE5lKS5sZW5ndGg7TmUubGVuZ3RoIT09amUmJmplPENlJiYoQ2U9amUpfXJldHVybiBDZT09PU51bWJlci5QT1NJVElWRV9JTkZJTklUWT8wOkNlfWZ1bmN0aW9uIHBlKGope2xldCBDZT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06ZmUoaik7cmV0dXJuIENlPT09MD9qOmouc3BsaXQoYFxuYCkubWFwKE5lPT5OZS5zbGljZShDZSkpLmpvaW4oYFxuYCl9ZnVuY3Rpb24gbWUoaixDZSl7bGV0IE5lPTA7Zm9yKGxldCBqZT0wO2plPGoubGVuZ3RoO2plKyspaltqZV09PT1DZSYmTmUrKztyZXR1cm4gTmV9ZnVuY3Rpb24gY2Uoail7cmV0dXJuIGoucmVwbGFjZSgvJmFwb3M7L2csXCInXCIpLnJlcGxhY2UoLyZxdW90Oy9nLCdcIicpfXZhciBoZT1uZXcgU2V0KFtcInRlbXBsYXRlXCIsXCJzdHlsZVwiLFwic2NyaXB0XCJdKTtmdW5jdGlvbiBKKGosQ2Upe3JldHVybiB5ZShqLENlKSYmIWhlLmhhcyhqLmZ1bGxOYW1lKX1mdW5jdGlvbiB5ZShqLENlKXtyZXR1cm4gQ2UucGFyc2VyPT09XCJ2dWVcIiYmai50eXBlPT09XCJlbGVtZW50XCImJmoucGFyZW50LnR5cGU9PT1cInJvb3RcIiYmai5mdWxsTmFtZS50b0xvd2VyQ2FzZSgpIT09XCJodG1sXCJ9ZnVuY3Rpb24gWChqLENlKXtyZXR1cm4geWUoaixDZSkmJihKKGosQ2UpfHxqLmF0dHJNYXAubGFuZyYmai5hdHRyTWFwLmxhbmchPT1cImh0bWxcIil9ZnVuY3Rpb24gWShqKXtsZXQgQ2U9ai5mdWxsTmFtZTtyZXR1cm4gQ2UuY2hhckF0KDApPT09XCIjXCJ8fENlPT09XCJzbG90LXNjb3BlXCJ8fENlPT09XCJ2LXNsb3RcInx8Q2Uuc3RhcnRzV2l0aChcInYtc2xvdDpcIil9ZnVuY3Rpb24gdGUoaixDZSl7bGV0IE5lPWoucGFyZW50O2lmKCF5ZShOZSxDZSkpcmV0dXJuITE7bGV0IGplPU5lLmZ1bGxOYW1lLFVlPWouZnVsbE5hbWU7cmV0dXJuIGplPT09XCJzY3JpcHRcIiYmVWU9PT1cInNldHVwXCJ8fGplPT09XCJzdHlsZVwiJiZVZT09PVwidmFyc1wifWZ1bmN0aW9uIHooail7bGV0IENlPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTpqLnZhbHVlO3JldHVybiBqLnBhcmVudC5pc1doaXRlc3BhY2VTZW5zaXRpdmU/ai5wYXJlbnQuaXNJbmRlbnRhdGlvblNlbnNpdGl2ZT9jKENlKTpjKHBlKGIoQ2UpKSxyKTphKHUoaSx2KENlKSkpfW4uZXhwb3J0cz17aHRtbFRyaW06VCxodG1sVHJpbVByZXNlcnZlSW5kZW50YXRpb246YixoYXNIdG1sV2hpdGVzcGFjZTpJLGdldExlYWRpbmdBbmRUcmFpbGluZ0h0bWxXaGl0ZXNwYWNlOncsY2FuSGF2ZUludGVycG9sYXRpb246eCxjb3VudENoYXJzOm1lLGNvdW50UGFyZW50czpnZSxkZWRlbnRTdHJpbmc6cGUsZm9yY2VCcmVha0NoaWxkcmVuOkgsZm9yY2VCcmVha0NvbnRlbnQ6TSxmb3JjZU5leHRFbXB0eUxpbmU6UixnZXRMYXN0RGVzY2VuZGFudDpVLGdldE5vZGVDc3NTdHlsZURpc3BsYXk6eGUsZ2V0Tm9kZUNzc1N0eWxlV2hpdGVTcGFjZTp3ZSxoYXNQcmV0dGllcklnbm9yZTpELGluZmVyU2NyaXB0UGFyc2VyOm9lLGlzVnVlQ3VzdG9tQmxvY2s6Sixpc1Z1ZU5vbkh0bWxCbG9jazpYLGlzVnVlU2xvdEF0dHJpYnV0ZTpZLGlzVnVlU2ZjQmluZGluZ3NBdHRyaWJ1dGU6dGUsaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZTpPLGlzSW5kZW50YXRpb25TZW5zaXRpdmVOb2RlOlMsaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmVOb2RlOmssaXNQcmVMaWtlTm9kZTpkZSxpc1NjcmlwdExpa2VUYWc6byxpc1RleHRMaWtlTm9kZTp5LGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZU5vZGU6Xyxpc1doaXRlc3BhY2VTZW5zaXRpdmVOb2RlOkYsaXNVbmtub3duTmFtZXNwYWNlOnAscHJlZmVySGFyZGxpbmVBc0xlYWRpbmdTcGFjZXM6UCxwcmVmZXJIYXJkbGluZUFzVHJhaWxpbmdTcGFjZXM6RyxzaG91bGRQcmVzZXJ2ZUNvbnRlbnQ6RSx1bmVzY2FwZVF1b3RlRW50aXRpZXM6Y2UsZ2V0VGV4dFZhbHVlUGFydHM6en19fSksa2Q9Wih7XCJub2RlX21vZHVsZXMvYW5ndWxhci1odG1sLXBhcnNlci9saWIvY29tcGlsZXIvc3JjL2NoYXJzLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7YWUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLiRFT0Y9MCxlLiRCU1BBQ0U9OCxlLiRUQUI9OSxlLiRMRj0xMCxlLiRWVEFCPTExLGUuJEZGPTEyLGUuJENSPTEzLGUuJFNQQUNFPTMyLGUuJEJBTkc9MzMsZS4kRFE9MzQsZS4kSEFTSD0zNSxlLiQkPTM2LGUuJFBFUkNFTlQ9MzcsZS4kQU1QRVJTQU5EPTM4LGUuJFNRPTM5LGUuJExQQVJFTj00MCxlLiRSUEFSRU49NDEsZS4kU1RBUj00MixlLiRQTFVTPTQzLGUuJENPTU1BPTQ0LGUuJE1JTlVTPTQ1LGUuJFBFUklPRD00NixlLiRTTEFTSD00NyxlLiRDT0xPTj01OCxlLiRTRU1JQ09MT049NTksZS4kTFQ9NjAsZS4kRVE9NjEsZS4kR1Q9NjIsZS4kUVVFU1RJT049NjMsZS4kMD00OCxlLiQ3PTU1LGUuJDk9NTcsZS4kQT02NSxlLiRFPTY5LGUuJEY9NzAsZS4kWD04OCxlLiRaPTkwLGUuJExCUkFDS0VUPTkxLGUuJEJBQ0tTTEFTSD05MixlLiRSQlJBQ0tFVD05MyxlLiRDQVJFVD05NCxlLiRfPTk1LGUuJGE9OTcsZS4kYj05OCxlLiRlPTEwMSxlLiRmPTEwMixlLiRuPTExMCxlLiRyPTExNCxlLiR0PTExNixlLiR1PTExNyxlLiR2PTExOCxlLiR4PTEyMCxlLiR6PTEyMixlLiRMQlJBQ0U9MTIzLGUuJEJBUj0xMjQsZS4kUkJSQUNFPTEyNSxlLiROQlNQPTE2MCxlLiRQSVBFPTEyNCxlLiRUSUxEQT0xMjYsZS4kQVQ9NjQsZS4kQlQ9OTY7ZnVuY3Rpb24gbihhKXtyZXR1cm4gYT49ZS4kVEFCJiZhPD1lLiRTUEFDRXx8YT09ZS4kTkJTUH1lLmlzV2hpdGVzcGFjZT1uO2Z1bmN0aW9uIHQoYSl7cmV0dXJuIGUuJDA8PWEmJmE8PWUuJDl9ZS5pc0RpZ2l0PXQ7ZnVuY3Rpb24gcyhhKXtyZXR1cm4gYT49ZS4kYSYmYTw9ZS4kenx8YT49ZS4kQSYmYTw9ZS4kWn1lLmlzQXNjaWlMZXR0ZXI9cztmdW5jdGlvbiBpKGEpe3JldHVybiBhPj1lLiRhJiZhPD1lLiRmfHxhPj1lLiRBJiZhPD1lLiRGfHx0KGEpfWUuaXNBc2NpaUhleERpZ2l0PWk7ZnVuY3Rpb24gcihhKXtyZXR1cm4gYT09PWUuJExGfHxhPT09ZS4kQ1J9ZS5pc05ld0xpbmU9cjtmdW5jdGlvbiB1KGEpe3JldHVybiBlLiQwPD1hJiZhPD1lLiQ3fWUuaXNPY3RhbERpZ2l0PXV9fSksTGQ9Wih7XCJub2RlX21vZHVsZXMvYW5ndWxhci1odG1sLXBhcnNlci9saWIvY29tcGlsZXIvc3JjL2FvdC9zdGF0aWNfc3ltYm9sLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7YWUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1jbGFzc3tjb25zdHJ1Y3RvcihzLGkscil7dGhpcy5maWxlUGF0aD1zLHRoaXMubmFtZT1pLHRoaXMubWVtYmVycz1yfWFzc2VydE5vTWVtYmVycygpe2lmKHRoaXMubWVtYmVycy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogc3ltYm9sIHdpdGhvdXQgbWVtYmVycyBleHBlY3RlZCwgYnV0IGdvdCBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkodGhpcyksXCIuXCIpKX19O2UuU3RhdGljU3ltYm9sPW47dmFyIHQ9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmNhY2hlPW5ldyBNYXB9Z2V0KHMsaSxyKXtyPXJ8fFtdO2xldCB1PXIubGVuZ3RoP1wiLlwiLmNvbmNhdChyLmpvaW4oXCIuXCIpKTpcIlwiLGE9J1wiJy5jb25jYXQocywnXCIuJykuY29uY2F0KGkpLmNvbmNhdCh1KSxjPXRoaXMuY2FjaGUuZ2V0KGEpO3JldHVybiBjfHwoYz1uZXcgbihzLGksciksdGhpcy5jYWNoZS5zZXQoYSxjKSksY319O2UuU3RhdGljU3ltYm9sQ2FjaGU9dH19KSxPZD1aKHtcIm5vZGVfbW9kdWxlcy9hbmd1bGFyLWh0bWwtcGFyc2VyL2xpYi9jb21waWxlci9zcmMvdXRpbC5qc1wiKGUpe1widXNlIHN0cmljdFwiO2FlKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49Ly0rKFthLXowLTldKS9nO2Z1bmN0aW9uIHQobyl7cmV0dXJuIG8ucmVwbGFjZShuLGZ1bmN0aW9uKCl7Zm9yKHZhciB4PWFyZ3VtZW50cy5sZW5ndGgsRj1uZXcgQXJyYXkoeCksUz0wO1M8eDtTKyspRltTXT1hcmd1bWVudHNbU107cmV0dXJuIEZbMV0udG9VcHBlckNhc2UoKX0pfWUuZGFzaENhc2VUb0NhbWVsQ2FzZT10O2Z1bmN0aW9uIHMobyx4KXtyZXR1cm4gcihvLFwiOlwiLHgpfWUuc3BsaXRBdENvbG9uPXM7ZnVuY3Rpb24gaShvLHgpe3JldHVybiByKG8sXCIuXCIseCl9ZS5zcGxpdEF0UGVyaW9kPWk7ZnVuY3Rpb24gcihvLHgsRil7bGV0IFM9by5pbmRleE9mKHgpO3JldHVybiBTPT0tMT9GOltvLnNsaWNlKDAsUykudHJpbSgpLG8uc2xpY2UoUysxKS50cmltKCldfWZ1bmN0aW9uIHUobyx4LEYpe3JldHVybiBBcnJheS5pc0FycmF5KG8pP3gudmlzaXRBcnJheShvLEYpOkEobyk/eC52aXNpdFN0cmluZ01hcChvLEYpOm89PW51bGx8fHR5cGVvZiBvPT1cInN0cmluZ1wifHx0eXBlb2Ygbz09XCJudW1iZXJcInx8dHlwZW9mIG89PVwiYm9vbGVhblwiP3gudmlzaXRQcmltaXRpdmUobyxGKTp4LnZpc2l0T3RoZXIobyxGKX1lLnZpc2l0VmFsdWU9dTtmdW5jdGlvbiBhKG8pe3JldHVybiBvIT1udWxsfWUuaXNEZWZpbmVkPWE7ZnVuY3Rpb24gYyhvKXtyZXR1cm4gbz09PXZvaWQgMD9udWxsOm99ZS5ub1VuZGVmaW5lZD1jO3ZhciBsPWNsYXNze3Zpc2l0QXJyYXkobyx4KXtyZXR1cm4gby5tYXAoRj0+dShGLHRoaXMseCkpfXZpc2l0U3RyaW5nTWFwKG8seCl7bGV0IEY9e307cmV0dXJuIE9iamVjdC5rZXlzKG8pLmZvckVhY2goUz0+e0ZbU109dShvW1NdLHRoaXMseCl9KSxGfXZpc2l0UHJpbWl0aXZlKG8seCl7cmV0dXJuIG99dmlzaXRPdGhlcihvLHgpe3JldHVybiBvfX07ZS5WYWx1ZVRyYW5zZm9ybWVyPWwsZS5TeW5jQXN5bmM9e2Fzc2VydFN5bmM6bz0+e2lmKHcobykpdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogdmFsdWUgY2Fubm90IGJlIGEgcHJvbWlzZVwiKTtyZXR1cm4gb30sdGhlbjoobyx4KT0+dyhvKT9vLnRoZW4oeCk6eChvKSxhbGw6bz0+by5zb21lKHcpP1Byb21pc2UuYWxsKG8pOm99O2Z1bmN0aW9uIEMobyl7dGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgRXJyb3I6IFwiLmNvbmNhdChvKSl9ZS5lcnJvcj1DO2Z1bmN0aW9uIG0obyx4KXtsZXQgRj1FcnJvcihvKTtyZXR1cm4gRltnXT0hMCx4JiYoRltwXT14KSxGfWUuc3ludGF4RXJyb3I9bTt2YXIgZz1cIm5nU3ludGF4RXJyb3JcIixwPVwibmdQYXJzZUVycm9yc1wiO2Z1bmN0aW9uIGYobyl7cmV0dXJuIG9bZ119ZS5pc1N5bnRheEVycm9yPWY7ZnVuY3Rpb24gaChvKXtyZXR1cm4gb1twXXx8W119ZS5nZXRQYXJzZUVycm9ycz1oO2Z1bmN0aW9uIE4obyl7cmV0dXJuIG8ucmVwbGFjZSgvKFsuKis/Xj0hOiR7fSgpfFtcXF1cXC9cXFxcXSkvZyxcIlxcXFwkMVwiKX1lLmVzY2FwZVJlZ0V4cD1OO3ZhciBUPU9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7ZnVuY3Rpb24gQShvKXtyZXR1cm4gdHlwZW9mIG89PVwib2JqZWN0XCImJm8hPT1udWxsJiZPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk9PT1UfWZ1bmN0aW9uIGIobyl7bGV0IHg9XCJcIjtmb3IobGV0IEY9MDtGPG8ubGVuZ3RoO0YrKyl7bGV0IFM9by5jaGFyQ29kZUF0KEYpO2lmKFM+PTU1Mjk2JiZTPD01NjMxOSYmby5sZW5ndGg+RisxKXtsZXQgaz1vLmNoYXJDb2RlQXQoRisxKTtrPj01NjMyMCYmazw9NTczNDMmJihGKyssUz0oUy01NTI5Njw8MTApK2stNTYzMjArNjU1MzYpfVM8PTEyNz94Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKFMpOlM8PTIwNDc/eCs9U3RyaW5nLmZyb21DaGFyQ29kZShTPj42JjMxfDE5MixTJjYzfDEyOCk6Uzw9NjU1MzU/eCs9U3RyaW5nLmZyb21DaGFyQ29kZShTPj4xMnwyMjQsUz4+NiY2M3wxMjgsUyY2M3wxMjgpOlM8PTIwOTcxNTEmJih4Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKFM+PjE4Jjd8MjQwLFM+PjEyJjYzfDEyOCxTPj42JjYzfDEyOCxTJjYzfDEyOCkpfXJldHVybiB4fWUudXRmOEVuY29kZT1iO2Z1bmN0aW9uIHYobyl7aWYodHlwZW9mIG89PVwic3RyaW5nXCIpcmV0dXJuIG87aWYobyBpbnN0YW5jZW9mIEFycmF5KXJldHVyblwiW1wiK28ubWFwKHYpLmpvaW4oXCIsIFwiKStcIl1cIjtpZihvPT1udWxsKXJldHVyblwiXCIrbztpZihvLm92ZXJyaWRkZW5OYW1lKXJldHVyblwiXCIuY29uY2F0KG8ub3ZlcnJpZGRlbk5hbWUpO2lmKG8ubmFtZSlyZXR1cm5cIlwiLmNvbmNhdChvLm5hbWUpO2lmKCFvLnRvU3RyaW5nKXJldHVyblwib2JqZWN0XCI7bGV0IHg9by50b1N0cmluZygpO2lmKHg9PW51bGwpcmV0dXJuXCJcIit4O2xldCBGPXguaW5kZXhPZihgXG5gKTtyZXR1cm4gRj09PS0xP3g6eC5zdWJzdHJpbmcoMCxGKX1lLnN0cmluZ2lmeT12O2Z1bmN0aW9uIEIobyl7cmV0dXJuIHR5cGVvZiBvPT1cImZ1bmN0aW9uXCImJm8uaGFzT3duUHJvcGVydHkoXCJfX2ZvcndhcmRfcmVmX19cIik/bygpOm99ZS5yZXNvbHZlRm9yd2FyZFJlZj1CO2Z1bmN0aW9uIHcobyl7cmV0dXJuISFvJiZ0eXBlb2Ygby50aGVuPT1cImZ1bmN0aW9uXCJ9ZS5pc1Byb21pc2U9dzt2YXIgST1jbGFzc3tjb25zdHJ1Y3RvcihvKXt0aGlzLmZ1bGw9bztsZXQgeD1vLnNwbGl0KFwiLlwiKTt0aGlzLm1ham9yPXhbMF0sdGhpcy5taW5vcj14WzFdLHRoaXMucGF0Y2g9eC5zbGljZSgyKS5qb2luKFwiLlwiKX19O2UuVmVyc2lvbj1JO3ZhciBFPXR5cGVvZiB3aW5kb3c8XCJ1XCImJndpbmRvdyxEPXR5cGVvZiBzZWxmPFwidVwiJiZ0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGU8XCJ1XCImJnNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSYmc2VsZixkPXR5cGVvZiBnbG9iYWxUaGlzPFwidVwiJiZnbG9iYWxUaGlzLHk9ZHx8RXx8RDtlLmdsb2JhbD15fX0pLGpkPVooe1wibm9kZV9tb2R1bGVzL2FuZ3VsYXItaHRtbC1wYXJzZXIvbGliL2NvbXBpbGVyL3NyYy9jb21waWxlX21ldGFkYXRhLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7YWUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1MZCgpLHQ9T2QoKSxzPS9eKD86KD86XFxbKFteXFxdXSspXFxdKXwoPzpcXCgoW15cXCldKylcXCkpKXwoXFxAWy1cXHddKykkLztmdW5jdGlvbiBpKEYpe3JldHVybiBGLnJlcGxhY2UoL1xcVy9nLFwiX1wiKX1lLnNhbml0aXplSWRlbnRpZmllcj1pO3ZhciByPTA7ZnVuY3Rpb24gdShGKXtpZighRnx8IUYucmVmZXJlbmNlKXJldHVybiBudWxsO2xldCBTPUYucmVmZXJlbmNlO2lmKFMgaW5zdGFuY2VvZiBuLlN0YXRpY1N5bWJvbClyZXR1cm4gUy5uYW1lO2lmKFMuX19hbm9ueW1vdXNUeXBlKXJldHVybiBTLl9fYW5vbnltb3VzVHlwZTtsZXQgaz10LnN0cmluZ2lmeShTKTtyZXR1cm4gay5pbmRleE9mKFwiKFwiKT49MD8oaz1cImFub255bW91c19cIi5jb25jYXQocisrKSxTLl9fYW5vbnltb3VzVHlwZT1rKTprPWkoayksa31lLmlkZW50aWZpZXJOYW1lPXU7ZnVuY3Rpb24gYShGKXtsZXQgUz1GLnJlZmVyZW5jZTtyZXR1cm4gUyBpbnN0YW5jZW9mIG4uU3RhdGljU3ltYm9sP1MuZmlsZVBhdGg6XCIuL1wiLmNvbmNhdCh0LnN0cmluZ2lmeShTKSl9ZS5pZGVudGlmaWVyTW9kdWxlVXJsPWE7ZnVuY3Rpb24gYyhGLFMpe3JldHVyblwiVmlld19cIi5jb25jYXQodSh7cmVmZXJlbmNlOkZ9KSxcIl9cIikuY29uY2F0KFMpfWUudmlld0NsYXNzTmFtZT1jO2Z1bmN0aW9uIGwoRil7cmV0dXJuXCJSZW5kZXJUeXBlX1wiLmNvbmNhdCh1KHtyZWZlcmVuY2U6Rn0pKX1lLnJlbmRlcmVyVHlwZU5hbWU9bDtmdW5jdGlvbiBDKEYpe3JldHVyblwiSG9zdFZpZXdfXCIuY29uY2F0KHUoe3JlZmVyZW5jZTpGfSkpfWUuaG9zdFZpZXdDbGFzc05hbWU9QztmdW5jdGlvbiBtKEYpe3JldHVyblwiXCIuY29uY2F0KHUoe3JlZmVyZW5jZTpGfSksXCJOZ0ZhY3RvcnlcIil9ZS5jb21wb25lbnRGYWN0b3J5TmFtZT1tO3ZhciBnOyhmdW5jdGlvbihGKXtGW0YuUGlwZT0wXT1cIlBpcGVcIixGW0YuRGlyZWN0aXZlPTFdPVwiRGlyZWN0aXZlXCIsRltGLk5nTW9kdWxlPTJdPVwiTmdNb2R1bGVcIixGW0YuSW5qZWN0YWJsZT0zXT1cIkluamVjdGFibGVcIn0pKGc9ZS5Db21waWxlU3VtbWFyeUtpbmR8fChlLkNvbXBpbGVTdW1tYXJ5S2luZD17fSkpO2Z1bmN0aW9uIHAoRil7cmV0dXJuIEYudmFsdWUhPW51bGw/aShGLnZhbHVlKTp1KEYuaWRlbnRpZmllcil9ZS50b2tlbk5hbWU9cDtmdW5jdGlvbiBmKEYpe3JldHVybiBGLmlkZW50aWZpZXIhPW51bGw/Ri5pZGVudGlmaWVyLnJlZmVyZW5jZTpGLnZhbHVlfWUudG9rZW5SZWZlcmVuY2U9Zjt2YXIgaD1jbGFzc3tjb25zdHJ1Y3Rvcigpe2xldHttb2R1bGVVcmw6RixzdHlsZXM6UyxzdHlsZVVybHM6a309YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT12b2lkIDA/YXJndW1lbnRzWzBdOnt9O3RoaXMubW9kdWxlVXJsPUZ8fG51bGwsdGhpcy5zdHlsZXM9dyhTKSx0aGlzLnN0eWxlVXJscz13KGspfX07ZS5Db21waWxlU3R5bGVzaGVldE1ldGFkYXRhPWg7dmFyIE49Y2xhc3N7Y29uc3RydWN0b3IoRil7bGV0e2VuY2Fwc3VsYXRpb246Uyx0ZW1wbGF0ZTprLHRlbXBsYXRlVXJsOl8saHRtbEFzdDpPLHN0eWxlczpSLHN0eWxlVXJsczpNLGV4dGVybmFsU3R5bGVzaGVldHM6SCxhbmltYXRpb25zOlAsbmdDb250ZW50U2VsZWN0b3JzOkcsaW50ZXJwb2xhdGlvbjpyZSxpc0lubGluZTokLHByZXNlcnZlV2hpdGVzcGFjZXM6V309RjtpZih0aGlzLmVuY2Fwc3VsYXRpb249Uyx0aGlzLnRlbXBsYXRlPWssdGhpcy50ZW1wbGF0ZVVybD1fLHRoaXMuaHRtbEFzdD1PLHRoaXMuc3R5bGVzPXcoUiksdGhpcy5zdHlsZVVybHM9dyhNKSx0aGlzLmV4dGVybmFsU3R5bGVzaGVldHM9dyhIKSx0aGlzLmFuaW1hdGlvbnM9UD9FKFApOltdLHRoaXMubmdDb250ZW50U2VsZWN0b3JzPUd8fFtdLHJlJiZyZS5sZW5ndGghPTIpdGhyb3cgbmV3IEVycm9yKFwiJ2ludGVycG9sYXRpb24nIHNob3VsZCBoYXZlIGEgc3RhcnQgYW5kIGFuIGVuZCBzeW1ib2wuXCIpO3RoaXMuaW50ZXJwb2xhdGlvbj1yZSx0aGlzLmlzSW5saW5lPSQsdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2VzPVd9dG9TdW1tYXJ5KCl7cmV0dXJue25nQ29udGVudFNlbGVjdG9yczp0aGlzLm5nQ29udGVudFNlbGVjdG9ycyxlbmNhcHN1bGF0aW9uOnRoaXMuZW5jYXBzdWxhdGlvbixzdHlsZXM6dGhpcy5zdHlsZXMsYW5pbWF0aW9uczp0aGlzLmFuaW1hdGlvbnN9fX07ZS5Db21waWxlVGVtcGxhdGVNZXRhZGF0YT1OO3ZhciBUPWNsYXNze3N0YXRpYyBjcmVhdGUoRil7bGV0e2lzSG9zdDpTLHR5cGU6ayxpc0NvbXBvbmVudDpfLHNlbGVjdG9yOk8sZXhwb3J0QXM6UixjaGFuZ2VEZXRlY3Rpb246TSxpbnB1dHM6SCxvdXRwdXRzOlAsaG9zdDpHLHByb3ZpZGVyczpyZSx2aWV3UHJvdmlkZXJzOiQscXVlcmllczpXLGd1YXJkczplZSx2aWV3UXVlcmllczpVLGVudHJ5Q29tcG9uZW50czpuZSx0ZW1wbGF0ZTpzZSxjb21wb25lbnRWaWV3VHlwZTpWLHJlbmRlcmVyVHlwZTpvZSxjb21wb25lbnRGYWN0b3J5Okt9PUYsRWU9e30scT17fSxsZT17fTtHIT1udWxsJiZPYmplY3Qua2V5cyhHKS5mb3JFYWNoKGRlPT57bGV0IGdlPUdbZGVdLHZlPWRlLm1hdGNoKHMpO3ZlPT09bnVsbD9sZVtkZV09Z2U6dmVbMV0hPW51bGw/cVt2ZVsxXV09Z2U6dmVbMl0hPW51bGwmJihFZVt2ZVsyXV09Z2UpfSk7bGV0IHVlPXt9O0ghPW51bGwmJkguZm9yRWFjaChkZT0+e2xldCBnZT10LnNwbGl0QXRDb2xvbihkZSxbZGUsZGVdKTt1ZVtnZVswXV09Z2VbMV19KTtsZXQgUT17fTtyZXR1cm4gUCE9bnVsbCYmUC5mb3JFYWNoKGRlPT57bGV0IGdlPXQuc3BsaXRBdENvbG9uKGRlLFtkZSxkZV0pO1FbZ2VbMF1dPWdlWzFdfSksbmV3IFQoe2lzSG9zdDpTLHR5cGU6ayxpc0NvbXBvbmVudDohIV8sc2VsZWN0b3I6TyxleHBvcnRBczpSLGNoYW5nZURldGVjdGlvbjpNLGlucHV0czp1ZSxvdXRwdXRzOlEsaG9zdExpc3RlbmVyczpFZSxob3N0UHJvcGVydGllczpxLGhvc3RBdHRyaWJ1dGVzOmxlLHByb3ZpZGVyczpyZSx2aWV3UHJvdmlkZXJzOiQscXVlcmllczpXLGd1YXJkczplZSx2aWV3UXVlcmllczpVLGVudHJ5Q29tcG9uZW50czpuZSx0ZW1wbGF0ZTpzZSxjb21wb25lbnRWaWV3VHlwZTpWLHJlbmRlcmVyVHlwZTpvZSxjb21wb25lbnRGYWN0b3J5Okt9KX1jb25zdHJ1Y3RvcihGKXtsZXR7aXNIb3N0OlMsdHlwZTprLGlzQ29tcG9uZW50Ol8sc2VsZWN0b3I6TyxleHBvcnRBczpSLGNoYW5nZURldGVjdGlvbjpNLGlucHV0czpILG91dHB1dHM6UCxob3N0TGlzdGVuZXJzOkcsaG9zdFByb3BlcnRpZXM6cmUsaG9zdEF0dHJpYnV0ZXM6JCxwcm92aWRlcnM6Vyx2aWV3UHJvdmlkZXJzOmVlLHF1ZXJpZXM6VSxndWFyZHM6bmUsdmlld1F1ZXJpZXM6c2UsZW50cnlDb21wb25lbnRzOlYsdGVtcGxhdGU6b2UsY29tcG9uZW50Vmlld1R5cGU6SyxyZW5kZXJlclR5cGU6RWUsY29tcG9uZW50RmFjdG9yeTpxfT1GO3RoaXMuaXNIb3N0PSEhUyx0aGlzLnR5cGU9ayx0aGlzLmlzQ29tcG9uZW50PV8sdGhpcy5zZWxlY3Rvcj1PLHRoaXMuZXhwb3J0QXM9Uix0aGlzLmNoYW5nZURldGVjdGlvbj1NLHRoaXMuaW5wdXRzPUgsdGhpcy5vdXRwdXRzPVAsdGhpcy5ob3N0TGlzdGVuZXJzPUcsdGhpcy5ob3N0UHJvcGVydGllcz1yZSx0aGlzLmhvc3RBdHRyaWJ1dGVzPSQsdGhpcy5wcm92aWRlcnM9dyhXKSx0aGlzLnZpZXdQcm92aWRlcnM9dyhlZSksdGhpcy5xdWVyaWVzPXcoVSksdGhpcy5ndWFyZHM9bmUsdGhpcy52aWV3UXVlcmllcz13KHNlKSx0aGlzLmVudHJ5Q29tcG9uZW50cz13KFYpLHRoaXMudGVtcGxhdGU9b2UsdGhpcy5jb21wb25lbnRWaWV3VHlwZT1LLHRoaXMucmVuZGVyZXJUeXBlPUVlLHRoaXMuY29tcG9uZW50RmFjdG9yeT1xfXRvU3VtbWFyeSgpe3JldHVybntzdW1tYXJ5S2luZDpnLkRpcmVjdGl2ZSx0eXBlOnRoaXMudHlwZSxpc0NvbXBvbmVudDp0aGlzLmlzQ29tcG9uZW50LHNlbGVjdG9yOnRoaXMuc2VsZWN0b3IsZXhwb3J0QXM6dGhpcy5leHBvcnRBcyxpbnB1dHM6dGhpcy5pbnB1dHMsb3V0cHV0czp0aGlzLm91dHB1dHMsaG9zdExpc3RlbmVyczp0aGlzLmhvc3RMaXN0ZW5lcnMsaG9zdFByb3BlcnRpZXM6dGhpcy5ob3N0UHJvcGVydGllcyxob3N0QXR0cmlidXRlczp0aGlzLmhvc3RBdHRyaWJ1dGVzLHByb3ZpZGVyczp0aGlzLnByb3ZpZGVycyx2aWV3UHJvdmlkZXJzOnRoaXMudmlld1Byb3ZpZGVycyxxdWVyaWVzOnRoaXMucXVlcmllcyxndWFyZHM6dGhpcy5ndWFyZHMsdmlld1F1ZXJpZXM6dGhpcy52aWV3UXVlcmllcyxlbnRyeUNvbXBvbmVudHM6dGhpcy5lbnRyeUNvbXBvbmVudHMsY2hhbmdlRGV0ZWN0aW9uOnRoaXMuY2hhbmdlRGV0ZWN0aW9uLHRlbXBsYXRlOnRoaXMudGVtcGxhdGUmJnRoaXMudGVtcGxhdGUudG9TdW1tYXJ5KCksY29tcG9uZW50Vmlld1R5cGU6dGhpcy5jb21wb25lbnRWaWV3VHlwZSxyZW5kZXJlclR5cGU6dGhpcy5yZW5kZXJlclR5cGUsY29tcG9uZW50RmFjdG9yeTp0aGlzLmNvbXBvbmVudEZhY3Rvcnl9fX07ZS5Db21waWxlRGlyZWN0aXZlTWV0YWRhdGE9VDt2YXIgQT1jbGFzc3tjb25zdHJ1Y3RvcihGKXtsZXR7dHlwZTpTLG5hbWU6ayxwdXJlOl99PUY7dGhpcy50eXBlPVMsdGhpcy5uYW1lPWssdGhpcy5wdXJlPSEhX310b1N1bW1hcnkoKXtyZXR1cm57c3VtbWFyeUtpbmQ6Zy5QaXBlLHR5cGU6dGhpcy50eXBlLG5hbWU6dGhpcy5uYW1lLHB1cmU6dGhpcy5wdXJlfX19O2UuQ29tcGlsZVBpcGVNZXRhZGF0YT1BO3ZhciBiPWNsYXNze307ZS5Db21waWxlU2hhbGxvd01vZHVsZU1ldGFkYXRhPWI7dmFyIHY9Y2xhc3N7Y29uc3RydWN0b3IoRil7bGV0e3R5cGU6Uyxwcm92aWRlcnM6ayxkZWNsYXJlZERpcmVjdGl2ZXM6XyxleHBvcnRlZERpcmVjdGl2ZXM6TyxkZWNsYXJlZFBpcGVzOlIsZXhwb3J0ZWRQaXBlczpNLGVudHJ5Q29tcG9uZW50czpILGJvb3RzdHJhcENvbXBvbmVudHM6UCxpbXBvcnRlZE1vZHVsZXM6RyxleHBvcnRlZE1vZHVsZXM6cmUsc2NoZW1hczokLHRyYW5zaXRpdmVNb2R1bGU6VyxpZDplZX09Rjt0aGlzLnR5cGU9U3x8bnVsbCx0aGlzLmRlY2xhcmVkRGlyZWN0aXZlcz13KF8pLHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzPXcoTyksdGhpcy5kZWNsYXJlZFBpcGVzPXcoUiksdGhpcy5leHBvcnRlZFBpcGVzPXcoTSksdGhpcy5wcm92aWRlcnM9dyhrKSx0aGlzLmVudHJ5Q29tcG9uZW50cz13KEgpLHRoaXMuYm9vdHN0cmFwQ29tcG9uZW50cz13KFApLHRoaXMuaW1wb3J0ZWRNb2R1bGVzPXcoRyksdGhpcy5leHBvcnRlZE1vZHVsZXM9dyhyZSksdGhpcy5zY2hlbWFzPXcoJCksdGhpcy5pZD1lZXx8bnVsbCx0aGlzLnRyYW5zaXRpdmVNb2R1bGU9V3x8bnVsbH10b1N1bW1hcnkoKXtsZXQgRj10aGlzLnRyYW5zaXRpdmVNb2R1bGU7cmV0dXJue3N1bW1hcnlLaW5kOmcuTmdNb2R1bGUsdHlwZTp0aGlzLnR5cGUsZW50cnlDb21wb25lbnRzOkYuZW50cnlDb21wb25lbnRzLHByb3ZpZGVyczpGLnByb3ZpZGVycyxtb2R1bGVzOkYubW9kdWxlcyxleHBvcnRlZERpcmVjdGl2ZXM6Ri5leHBvcnRlZERpcmVjdGl2ZXMsZXhwb3J0ZWRQaXBlczpGLmV4cG9ydGVkUGlwZXN9fX07ZS5Db21waWxlTmdNb2R1bGVNZXRhZGF0YT12O3ZhciBCPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5kaXJlY3RpdmVzU2V0PW5ldyBTZXQsdGhpcy5kaXJlY3RpdmVzPVtdLHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzU2V0PW5ldyBTZXQsdGhpcy5leHBvcnRlZERpcmVjdGl2ZXM9W10sdGhpcy5waXBlc1NldD1uZXcgU2V0LHRoaXMucGlwZXM9W10sdGhpcy5leHBvcnRlZFBpcGVzU2V0PW5ldyBTZXQsdGhpcy5leHBvcnRlZFBpcGVzPVtdLHRoaXMubW9kdWxlc1NldD1uZXcgU2V0LHRoaXMubW9kdWxlcz1bXSx0aGlzLmVudHJ5Q29tcG9uZW50c1NldD1uZXcgU2V0LHRoaXMuZW50cnlDb21wb25lbnRzPVtdLHRoaXMucHJvdmlkZXJzPVtdfWFkZFByb3ZpZGVyKEYsUyl7dGhpcy5wcm92aWRlcnMucHVzaCh7cHJvdmlkZXI6Rixtb2R1bGU6U30pfWFkZERpcmVjdGl2ZShGKXt0aGlzLmRpcmVjdGl2ZXNTZXQuaGFzKEYucmVmZXJlbmNlKXx8KHRoaXMuZGlyZWN0aXZlc1NldC5hZGQoRi5yZWZlcmVuY2UpLHRoaXMuZGlyZWN0aXZlcy5wdXNoKEYpKX1hZGRFeHBvcnRlZERpcmVjdGl2ZShGKXt0aGlzLmV4cG9ydGVkRGlyZWN0aXZlc1NldC5oYXMoRi5yZWZlcmVuY2UpfHwodGhpcy5leHBvcnRlZERpcmVjdGl2ZXNTZXQuYWRkKEYucmVmZXJlbmNlKSx0aGlzLmV4cG9ydGVkRGlyZWN0aXZlcy5wdXNoKEYpKX1hZGRQaXBlKEYpe3RoaXMucGlwZXNTZXQuaGFzKEYucmVmZXJlbmNlKXx8KHRoaXMucGlwZXNTZXQuYWRkKEYucmVmZXJlbmNlKSx0aGlzLnBpcGVzLnB1c2goRikpfWFkZEV4cG9ydGVkUGlwZShGKXt0aGlzLmV4cG9ydGVkUGlwZXNTZXQuaGFzKEYucmVmZXJlbmNlKXx8KHRoaXMuZXhwb3J0ZWRQaXBlc1NldC5hZGQoRi5yZWZlcmVuY2UpLHRoaXMuZXhwb3J0ZWRQaXBlcy5wdXNoKEYpKX1hZGRNb2R1bGUoRil7dGhpcy5tb2R1bGVzU2V0LmhhcyhGLnJlZmVyZW5jZSl8fCh0aGlzLm1vZHVsZXNTZXQuYWRkKEYucmVmZXJlbmNlKSx0aGlzLm1vZHVsZXMucHVzaChGKSl9YWRkRW50cnlDb21wb25lbnQoRil7dGhpcy5lbnRyeUNvbXBvbmVudHNTZXQuaGFzKEYuY29tcG9uZW50VHlwZSl8fCh0aGlzLmVudHJ5Q29tcG9uZW50c1NldC5hZGQoRi5jb21wb25lbnRUeXBlKSx0aGlzLmVudHJ5Q29tcG9uZW50cy5wdXNoKEYpKX19O2UuVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhPUI7ZnVuY3Rpb24gdyhGKXtyZXR1cm4gRnx8W119dmFyIEk9Y2xhc3N7Y29uc3RydWN0b3IoRixTKXtsZXR7dXNlQ2xhc3M6ayx1c2VWYWx1ZTpfLHVzZUV4aXN0aW5nOk8sdXNlRmFjdG9yeTpSLGRlcHM6TSxtdWx0aTpIfT1TO3RoaXMudG9rZW49Rix0aGlzLnVzZUNsYXNzPWt8fG51bGwsdGhpcy51c2VWYWx1ZT1fLHRoaXMudXNlRXhpc3Rpbmc9Tyx0aGlzLnVzZUZhY3Rvcnk9Unx8bnVsbCx0aGlzLmRlcGVuZGVuY2llcz1NfHxudWxsLHRoaXMubXVsdGk9ISFIfX07ZS5Qcm92aWRlck1ldGE9STtmdW5jdGlvbiBFKEYpe3JldHVybiBGLnJlZHVjZSgoUyxrKT0+e2xldCBfPUFycmF5LmlzQXJyYXkoayk/RShrKTprO3JldHVybiBTLmNvbmNhdChfKX0sW10pfWUuZmxhdHRlbj1FO2Z1bmN0aW9uIEQoRil7cmV0dXJuIEYucmVwbGFjZSgvKFxcdys6XFwvXFwvW1xcdzotXSspPyhcXC8rKT8vLFwibmc6Ly8vXCIpfWZ1bmN0aW9uIGQoRixTLGspe2xldCBfO3JldHVybiBrLmlzSW5saW5lP1MudHlwZS5yZWZlcmVuY2UgaW5zdGFuY2VvZiBuLlN0YXRpY1N5bWJvbD9fPVwiXCIuY29uY2F0KFMudHlwZS5yZWZlcmVuY2UuZmlsZVBhdGgsXCIuXCIpLmNvbmNhdChTLnR5cGUucmVmZXJlbmNlLm5hbWUsXCIuaHRtbFwiKTpfPVwiXCIuY29uY2F0KHUoRiksXCIvXCIpLmNvbmNhdCh1KFMudHlwZSksXCIuaHRtbFwiKTpfPWsudGVtcGxhdGVVcmwsUy50eXBlLnJlZmVyZW5jZSBpbnN0YW5jZW9mIG4uU3RhdGljU3ltYm9sP186RChfKX1lLnRlbXBsYXRlU291cmNlVXJsPWQ7ZnVuY3Rpb24geShGLFMpe2xldCBrPUYubW9kdWxlVXJsLnNwbGl0KC9cXC9cXFxcL2cpLF89a1trLmxlbmd0aC0xXTtyZXR1cm4gRChcImNzcy9cIi5jb25jYXQoUykuY29uY2F0KF8sXCIubmdzdHlsZS5qc1wiKSl9ZS5zaGFyZWRTdHlsZXNoZWV0Sml0VXJsPXk7ZnVuY3Rpb24gbyhGKXtyZXR1cm4gRChcIlwiLmNvbmNhdCh1KEYudHlwZSksXCIvbW9kdWxlLm5nZmFjdG9yeS5qc1wiKSl9ZS5uZ01vZHVsZUppdFVybD1vO2Z1bmN0aW9uIHgoRixTKXtyZXR1cm4gRChcIlwiLmNvbmNhdCh1KEYpLFwiL1wiKS5jb25jYXQodShTLnR5cGUpLFwiLm5nZmFjdG9yeS5qc1wiKSl9ZS50ZW1wbGF0ZUppdFVybD14fX0pLHFkPVooe1wibm9kZV9tb2R1bGVzL2FuZ3VsYXItaHRtbC1wYXJzZXIvbGliL2NvbXBpbGVyL3NyYy9wYXJzZV91dGlsLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7YWUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1rZCgpLHQ9amQoKSxzPWNsYXNze2NvbnN0cnVjdG9yKEMsbSxnLHApe3RoaXMuZmlsZT1DLHRoaXMub2Zmc2V0PW0sdGhpcy5saW5lPWcsdGhpcy5jb2w9cH10b1N0cmluZygpe3JldHVybiB0aGlzLm9mZnNldCE9bnVsbD9cIlwiLmNvbmNhdCh0aGlzLmZpbGUudXJsLFwiQFwiKS5jb25jYXQodGhpcy5saW5lLFwiOlwiKS5jb25jYXQodGhpcy5jb2wpOnRoaXMuZmlsZS51cmx9bW92ZUJ5KEMpe2xldCBtPXRoaXMuZmlsZS5jb250ZW50LGc9bS5sZW5ndGgscD10aGlzLm9mZnNldCxmPXRoaXMubGluZSxoPXRoaXMuY29sO2Zvcig7cD4wJiZDPDA7KWlmKHAtLSxDKyssbS5jaGFyQ29kZUF0KHApPT1uLiRMRil7Zi0tO2xldCBUPW0uc3Vic3RyKDAscC0xKS5sYXN0SW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKG4uJExGKSk7aD1UPjA/cC1UOnB9ZWxzZSBoLS07Zm9yKDtwPGcmJkM+MDspe2xldCBOPW0uY2hhckNvZGVBdChwKTtwKyssQy0tLE49PW4uJExGPyhmKyssaD0wKTpoKyt9cmV0dXJuIG5ldyBzKHRoaXMuZmlsZSxwLGYsaCl9Z2V0Q29udGV4dChDLG0pe2xldCBnPXRoaXMuZmlsZS5jb250ZW50LHA9dGhpcy5vZmZzZXQ7aWYocCE9bnVsbCl7cD5nLmxlbmd0aC0xJiYocD1nLmxlbmd0aC0xKTtsZXQgZj1wLGg9MCxOPTA7Zm9yKDtoPEMmJnA+MCYmKHAtLSxoKyssIShnW3BdPT1gXG5gJiYrK049PW0pKTspO2ZvcihoPTAsTj0wO2g8QyYmZjxnLmxlbmd0aC0xJiYoZisrLGgrKywhKGdbZl09PWBcbmAmJisrTj09bSkpOyk7cmV0dXJue2JlZm9yZTpnLnN1YnN0cmluZyhwLHRoaXMub2Zmc2V0KSxhZnRlcjpnLnN1YnN0cmluZyh0aGlzLm9mZnNldCxmKzEpfX1yZXR1cm4gbnVsbH19O2UuUGFyc2VMb2NhdGlvbj1zO3ZhciBpPWNsYXNze2NvbnN0cnVjdG9yKEMsbSl7dGhpcy5jb250ZW50PUMsdGhpcy51cmw9bX19O2UuUGFyc2VTb3VyY2VGaWxlPWk7dmFyIHI9Y2xhc3N7Y29uc3RydWN0b3IoQyxtKXtsZXQgZz1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06bnVsbDt0aGlzLnN0YXJ0PUMsdGhpcy5lbmQ9bSx0aGlzLmRldGFpbHM9Z310b1N0cmluZygpe3JldHVybiB0aGlzLnN0YXJ0LmZpbGUuY29udGVudC5zdWJzdHJpbmcodGhpcy5zdGFydC5vZmZzZXQsdGhpcy5lbmQub2Zmc2V0KX19O2UuUGFyc2VTb3VyY2VTcGFuPXIsZS5FTVBUWV9QQVJTRV9MT0NBVElPTj1uZXcgcyhuZXcgaShcIlwiLFwiXCIpLDAsMCwwKSxlLkVNUFRZX1NPVVJDRV9TUEFOPW5ldyByKGUuRU1QVFlfUEFSU0VfTE9DQVRJT04sZS5FTVBUWV9QQVJTRV9MT0NBVElPTik7dmFyIHU7KGZ1bmN0aW9uKEMpe0NbQy5XQVJOSU5HPTBdPVwiV0FSTklOR1wiLENbQy5FUlJPUj0xXT1cIkVSUk9SXCJ9KSh1PWUuUGFyc2VFcnJvckxldmVsfHwoZS5QYXJzZUVycm9yTGV2ZWw9e30pKTt2YXIgYT1jbGFzc3tjb25zdHJ1Y3RvcihDLG0pe2xldCBnPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTp1LkVSUk9SO3RoaXMuc3Bhbj1DLHRoaXMubXNnPW0sdGhpcy5sZXZlbD1nfWNvbnRleHR1YWxNZXNzYWdlKCl7bGV0IEM9dGhpcy5zcGFuLnN0YXJ0LmdldENvbnRleHQoMTAwLDMpO3JldHVybiBDP1wiXCIuY29uY2F0KHRoaXMubXNnLCcgKFwiJykuY29uY2F0KEMuYmVmb3JlLFwiW1wiKS5jb25jYXQodVt0aGlzLmxldmVsXSxcIiAtPl1cIikuY29uY2F0KEMuYWZ0ZXIsJ1wiKScpOnRoaXMubXNnfXRvU3RyaW5nKCl7bGV0IEM9dGhpcy5zcGFuLmRldGFpbHM/XCIsIFwiLmNvbmNhdCh0aGlzLnNwYW4uZGV0YWlscyk6XCJcIjtyZXR1cm5cIlwiLmNvbmNhdCh0aGlzLmNvbnRleHR1YWxNZXNzYWdlKCksXCI6IFwiKS5jb25jYXQodGhpcy5zcGFuLnN0YXJ0KS5jb25jYXQoQyl9fTtlLlBhcnNlRXJyb3I9YTtmdW5jdGlvbiBjKEMsbSl7bGV0IGc9dC5pZGVudGlmaWVyTW9kdWxlVXJsKG0pLHA9ZyE9bnVsbD9cImluIFwiLmNvbmNhdChDLFwiIFwiKS5jb25jYXQodC5pZGVudGlmaWVyTmFtZShtKSxcIiBpbiBcIikuY29uY2F0KGcpOlwiaW4gXCIuY29uY2F0KEMsXCIgXCIpLmNvbmNhdCh0LmlkZW50aWZpZXJOYW1lKG0pKSxmPW5ldyBpKFwiXCIscCk7cmV0dXJuIG5ldyByKG5ldyBzKGYsLTEsLTEsLTEpLG5ldyBzKGYsLTEsLTEsLTEpKX1lLnR5cGVTb3VyY2VTcGFuPWM7ZnVuY3Rpb24gbChDLG0sZyl7bGV0IHA9XCJpbiBcIi5jb25jYXQoQyxcIiBcIikuY29uY2F0KG0sXCIgaW4gXCIpLmNvbmNhdChnKSxmPW5ldyBpKFwiXCIscCk7cmV0dXJuIG5ldyByKG5ldyBzKGYsLTEsLTEsLTEpLG5ldyBzKGYsLTEsLTEsLTEpKX1lLnIzSml0VHlwZVNvdXJjZVNwYW49bH19KSxNZD1aKHtcInNyYy9sYW5ndWFnZS1odG1sL3ByaW50LXByZXByb2Nlc3MuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye1BhcnNlU291cmNlU3Bhbjp0fT1xZCgpLHtodG1sVHJpbTpzLGdldExlYWRpbmdBbmRUcmFpbGluZ0h0bWxXaGl0ZXNwYWNlOmksaGFzSHRtbFdoaXRlc3BhY2U6cixjYW5IYXZlSW50ZXJwb2xhdGlvbjp1LGdldE5vZGVDc3NTdHlsZURpc3BsYXk6YSxpc0RhbmdsaW5nU3BhY2VTZW5zaXRpdmVOb2RlOmMsaXNJbmRlbnRhdGlvblNlbnNpdGl2ZU5vZGU6bCxpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZU5vZGU6Qyxpc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmVOb2RlOm0saXNXaGl0ZXNwYWNlU2Vuc2l0aXZlTm9kZTpnfT1PdCgpLHA9W2gsTixBLHYsQixFLHcsSSxELGJdO2Z1bmN0aW9uIGYoZCx5KXtmb3IobGV0IG8gb2YgcClvKGQseSk7cmV0dXJuIGR9ZnVuY3Rpb24gaChkKXtkLndhbGsoeT0+e2lmKHkudHlwZT09PVwiZWxlbWVudFwiJiZ5LnRhZ0RlZmluaXRpb24uaWdub3JlRmlyc3RMZiYmeS5jaGlsZHJlbi5sZW5ndGg+MCYmeS5jaGlsZHJlblswXS50eXBlPT09XCJ0ZXh0XCImJnkuY2hpbGRyZW5bMF0udmFsdWVbMF09PT1gXG5gKXtsZXQgbz15LmNoaWxkcmVuWzBdO28udmFsdWUubGVuZ3RoPT09MT95LnJlbW92ZUNoaWxkKG8pOm8udmFsdWU9by52YWx1ZS5zbGljZSgxKX19KX1mdW5jdGlvbiBOKGQpe2xldCB5PW89Pm8udHlwZT09PVwiZWxlbWVudFwiJiZvLnByZXYmJm8ucHJldi50eXBlPT09XCJpZUNvbmRpdGlvbmFsU3RhcnRDb21tZW50XCImJm8ucHJldi5zb3VyY2VTcGFuLmVuZC5vZmZzZXQ9PT1vLnN0YXJ0U291cmNlU3Bhbi5zdGFydC5vZmZzZXQmJm8uZmlyc3RDaGlsZCYmby5maXJzdENoaWxkLnR5cGU9PT1cImllQ29uZGl0aW9uYWxFbmRDb21tZW50XCImJm8uZmlyc3RDaGlsZC5zb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldD09PW8uc3RhcnRTb3VyY2VTcGFuLmVuZC5vZmZzZXQ7ZC53YWxrKG89PntpZihvLmNoaWxkcmVuKWZvcihsZXQgeD0wO3g8by5jaGlsZHJlbi5sZW5ndGg7eCsrKXtsZXQgRj1vLmNoaWxkcmVuW3hdO2lmKCF5KEYpKWNvbnRpbnVlO2xldCBTPUYucHJldixrPUYuZmlyc3RDaGlsZDtvLnJlbW92ZUNoaWxkKFMpLHgtLTtsZXQgXz1uZXcgdChTLnNvdXJjZVNwYW4uc3RhcnQsay5zb3VyY2VTcGFuLmVuZCksTz1uZXcgdChfLnN0YXJ0LEYuc291cmNlU3Bhbi5lbmQpO0YuY29uZGl0aW9uPVMuY29uZGl0aW9uLEYuc291cmNlU3Bhbj1PLEYuc3RhcnRTb3VyY2VTcGFuPV8sRi5yZW1vdmVDaGlsZChrKX19KX1mdW5jdGlvbiBUKGQseSxvKXtkLndhbGsoeD0+e2lmKHguY2hpbGRyZW4pZm9yKGxldCBGPTA7Rjx4LmNoaWxkcmVuLmxlbmd0aDtGKyspe2xldCBTPXguY2hpbGRyZW5bRl07aWYoUy50eXBlIT09XCJ0ZXh0XCImJiF5KFMpKWNvbnRpbnVlO1MudHlwZSE9PVwidGV4dFwiJiYoUy50eXBlPVwidGV4dFwiLFMudmFsdWU9byhTKSk7bGV0IGs9Uy5wcmV2OyFrfHxrLnR5cGUhPT1cInRleHRcInx8KGsudmFsdWUrPVMudmFsdWUsay5zb3VyY2VTcGFuPW5ldyB0KGsuc291cmNlU3Bhbi5zdGFydCxTLnNvdXJjZVNwYW4uZW5kKSx4LnJlbW92ZUNoaWxkKFMpLEYtLSl9fSl9ZnVuY3Rpb24gQShkKXtyZXR1cm4gVChkLHk9PnkudHlwZT09PVwiY2RhdGFcIix5PT5cIjwhW0NEQVRBW1wiLmNvbmNhdCh5LnZhbHVlLFwiXV0+XCIpKX1mdW5jdGlvbiBiKGQpe2xldCB5PW89Pm8udHlwZT09PVwiZWxlbWVudFwiJiZvLmF0dHJzLmxlbmd0aD09PTAmJm8uY2hpbGRyZW4ubGVuZ3RoPT09MSYmby5maXJzdENoaWxkLnR5cGU9PT1cInRleHRcIiYmIXIoby5jaGlsZHJlblswXS52YWx1ZSkmJiFvLmZpcnN0Q2hpbGQuaGFzTGVhZGluZ1NwYWNlcyYmIW8uZmlyc3RDaGlsZC5oYXNUcmFpbGluZ1NwYWNlcyYmby5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZSYmIW8uaGFzTGVhZGluZ1NwYWNlcyYmby5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUmJiFvLmhhc1RyYWlsaW5nU3BhY2VzJiZvLnByZXYmJm8ucHJldi50eXBlPT09XCJ0ZXh0XCImJm8ubmV4dCYmby5uZXh0LnR5cGU9PT1cInRleHRcIjtkLndhbGsobz0+e2lmKG8uY2hpbGRyZW4pZm9yKGxldCB4PTA7eDxvLmNoaWxkcmVuLmxlbmd0aDt4Kyspe2xldCBGPW8uY2hpbGRyZW5beF07aWYoIXkoRikpY29udGludWU7bGV0IFM9Ri5wcmV2LGs9Ri5uZXh0O1MudmFsdWUrPVwiPFwiLmNvbmNhdChGLnJhd05hbWUsXCI+XCIpK0YuZmlyc3RDaGlsZC52YWx1ZStcIjwvXCIuY29uY2F0KEYucmF3TmFtZSxcIj5cIikray52YWx1ZSxTLnNvdXJjZVNwYW49bmV3IHQoUy5zb3VyY2VTcGFuLnN0YXJ0LGsuc291cmNlU3Bhbi5lbmQpLFMuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlPWsuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlLFMuaGFzVHJhaWxpbmdTcGFjZXM9ay5oYXNUcmFpbGluZ1NwYWNlcyxvLnJlbW92ZUNoaWxkKEYpLHgtLSxvLnJlbW92ZUNoaWxkKGspfX0pfWZ1bmN0aW9uIHYoZCx5KXtpZih5LnBhcnNlcj09PVwiaHRtbFwiKXJldHVybjtsZXQgbz0ve3soLis/KX19L3M7ZC53YWxrKHg9PntpZighIXUoeCkpZm9yKGxldCBGIG9mIHguY2hpbGRyZW4pe2lmKEYudHlwZSE9PVwidGV4dFwiKWNvbnRpbnVlO2xldCBTPUYuc291cmNlU3Bhbi5zdGFydCxrPW51bGwsXz1GLnZhbHVlLnNwbGl0KG8pO2ZvcihsZXQgTz0wO088Xy5sZW5ndGg7TysrLFM9ayl7bGV0IFI9X1tPXTtpZihPJTI9PT0wKXtrPVMubW92ZUJ5KFIubGVuZ3RoKSxSLmxlbmd0aD4wJiZ4Lmluc2VydENoaWxkQmVmb3JlKEYse3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Uixzb3VyY2VTcGFuOm5ldyB0KFMsayl9KTtjb250aW51ZX1rPVMubW92ZUJ5KFIubGVuZ3RoKzQpLHguaW5zZXJ0Q2hpbGRCZWZvcmUoRix7dHlwZTpcImludGVycG9sYXRpb25cIixzb3VyY2VTcGFuOm5ldyB0KFMsayksY2hpbGRyZW46Ui5sZW5ndGg9PT0wP1tdOlt7dHlwZTpcInRleHRcIix2YWx1ZTpSLHNvdXJjZVNwYW46bmV3IHQoUy5tb3ZlQnkoMiksay5tb3ZlQnkoLTIpKX1dfSl9eC5yZW1vdmVDaGlsZChGKX19KX1mdW5jdGlvbiBCKGQpe2Qud2Fsayh5PT57aWYoIXkuY2hpbGRyZW4pcmV0dXJuO2lmKHkuY2hpbGRyZW4ubGVuZ3RoPT09MHx8eS5jaGlsZHJlbi5sZW5ndGg9PT0xJiZ5LmNoaWxkcmVuWzBdLnR5cGU9PT1cInRleHRcIiYmcyh5LmNoaWxkcmVuWzBdLnZhbHVlKS5sZW5ndGg9PT0wKXt5Lmhhc0RhbmdsaW5nU3BhY2VzPXkuY2hpbGRyZW4ubGVuZ3RoPjAseS5jaGlsZHJlbj1bXTtyZXR1cm59bGV0IG89Zyh5KSx4PWwoeSk7aWYoIW8pZm9yKGxldCBGPTA7Rjx5LmNoaWxkcmVuLmxlbmd0aDtGKyspe2xldCBTPXkuY2hpbGRyZW5bRl07aWYoUy50eXBlIT09XCJ0ZXh0XCIpY29udGludWU7bGV0e2xlYWRpbmdXaGl0ZXNwYWNlOmssdGV4dDpfLHRyYWlsaW5nV2hpdGVzcGFjZTpPfT1pKFMudmFsdWUpLFI9Uy5wcmV2LE09Uy5uZXh0O18/KFMudmFsdWU9XyxTLnNvdXJjZVNwYW49bmV3IHQoUy5zb3VyY2VTcGFuLnN0YXJ0Lm1vdmVCeShrLmxlbmd0aCksUy5zb3VyY2VTcGFuLmVuZC5tb3ZlQnkoLU8ubGVuZ3RoKSksayYmKFImJihSLmhhc1RyYWlsaW5nU3BhY2VzPSEwKSxTLmhhc0xlYWRpbmdTcGFjZXM9ITApLE8mJihTLmhhc1RyYWlsaW5nU3BhY2VzPSEwLE0mJihNLmhhc0xlYWRpbmdTcGFjZXM9ITApKSk6KHkucmVtb3ZlQ2hpbGQoUyksRi0tLChrfHxPKSYmKFImJihSLmhhc1RyYWlsaW5nU3BhY2VzPSEwKSxNJiYoTS5oYXNMZWFkaW5nU3BhY2VzPSEwKSkpfXkuaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlPW8seS5pc0luZGVudGF0aW9uU2Vuc2l0aXZlPXh9KX1mdW5jdGlvbiB3KGQpe2Qud2Fsayh5PT57eS5pc1NlbGZDbG9zaW5nPSF5LmNoaWxkcmVufHx5LnR5cGU9PT1cImVsZW1lbnRcIiYmKHkudGFnRGVmaW5pdGlvbi5pc1ZvaWR8fHkuc3RhcnRTb3VyY2VTcGFuPT09eS5lbmRTb3VyY2VTcGFuKX0pfWZ1bmN0aW9uIEkoZCx5KXtkLndhbGsobz0+e28udHlwZT09PVwiZWxlbWVudFwiJiYoby5oYXNIdG1Db21wb25lbnRDbG9zaW5nVGFnPW8uZW5kU291cmNlU3BhbiYmL148XFxzKlxcL1xccypcXC9cXHMqPiQvLnRlc3QoeS5vcmlnaW5hbFRleHQuc2xpY2Uoby5lbmRTb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCxvLmVuZFNvdXJjZVNwYW4uZW5kLm9mZnNldCkpKX0pfWZ1bmN0aW9uIEUoZCx5KXtkLndhbGsobz0+e28uY3NzRGlzcGxheT1hKG8seSl9KX1mdW5jdGlvbiBEKGQseSl7ZC53YWxrKG89PntsZXR7Y2hpbGRyZW46eH09bztpZighIXgpe2lmKHgubGVuZ3RoPT09MCl7by5pc0RhbmdsaW5nU3BhY2VTZW5zaXRpdmU9YyhvKTtyZXR1cm59Zm9yKGxldCBGIG9mIHgpRi5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZT1DKEYseSksRi5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmU9bShGLHkpO2ZvcihsZXQgRj0wO0Y8eC5sZW5ndGg7RisrKXtsZXQgUz14W0ZdO1MuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmU9KEY9PT0wfHxTLnByZXYuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlKSYmUy5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZSxTLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZT0oRj09PXgubGVuZ3RoLTF8fFMubmV4dC5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZSkmJlMuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlfX19KX1uLmV4cG9ydHM9Zn19KSxSZD1aKHtcInNyYy9sYW5ndWFnZS1odG1sL3ByYWdtYS5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KGkpe3JldHVybi9eXFxzKjwhLS1cXHMqQCg/OmZvcm1hdHxwcmV0dGllcilcXHMqLS0+Ly50ZXN0KGkpfWZ1bmN0aW9uIHMoaSl7cmV0dXJuYDwhLS0gQGZvcm1hdCAtLT5cblxuYCtpLnJlcGxhY2UoL15cXHMqXFxuLyxcIlwiKX1uLmV4cG9ydHM9e2hhc1ByYWdtYTp0LGluc2VydFByYWdtYTpzfX19KSxZbj1aKHtcInNyYy9sYW5ndWFnZS1odG1sL2xvYy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KGkpe3JldHVybiBpLnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0fWZ1bmN0aW9uIHMoaSl7cmV0dXJuIGkuc291cmNlU3Bhbi5lbmQub2Zmc2V0fW4uZXhwb3J0cz17bG9jU3RhcnQ6dCxsb2NFbmQ6c319fSksUXQ9Wih7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9wcmludC90YWcuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9VXQoKSx7aXNOb25FbXB0eUFycmF5OnN9PUdlKCkse2J1aWxkZXJzOntpbmRlbnQ6aSxqb2luOnIsbGluZTp1LHNvZnRsaW5lOmEsaGFyZGxpbmU6Y30sdXRpbHM6e3JlcGxhY2VUZXh0RW5kT2ZMaW5lOmx9fT1MZSgpLHtsb2NTdGFydDpDLGxvY0VuZDptfT1ZbigpLHtpc1RleHRMaWtlTm9kZTpnLGdldExhc3REZXNjZW5kYW50OnAsaXNQcmVMaWtlTm9kZTpmLGhhc1ByZXR0aWVySWdub3JlOmgsc2hvdWxkUHJlc2VydmVDb250ZW50Ok59PU90KCk7ZnVuY3Rpb24gVChQLEcpe3JldHVybltQLmlzU2VsZkNsb3Npbmc/XCJcIjpBKFAsRyksYihQLEcpXX1mdW5jdGlvbiBBKFAsRyl7cmV0dXJuIFAubGFzdENoaWxkJiZ5KFAubGFzdENoaWxkKT9cIlwiOlt2KFAsRyksdyhQLEcpXX1mdW5jdGlvbiBiKFAsRyl7cmV0dXJuKFAubmV4dD9EKFAubmV4dCk6ZChQLnBhcmVudCkpP1wiXCI6W0koUCxHKSxCKFAsRyldfWZ1bmN0aW9uIHYoUCxHKXtyZXR1cm4gZChQKT9JKFAubGFzdENoaWxkLEcpOlwiXCJ9ZnVuY3Rpb24gQihQLEcpe3JldHVybiB5KFApP3coUC5wYXJlbnQsRyk6byhQKT9NKFAubmV4dCk6XCJcIn1mdW5jdGlvbiB3KFAsRyl7aWYodCghUC5pc1NlbGZDbG9zaW5nKSxFKFAsRykpcmV0dXJuXCJcIjtzd2l0Y2goUC50eXBlKXtjYXNlXCJpZUNvbmRpdGlvbmFsQ29tbWVudFwiOnJldHVyblwiPCFcIjtjYXNlXCJlbGVtZW50XCI6aWYoUC5oYXNIdG1Db21wb25lbnRDbG9zaW5nVGFnKXJldHVyblwiPC8vXCI7ZGVmYXVsdDpyZXR1cm5cIjwvXCIuY29uY2F0KFAucmF3TmFtZSl9fWZ1bmN0aW9uIEkoUCxHKXtpZihFKFAsRykpcmV0dXJuXCJcIjtzd2l0Y2goUC50eXBlKXtjYXNlXCJpZUNvbmRpdGlvbmFsQ29tbWVudFwiOmNhc2VcImllQ29uZGl0aW9uYWxFbmRDb21tZW50XCI6cmV0dXJuXCJbZW5kaWZdLS0+XCI7Y2FzZVwiaWVDb25kaXRpb25hbFN0YXJ0Q29tbWVudFwiOnJldHVyblwiXT48IS0tPlwiO2Nhc2VcImludGVycG9sYXRpb25cIjpyZXR1cm5cIn19XCI7Y2FzZVwiZWxlbWVudFwiOmlmKFAuaXNTZWxmQ2xvc2luZylyZXR1cm5cIi8+XCI7ZGVmYXVsdDpyZXR1cm5cIj5cIn19ZnVuY3Rpb24gRShQLEcpe3JldHVybiFQLmlzU2VsZkNsb3NpbmcmJiFQLmVuZFNvdXJjZVNwYW4mJihoKFApfHxOKFAucGFyZW50LEcpKX1mdW5jdGlvbiBEKFApe3JldHVybiBQLnByZXYmJlAucHJldi50eXBlIT09XCJkb2NUeXBlXCImJiFnKFAucHJldikmJlAuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmUmJiFQLmhhc0xlYWRpbmdTcGFjZXN9ZnVuY3Rpb24gZChQKXtyZXR1cm4gUC5sYXN0Q2hpbGQmJlAubGFzdENoaWxkLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZSYmIVAubGFzdENoaWxkLmhhc1RyYWlsaW5nU3BhY2VzJiYhZyhwKFAubGFzdENoaWxkKSkmJiFmKFApfWZ1bmN0aW9uIHkoUCl7cmV0dXJuIVAubmV4dCYmIVAuaGFzVHJhaWxpbmdTcGFjZXMmJlAuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlJiZnKHAoUCkpfWZ1bmN0aW9uIG8oUCl7cmV0dXJuIFAubmV4dCYmIWcoUC5uZXh0KSYmZyhQKSYmUC5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUmJiFQLmhhc1RyYWlsaW5nU3BhY2VzfWZ1bmN0aW9uIHgoUCl7bGV0IEc9UC50cmltKCkubWF0Y2goL15wcmV0dGllci1pZ25vcmUtYXR0cmlidXRlKD86XFxzKyguKykpPyQvcyk7cmV0dXJuIEc/R1sxXT9HWzFdLnNwbGl0KC9cXHMrLyk6ITA6ITF9ZnVuY3Rpb24gRihQKXtyZXR1cm4hUC5wcmV2JiZQLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlJiYhUC5oYXNMZWFkaW5nU3BhY2VzfWZ1bmN0aW9uIFMoUCxHLHJlKXtsZXQgJD1QLmdldFZhbHVlKCk7aWYoIXMoJC5hdHRycykpcmV0dXJuICQuaXNTZWxmQ2xvc2luZz9cIiBcIjpcIlwiO2xldCBXPSQucHJldiYmJC5wcmV2LnR5cGU9PT1cImNvbW1lbnRcIiYmeCgkLnByZXYudmFsdWUpLGVlPXR5cGVvZiBXPT1cImJvb2xlYW5cIj8oKT0+VzpBcnJheS5pc0FycmF5KFcpP29lPT5XLmluY2x1ZGVzKG9lLnJhd05hbWUpOigpPT4hMSxVPVAubWFwKG9lPT57bGV0IEs9b2UuZ2V0VmFsdWUoKTtyZXR1cm4gZWUoSyk/bChHLm9yaWdpbmFsVGV4dC5zbGljZShDKEspLG0oSykpKTpyZSgpfSxcImF0dHJzXCIpLG5lPSQudHlwZT09PVwiZWxlbWVudFwiJiYkLmZ1bGxOYW1lPT09XCJzY3JpcHRcIiYmJC5hdHRycy5sZW5ndGg9PT0xJiYkLmF0dHJzWzBdLmZ1bGxOYW1lPT09XCJzcmNcIiYmJC5jaGlsZHJlbi5sZW5ndGg9PT0wLHNlPUcuc2luZ2xlQXR0cmlidXRlUGVyTGluZSYmJC5hdHRycy5sZW5ndGg+MT9jOnUsVj1baShbbmU/XCIgXCI6dSxyKHNlLFUpXSldO3JldHVybiAkLmZpcnN0Q2hpbGQmJkYoJC5maXJzdENoaWxkKXx8JC5pc1NlbGZDbG9zaW5nJiZkKCQucGFyZW50KXx8bmU/Vi5wdXNoKCQuaXNTZWxmQ2xvc2luZz9cIiBcIjpcIlwiKTpWLnB1c2goRy5icmFja2V0U2FtZUxpbmU/JC5pc1NlbGZDbG9zaW5nP1wiIFwiOlwiXCI6JC5pc1NlbGZDbG9zaW5nP3U6YSksVn1mdW5jdGlvbiBrKFApe3JldHVybiBQLmZpcnN0Q2hpbGQmJkYoUC5maXJzdENoaWxkKT9cIlwiOkgoUCl9ZnVuY3Rpb24gXyhQLEcscmUpe2xldCAkPVAuZ2V0VmFsdWUoKTtyZXR1cm5bTygkLEcpLFMoUCxHLHJlKSwkLmlzU2VsZkNsb3Npbmc/XCJcIjprKCQpXX1mdW5jdGlvbiBPKFAsRyl7cmV0dXJuIFAucHJldiYmbyhQLnByZXYpP1wiXCI6W1IoUCxHKSxNKFApXX1mdW5jdGlvbiBSKFAsRyl7cmV0dXJuIEYoUCk/SChQLnBhcmVudCk6RChQKT9JKFAucHJldixHKTpcIlwifWZ1bmN0aW9uIE0oUCl7c3dpdGNoKFAudHlwZSl7Y2FzZVwiaWVDb25kaXRpb25hbENvbW1lbnRcIjpjYXNlXCJpZUNvbmRpdGlvbmFsU3RhcnRDb21tZW50XCI6cmV0dXJuXCI8IS0tW2lmIFwiLmNvbmNhdChQLmNvbmRpdGlvbik7Y2FzZVwiaWVDb25kaXRpb25hbEVuZENvbW1lbnRcIjpyZXR1cm5cIjwhLS08IVwiO2Nhc2VcImludGVycG9sYXRpb25cIjpyZXR1cm5cInt7XCI7Y2FzZVwiZG9jVHlwZVwiOnJldHVyblwiPCFET0NUWVBFXCI7Y2FzZVwiZWxlbWVudFwiOmlmKFAuY29uZGl0aW9uKXJldHVyblwiPCEtLVtpZiBcIi5jb25jYXQoUC5jb25kaXRpb24sXCJdPjwhLS0+PFwiKS5jb25jYXQoUC5yYXdOYW1lKTtkZWZhdWx0OnJldHVyblwiPFwiLmNvbmNhdChQLnJhd05hbWUpfX1mdW5jdGlvbiBIKFApe3N3aXRjaCh0KCFQLmlzU2VsZkNsb3NpbmcpLFAudHlwZSl7Y2FzZVwiaWVDb25kaXRpb25hbENvbW1lbnRcIjpyZXR1cm5cIl0+XCI7Y2FzZVwiZWxlbWVudFwiOmlmKFAuY29uZGl0aW9uKXJldHVyblwiPjwhLS08IVtlbmRpZl0tLT5cIjtkZWZhdWx0OnJldHVyblwiPlwifX1uLmV4cG9ydHM9e3ByaW50Q2xvc2luZ1RhZzpULHByaW50Q2xvc2luZ1RhZ1N0YXJ0OkEscHJpbnRDbG9zaW5nVGFnU3RhcnRNYXJrZXI6dyxwcmludENsb3NpbmdUYWdFbmRNYXJrZXI6SSxwcmludENsb3NpbmdUYWdTdWZmaXg6QixwcmludENsb3NpbmdUYWdFbmQ6YixuZWVkc1RvQm9ycm93TGFzdENoaWxkQ2xvc2luZ1RhZ0VuZE1hcmtlcjpkLG5lZWRzVG9Cb3Jyb3dQYXJlbnRDbG9zaW5nVGFnU3RhcnRNYXJrZXI6eSxuZWVkc1RvQm9ycm93UHJldkNsb3NpbmdUYWdFbmRNYXJrZXI6RCxwcmludE9wZW5pbmdUYWc6XyxwcmludE9wZW5pbmdUYWdTdGFydDpPLHByaW50T3BlbmluZ1RhZ1ByZWZpeDpSLHByaW50T3BlbmluZ1RhZ1N0YXJ0TWFya2VyOk0scHJpbnRPcGVuaW5nVGFnRW5kTWFya2VyOkgsbmVlZHNUb0JvcnJvd05leHRPcGVuaW5nVGFnU3RhcnRNYXJrZXI6byxuZWVkc1RvQm9ycm93UGFyZW50T3BlbmluZ1RhZ0VuZE1hcmtlcjpGfX19KSxWZD1aKHtcIm5vZGVfbW9kdWxlcy9wYXJzZS1zcmNzZXQvc3JjL3BhcnNlLXNyY3NldC5qc1wiKGUsbil7YWUoKSxmdW5jdGlvbih0LHMpe3R5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZD9kZWZpbmUoW10scyk6dHlwZW9mIG49PVwib2JqZWN0XCImJm4uZXhwb3J0cz9uLmV4cG9ydHM9cygpOnQucGFyc2VTcmNzZXQ9cygpfShlLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQscyl7dmFyIGk9cyYmcy5sb2dnZXJ8fGNvbnNvbGU7ZnVuY3Rpb24gcihJKXtyZXR1cm4gST09PVwiIFwifHxJPT09XCJcdFwifHxJPT09YFxuYHx8ST09PVwiXFxmXCJ8fEk9PT1cIlxcclwifWZ1bmN0aW9uIHUoSSl7dmFyIEUsRD1JLmV4ZWModC5zdWJzdHJpbmcoYikpO2lmKEQpcmV0dXJuIEU9RFswXSxiKz1FLmxlbmd0aCxFfWZvcih2YXIgYT10Lmxlbmd0aCxjPS9eWyBcXHRcXG5cXHJcXHUwMDBjXSsvLGw9L15bLCBcXHRcXG5cXHJcXHUwMDBjXSsvLEM9L15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvLG09L1ssXSskLyxnPS9eXFxkKyQvLHA9L14tPyg/OlswLTldK3xbMC05XSpcXC5bMC05XSspKD86W2VFXVsrLV0/WzAtOV0rKT8kLyxmLGgsTixULEEsYj0wLHY9W107Oyl7aWYodShsKSxiPj1hKXJldHVybiB2O2Y9dShDKSxoPVtdLGYuc2xpY2UoLTEpPT09XCIsXCI/KGY9Zi5yZXBsYWNlKG0sXCJcIiksdygpKTpCKCl9ZnVuY3Rpb24gQigpe2Zvcih1KGMpLE49XCJcIixUPVwiaW4gZGVzY3JpcHRvclwiOzspe2lmKEE9dC5jaGFyQXQoYiksVD09PVwiaW4gZGVzY3JpcHRvclwiKWlmKHIoQSkpTiYmKGgucHVzaChOKSxOPVwiXCIsVD1cImFmdGVyIGRlc2NyaXB0b3JcIik7ZWxzZSBpZihBPT09XCIsXCIpe2IrPTEsTiYmaC5wdXNoKE4pLHcoKTtyZXR1cm59ZWxzZSBpZihBPT09XCIoXCIpTj1OK0EsVD1cImluIHBhcmVuc1wiO2Vsc2UgaWYoQT09PVwiXCIpe04mJmgucHVzaChOKSx3KCk7cmV0dXJufWVsc2UgTj1OK0E7ZWxzZSBpZihUPT09XCJpbiBwYXJlbnNcIilpZihBPT09XCIpXCIpTj1OK0EsVD1cImluIGRlc2NyaXB0b3JcIjtlbHNlIGlmKEE9PT1cIlwiKXtoLnB1c2goTiksdygpO3JldHVybn1lbHNlIE49TitBO2Vsc2UgaWYoVD09PVwiYWZ0ZXIgZGVzY3JpcHRvclwiJiYhcihBKSlpZihBPT09XCJcIil7dygpO3JldHVybn1lbHNlIFQ9XCJpbiBkZXNjcmlwdG9yXCIsYi09MTtiKz0xfX1mdW5jdGlvbiB3KCl7dmFyIEk9ITEsRSxELGQseSxvPXt9LHgsRixTLGssXztmb3IoeT0wO3k8aC5sZW5ndGg7eSsrKXg9aFt5XSxGPXhbeC5sZW5ndGgtMV0sUz14LnN1YnN0cmluZygwLHgubGVuZ3RoLTEpLGs9cGFyc2VJbnQoUywxMCksXz1wYXJzZUZsb2F0KFMpLGcudGVzdChTKSYmRj09PVwid1wiPygoRXx8RCkmJihJPSEwKSxrPT09MD9JPSEwOkU9ayk6cC50ZXN0KFMpJiZGPT09XCJ4XCI/KChFfHxEfHxkKSYmKEk9ITApLF88MD9JPSEwOkQ9Xyk6Zy50ZXN0KFMpJiZGPT09XCJoXCI/KChkfHxEKSYmKEk9ITApLGs9PT0wP0k9ITA6ZD1rKTpJPSEwO0k/aSYmaS5lcnJvciYmaS5lcnJvcihcIkludmFsaWQgc3Jjc2V0IGRlc2NyaXB0b3IgZm91bmQgaW4gJ1wiK3QrXCInIGF0ICdcIit4K1wiJy5cIik6KG8udXJsPWYsRSYmKG8udz1FKSxEJiYoby5kPUQpLGQmJihvLmg9ZCksdi5wdXNoKG8pKX19fSl9fSksV2Q9Wih7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9zeW50YXgtYXR0cmlidXRlLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PVZkKCkse2J1aWxkZXJzOntpZkJyZWFrOnMsam9pbjppLGxpbmU6cn19PUxlKCk7ZnVuY3Rpb24gdShjKXtsZXQgbD10KGMse2xvZ2dlcjp7ZXJyb3IoQil7dGhyb3cgbmV3IEVycm9yKEIpfX19KSxDPWwuc29tZShCPT57bGV0e3d9PUI7cmV0dXJuIHd9KSxtPWwuc29tZShCPT57bGV0e2g6d309QjtyZXR1cm4gd30pLGc9bC5zb21lKEI9PntsZXR7ZDp3fT1CO3JldHVybiB3fSk7aWYoQyttK2c+MSl0aHJvdyBuZXcgRXJyb3IoXCJNaXhlZCBkZXNjcmlwdG9yIGluIHNyY3NldCBpcyBub3Qgc3VwcG9ydGVkXCIpO2xldCBwPUM/XCJ3XCI6bT9cImhcIjpcImRcIixmPUM/XCJ3XCI6bT9cImhcIjpcInhcIixoPUI9Pk1hdGgubWF4KC4uLkIpLE49bC5tYXAoQj0+Qi51cmwpLFQ9aChOLm1hcChCPT5CLmxlbmd0aCkpLEE9bC5tYXAoQj0+QltwXSkubWFwKEI9PkI/Qi50b1N0cmluZygpOlwiXCIpLGI9QS5tYXAoQj0+e2xldCB3PUIuaW5kZXhPZihcIi5cIik7cmV0dXJuIHc9PT0tMT9CLmxlbmd0aDp3fSksdj1oKGIpO3JldHVybiBpKFtcIixcIixyXSxOLm1hcCgoQix3KT0+e2xldCBJPVtCXSxFPUFbd107aWYoRSl7bGV0IEQ9VC1CLmxlbmd0aCsxLGQ9di1iW3ddLHk9XCIgXCIucmVwZWF0KEQrZCk7SS5wdXNoKHMoeSxcIiBcIiksRStmKX1yZXR1cm4gSX0pKX1mdW5jdGlvbiBhKGMpe3JldHVybiBjLnRyaW0oKS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIgXCIpfW4uZXhwb3J0cz17cHJpbnRJbWdTcmNzZXQ6dSxwcmludENsYXNzTmFtZXM6YX19fSksJGQ9Wih7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9zeW50YXgtdnVlLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntidWlsZGVyczp7Z3JvdXA6dH19PUxlKCk7ZnVuY3Rpb24gcyhhLGMpe2xldHtsZWZ0Omwsb3BlcmF0b3I6QyxyaWdodDptfT1pKGEpO3JldHVyblt0KGMoXCJmdW5jdGlvbiBfKFwiLmNvbmNhdChsLFwiKSB7fVwiKSx7cGFyc2VyOlwiYmFiZWxcIixfX2lzVnVlRm9yQmluZGluZ0xlZnQ6ITB9KSksXCIgXCIsQyxcIiBcIixjKG0se3BhcnNlcjpcIl9fanNfZXhwcmVzc2lvblwifSx7c3RyaXBUcmFpbGluZ0hhcmRsaW5lOiEwfSldfWZ1bmN0aW9uIGkoYSl7bGV0IGM9LyguKj8pXFxzKyhpbnxvZilcXHMrKC4qKS9zLGw9LywoW14sXFxdfV0qKSg/OiwoW14sXFxdfV0qKSk/JC8sQz0vXlxcKHxcXCkkL2csbT1hLm1hdGNoKGMpO2lmKCFtKXJldHVybjtsZXQgZz17fTtpZihnLmZvcj1tWzNdLnRyaW0oKSwhZy5mb3IpcmV0dXJuO2xldCBwPW1bMV0udHJpbSgpLnJlcGxhY2UoQyxcIlwiKSxmPXAubWF0Y2gobCk7Zj8oZy5hbGlhcz1wLnJlcGxhY2UobCxcIlwiKSxnLml0ZXJhdG9yMT1mWzFdLnRyaW0oKSxmWzJdJiYoZy5pdGVyYXRvcjI9ZlsyXS50cmltKCkpKTpnLmFsaWFzPXA7bGV0IGg9W2cuYWxpYXMsZy5pdGVyYXRvcjEsZy5pdGVyYXRvcjJdO2lmKCFoLnNvbWUoKE4sVCk9PiFOJiYoVD09PTB8fGguc2xpY2UoVCsxKS5zb21lKEJvb2xlYW4pKSkpcmV0dXJue2xlZnQ6aC5maWx0ZXIoQm9vbGVhbikuam9pbihcIixcIiksb3BlcmF0b3I6bVsyXSxyaWdodDpnLmZvcn19ZnVuY3Rpb24gcihhLGMpe3JldHVybiBjKFwiZnVuY3Rpb24gXyhcIi5jb25jYXQoYSxcIikge31cIikse3BhcnNlcjpcImJhYmVsXCIsX19pc1Z1ZUJpbmRpbmdzOiEwfSl9ZnVuY3Rpb24gdShhKXtsZXQgYz0vXig/OltcXHckXSt8XFwoW14pXSpcXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvLGw9L15bJEEtWl9hLXpdW1xcdyRdKig/OlxcLlskQS1aX2Etel1bXFx3JF0qfFxcWydbXiddKiddfFxcW1wiW15cIl0qXCJdfFxcW1xcZCtdfFxcW1skQS1aX2Etel1bXFx3JF0qXSkqJC8sQz1hLnRyaW0oKTtyZXR1cm4gYy50ZXN0KEMpfHxsLnRlc3QoQyl9bi5leHBvcnRzPXtpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb246dSxwcmludFZ1ZUZvcjpzLHByaW50VnVlQmluZGluZ3M6cn19fSksbW89Wih7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9nZXQtbm9kZS1jb250ZW50LmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntuZWVkc1RvQm9ycm93UGFyZW50Q2xvc2luZ1RhZ1N0YXJ0TWFya2VyOnQscHJpbnRDbG9zaW5nVGFnU3RhcnRNYXJrZXI6cyxuZWVkc1RvQm9ycm93TGFzdENoaWxkQ2xvc2luZ1RhZ0VuZE1hcmtlcjppLHByaW50Q2xvc2luZ1RhZ0VuZE1hcmtlcjpyLG5lZWRzVG9Cb3Jyb3dQYXJlbnRPcGVuaW5nVGFnRW5kTWFya2VyOnUscHJpbnRPcGVuaW5nVGFnRW5kTWFya2VyOmF9PVF0KCk7ZnVuY3Rpb24gYyhsLEMpe2xldCBtPWwuc3RhcnRTb3VyY2VTcGFuLmVuZC5vZmZzZXQ7bC5maXJzdENoaWxkJiZ1KGwuZmlyc3RDaGlsZCkmJihtLT1hKGwpLmxlbmd0aCk7bGV0IGc9bC5lbmRTb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldDtyZXR1cm4gbC5sYXN0Q2hpbGQmJnQobC5sYXN0Q2hpbGQpP2crPXMobCxDKS5sZW5ndGg6aShsKSYmKGctPXIobC5sYXN0Q2hpbGQsQykubGVuZ3RoKSxDLm9yaWdpbmFsVGV4dC5zbGljZShtLGcpfW4uZXhwb3J0cz1jfX0pLEhkPVooe1wic3JjL2xhbmd1YWdlLWh0bWwvZW1iZWQuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2J1aWxkZXJzOnticmVha1BhcmVudDp0LGdyb3VwOnMsaGFyZGxpbmU6aSxpbmRlbnQ6cixsaW5lOnUsZmlsbDphLHNvZnRsaW5lOmN9LHV0aWxzOnttYXBEb2M6bCxyZXBsYWNlVGV4dEVuZE9mTGluZTpDfX09TGUoKSxtPVhuKCkse3ByaW50Q2xvc2luZ1RhZzpnLHByaW50Q2xvc2luZ1RhZ1N1ZmZpeDpwLG5lZWRzVG9Cb3Jyb3dQcmV2Q2xvc2luZ1RhZ0VuZE1hcmtlcjpmLHByaW50T3BlbmluZ1RhZ1ByZWZpeDpoLHByaW50T3BlbmluZ1RhZzpOfT1RdCgpLHtwcmludEltZ1NyY3NldDpULHByaW50Q2xhc3NOYW1lczpBfT1XZCgpLHtwcmludFZ1ZUZvcjpiLHByaW50VnVlQmluZGluZ3M6dixpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb246Qn09JGQoKSx7aXNTY3JpcHRMaWtlVGFnOncsaXNWdWVOb25IdG1sQmxvY2s6SSxpbmZlclNjcmlwdFBhcnNlcjpFLGh0bWxUcmltUHJlc2VydmVJbmRlbnRhdGlvbjpELGRlZGVudFN0cmluZzpkLHVuZXNjYXBlUXVvdGVFbnRpdGllczp5LGlzVnVlU2xvdEF0dHJpYnV0ZTpvLGlzVnVlU2ZjQmluZGluZ3NBdHRyaWJ1dGU6eCxnZXRUZXh0VmFsdWVQYXJ0czpGfT1PdCgpLFM9bW8oKTtmdW5jdGlvbiBrKE8sUixNKXtsZXQgSD1uZT0+bmV3IFJlZ0V4cChuZS5qb2luKFwifFwiKSkudGVzdChPLmZ1bGxOYW1lKSxQPSgpPT55KE8udmFsdWUpLEc9ITEscmU9KG5lLHNlKT0+e2xldCBWPW5lLnR5cGU9PT1cIk5HUm9vdFwiP25lLm5vZGUudHlwZT09PVwiTkdNaWNyb3N5bnRheFwiJiZuZS5ub2RlLmJvZHkubGVuZ3RoPT09MSYmbmUubm9kZS5ib2R5WzBdLnR5cGU9PT1cIk5HTWljcm9zeW50YXhFeHByZXNzaW9uXCI/bmUubm9kZS5ib2R5WzBdLmV4cHJlc3Npb246bmUubm9kZTpuZS50eXBlPT09XCJKc0V4cHJlc3Npb25Sb290XCI/bmUubm9kZTpuZTtWJiYoVi50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCJ8fFYudHlwZT09PVwiQXJyYXlFeHByZXNzaW9uXCJ8fHNlLnBhcnNlcj09PVwiX192dWVfZXhwcmVzc2lvblwiJiYoVi50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcInx8Vi50eXBlPT09XCJTdHJpbmdMaXRlcmFsXCIpKSYmKEc9ITApfSwkPW5lPT5zKG5lKSxXPWZ1bmN0aW9uKG5lKXtsZXQgc2U9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiEwO3JldHVybiBzKFtyKFtjLG5lXSksc2U/YzpcIlwiXSl9LGVlPW5lPT5HPyQobmUpOlcobmUpLFU9KG5lLHNlKT0+UihuZSxPYmplY3QuYXNzaWduKHtfX29uSHRtbEJpbmRpbmdSb290OnJlLF9fZW1iZWRkZWRJbkh0bWw6ITB9LHNlKSk7aWYoTy5mdWxsTmFtZT09PVwic3Jjc2V0XCImJihPLnBhcmVudC5mdWxsTmFtZT09PVwiaW1nXCJ8fE8ucGFyZW50LmZ1bGxOYW1lPT09XCJzb3VyY2VcIikpcmV0dXJuIFcoVChQKCkpKTtpZihPLmZ1bGxOYW1lPT09XCJjbGFzc1wiJiYhTS5wYXJlbnRQYXJzZXIpe2xldCBuZT1QKCk7aWYoIW5lLmluY2x1ZGVzKFwie3tcIikpcmV0dXJuIEEobmUpfWlmKE8uZnVsbE5hbWU9PT1cInN0eWxlXCImJiFNLnBhcmVudFBhcnNlcil7bGV0IG5lPVAoKTtpZighbmUuaW5jbHVkZXMoXCJ7e1wiKSlyZXR1cm4gVyhVKG5lLHtwYXJzZXI6XCJjc3NcIixfX2lzSFRNTFN0eWxlQXR0cmlidXRlOiEwfSkpfWlmKE0ucGFyc2VyPT09XCJ2dWVcIil7aWYoTy5mdWxsTmFtZT09PVwidi1mb3JcIilyZXR1cm4gYihQKCksVSk7aWYobyhPKXx8eChPLE0pKXJldHVybiB2KFAoKSxVKTtsZXQgbmU9W1wiXkBcIixcIl52LW9uOlwiXSxzZT1bXCJeOlwiLFwiXnYtYmluZDpcIl0sVj1bXCJedi1cIl07aWYoSChuZSkpe2xldCBvZT1QKCk7cmV0dXJuIGVlKFUob2Use3BhcnNlcjpCKG9lKT9cIl9fanNfZXhwcmVzc2lvblwiOlwiX192dWVfZXZlbnRfYmluZGluZ1wifSkpfWlmKEgoc2UpKXJldHVybiBlZShVKFAoKSx7cGFyc2VyOlwiX192dWVfZXhwcmVzc2lvblwifSkpO2lmKEgoVikpcmV0dXJuIGVlKFUoUCgpLHtwYXJzZXI6XCJfX2pzX2V4cHJlc3Npb25cIn0pKX1pZihNLnBhcnNlcj09PVwiYW5ndWxhclwiKXtsZXQgbmU9KGxlLHVlKT0+VShsZSxPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdWUpLHt9LHt0cmFpbGluZ0NvbW1hOlwibm9uZVwifSkpLHNlPVtcIl5cXFxcKlwiXSxWPVtcIl5cXFxcKC4rXFxcXCkkXCIsXCJeb24tXCJdLG9lPVtcIl5cXFxcWy4rXFxcXF0kXCIsXCJeYmluZChvbik/LVwiLFwiXm5nLShpZnxzaG93fGhpZGV8Y2xhc3N8c3R5bGUpJFwiXSxLPVtcIl5pMThuKC0uKyk/JFwiXTtpZihIKFYpKXJldHVybiBlZShuZShQKCkse3BhcnNlcjpcIl9fbmdfYWN0aW9uXCJ9KSk7aWYoSChvZSkpcmV0dXJuIGVlKG5lKFAoKSx7cGFyc2VyOlwiX19uZ19iaW5kaW5nXCJ9KSk7aWYoSChLKSl7bGV0IGxlPVAoKS50cmltKCk7cmV0dXJuIFcoYShGKE8sbGUpKSwhbGUuaW5jbHVkZXMoXCJAQFwiKSl9aWYoSChzZSkpcmV0dXJuIGVlKG5lKFAoKSx7cGFyc2VyOlwiX19uZ19kaXJlY3RpdmVcIn0pKTtsZXQgRWU9L3t7KC4rPyl9fS9zLHE9UCgpO2lmKEVlLnRlc3QocSkpe2xldCBsZT1bXTtmb3IobGV0W3VlLFFdb2YgcS5zcGxpdChFZSkuZW50cmllcygpKWlmKHVlJTI9PT0wKWxlLnB1c2goQyhRKSk7ZWxzZSB0cnl7bGUucHVzaChzKFtcInt7XCIscihbdSxuZShRLHtwYXJzZXI6XCJfX25nX2ludGVycG9sYXRpb25cIixfX2lzSW5IdG1sSW50ZXJwb2xhdGlvbjohMH0pXSksdSxcIn19XCJdKSl9Y2F0Y2h7bGUucHVzaChcInt7XCIsQyhRKSxcIn19XCIpfXJldHVybiBzKGxlKX19cmV0dXJuIG51bGx9ZnVuY3Rpb24gXyhPLFIsTSxIKXtsZXQgUD1PLmdldFZhbHVlKCk7c3dpdGNoKFAudHlwZSl7Y2FzZVwiZWxlbWVudFwiOntpZih3KFApfHxQLnR5cGU9PT1cImludGVycG9sYXRpb25cIilyZXR1cm47aWYoIVAuaXNTZWxmQ2xvc2luZyYmSShQLEgpKXtsZXQgRz1FKFAsSCk7aWYoIUcpcmV0dXJuO2xldCByZT1TKFAsSCksJD0vXlxccyokLy50ZXN0KHJlKSxXPVwiXCI7cmV0dXJuICR8fChXPU0oRChyZSkse3BhcnNlcjpHLF9fZW1iZWRkZWRJbkh0bWw6ITB9LHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6ITB9KSwkPVc9PT1cIlwiKSxbaChQLEgpLHMoTihPLEgsUikpLCQ/XCJcIjppLFcsJD9cIlwiOmksZyhQLEgpLHAoUCxIKV19YnJlYWt9Y2FzZVwidGV4dFwiOntpZih3KFAucGFyZW50KSl7bGV0IEc9RShQLnBhcmVudCk7aWYoRyl7bGV0IHJlPUc9PT1cIm1hcmtkb3duXCI/ZChQLnZhbHVlLnJlcGxhY2UoL15bXlxcU1xcbl0qXFxuLyxcIlwiKSk6UC52YWx1ZSwkPXtwYXJzZXI6RyxfX2VtYmVkZGVkSW5IdG1sOiEwfTtpZihILnBhcnNlcj09PVwiaHRtbFwiJiZHPT09XCJiYWJlbFwiKXtsZXQgVz1cInNjcmlwdFwiLHthdHRyTWFwOmVlfT1QLnBhcmVudDtlZSYmKGVlLnR5cGU9PT1cIm1vZHVsZVwifHxlZS50eXBlPT09XCJ0ZXh0L2JhYmVsXCImJmVlW1wiZGF0YS10eXBlXCJdPT09XCJtb2R1bGVcIikmJihXPVwibW9kdWxlXCIpLCQuX19iYWJlbFNvdXJjZVR5cGU9V31yZXR1cm5bdCxoKFAsSCksTShyZSwkLHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6ITB9KSxwKFAsSCldfX1lbHNlIGlmKFAucGFyZW50LnR5cGU9PT1cImludGVycG9sYXRpb25cIil7bGV0IEc9e19faXNJbkh0bWxJbnRlcnBvbGF0aW9uOiEwLF9fZW1iZWRkZWRJbkh0bWw6ITB9O3JldHVybiBILnBhcnNlcj09PVwiYW5ndWxhclwiPyhHLnBhcnNlcj1cIl9fbmdfaW50ZXJwb2xhdGlvblwiLEcudHJhaWxpbmdDb21tYT1cIm5vbmVcIik6SC5wYXJzZXI9PT1cInZ1ZVwiP0cucGFyc2VyPVwiX192dWVfZXhwcmVzc2lvblwiOkcucGFyc2VyPVwiX19qc19leHByZXNzaW9uXCIsW3IoW3UsTShQLnZhbHVlLEcse3N0cmlwVHJhaWxpbmdIYXJkbGluZTohMH0pXSksUC5wYXJlbnQubmV4dCYmZihQLnBhcmVudC5uZXh0KT9cIiBcIjp1XX1icmVha31jYXNlXCJhdHRyaWJ1dGVcIjp7aWYoIVAudmFsdWUpYnJlYWs7aWYoL15QUkVUVElFUl9IVE1MX1BMQUNFSE9MREVSX1xcZCtfXFxkK19JTl9KUyQvLnRlc3QoSC5vcmlnaW5hbFRleHQuc2xpY2UoUC52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0LFAudmFsdWVTcGFuLmVuZC5vZmZzZXQpKSlyZXR1cm5bUC5yYXdOYW1lLFwiPVwiLFAudmFsdWVdO2lmKEgucGFyc2VyPT09XCJsd2NcIiYmL157Lip9JC9zLnRlc3QoSC5vcmlnaW5hbFRleHQuc2xpY2UoUC52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0LFAudmFsdWVTcGFuLmVuZC5vZmZzZXQpKSlyZXR1cm5bUC5yYXdOYW1lLFwiPVwiLFAudmFsdWVdO2xldCBHPWsoUCwocmUsJCk9Pk0ocmUsT2JqZWN0LmFzc2lnbih7X19pc0luSHRtbEF0dHJpYnV0ZTohMCxfX2VtYmVkZGVkSW5IdG1sOiEwfSwkKSx7c3RyaXBUcmFpbGluZ0hhcmRsaW5lOiEwfSksSCk7aWYoRylyZXR1cm5bUC5yYXdOYW1lLCc9XCInLHMobChHLHJlPT50eXBlb2YgcmU9PVwic3RyaW5nXCI/cmUucmVwbGFjZSgvXCIvZyxcIiZxdW90O1wiKTpyZSkpLCdcIiddO2JyZWFrfWNhc2VcImZyb250LW1hdHRlclwiOnJldHVybiBtKFAsTSl9fW4uZXhwb3J0cz1ffX0pLGdvPVooe1wic3JjL2xhbmd1YWdlLWh0bWwvcHJpbnQvY2hpbGRyZW4uanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2J1aWxkZXJzOnticmVha1BhcmVudDp0LGdyb3VwOnMsaWZCcmVhazppLGxpbmU6cixzb2Z0bGluZTp1LGhhcmRsaW5lOmF9LHV0aWxzOntyZXBsYWNlVGV4dEVuZE9mTGluZTpjfX09TGUoKSx7bG9jU3RhcnQ6bCxsb2NFbmQ6Q309WW4oKSx7Zm9yY2VCcmVha0NoaWxkcmVuOm0sZm9yY2VOZXh0RW1wdHlMaW5lOmcsaXNUZXh0TGlrZU5vZGU6cCxoYXNQcmV0dGllcklnbm9yZTpmLHByZWZlckhhcmRsaW5lQXNMZWFkaW5nU3BhY2VzOmh9PU90KCkse3ByaW50T3BlbmluZ1RhZ1ByZWZpeDpOLG5lZWRzVG9Cb3Jyb3dOZXh0T3BlbmluZ1RhZ1N0YXJ0TWFya2VyOlQscHJpbnRPcGVuaW5nVGFnU3RhcnRNYXJrZXI6QSxuZWVkc1RvQm9ycm93UHJldkNsb3NpbmdUYWdFbmRNYXJrZXI6YixwcmludENsb3NpbmdUYWdFbmRNYXJrZXI6dixwcmludENsb3NpbmdUYWdTdWZmaXg6QixuZWVkc1RvQm9ycm93UGFyZW50Q2xvc2luZ1RhZ1N0YXJ0TWFya2VyOnd9PVF0KCk7ZnVuY3Rpb24gSShkLHksbyl7bGV0IHg9ZC5nZXRWYWx1ZSgpO3JldHVybiBmKHgpP1tOKHgseSksLi4uYyh5Lm9yaWdpbmFsVGV4dC5zbGljZShsKHgpKyh4LnByZXYmJlQoeC5wcmV2KT9BKHgpLmxlbmd0aDowKSxDKHgpLSh4Lm5leHQmJmIoeC5uZXh0KT92KHgseSkubGVuZ3RoOjApKSksQih4LHkpXTpvKCl9ZnVuY3Rpb24gRShkLHkpe3JldHVybiBwKGQpJiZwKHkpP2QuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlP2QuaGFzVHJhaWxpbmdTcGFjZXM/aCh5KT9hOnI6XCJcIjpoKHkpP2E6dTpUKGQpJiYoZih5KXx8eS5maXJzdENoaWxkfHx5LmlzU2VsZkNsb3Npbmd8fHkudHlwZT09PVwiZWxlbWVudFwiJiZ5LmF0dHJzLmxlbmd0aD4wKXx8ZC50eXBlPT09XCJlbGVtZW50XCImJmQuaXNTZWxmQ2xvc2luZyYmYih5KT9cIlwiOiF5LmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlfHxoKHkpfHxiKHkpJiZkLmxhc3RDaGlsZCYmdyhkLmxhc3RDaGlsZCkmJmQubGFzdENoaWxkLmxhc3RDaGlsZCYmdyhkLmxhc3RDaGlsZC5sYXN0Q2hpbGQpP2E6eS5oYXNMZWFkaW5nU3BhY2VzP3I6dX1mdW5jdGlvbiBEKGQseSxvKXtsZXQgeD1kLmdldFZhbHVlKCk7aWYobSh4KSlyZXR1cm5bdCwuLi5kLm1hcChTPT57bGV0IGs9Uy5nZXRWYWx1ZSgpLF89ay5wcmV2P0Uoay5wcmV2LGspOlwiXCI7cmV0dXJuW18/W18sZyhrLnByZXYpP2E6XCJcIl06XCJcIixJKFMseSxvKV19LFwiY2hpbGRyZW5cIildO2xldCBGPXguY2hpbGRyZW4ubWFwKCgpPT5TeW1ib2woXCJcIikpO3JldHVybiBkLm1hcCgoUyxrKT0+e2xldCBfPVMuZ2V0VmFsdWUoKTtpZihwKF8pKXtpZihfLnByZXYmJnAoXy5wcmV2KSl7bGV0IHJlPUUoXy5wcmV2LF8pO2lmKHJlKXJldHVybiBnKF8ucHJldik/W2EsYSxJKFMseSxvKV06W3JlLEkoUyx5LG8pXX1yZXR1cm4gSShTLHksbyl9bGV0IE89W10sUj1bXSxNPVtdLEg9W10sUD1fLnByZXY/RShfLnByZXYsXyk6XCJcIixHPV8ubmV4dD9FKF8sXy5uZXh0KTpcIlwiO3JldHVybiBQJiYoZyhfLnByZXYpP08ucHVzaChhLGEpOlA9PT1hP08ucHVzaChhKTpwKF8ucHJldik/Ui5wdXNoKFApOlIucHVzaChpKFwiXCIsdSx7Z3JvdXBJZDpGW2stMV19KSkpLEcmJihnKF8pP3AoXy5uZXh0KSYmSC5wdXNoKGEsYSk6Rz09PWE/cChfLm5leHQpJiZILnB1c2goYSk6TS5wdXNoKEcpKSxbLi4uTyxzKFsuLi5SLHMoW0koUyx5LG8pLC4uLk1dLHtpZDpGW2tdfSldKSwuLi5IXX0sXCJjaGlsZHJlblwiKX1uLmV4cG9ydHM9e3ByaW50Q2hpbGRyZW46RH19fSksR2Q9Wih7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9wcmludC9lbGVtZW50LmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntidWlsZGVyczp7YnJlYWtQYXJlbnQ6dCxkZWRlbnRUb1Jvb3Q6cyxncm91cDppLGlmQnJlYWs6cixpbmRlbnRJZkJyZWFrOnUsaW5kZW50OmEsbGluZTpjLHNvZnRsaW5lOmx9LHV0aWxzOntyZXBsYWNlVGV4dEVuZE9mTGluZTpDfX09TGUoKSxtPW1vKCkse3Nob3VsZFByZXNlcnZlQ29udGVudDpnLGlzU2NyaXB0TGlrZVRhZzpwLGlzVnVlQ3VzdG9tQmxvY2s6Zixjb3VudFBhcmVudHM6aCxmb3JjZUJyZWFrQ29udGVudDpOfT1PdCgpLHtwcmludE9wZW5pbmdUYWdQcmVmaXg6VCxwcmludE9wZW5pbmdUYWc6QSxwcmludENsb3NpbmdUYWdTdWZmaXg6YixwcmludENsb3NpbmdUYWc6dixuZWVkc1RvQm9ycm93UHJldkNsb3NpbmdUYWdFbmRNYXJrZXI6QixuZWVkc1RvQm9ycm93TGFzdENoaWxkQ2xvc2luZ1RhZ0VuZE1hcmtlcjp3fT1RdCgpLHtwcmludENoaWxkcmVuOkl9PWdvKCk7ZnVuY3Rpb24gRShELGQseSl7bGV0IG89RC5nZXRWYWx1ZSgpO2lmKGcobyxkKSlyZXR1cm5bVChvLGQpLGkoQShELGQseSkpLC4uLkMobShvLGQpKSwuLi52KG8sZCksYihvLGQpXTtsZXQgeD1vLmNoaWxkcmVuLmxlbmd0aD09PTEmJm8uZmlyc3RDaGlsZC50eXBlPT09XCJpbnRlcnBvbGF0aW9uXCImJm8uZmlyc3RDaGlsZC5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZSYmIW8uZmlyc3RDaGlsZC5oYXNMZWFkaW5nU3BhY2VzJiZvLmxhc3RDaGlsZC5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUmJiFvLmxhc3RDaGlsZC5oYXNUcmFpbGluZ1NwYWNlcyxGPVN5bWJvbChcImVsZW1lbnQtYXR0ci1ncm91cC1pZFwiKSxTPVI9PmkoW2koQShELGQseSkse2lkOkZ9KSxSLHYobyxkKV0pLGs9Uj0+eD91KFIse2dyb3VwSWQ6Rn0pOihwKG8pfHxmKG8sZCkpJiZvLnBhcmVudC50eXBlPT09XCJyb290XCImJmQucGFyc2VyPT09XCJ2dWVcIiYmIWQudnVlSW5kZW50U2NyaXB0QW5kU3R5bGU/UjphKFIpLF89KCk9Png/cihsLFwiXCIse2dyb3VwSWQ6Rn0pOm8uZmlyc3RDaGlsZC5oYXNMZWFkaW5nU3BhY2VzJiZvLmZpcnN0Q2hpbGQuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmU/YzpvLmZpcnN0Q2hpbGQudHlwZT09PVwidGV4dFwiJiZvLmlzV2hpdGVzcGFjZVNlbnNpdGl2ZSYmby5pc0luZGVudGF0aW9uU2Vuc2l0aXZlP3MobCk6bCxPPSgpPT4oby5uZXh0P0Ioby5uZXh0KTp3KG8ucGFyZW50KSk/by5sYXN0Q2hpbGQuaGFzVHJhaWxpbmdTcGFjZXMmJm8ubGFzdENoaWxkLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZT9cIiBcIjpcIlwiOng/cihsLFwiXCIse2dyb3VwSWQ6Rn0pOm8ubGFzdENoaWxkLmhhc1RyYWlsaW5nU3BhY2VzJiZvLmxhc3RDaGlsZC5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmU/Yzooby5sYXN0Q2hpbGQudHlwZT09PVwiY29tbWVudFwifHxvLmxhc3RDaGlsZC50eXBlPT09XCJ0ZXh0XCImJm8uaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlJiZvLmlzSW5kZW50YXRpb25TZW5zaXRpdmUpJiZuZXcgUmVnRXhwKFwiXFxcXG5bXFxcXHQgXXtcIi5jb25jYXQoZC50YWJXaWR0aCpoKEQsTT0+TS5wYXJlbnQmJk0ucGFyZW50LnR5cGUhPT1cInJvb3RcIiksXCJ9JFwiKSkudGVzdChvLmxhc3RDaGlsZC52YWx1ZSk/XCJcIjpsO3JldHVybiBvLmNoaWxkcmVuLmxlbmd0aD09PTA/UyhvLmhhc0RhbmdsaW5nU3BhY2VzJiZvLmlzRGFuZ2xpbmdTcGFjZVNlbnNpdGl2ZT9jOlwiXCIpOlMoW04obyk/dDpcIlwiLGsoW18oKSxJKEQsZCx5KV0pLE8oKV0pfW4uZXhwb3J0cz17cHJpbnRFbGVtZW50OkV9fX0pLEpkPVooe1wic3JjL2xhbmd1YWdlLWh0bWwvcHJpbnRlci1odG1sLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntidWlsZGVyczp7ZmlsbDp0LGdyb3VwOnMsaGFyZGxpbmU6aSxsaXRlcmFsbGluZTpyfSx1dGlsczp7Y2xlYW5Eb2M6dSxnZXREb2NQYXJ0czphLGlzQ29uY2F0OmMscmVwbGFjZVRleHRFbmRPZkxpbmU6bH19PUxlKCksQz1fZCgpLHtjb3VudENoYXJzOm0sdW5lc2NhcGVRdW90ZUVudGl0aWVzOmcsZ2V0VGV4dFZhbHVlUGFydHM6cH09T3QoKSxmPU1kKCkse2luc2VydFByYWdtYTpofT1SZCgpLHtsb2NTdGFydDpOLGxvY0VuZDpUfT1ZbigpLEE9SGQoKSx7cHJpbnRDbG9zaW5nVGFnU3VmZml4OmIscHJpbnRDbG9zaW5nVGFnRW5kOnYscHJpbnRPcGVuaW5nVGFnUHJlZml4OkIscHJpbnRPcGVuaW5nVGFnU3RhcnQ6d309UXQoKSx7cHJpbnRFbGVtZW50Okl9PUdkKCkse3ByaW50Q2hpbGRyZW46RX09Z28oKTtmdW5jdGlvbiBEKGQseSxvKXtsZXQgeD1kLmdldFZhbHVlKCk7c3dpdGNoKHgudHlwZSl7Y2FzZVwiZnJvbnQtbWF0dGVyXCI6cmV0dXJuIGwoeC5yYXcpO2Nhc2VcInJvb3RcIjpyZXR1cm4geS5fX29uSHRtbFJvb3QmJnkuX19vbkh0bWxSb290KHgpLFtzKEUoZCx5LG8pKSxpXTtjYXNlXCJlbGVtZW50XCI6Y2FzZVwiaWVDb25kaXRpb25hbENvbW1lbnRcIjpyZXR1cm4gSShkLHksbyk7Y2FzZVwiaWVDb25kaXRpb25hbFN0YXJ0Q29tbWVudFwiOmNhc2VcImllQ29uZGl0aW9uYWxFbmRDb21tZW50XCI6cmV0dXJuW3coeCksdih4KV07Y2FzZVwiaW50ZXJwb2xhdGlvblwiOnJldHVyblt3KHgseSksLi4uZC5tYXAobyxcImNoaWxkcmVuXCIpLHYoeCx5KV07Y2FzZVwidGV4dFwiOntpZih4LnBhcmVudC50eXBlPT09XCJpbnRlcnBvbGF0aW9uXCIpe2xldCBTPS9cXG5bXlxcU1xcbl0qJC8saz1TLnRlc3QoeC52YWx1ZSksXz1rP3gudmFsdWUucmVwbGFjZShTLFwiXCIpOngudmFsdWU7cmV0dXJuWy4uLmwoXyksaz9pOlwiXCJdfWxldCBGPXUoW0IoeCx5KSwuLi5wKHgpLGIoeCx5KV0pO3JldHVybiBjKEYpfHxGLnR5cGU9PT1cImZpbGxcIj90KGEoRikpOkZ9Y2FzZVwiZG9jVHlwZVwiOnJldHVybltzKFt3KHgseSksXCIgXCIseC52YWx1ZS5yZXBsYWNlKC9eaHRtbFxcYi9pLFwiaHRtbFwiKS5yZXBsYWNlKC9cXHMrL2csXCIgXCIpXSksdih4LHkpXTtjYXNlXCJjb21tZW50XCI6cmV0dXJuW0IoeCx5KSwuLi5sKHkub3JpZ2luYWxUZXh0LnNsaWNlKE4oeCksVCh4KSksciksYih4LHkpXTtjYXNlXCJhdHRyaWJ1dGVcIjp7aWYoeC52YWx1ZT09PW51bGwpcmV0dXJuIHgucmF3TmFtZTtsZXQgRj1nKHgudmFsdWUpLFM9bShGLFwiJ1wiKSxrPW0oRiwnXCInKSxfPVM8az9cIidcIjonXCInO3JldHVyblt4LnJhd05hbWUsXCI9XCIsXywuLi5sKF89PT0nXCInP0YucmVwbGFjZSgvXCIvZyxcIiZxdW90O1wiKTpGLnJlcGxhY2UoLycvZyxcIiZhcG9zO1wiKSksX119ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIi5jb25jYXQoeC50eXBlKSl9fW4uZXhwb3J0cz17cHJlcHJvY2VzczpmLHByaW50OkQsaW5zZXJ0UHJhZ21hOmgsbWFzc2FnZUFzdE5vZGU6QyxlbWJlZDpBfX19KSxVZD1aKHtcInNyYy9sYW5ndWFnZS1odG1sL29wdGlvbnMuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFyIHQ9THQoKSxzPVwiSFRNTFwiO24uZXhwb3J0cz17YnJhY2tldFNhbWVMaW5lOnQuYnJhY2tldFNhbWVMaW5lLGh0bWxXaGl0ZXNwYWNlU2Vuc2l0aXZpdHk6e3NpbmNlOlwiMS4xNS4wXCIsY2F0ZWdvcnk6cyx0eXBlOlwiY2hvaWNlXCIsZGVmYXVsdDpcImNzc1wiLGRlc2NyaXB0aW9uOlwiSG93IHRvIGhhbmRsZSB3aGl0ZXNwYWNlcyBpbiBIVE1MLlwiLGNob2ljZXM6W3t2YWx1ZTpcImNzc1wiLGRlc2NyaXB0aW9uOlwiUmVzcGVjdCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBDU1MgZGlzcGxheSBwcm9wZXJ0eS5cIn0se3ZhbHVlOlwic3RyaWN0XCIsZGVzY3JpcHRpb246XCJXaGl0ZXNwYWNlcyBhcmUgY29uc2lkZXJlZCBzZW5zaXRpdmUuXCJ9LHt2YWx1ZTpcImlnbm9yZVwiLGRlc2NyaXB0aW9uOlwiV2hpdGVzcGFjZXMgYXJlIGNvbnNpZGVyZWQgaW5zZW5zaXRpdmUuXCJ9XX0sc2luZ2xlQXR0cmlidXRlUGVyTGluZTp0LnNpbmdsZUF0dHJpYnV0ZVBlckxpbmUsdnVlSW5kZW50U2NyaXB0QW5kU3R5bGU6e3NpbmNlOlwiMS4xOS4wXCIsY2F0ZWdvcnk6cyx0eXBlOlwiYm9vbGVhblwiLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJJbmRlbnQgc2NyaXB0IGFuZCBzdHlsZSB0YWdzIGluIFZ1ZSBmaWxlcy5cIn19fX0pLHpkPVooe1wic3JjL2xhbmd1YWdlLWh0bWwvcGFyc2Vycy5qc1wiKCl7YWUoKX19KSxBbj1aKHtcIm5vZGVfbW9kdWxlcy9saW5ndWlzdC1sYW5ndWFnZXMvZGF0YS9IVE1MLmpzb25cIihlLG4pe24uZXhwb3J0cz17bmFtZTpcIkhUTUxcIix0eXBlOlwibWFya3VwXCIsdG1TY29wZTpcInRleHQuaHRtbC5iYXNpY1wiLGFjZU1vZGU6XCJodG1sXCIsY29kZW1pcnJvck1vZGU6XCJodG1sbWl4ZWRcIixjb2RlbWlycm9yTWltZVR5cGU6XCJ0ZXh0L2h0bWxcIixjb2xvcjpcIiNlMzRjMjZcIixhbGlhc2VzOltcInhodG1sXCJdLGV4dGVuc2lvbnM6W1wiLmh0bWxcIixcIi5odG1cIixcIi5odG1sLmhsXCIsXCIuaW5jXCIsXCIueGh0XCIsXCIueGh0bWxcIl0sbGFuZ3VhZ2VJZDoxNDZ9fX0pLFhkPVooe1wibm9kZV9tb2R1bGVzL2xpbmd1aXN0LWxhbmd1YWdlcy9kYXRhL1Z1ZS5qc29uXCIoZSxuKXtuLmV4cG9ydHM9e25hbWU6XCJWdWVcIix0eXBlOlwibWFya3VwXCIsY29sb3I6XCIjNDFiODgzXCIsZXh0ZW5zaW9uczpbXCIudnVlXCJdLHRtU2NvcGU6XCJ0ZXh0Lmh0bWwudnVlXCIsYWNlTW9kZTpcImh0bWxcIixsYW5ndWFnZUlkOjM5MX19fSksS2Q9Wih7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9pbmRleC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXIgdD1idCgpLHM9SmQoKSxpPVVkKCkscj16ZCgpLHU9W3QoQW4oKSwoKT0+KHtuYW1lOlwiQW5ndWxhclwiLHNpbmNlOlwiMS4xNS4wXCIscGFyc2VyczpbXCJhbmd1bGFyXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcImh0bWxcIl0sZXh0ZW5zaW9uczpbXCIuY29tcG9uZW50Lmh0bWxcIl0sZmlsZW5hbWVzOltdfSkpLHQoQW4oKSxjPT4oe3NpbmNlOlwiMS4xNS4wXCIscGFyc2VyczpbXCJodG1sXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcImh0bWxcIl0sZXh0ZW5zaW9uczpbLi4uYy5leHRlbnNpb25zLFwiLm1qbWxcIl19KSksdChBbigpLCgpPT4oe25hbWU6XCJMaWdodG5pbmcgV2ViIENvbXBvbmVudHNcIixzaW5jZTpcIjEuMTcuMFwiLHBhcnNlcnM6W1wibHdjXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcImh0bWxcIl0sZXh0ZW5zaW9uczpbXSxmaWxlbmFtZXM6W119KSksdChYZCgpLCgpPT4oe3NpbmNlOlwiMS4xMC4wXCIscGFyc2VyczpbXCJ2dWVcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1widnVlXCJdfSkpXSxhPXtodG1sOnN9O24uZXhwb3J0cz17bGFuZ3VhZ2VzOnUscHJpbnRlcnM6YSxvcHRpb25zOmkscGFyc2VyczpyfX19KSxZZD1aKHtcInNyYy9sYW5ndWFnZS15YW1sL3ByYWdtYS5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KHIpe3JldHVybi9eXFxzKkAoPzpwcmV0dGllcnxmb3JtYXQpXFxzKiQvLnRlc3Qocil9ZnVuY3Rpb24gcyhyKXtyZXR1cm4vXlxccyojW15cXFNcXG5dKkAoPzpwcmV0dGllcnxmb3JtYXQpXFxzKj8oPzpcXG58JCkvLnRlc3Qocil9ZnVuY3Rpb24gaShyKXtyZXR1cm5gIyBAZm9ybWF0XG5cbmAuY29uY2F0KHIpfW4uZXhwb3J0cz17aXNQcmFnbWE6dCxoYXNQcmFnbWE6cyxpbnNlcnRQcmFnbWE6aX19fSksUWQ9Wih7XCJzcmMvbGFuZ3VhZ2UteWFtbC9sb2MuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7ZnVuY3Rpb24gdChpKXtyZXR1cm4gaS5wb3NpdGlvbi5zdGFydC5vZmZzZXR9ZnVuY3Rpb24gcyhpKXtyZXR1cm4gaS5wb3NpdGlvbi5lbmQub2Zmc2V0fW4uZXhwb3J0cz17bG9jU3RhcnQ6dCxsb2NFbmQ6c319fSksWmQ9Wih7XCJzcmMvbGFuZ3VhZ2UteWFtbC9lbWJlZC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTtmdW5jdGlvbiB0KHMsaSxyLHUpe2lmKHMuZ2V0VmFsdWUoKS50eXBlPT09XCJyb290XCImJnUuZmlsZXBhdGgmJi8oPzpbL1xcXFxdfF4pXFwuKD86cHJldHRpZXJ8c3R5bGVsaW50KXJjJC8udGVzdCh1LmZpbGVwYXRoKSlyZXR1cm4gcih1Lm9yaWdpbmFsVGV4dCxPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse30se3BhcnNlcjpcImpzb25cIn0pKX1uLmV4cG9ydHM9dH19KSxqdD1aKHtcInNyYy9sYW5ndWFnZS15YW1sL3V0aWxzLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntnZXRMYXN0OnQsaXNOb25FbXB0eUFycmF5OnN9PUdlKCk7ZnVuY3Rpb24gaShFLEQpe2xldCBkPTAseT1FLnN0YWNrLmxlbmd0aC0xO2ZvcihsZXQgbz0wO288eTtvKyspe2xldCB4PUUuc3RhY2tbb107cih4KSYmRCh4KSYmZCsrfXJldHVybiBkfWZ1bmN0aW9uIHIoRSxEKXtyZXR1cm4gRSYmdHlwZW9mIEUudHlwZT09XCJzdHJpbmdcIiYmKCFEfHxELmluY2x1ZGVzKEUudHlwZSkpfWZ1bmN0aW9uIHUoRSxELGQpe3JldHVybiBEKFwiY2hpbGRyZW5cImluIEU/T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LEUpLHt9LHtjaGlsZHJlbjpFLmNoaWxkcmVuLm1hcCh5PT51KHksRCxFKSl9KTpFLGQpfWZ1bmN0aW9uIGEoRSxELGQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLEQse2dldDpkLGVudW1lcmFibGU6ITF9KX1mdW5jdGlvbiBjKEUsRCl7bGV0IGQ9MCx5PUQubGVuZ3RoO2ZvcihsZXQgbz1FLnBvc2l0aW9uLmVuZC5vZmZzZXQtMTtvPHk7bysrKXtsZXQgeD1EW29dO2lmKHg9PT1gXG5gJiZkKyssZD09PTEmJi9cXFMvLnRlc3QoeCkpcmV0dXJuITE7aWYoZD09PTIpcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gbChFKXtzd2l0Y2goRS5nZXRWYWx1ZSgpLnR5cGUpe2Nhc2VcInRhZ1wiOmNhc2VcImFuY2hvclwiOmNhc2VcImNvbW1lbnRcIjpyZXR1cm4hMX1sZXQgZD1FLnN0YWNrLmxlbmd0aDtmb3IobGV0IHk9MTt5PGQ7eSsrKXtsZXQgbz1FLnN0YWNrW3ldLHg9RS5zdGFja1t5LTFdO2lmKEFycmF5LmlzQXJyYXkoeCkmJnR5cGVvZiBvPT1cIm51bWJlclwiJiZvIT09eC5sZW5ndGgtMSlyZXR1cm4hMX1yZXR1cm4hMH1mdW5jdGlvbiBDKEUpe3JldHVybiBzKEUuY2hpbGRyZW4pP0ModChFLmNoaWxkcmVuKSk6RX1mdW5jdGlvbiBtKEUpe3JldHVybiBFLnZhbHVlLnRyaW0oKT09PVwicHJldHRpZXItaWdub3JlXCJ9ZnVuY3Rpb24gZyhFKXtsZXQgRD1FLmdldFZhbHVlKCk7aWYoRC50eXBlPT09XCJkb2N1bWVudEJvZHlcIil7bGV0IGQ9RS5nZXRQYXJlbnROb2RlKCk7cmV0dXJuIGIoZC5oZWFkKSYmbSh0KGQuaGVhZC5lbmRDb21tZW50cykpfXJldHVybiBoKEQpJiZtKHQoRC5sZWFkaW5nQ29tbWVudHMpKX1mdW5jdGlvbiBwKEUpe3JldHVybiFzKEUuY2hpbGRyZW4pJiYhZihFKX1mdW5jdGlvbiBmKEUpe3JldHVybiBoKEUpfHxOKEUpfHxUKEUpfHxBKEUpfHxiKEUpfWZ1bmN0aW9uIGgoRSl7cmV0dXJuIEUmJnMoRS5sZWFkaW5nQ29tbWVudHMpfWZ1bmN0aW9uIE4oRSl7cmV0dXJuIEUmJnMoRS5taWRkbGVDb21tZW50cyl9ZnVuY3Rpb24gVChFKXtyZXR1cm4gRSYmRS5pbmRpY2F0b3JDb21tZW50fWZ1bmN0aW9uIEEoRSl7cmV0dXJuIEUmJkUudHJhaWxpbmdDb21tZW50fWZ1bmN0aW9uIGIoRSl7cmV0dXJuIEUmJnMoRS5lbmRDb21tZW50cyl9ZnVuY3Rpb24gdihFKXtsZXQgRD1bXSxkO2ZvcihsZXQgeSBvZiBFLnNwbGl0KC8oICspLykpeSE9PVwiIFwiP2Q9PT1cIiBcIj9ELnB1c2goeSk6RC5wdXNoKChELnBvcCgpfHxcIlwiKSt5KTpkPT09dm9pZCAwJiZELnVuc2hpZnQoXCJcIiksZD15O3JldHVybiBkPT09XCIgXCImJkQucHVzaCgoRC5wb3AoKXx8XCJcIikrXCIgXCIpLERbMF09PT1cIlwiJiYoRC5zaGlmdCgpLEQudW5zaGlmdChcIiBcIisoRC5zaGlmdCgpfHxcIlwiKSkpLER9ZnVuY3Rpb24gQihFLEQsZCl7bGV0IHk9RC5zcGxpdChgXG5gKS5tYXAoKG8seCxGKT0+eD09PTAmJng9PT1GLmxlbmd0aC0xP286eCE9PTAmJnghPT1GLmxlbmd0aC0xP28udHJpbSgpOng9PT0wP28udHJpbUVuZCgpOm8udHJpbVN0YXJ0KCkpO3JldHVybiBkLnByb3NlV3JhcD09PVwicHJlc2VydmVcIj95Lm1hcChvPT5vLmxlbmd0aD09PTA/W106W29dKTp5Lm1hcChvPT5vLmxlbmd0aD09PTA/W106dihvKSkucmVkdWNlKChvLHgsRik9PkYhPT0wJiZ5W0YtMV0ubGVuZ3RoPjAmJngubGVuZ3RoPjAmJiEoRT09PVwicXVvdGVEb3VibGVcIiYmdCh0KG8pKS5lbmRzV2l0aChcIlxcXFxcIikpP1suLi5vLnNsaWNlKDAsLTEpLFsuLi50KG8pLC4uLnhdXTpbLi4ubyx4XSxbXSkubWFwKG89PmQucHJvc2VXcmFwPT09XCJuZXZlclwiP1tvLmpvaW4oXCIgXCIpXTpvKX1mdW5jdGlvbiB3KEUsRCl7bGV0e3BhcmVudEluZGVudDpkLGlzTGFzdERlc2NlbmRhbnQ6eSxvcHRpb25zOm99PUQseD1FLnBvc2l0aW9uLnN0YXJ0LmxpbmU9PT1FLnBvc2l0aW9uLmVuZC5saW5lP1wiXCI6by5vcmlnaW5hbFRleHQuc2xpY2UoRS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsRS5wb3NpdGlvbi5lbmQub2Zmc2V0KS5tYXRjaCgvXlteXFxuXSpcXG4oLiopJC9zKVsxXSxGO2lmKEUuaW5kZW50PT09bnVsbCl7bGV0IF89eC5tYXRjaCgvXig/PGxlYWRpbmdTcGFjZT4gKilbXlxcblxcciBdL20pO0Y9Xz9fLmdyb3Vwcy5sZWFkaW5nU3BhY2UubGVuZ3RoOk51bWJlci5QT1NJVElWRV9JTkZJTklUWX1lbHNlIEY9RS5pbmRlbnQtMStkO2xldCBTPXguc3BsaXQoYFxuYCkubWFwKF89Pl8uc2xpY2UoRikpO2lmKG8ucHJvc2VXcmFwPT09XCJwcmVzZXJ2ZVwifHxFLnR5cGU9PT1cImJsb2NrTGl0ZXJhbFwiKXJldHVybiBrKFMubWFwKF89Pl8ubGVuZ3RoPT09MD9bXTpbX10pKTtyZXR1cm4gayhTLm1hcChfPT5fLmxlbmd0aD09PTA/W106dihfKSkucmVkdWNlKChfLE8sUik9PlIhPT0wJiZTW1ItMV0ubGVuZ3RoPjAmJk8ubGVuZ3RoPjAmJiEvXlxccy8udGVzdChPWzBdKSYmIS9eXFxzfFxccyQvLnRlc3QodChfKSk/Wy4uLl8uc2xpY2UoMCwtMSksWy4uLnQoXyksLi4uT11dOlsuLi5fLE9dLFtdKS5tYXAoXz0+Xy5yZWR1Y2UoKE8sUik9Pk8ubGVuZ3RoPjAmJi9cXHMkLy50ZXN0KHQoTykpP1suLi5PLnNsaWNlKDAsLTEpLHQoTykrXCIgXCIrUl06Wy4uLk8sUl0sW10pKS5tYXAoXz0+by5wcm9zZVdyYXA9PT1cIm5ldmVyXCI/W18uam9pbihcIiBcIildOl8pKTtmdW5jdGlvbiBrKF8pe2lmKEUuY2hvbXBpbmc9PT1cImtlZXBcIilyZXR1cm4gdChfKS5sZW5ndGg9PT0wP18uc2xpY2UoMCwtMSk6XztsZXQgTz0wO2ZvcihsZXQgUj1fLmxlbmd0aC0xO1I+PTAmJl9bUl0ubGVuZ3RoPT09MDtSLS0pTysrO3JldHVybiBPPT09MD9fOk8+PTImJiF5P18uc2xpY2UoMCwtKE8tMSkpOl8uc2xpY2UoMCwtTyl9fWZ1bmN0aW9uIEkoRSl7aWYoIUUpcmV0dXJuITA7c3dpdGNoKEUudHlwZSl7Y2FzZVwicGxhaW5cIjpjYXNlXCJxdW90ZURvdWJsZVwiOmNhc2VcInF1b3RlU2luZ2xlXCI6Y2FzZVwiYWxpYXNcIjpjYXNlXCJmbG93TWFwcGluZ1wiOmNhc2VcImZsb3dTZXF1ZW5jZVwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fW4uZXhwb3J0cz17Z2V0TGFzdDp0LGdldEFuY2VzdG9yQ291bnQ6aSxpc05vZGU6cixpc0VtcHR5Tm9kZTpwLGlzSW5saW5lTm9kZTpJLG1hcE5vZGU6dSxkZWZpbmVTaG9ydGN1dDphLGlzTmV4dExpbmVFbXB0eTpjLGlzTGFzdERlc2NlbmRhbnROb2RlOmwsZ2V0QmxvY2tWYWx1ZUxpbmVDb250ZW50czp3LGdldEZsb3dTY2FsYXJMaW5lQ29udGVudHM6QixnZXRMYXN0RGVzY2VuZGFudE5vZGU6QyxoYXNQcmV0dGllcklnbm9yZTpnLGhhc0xlYWRpbmdDb21tZW50czpoLGhhc01pZGRsZUNvbW1lbnRzOk4saGFzSW5kaWNhdG9yQ29tbWVudDpULGhhc1RyYWlsaW5nQ29tbWVudDpBLGhhc0VuZENvbW1lbnRzOmJ9fX0pLGVnPVooe1wic3JjL2xhbmd1YWdlLXlhbWwvcHJpbnQtcHJlcHJvY2Vzcy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7ZGVmaW5lU2hvcnRjdXQ6dCxtYXBOb2RlOnN9PWp0KCk7ZnVuY3Rpb24gaSh1KXtyZXR1cm4gcyh1LHIpfWZ1bmN0aW9uIHIodSl7c3dpdGNoKHUudHlwZSl7Y2FzZVwiZG9jdW1lbnRcIjp0KHUsXCJoZWFkXCIsKCk9PnUuY2hpbGRyZW5bMF0pLHQodSxcImJvZHlcIiwoKT0+dS5jaGlsZHJlblsxXSk7YnJlYWs7Y2FzZVwiZG9jdW1lbnRCb2R5XCI6Y2FzZVwic2VxdWVuY2VJdGVtXCI6Y2FzZVwiZmxvd1NlcXVlbmNlSXRlbVwiOmNhc2VcIm1hcHBpbmdLZXlcIjpjYXNlXCJtYXBwaW5nVmFsdWVcIjp0KHUsXCJjb250ZW50XCIsKCk9PnUuY2hpbGRyZW5bMF0pO2JyZWFrO2Nhc2VcIm1hcHBpbmdJdGVtXCI6Y2FzZVwiZmxvd01hcHBpbmdJdGVtXCI6dCh1LFwia2V5XCIsKCk9PnUuY2hpbGRyZW5bMF0pLHQodSxcInZhbHVlXCIsKCk9PnUuY2hpbGRyZW5bMV0pO2JyZWFrfXJldHVybiB1fW4uZXhwb3J0cz1pfX0pLGtyPVooe1wic3JjL2xhbmd1YWdlLXlhbWwvcHJpbnQvbWlzYy5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7YnVpbGRlcnM6e3NvZnRsaW5lOnQsYWxpZ246c319PUxlKCkse2hhc0VuZENvbW1lbnRzOmksaXNOZXh0TGluZUVtcHR5OnIsaXNOb2RlOnV9PWp0KCksYT1uZXcgV2Vha01hcDtmdW5jdGlvbiBjKG0sZyl7bGV0IHA9bS5nZXRWYWx1ZSgpLGY9bS5zdGFja1swXSxoO3JldHVybiBhLmhhcyhmKT9oPWEuZ2V0KGYpOihoPW5ldyBTZXQsYS5zZXQoZixoKSksIWguaGFzKHAucG9zaXRpb24uZW5kLmxpbmUpJiYoaC5hZGQocC5wb3NpdGlvbi5lbmQubGluZSkscihwLGcpJiYhbChtLmdldFBhcmVudE5vZGUoKSkpP3Q6XCJcIn1mdW5jdGlvbiBsKG0pe3JldHVybiBpKG0pJiYhdShtLFtcImRvY3VtZW50SGVhZFwiLFwiZG9jdW1lbnRCb2R5XCIsXCJmbG93TWFwcGluZ1wiLFwiZmxvd1NlcXVlbmNlXCJdKX1mdW5jdGlvbiBDKG0sZyl7cmV0dXJuIHMoXCIgXCIucmVwZWF0KG0pLGcpfW4uZXhwb3J0cz17YWxpZ25XaXRoU3BhY2VzOkMsc2hvdWxkUHJpbnRFbmRDb21tZW50czpsLHByaW50TmV4dEVtcHR5TGluZTpjfX19KSx0Zz1aKHtcInNyYy9sYW5ndWFnZS15YW1sL3ByaW50L2Zsb3ctbWFwcGluZy1zZXF1ZW5jZS5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7YnVpbGRlcnM6e2lmQnJlYWs6dCxsaW5lOnMsc29mdGxpbmU6aSxoYXJkbGluZTpyLGpvaW46dX19PUxlKCkse2lzRW1wdHlOb2RlOmEsZ2V0TGFzdDpjLGhhc0VuZENvbW1lbnRzOmx9PWp0KCkse3ByaW50TmV4dEVtcHR5TGluZTpDLGFsaWduV2l0aFNwYWNlczptfT1rcigpO2Z1bmN0aW9uIGcoZixoLE4pe2xldCBUPWYuZ2V0VmFsdWUoKSxBPVQudHlwZT09PVwiZmxvd01hcHBpbmdcIixiPUE/XCJ7XCI6XCJbXCIsdj1BP1wifVwiOlwiXVwiLEI9aTtBJiZULmNoaWxkcmVuLmxlbmd0aD4wJiZOLmJyYWNrZXRTcGFjaW5nJiYoQj1zKTtsZXQgdz1jKFQuY2hpbGRyZW4pLEk9dyYmdy50eXBlPT09XCJmbG93TWFwcGluZ0l0ZW1cIiYmYSh3LmtleSkmJmEody52YWx1ZSk7cmV0dXJuW2IsbShOLnRhYldpZHRoLFtCLHAoZixoLE4pLE4udHJhaWxpbmdDb21tYT09PVwibm9uZVwiP1wiXCI6dChcIixcIiksbChUKT9bcix1KHIsZi5tYXAoaCxcImVuZENvbW1lbnRzXCIpKV06XCJcIl0pLEk/XCJcIjpCLHZdfWZ1bmN0aW9uIHAoZixoLE4pe2xldCBUPWYuZ2V0VmFsdWUoKTtyZXR1cm4gZi5tYXAoKGIsdik9PltoKCksdj09PVQuY2hpbGRyZW4ubGVuZ3RoLTE/XCJcIjpbXCIsXCIscyxULmNoaWxkcmVuW3ZdLnBvc2l0aW9uLnN0YXJ0LmxpbmUhPT1ULmNoaWxkcmVuW3YrMV0ucG9zaXRpb24uc3RhcnQubGluZT9DKGIsTi5vcmlnaW5hbFRleHQpOlwiXCJdXSxcImNoaWxkcmVuXCIpfW4uZXhwb3J0cz17cHJpbnRGbG93TWFwcGluZzpnLHByaW50Rmxvd1NlcXVlbmNlOmd9fX0pLHJnPVooe1wic3JjL2xhbmd1YWdlLXlhbWwvcHJpbnQvbWFwcGluZy1pdGVtLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhcntidWlsZGVyczp7Y29uZGl0aW9uYWxHcm91cDp0LGdyb3VwOnMsaGFyZGxpbmU6aSxpZkJyZWFrOnIsam9pbjp1LGxpbmU6YX19PUxlKCkse2hhc0xlYWRpbmdDb21tZW50czpjLGhhc01pZGRsZUNvbW1lbnRzOmwsaGFzVHJhaWxpbmdDb21tZW50OkMsaGFzRW5kQ29tbWVudHM6bSxpc05vZGU6Zyxpc0VtcHR5Tm9kZTpwLGlzSW5saW5lTm9kZTpmfT1qdCgpLHthbGlnbldpdGhTcGFjZXM6aH09a3IoKTtmdW5jdGlvbiBOKHYsQix3LEksRSl7bGV0e2tleTpELHZhbHVlOmR9PXYseT1wKEQpLG89cChkKTtpZih5JiZvKXJldHVyblwiOiBcIjtsZXQgeD1JKFwia2V5XCIpLEY9QSh2KT9cIiBcIjpcIlwiO2lmKG8pcmV0dXJuIHYudHlwZT09PVwiZmxvd01hcHBpbmdJdGVtXCImJkIudHlwZT09PVwiZmxvd01hcHBpbmdcIj94OnYudHlwZT09PVwibWFwcGluZ0l0ZW1cIiYmVChELmNvbnRlbnQsRSkmJiFDKEQuY29udGVudCkmJighQi50YWd8fEIudGFnLnZhbHVlIT09XCJ0YWc6eWFtbC5vcmcsMjAwMjpzZXRcIik/W3gsRixcIjpcIl06W1wiPyBcIixoKDIseCldO2xldCBTPUkoXCJ2YWx1ZVwiKTtpZih5KXJldHVybltcIjogXCIsaCgyLFMpXTtpZihjKGQpfHwhZihELmNvbnRlbnQpKXJldHVybltcIj8gXCIsaCgyLHgpLGksdShcIlwiLHcubWFwKEksXCJ2YWx1ZVwiLFwibGVhZGluZ0NvbW1lbnRzXCIpLm1hcChIPT5bSCxpXSkpLFwiOiBcIixoKDIsUyldO2lmKGIoRC5jb250ZW50KSYmIWMoRC5jb250ZW50KSYmIWwoRC5jb250ZW50KSYmIUMoRC5jb250ZW50KSYmIW0oRCkmJiFjKGQuY29udGVudCkmJiFsKGQuY29udGVudCkmJiFtKGQpJiZUKGQuY29udGVudCxFKSlyZXR1cm5beCxGLFwiOiBcIixTXTtsZXQgaz1TeW1ib2woXCJtYXBwaW5nS2V5XCIpLF89cyhbcihcIj8gXCIpLHMoaCgyLHgpLHtpZDprfSldKSxPPVtpLFwiOiBcIixoKDIsUyldLFI9W0YsXCI6XCJdO2MoZC5jb250ZW50KXx8bShkKSYmZC5jb250ZW50JiYhZyhkLmNvbnRlbnQsW1wibWFwcGluZ1wiLFwic2VxdWVuY2VcIl0pfHxCLnR5cGU9PT1cIm1hcHBpbmdcIiYmQyhELmNvbnRlbnQpJiZmKGQuY29udGVudCl8fGcoZC5jb250ZW50LFtcIm1hcHBpbmdcIixcInNlcXVlbmNlXCJdKSYmZC5jb250ZW50LnRhZz09PW51bGwmJmQuY29udGVudC5hbmNob3I9PT1udWxsP1IucHVzaChpKTpkLmNvbnRlbnQmJlIucHVzaChhKSxSLnB1c2goUyk7bGV0IE09aChFLnRhYldpZHRoLFIpO3JldHVybiBUKEQuY29udGVudCxFKSYmIWMoRC5jb250ZW50KSYmIWwoRC5jb250ZW50KSYmIW0oRCk/dChbW3gsTV1dKTp0KFtbXyxyKE8sTSx7Z3JvdXBJZDprfSldXSl9ZnVuY3Rpb24gVCh2LEIpe2lmKCF2KXJldHVybiEwO3N3aXRjaCh2LnR5cGUpe2Nhc2VcInBsYWluXCI6Y2FzZVwicXVvdGVTaW5nbGVcIjpjYXNlXCJxdW90ZURvdWJsZVwiOmJyZWFrO2Nhc2VcImFsaWFzXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX1pZihCLnByb3NlV3JhcD09PVwicHJlc2VydmVcIilyZXR1cm4gdi5wb3NpdGlvbi5zdGFydC5saW5lPT09di5wb3NpdGlvbi5lbmQubGluZTtpZigvXFxcXCQvbS50ZXN0KEIub3JpZ2luYWxUZXh0LnNsaWNlKHYucG9zaXRpb24uc3RhcnQub2Zmc2V0LHYucG9zaXRpb24uZW5kLm9mZnNldCkpKXJldHVybiExO3N3aXRjaChCLnByb3NlV3JhcCl7Y2FzZVwibmV2ZXJcIjpyZXR1cm4hdi52YWx1ZS5pbmNsdWRlcyhgXG5gKTtjYXNlXCJhbHdheXNcIjpyZXR1cm4hL1tcXG4gXS8udGVzdCh2LnZhbHVlKTtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBBKHYpe3JldHVybiB2LmtleS5jb250ZW50JiZ2LmtleS5jb250ZW50LnR5cGU9PT1cImFsaWFzXCJ9ZnVuY3Rpb24gYih2KXtpZighdilyZXR1cm4hMDtzd2l0Y2godi50eXBlKXtjYXNlXCJwbGFpblwiOmNhc2VcInF1b3RlRG91YmxlXCI6Y2FzZVwicXVvdGVTaW5nbGVcIjpyZXR1cm4gdi5wb3NpdGlvbi5zdGFydC5saW5lPT09di5wb3NpdGlvbi5lbmQubGluZTtjYXNlXCJhbGlhc1wiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fW4uZXhwb3J0cz1OfX0pLG5nPVooe1wic3JjL2xhbmd1YWdlLXlhbWwvcHJpbnQvYmxvY2suanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCk7dmFye2J1aWxkZXJzOntkZWRlbnQ6dCxkZWRlbnRUb1Jvb3Q6cyxmaWxsOmksaGFyZGxpbmU6cixqb2luOnUsbGluZTphLGxpdGVyYWxsaW5lOmMsbWFya0FzUm9vdDpsfSx1dGlsczp7Z2V0RG9jUGFydHM6Q319PUxlKCkse2dldEFuY2VzdG9yQ291bnQ6bSxnZXRCbG9ja1ZhbHVlTGluZUNvbnRlbnRzOmcsaGFzSW5kaWNhdG9yQ29tbWVudDpwLGlzTGFzdERlc2NlbmRhbnROb2RlOmYsaXNOb2RlOmh9PWp0KCkse2FsaWduV2l0aFNwYWNlczpOfT1rcigpO2Z1bmN0aW9uIFQoQSxiLHYpe2xldCBCPUEuZ2V0VmFsdWUoKSx3PW0oQSx5PT5oKHksW1wic2VxdWVuY2VcIixcIm1hcHBpbmdcIl0pKSxJPWYoQSksRT1bQi50eXBlPT09XCJibG9ja0ZvbGRlZFwiP1wiPlwiOlwifFwiXTtCLmluZGVudCE9PW51bGwmJkUucHVzaChCLmluZGVudC50b1N0cmluZygpKSxCLmNob21waW5nIT09XCJjbGlwXCImJkUucHVzaChCLmNob21waW5nPT09XCJrZWVwXCI/XCIrXCI6XCItXCIpLHAoQikmJkUucHVzaChcIiBcIixiKFwiaW5kaWNhdG9yQ29tbWVudFwiKSk7bGV0IEQ9ZyhCLHtwYXJlbnRJbmRlbnQ6dyxpc0xhc3REZXNjZW5kYW50Okksb3B0aW9uczp2fSksZD1bXTtmb3IobGV0W3ksb11vZiBELmVudHJpZXMoKSl5PT09MCYmZC5wdXNoKHIpLGQucHVzaChpKEModShhLG8pKSkpLHkhPT1ELmxlbmd0aC0xP2QucHVzaChvLmxlbmd0aD09PTA/cjpsKGMpKTpCLmNob21waW5nPT09XCJrZWVwXCImJkkmJmQucHVzaChzKG8ubGVuZ3RoPT09MD9yOmMpKTtyZXR1cm4gQi5pbmRlbnQ9PT1udWxsP0UucHVzaCh0KE4odi50YWJXaWR0aCxkKSkpOkUucHVzaChzKE4oQi5pbmRlbnQtMSt3LGQpKSksRX1uLmV4cG9ydHM9VH19KSx1Zz1aKHtcInNyYy9sYW5ndWFnZS15YW1sL3ByaW50ZXIteWFtbC5qc1wiKGUsbil7XCJ1c2Ugc3RyaWN0XCI7YWUoKTt2YXJ7YnVpbGRlcnM6e2JyZWFrUGFyZW50OnQsZmlsbDpzLGdyb3VwOmksaGFyZGxpbmU6cixqb2luOnUsbGluZTphLGxpbmVTdWZmaXg6YyxsaXRlcmFsbGluZTpsfSx1dGlsczp7Z2V0RG9jUGFydHM6QyxyZXBsYWNlVGV4dEVuZE9mTGluZTptfX09TGUoKSx7aXNQcmV2aW91c0xpbmVFbXB0eTpnfT1HZSgpLHtpbnNlcnRQcmFnbWE6cCxpc1ByYWdtYTpmfT1ZZCgpLHtsb2NTdGFydDpofT1RZCgpLE49WmQoKSx7Z2V0Rmxvd1NjYWxhckxpbmVDb250ZW50czpULGdldExhc3REZXNjZW5kYW50Tm9kZTpBLGhhc0xlYWRpbmdDb21tZW50czpiLGhhc01pZGRsZUNvbW1lbnRzOnYsaGFzVHJhaWxpbmdDb21tZW50OkIsaGFzRW5kQ29tbWVudHM6dyxoYXNQcmV0dGllcklnbm9yZTpJLGlzTGFzdERlc2NlbmRhbnROb2RlOkUsaXNOb2RlOkQsaXNJbmxpbmVOb2RlOmR9PWp0KCkseT1lZygpLHthbGlnbldpdGhTcGFjZXM6byxwcmludE5leHRFbXB0eUxpbmU6eCxzaG91bGRQcmludEVuZENvbW1lbnRzOkZ9PWtyKCkse3ByaW50Rmxvd01hcHBpbmc6UyxwcmludEZsb3dTZXF1ZW5jZTprfT10ZygpLF89cmcoKSxPPW5nKCk7ZnVuY3Rpb24gUihXLGVlLFUpe2xldCBuZT1XLmdldFZhbHVlKCksc2U9W107bmUudHlwZSE9PVwibWFwcGluZ1ZhbHVlXCImJmIobmUpJiZzZS5wdXNoKFt1KHIsVy5tYXAoVSxcImxlYWRpbmdDb21tZW50c1wiKSkscl0pO2xldHt0YWc6VixhbmNob3I6b2V9PW5lO1YmJnNlLnB1c2goVShcInRhZ1wiKSksViYmb2UmJnNlLnB1c2goXCIgXCIpLG9lJiZzZS5wdXNoKFUoXCJhbmNob3JcIikpO2xldCBLPVwiXCI7RChuZSxbXCJtYXBwaW5nXCIsXCJzZXF1ZW5jZVwiLFwiY29tbWVudFwiLFwiZGlyZWN0aXZlXCIsXCJtYXBwaW5nSXRlbVwiLFwic2VxdWVuY2VJdGVtXCJdKSYmIUUoVykmJihLPXgoVyxlZS5vcmlnaW5hbFRleHQpKSwoVnx8b2UpJiYoRChuZSxbXCJzZXF1ZW5jZVwiLFwibWFwcGluZ1wiXSkmJiF2KG5lKT9zZS5wdXNoKHIpOnNlLnB1c2goXCIgXCIpKSx2KG5lKSYmc2UucHVzaChbbmUubWlkZGxlQ29tbWVudHMubGVuZ3RoPT09MT9cIlwiOnIsdShyLFcubWFwKFUsXCJtaWRkbGVDb21tZW50c1wiKSkscl0pO2xldCBFZT1XLmdldFBhcmVudE5vZGUoKTtyZXR1cm4gSShXKT9zZS5wdXNoKG0oZWUub3JpZ2luYWxUZXh0LnNsaWNlKG5lLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCxuZS5wb3NpdGlvbi5lbmQub2Zmc2V0KS50cmltRW5kKCksbCkpOnNlLnB1c2goaShNKG5lLEVlLFcsZWUsVSkpKSxCKG5lKSYmIUQobmUsW1wiZG9jdW1lbnRcIixcImRvY3VtZW50SGVhZFwiXSkmJnNlLnB1c2goYyhbbmUudHlwZT09PVwibWFwcGluZ1ZhbHVlXCImJiFuZS5jb250ZW50P1wiXCI6XCIgXCIsRWUudHlwZT09PVwibWFwcGluZ0tleVwiJiZXLmdldFBhcmVudE5vZGUoMikudHlwZT09PVwibWFwcGluZ1wiJiZkKG5lKT9cIlwiOnQsVShcInRyYWlsaW5nQ29tbWVudFwiKV0pKSxGKG5lKSYmc2UucHVzaChvKG5lLnR5cGU9PT1cInNlcXVlbmNlSXRlbVwiPzI6MCxbcix1KHIsVy5tYXAocT0+W2coZWUub3JpZ2luYWxUZXh0LHEuZ2V0VmFsdWUoKSxoKT9yOlwiXCIsVSgpXSxcImVuZENvbW1lbnRzXCIpKV0pKSxzZS5wdXNoKEspLHNlfWZ1bmN0aW9uIE0oVyxlZSxVLG5lLHNlKXtzd2l0Y2goVy50eXBlKXtjYXNlXCJyb290XCI6e2xldHtjaGlsZHJlbjpWfT1XLG9lPVtdO1UuZWFjaCgoRWUscSk9PntsZXQgbGU9VltxXSx1ZT1WW3ErMV07cSE9PTAmJm9lLnB1c2gociksb2UucHVzaChzZSgpKSxQKGxlLHVlKT8ob2UucHVzaChyLFwiLi4uXCIpLEIobGUpJiZvZS5wdXNoKFwiIFwiLHNlKFwidHJhaWxpbmdDb21tZW50XCIpKSk6dWUmJiFCKHVlLmhlYWQpJiZvZS5wdXNoKHIsXCItLS1cIil9LFwiY2hpbGRyZW5cIik7bGV0IEs9QShXKTtyZXR1cm4oIUQoSyxbXCJibG9ja0xpdGVyYWxcIixcImJsb2NrRm9sZGVkXCJdKXx8Sy5jaG9tcGluZyE9PVwia2VlcFwiKSYmb2UucHVzaChyKSxvZX1jYXNlXCJkb2N1bWVudFwiOntsZXQgVj1lZS5jaGlsZHJlbltVLmdldE5hbWUoKSsxXSxvZT1bXTtyZXR1cm4gRyhXLFYsZWUsbmUpPT09XCJoZWFkXCImJigoVy5oZWFkLmNoaWxkcmVuLmxlbmd0aD4wfHxXLmhlYWQuZW5kQ29tbWVudHMubGVuZ3RoPjApJiZvZS5wdXNoKHNlKFwiaGVhZFwiKSksQihXLmhlYWQpP29lLnB1c2goW1wiLS0tXCIsXCIgXCIsc2UoW1wiaGVhZFwiLFwidHJhaWxpbmdDb21tZW50XCJdKV0pOm9lLnB1c2goXCItLS1cIikpLEgoVykmJm9lLnB1c2goc2UoXCJib2R5XCIpKSx1KHIsb2UpfWNhc2VcImRvY3VtZW50SGVhZFwiOnJldHVybiB1KHIsWy4uLlUubWFwKHNlLFwiY2hpbGRyZW5cIiksLi4uVS5tYXAoc2UsXCJlbmRDb21tZW50c1wiKV0pO2Nhc2VcImRvY3VtZW50Qm9keVwiOntsZXR7Y2hpbGRyZW46VixlbmRDb21tZW50czpvZX09VyxLPVwiXCI7aWYoVi5sZW5ndGg+MCYmb2UubGVuZ3RoPjApe2xldCBFZT1BKFcpO0QoRWUsW1wiYmxvY2tGb2xkZWRcIixcImJsb2NrTGl0ZXJhbFwiXSk/RWUuY2hvbXBpbmchPT1cImtlZXBcIiYmKEs9W3Iscl0pOks9cn1yZXR1cm5bdShyLFUubWFwKHNlLFwiY2hpbGRyZW5cIikpLEssdShyLFUubWFwKHNlLFwiZW5kQ29tbWVudHNcIikpXX1jYXNlXCJkaXJlY3RpdmVcIjpyZXR1cm5bXCIlXCIsdShcIiBcIixbVy5uYW1lLC4uLlcucGFyYW1ldGVyc10pXTtjYXNlXCJjb21tZW50XCI6cmV0dXJuW1wiI1wiLFcudmFsdWVdO2Nhc2VcImFsaWFzXCI6cmV0dXJuW1wiKlwiLFcudmFsdWVdO2Nhc2VcInRhZ1wiOnJldHVybiBuZS5vcmlnaW5hbFRleHQuc2xpY2UoVy5wb3NpdGlvbi5zdGFydC5vZmZzZXQsVy5wb3NpdGlvbi5lbmQub2Zmc2V0KTtjYXNlXCJhbmNob3JcIjpyZXR1cm5bXCImXCIsVy52YWx1ZV07Y2FzZVwicGxhaW5cIjpyZXR1cm4gcmUoVy50eXBlLG5lLm9yaWdpbmFsVGV4dC5zbGljZShXLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCxXLnBvc2l0aW9uLmVuZC5vZmZzZXQpLG5lKTtjYXNlXCJxdW90ZURvdWJsZVwiOmNhc2VcInF1b3RlU2luZ2xlXCI6e2xldCBWPVwiJ1wiLG9lPSdcIicsSz1uZS5vcmlnaW5hbFRleHQuc2xpY2UoVy5wb3NpdGlvbi5zdGFydC5vZmZzZXQrMSxXLnBvc2l0aW9uLmVuZC5vZmZzZXQtMSk7aWYoVy50eXBlPT09XCJxdW90ZVNpbmdsZVwiJiZLLmluY2x1ZGVzKFwiXFxcXFwiKXx8Vy50eXBlPT09XCJxdW90ZURvdWJsZVwiJiYvXFxcXFteXCJdLy50ZXN0KEspKXtsZXQgcT1XLnR5cGU9PT1cInF1b3RlRG91YmxlXCI/b2U6VjtyZXR1cm5bcSxyZShXLnR5cGUsSyxuZSkscV19aWYoSy5pbmNsdWRlcyhvZSkpcmV0dXJuW1YscmUoVy50eXBlLFcudHlwZT09PVwicXVvdGVEb3VibGVcIj9LLnJlcGxhY2UoL1xcXFxcIi9nLG9lKS5yZXBsYWNlKC8nL2csVi5yZXBlYXQoMikpOkssbmUpLFZdO2lmKEsuaW5jbHVkZXMoVikpcmV0dXJuW29lLHJlKFcudHlwZSxXLnR5cGU9PT1cInF1b3RlU2luZ2xlXCI/Sy5yZXBsYWNlKC8nJy9nLFYpOkssbmUpLG9lXTtsZXQgRWU9bmUuc2luZ2xlUXVvdGU/VjpvZTtyZXR1cm5bRWUscmUoVy50eXBlLEssbmUpLEVlXX1jYXNlXCJibG9ja0ZvbGRlZFwiOmNhc2VcImJsb2NrTGl0ZXJhbFwiOnJldHVybiBPKFUsc2UsbmUpO2Nhc2VcIm1hcHBpbmdcIjpjYXNlXCJzZXF1ZW5jZVwiOnJldHVybiB1KHIsVS5tYXAoc2UsXCJjaGlsZHJlblwiKSk7Y2FzZVwic2VxdWVuY2VJdGVtXCI6cmV0dXJuW1wiLSBcIixvKDIsVy5jb250ZW50P3NlKFwiY29udGVudFwiKTpcIlwiKV07Y2FzZVwibWFwcGluZ0tleVwiOmNhc2VcIm1hcHBpbmdWYWx1ZVwiOnJldHVybiBXLmNvbnRlbnQ/c2UoXCJjb250ZW50XCIpOlwiXCI7Y2FzZVwibWFwcGluZ0l0ZW1cIjpjYXNlXCJmbG93TWFwcGluZ0l0ZW1cIjpyZXR1cm4gXyhXLGVlLFUsc2UsbmUpO2Nhc2VcImZsb3dNYXBwaW5nXCI6cmV0dXJuIFMoVSxzZSxuZSk7Y2FzZVwiZmxvd1NlcXVlbmNlXCI6cmV0dXJuIGsoVSxzZSxuZSk7Y2FzZVwiZmxvd1NlcXVlbmNlSXRlbVwiOnJldHVybiBzZShcImNvbnRlbnRcIik7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIi5jb25jYXQoVy50eXBlKSl9fWZ1bmN0aW9uIEgoVyl7cmV0dXJuIFcuYm9keS5jaGlsZHJlbi5sZW5ndGg+MHx8dyhXLmJvZHkpfWZ1bmN0aW9uIFAoVyxlZSl7cmV0dXJuIEIoVyl8fGVlJiYoZWUuaGVhZC5jaGlsZHJlbi5sZW5ndGg+MHx8dyhlZS5oZWFkKSl9ZnVuY3Rpb24gRyhXLGVlLFUsbmUpe3JldHVybiBVLmNoaWxkcmVuWzBdPT09VyYmLy0tLSg/Olxcc3wkKS8udGVzdChuZS5vcmlnaW5hbFRleHQuc2xpY2UoaChXKSxoKFcpKzQpKXx8Vy5oZWFkLmNoaWxkcmVuLmxlbmd0aD4wfHx3KFcuaGVhZCl8fEIoVy5oZWFkKT9cImhlYWRcIjpQKFcsZWUpPyExOmVlP1wicm9vdFwiOiExfWZ1bmN0aW9uIHJlKFcsZWUsVSl7bGV0IG5lPVQoVyxlZSxVKTtyZXR1cm4gdShyLG5lLm1hcChzZT0+cyhDKHUoYSxzZSkpKSkpfWZ1bmN0aW9uICQoVyxlZSl7aWYoRChlZSkpc3dpdGNoKGRlbGV0ZSBlZS5wb3NpdGlvbixlZS50eXBlKXtjYXNlXCJjb21tZW50XCI6aWYoZihlZS52YWx1ZSkpcmV0dXJuIG51bGw7YnJlYWs7Y2FzZVwicXVvdGVEb3VibGVcIjpjYXNlXCJxdW90ZVNpbmdsZVwiOmVlLnR5cGU9XCJxdW90ZVwiO2JyZWFrfX1uLmV4cG9ydHM9e3ByZXByb2Nlc3M6eSxlbWJlZDpOLHByaW50OlIsbWFzc2FnZUFzdE5vZGU6JCxpbnNlcnRQcmFnbWE6cH19fSksc2c9Wih7XCJzcmMvbGFuZ3VhZ2UteWFtbC9vcHRpb25zLmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PUx0KCk7bi5leHBvcnRzPXticmFja2V0U3BhY2luZzp0LmJyYWNrZXRTcGFjaW5nLHNpbmdsZVF1b3RlOnQuc2luZ2xlUXVvdGUscHJvc2VXcmFwOnQucHJvc2VXcmFwfX19KSxhZz1aKHtcInNyYy9sYW5ndWFnZS15YW1sL3BhcnNlcnMuanNcIigpe2FlKCl9fSksaWc9Wih7XCJub2RlX21vZHVsZXMvbGluZ3Vpc3QtbGFuZ3VhZ2VzL2RhdGEvWUFNTC5qc29uXCIoZSxuKXtuLmV4cG9ydHM9e25hbWU6XCJZQU1MXCIsdHlwZTpcImRhdGFcIixjb2xvcjpcIiNjYjE3MWVcIix0bVNjb3BlOlwic291cmNlLnlhbWxcIixhbGlhc2VzOltcInltbFwiXSxleHRlbnNpb25zOltcIi55bWxcIixcIi5taXJcIixcIi5yZWVrXCIsXCIucnZpelwiLFwiLnN1YmxpbWUtc3ludGF4XCIsXCIuc3ludGF4XCIsXCIueWFtbFwiLFwiLnlhbWwtdG1sYW5ndWFnZVwiLFwiLnlhbWwuc2VkXCIsXCIueW1sLm15c3FsXCJdLGZpbGVuYW1lczpbXCIuY2xhbmctZm9ybWF0XCIsXCIuY2xhbmctdGlkeVwiLFwiLmdlbXJjXCIsXCJnbGlkZS5sb2NrXCIsXCJ5YXJuLmxvY2tcIl0sYWNlTW9kZTpcInlhbWxcIixjb2RlbWlycm9yTW9kZTpcInlhbWxcIixjb2RlbWlycm9yTWltZVR5cGU6XCJ0ZXh0L3gteWFtbFwiLGxhbmd1YWdlSWQ6NDA3fX19KSxvZz1aKHtcInNyYy9sYW5ndWFnZS15YW1sL2luZGV4LmpzXCIoZSxuKXtcInVzZSBzdHJpY3RcIjthZSgpO3ZhciB0PWJ0KCkscz11ZygpLGk9c2coKSxyPWFnKCksdT1bdChpZygpLGE9Pih7c2luY2U6XCIxLjE0LjBcIixwYXJzZXJzOltcInlhbWxcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wieWFtbFwiLFwiYW5zaWJsZVwiLFwiaG9tZS1hc3Npc3RhbnRcIl0sZmlsZW5hbWVzOlsuLi5hLmZpbGVuYW1lcy5maWx0ZXIoYz0+YyE9PVwieWFybi5sb2NrXCIpLFwiLnByZXR0aWVycmNcIixcIi5zdHlsZWxpbnRyY1wiXX0pKV07bi5leHBvcnRzPXtsYW5ndWFnZXM6dSxwcmludGVyczp7eWFtbDpzfSxvcHRpb25zOmkscGFyc2VyczpyfX19KSxjZz1aKHtcInNyYy9sYW5ndWFnZXMuanNcIihlLG4pe1widXNlIHN0cmljdFwiO2FlKCksbi5leHBvcnRzPVskbSgpLGlkKCksZGQoKSxGZCgpLHdkKCksS2QoKSxvZygpXX19KTthZSgpO3Zhcnt2ZXJzaW9uOmxnfT1naSgpLF90PW9tKCkse2dldFN1cHBvcnRJbmZvOnBnfT1NbigpLGZnPWNtKCksRGc9Y2coKSxtZz1MZSgpO2Z1bmN0aW9uIFN0KGUpe2xldCBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXToxO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLHM9bmV3IEFycmF5KHQpLGk9MDtpPHQ7aSsrKXNbaV09YXJndW1lbnRzW2ldO2xldCByPXNbbl18fHt9LHU9ci5wbHVnaW5zfHxbXTtyZXR1cm4gc1tuXT1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse30se3BsdWdpbnM6Wy4uLkRnLC4uLkFycmF5LmlzQXJyYXkodSk/dTpPYmplY3QudmFsdWVzKHUpXX0pLGUoLi4ucyl9fXZhciBTbj1TdChfdC5mb3JtYXRXaXRoQ3Vyc29yKTt5by5leHBvcnRzPXtmb3JtYXRXaXRoQ3Vyc29yOlNuLGZvcm1hdChlLG4pe3JldHVybiBTbihlLG4pLmZvcm1hdHRlZH0sY2hlY2soZSxuKXtsZXR7Zm9ybWF0dGVkOnR9PVNuKGUsbik7cmV0dXJuIHQ9PT1lfSxkb2M6bWcsZ2V0U3VwcG9ydEluZm86U3QocGcsMCksdmVyc2lvbjpsZyx1dGlsOmZnLF9fZGVidWc6e3BhcnNlOlN0KF90LnBhcnNlKSxmb3JtYXRBU1Q6U3QoX3QuZm9ybWF0QVNUKSxmb3JtYXREb2M6U3QoX3QuZm9ybWF0RG9jKSxwcmludFRvRG9jOlN0KF90LnByaW50VG9Eb2MpLHByaW50RG9jVG9TdHJpbmc6U3QoX3QucHJpbnREb2NUb1N0cmluZyl9fX0pO1widXNlIHN0cmljdFwiO3JldHVybiBkZygpO30pOyIsImltcG9ydCB7IGRvYyB9IGZyb20gXCJwcmV0dGllclwiO1xuaW1wb3J0IHNlYXJjaEljb24gZnJvbSBcIi4vYXNzZXRzL3NlYXJjaC5zdmdcIjtcbmltcG9ydCBjbG91ZHkgZnJvbSBcIi4vYXNzZXRzL2Nsb3VkeS5zdmdcIjtcblxubGV0IFVJID0gKCgpID0+IHtcbiAgZnVuY3Rpb24gbG9hZCgpIHtcbiAgICBsb2FkU2lkZUJhcigpO1xuICAgIGxvYWRJbmZvQmFyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkU2lkZUJhcigpIHtcbiAgICBsZXQgYXNpZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYXNpZGVcIik7XG5cbiAgICBsZXQgc2VhcmNoQnV0dG9uID0gbmV3IEltYWdlKCk7XG4gICAgc2VhcmNoQnV0dG9uLmNsYXNzTmFtZSA9IFwic2VhcmNoQnV0dG9uXCI7XG4gICAgc2VhcmNoQnV0dG9uLnNyYyA9IHNlYXJjaEljb247XG4gICAgc2VhcmNoQnV0dG9uLm9uY2xpY2sgPSBvcGVuU2VhcmNoQmFyO1xuICAgIGFzaWRlLmFwcGVuZENoaWxkKHNlYXJjaEJ1dHRvbik7XG5cbiAgICBsZXQgY2l0eU5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNpdHlOYW1lLmNsYXNzTmFtZSA9IFwiY2l0eU5hbWVcIjtcbiAgICBjaXR5TmFtZS50ZXh0Q29udGVudCA9IFwiTmFybmlhXCI7XG4gICAgYXNpZGUuYXBwZW5kQ2hpbGQoY2l0eU5hbWUpO1xuXG4gICAgbG9hZFNlYXJjaEJhcihhc2lkZSk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkU2VhcmNoQmFyKGFzaWRlKSB7XG4gICAgbGV0IHNlYXJjaEJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc2VhcmNoQmFyLmNsYXNzTmFtZSA9IFwic2VhcmNoQmFyXCI7XG5cbiAgICBsZXQgc2VhcmNoVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJJTlBVVFwiKTtcbiAgICBzZWFyY2hUZXh0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0XCIpO1xuICAgIHNlYXJjaEJhci5hcHBlbmRDaGlsZChzZWFyY2hUZXh0KTtcblxuICAgIGFzaWRlLmFwcGVuZChzZWFyY2hCYXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9hZEluZm9CYXIoKSB7XG4gICAgbGV0IG1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWFpblwiKTtcblxuICAgIGxldCBvdGhlckluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG90aGVySW5mby5jbGFzc05hbWUgPSBcIm90aGVySW5mb1wiO1xuXG4gICAgbGV0IHRpbWVJbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aW1lSW5mby50ZXh0Q29udGVudCA9IFwiNjowOSBQTVwiO1xuICAgIHRpbWVJbmZvLmNsYXNzTmFtZSA9IFwidGltZVwiO1xuICAgIG90aGVySW5mby5hcHBlbmRDaGlsZCh0aW1lSW5mbyk7XG5cbiAgICBsZXQgZGF0ZUluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRhdGVJbmZvLnRleHRDb250ZW50ID0gXCIzMXN0IEZlYnJ1YXJ5LCAxOTExXCI7XG4gICAgZGF0ZUluZm8uY2xhc3NOYW1lID0gXCJkYXRlXCI7XG4gICAgb3RoZXJJbmZvLmFwcGVuZENoaWxkKGRhdGVJbmZvKTtcblxuICAgIG1haW4uYXBwZW5kQ2hpbGQob3RoZXJJbmZvKTtcblxuICAgIGxldCBkZXNjcmlwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGVzY3JpcHRpb24uY2xhc3NOYW1lID0gXCJkZXNjXCI7XG4gICAgZGVzY3JpcHRpb24udGV4dENvbnRlbnQgPSBcIlN1bm55ICYgTWFnaWNhbFwiO1xuXG4gICAgbGV0IHdlYXRoZXJJbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB3ZWF0aGVySW5mby5jbGFzc05hbWUgPSBcIndlYXRoZXJJbmZvXCI7XG5cbiAgICBsZXQgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGVtcC5jbGFzc05hbWUgPSBcInRlbXBJbmZvXCI7XG5cbiAgICBsZXQgdGVtcEljb24gPSBuZXcgSW1hZ2UoKTtcbiAgICB0ZW1wSWNvbi5jbGFzc05hbWUgPSBcInRlbXBJY29uXCI7XG4gICAgdGVtcEljb24uc3JjID0gY2xvdWR5O1xuICAgIHRlbXAuYXBwZW5kQ2hpbGQodGVtcEljb24pO1xuXG4gICAgbGV0IHRlbXBUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0ZW1wVGV4dC5jbGFzc05hbWUgPSBcInRlbXBUZXh0XCI7XG4gICAgdGVtcC50ZXh0Q29udGVudCA9IFwiNjnCsCBGXCI7XG4gICAgdGVtcC5hcHBlbmRDaGlsZCh0ZW1wVGV4dCk7XG5cbiAgICBsb2FkQ0ZCdXR0b24obWFpbik7XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkQ0ZCdXR0b24obWFpbikge1xuICAgIGxldCBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgYnRuLmNsYXNzTmFtZSA9IFwic3dpdGNoXCI7XG5cbiAgICBsZXQgYnRuSW5wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIklOUFVUXCIpO1xuICAgIGJ0bklucC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiY2hlY2tib3hcIik7XG5cbiAgICBsZXQgc2xpZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgc2xpZGVyLmNsYXNzTmFtZSA9IFwic2xpZGVyIHJvdW5kXCI7XG5cbiAgICBidG4uYXBwZW5kQ2hpbGQoYnRuSW5wKTtcbiAgICBidG4uYXBwZW5kQ2hpbGQoc2xpZGVyKTtcbiAgICBtYWluLmFwcGVuZENoaWxkKGJ0bik7XG4gIH1cblxuICBsZXQgb3BlblNlYXJjaEJhciA9ICgpID0+XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5zZWFyY2hCYXJcIikuY2xhc3NMaXN0LnRvZ2dsZShcInNlYXJjaFNob3dcIik7XG5cbiAgcmV0dXJuIHtcbiAgICBsb2FkLFxuICB9O1xufSkoKTtcblxuZXhwb3J0IHsgVUkgfTtcbiIsImZ1bmN0aW9uIHVwZGF0ZXIoKSB7fVxuXG5leHBvcnQgeyB1cGRhdGVyIH07XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJ2YXIgc2NyaXB0VXJsO1xuaWYgKF9fd2VicGFja19yZXF1aXJlX18uZy5pbXBvcnRTY3JpcHRzKSBzY3JpcHRVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcubG9jYXRpb24gKyBcIlwiO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmRvY3VtZW50O1xuaWYgKCFzY3JpcHRVcmwgJiYgZG9jdW1lbnQpIHtcblx0aWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmNcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSBzY3JpcHRVcmwgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3JjXG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsOyIsImltcG9ydCB7IFVJIH0gZnJvbSBcIi4vbG9hZGVyXCI7XG5pbXBvcnQgeyB1cGRhdGUgfSBmcm9tIFwiLi91cGRhdGVcIjtcblxuVUkubG9hZCgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9
